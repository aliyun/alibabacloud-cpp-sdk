// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CCC20200701_H_
#define ALIBABACLOUD_CCC20200701_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_CCC20200701 {
class DataPropertiesValue : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> dataType{};
  shared_ptr<string> pattern{};
  shared_ptr<string> patternErrorMessage{};
  shared_ptr<long> minLength{};
  shared_ptr<long> maxLength{};
  shared_ptr<double> minimum{};
  shared_ptr<double> maximum{};
  shared_ptr<bool> required{};
  shared_ptr<bool> system{};
  shared_ptr<bool> disabled{};
  shared_ptr<bool> array{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> editorType{};
  shared_ptr<string> attributes{};
  shared_ptr<long> displayOrder{};
  shared_ptr<long> createdTime{};
  shared_ptr<long> updatedTime{};
  shared_ptr<string> creator{};

  DataPropertiesValue() {}

  explicit DataPropertiesValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (patternErrorMessage) {
      res["PatternErrorMessage"] = boost::any(*patternErrorMessage);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (minimum) {
      res["Minimum"] = boost::any(*minimum);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (array) {
      res["Array"] = boost::any(*array);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (editorType) {
      res["EditorType"] = boost::any(*editorType);
    }
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (displayOrder) {
      res["DisplayOrder"] = boost::any(*displayOrder);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("PatternErrorMessage") != m.end() && !m["PatternErrorMessage"].empty()) {
      patternErrorMessage = make_shared<string>(boost::any_cast<string>(m["PatternErrorMessage"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("Minimum") != m.end() && !m["Minimum"].empty()) {
      minimum = make_shared<double>(boost::any_cast<double>(m["Minimum"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<double>(boost::any_cast<double>(m["Maximum"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("Array") != m.end() && !m["Array"].empty()) {
      array = make_shared<bool>(boost::any_cast<bool>(m["Array"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("EditorType") != m.end() && !m["EditorType"].empty()) {
      editorType = make_shared<string>(boost::any_cast<string>(m["EditorType"]));
    }
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      attributes = make_shared<string>(boost::any_cast<string>(m["Attributes"]));
    }
    if (m.find("DisplayOrder") != m.end() && !m["DisplayOrder"].empty()) {
      displayOrder = make_shared<long>(boost::any_cast<long>(m["DisplayOrder"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
  }


  virtual ~DataPropertiesValue() = default;
};
class DataSchemaPropertiesValue : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> dataType{};
  shared_ptr<string> pattern{};
  shared_ptr<string> patternErrorMessage{};
  shared_ptr<long> minLength{};
  shared_ptr<long> maxLength{};
  shared_ptr<double> minimum{};
  shared_ptr<double> maximum{};
  shared_ptr<bool> required{};
  shared_ptr<bool> system{};
  shared_ptr<bool> disabled{};
  shared_ptr<bool> array{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> editorType{};
  shared_ptr<string> attributes{};
  shared_ptr<long> displayOrder{};
  shared_ptr<long> createdTime{};
  shared_ptr<long> updatedTime{};
  shared_ptr<string> creator{};

  DataSchemaPropertiesValue() {}

  explicit DataSchemaPropertiesValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (patternErrorMessage) {
      res["PatternErrorMessage"] = boost::any(*patternErrorMessage);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (minimum) {
      res["Minimum"] = boost::any(*minimum);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (array) {
      res["Array"] = boost::any(*array);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (editorType) {
      res["EditorType"] = boost::any(*editorType);
    }
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (displayOrder) {
      res["DisplayOrder"] = boost::any(*displayOrder);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("PatternErrorMessage") != m.end() && !m["PatternErrorMessage"].empty()) {
      patternErrorMessage = make_shared<string>(boost::any_cast<string>(m["PatternErrorMessage"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("Minimum") != m.end() && !m["Minimum"].empty()) {
      minimum = make_shared<double>(boost::any_cast<double>(m["Minimum"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<double>(boost::any_cast<double>(m["Maximum"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("Array") != m.end() && !m["Array"].empty()) {
      array = make_shared<bool>(boost::any_cast<bool>(m["Array"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("EditorType") != m.end() && !m["EditorType"].empty()) {
      editorType = make_shared<string>(boost::any_cast<string>(m["EditorType"]));
    }
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      attributes = make_shared<string>(boost::any_cast<string>(m["Attributes"]));
    }
    if (m.find("DisplayOrder") != m.end() && !m["DisplayOrder"].empty()) {
      displayOrder = make_shared<long>(boost::any_cast<long>(m["DisplayOrder"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
  }


  virtual ~DataSchemaPropertiesValue() = default;
};
class AbortCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  AbortCampaignRequest() {}

  explicit AbortCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AbortCampaignRequest() = default;
};
class AbortCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AbortCampaignResponseBody() {}

  explicit AbortCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AbortCampaignResponseBody() = default;
};
class AbortCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AbortCampaignResponseBody> body{};

  AbortCampaignResponse() {}

  explicit AbortCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbortCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbortCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~AbortCampaignResponse() = default;
};
class AcceptChatRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  AcceptChatRequest() {}

  explicit AcceptChatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~AcceptChatRequest() = default;
};
class AcceptChatResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AcceptChatResponseBody() {}

  explicit AcceptChatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AcceptChatResponseBody() = default;
};
class AcceptChatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AcceptChatResponseBody> body{};

  AcceptChatResponse() {}

  explicit AcceptChatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AcceptChatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AcceptChatResponseBody>(model1);
      }
    }
  }


  virtual ~AcceptChatResponse() = default;
};
class AddBlacklistCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> number{};

  AddBlacklistCallTaggingRequest() {}

  explicit AddBlacklistCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~AddBlacklistCallTaggingRequest() = default;
};
class AddBlacklistCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddBlacklistCallTaggingResponseBody() {}

  explicit AddBlacklistCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddBlacklistCallTaggingResponseBody() = default;
};
class AddBlacklistCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddBlacklistCallTaggingResponseBody> body{};

  AddBlacklistCallTaggingResponse() {}

  explicit AddBlacklistCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddBlacklistCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddBlacklistCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~AddBlacklistCallTaggingResponse() = default;
};
class AddCasesRequestCaseList : public Darabonba::Model {
public:
  shared_ptr<string> caller{};
  shared_ptr<string> customVariables{};
  shared_ptr<string> maskedCallee{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};

  AddCasesRequestCaseList() {}

  explicit AddCasesRequestCaseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (maskedCallee) {
      res["MaskedCallee"] = boost::any(*maskedCallee);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("MaskedCallee") != m.end() && !m["MaskedCallee"].empty()) {
      maskedCallee = make_shared<string>(boost::any_cast<string>(m["MaskedCallee"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~AddCasesRequestCaseList() = default;
};
class AddCasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<vector<AddCasesRequestCaseList>> caseList{};
  shared_ptr<string> instanceId{};

  AddCasesRequest() {}

  explicit AddCasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (caseList) {
      vector<boost::any> temp1;
      for(auto item1:*caseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CaseList"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CaseList") != m.end() && !m["CaseList"].empty()) {
      if (typeid(vector<boost::any>) == m["CaseList"].type()) {
        vector<AddCasesRequestCaseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CaseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasesRequestCaseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        caseList = make_shared<vector<AddCasesRequestCaseList>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AddCasesRequest() = default;
};
class AddCasesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> caseListShrink{};
  shared_ptr<string> instanceId{};

  AddCasesShrinkRequest() {}

  explicit AddCasesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (caseListShrink) {
      res["CaseList"] = boost::any(*caseListShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CaseList") != m.end() && !m["CaseList"].empty()) {
      caseListShrink = make_shared<string>(boost::any_cast<string>(m["CaseList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AddCasesShrinkRequest() = default;
};
class AddCasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddCasesResponseBody() {}

  explicit AddCasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasesResponseBody() = default;
};
class AddCasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasesResponseBody> body{};

  AddCasesResponse() {}

  explicit AddCasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasesResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasesResponse() = default;
};
class AddNumbersToSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instNumberGroupIdList{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> skillGroupId{};

  AddNumbersToSkillGroupRequest() {}

  explicit AddNumbersToSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instNumberGroupIdList) {
      res["InstNumberGroupIdList"] = boost::any(*instNumberGroupIdList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstNumberGroupIdList") != m.end() && !m["InstNumberGroupIdList"].empty()) {
      instNumberGroupIdList = make_shared<string>(boost::any_cast<string>(m["InstNumberGroupIdList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~AddNumbersToSkillGroupRequest() = default;
};
class AddNumbersToSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddNumbersToSkillGroupResponseBody() {}

  explicit AddNumbersToSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddNumbersToSkillGroupResponseBody() = default;
};
class AddNumbersToSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddNumbersToSkillGroupResponseBody> body{};

  AddNumbersToSkillGroupResponse() {}

  explicit AddNumbersToSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddNumbersToSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddNumbersToSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddNumbersToSkillGroupResponse() = default;
};
class AddPersonalNumbersToUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> userId{};

  AddPersonalNumbersToUserRequest() {}

  explicit AddPersonalNumbersToUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AddPersonalNumbersToUserRequest() = default;
};
class AddPersonalNumbersToUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPersonalNumbersToUserResponseBody() {}

  explicit AddPersonalNumbersToUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPersonalNumbersToUserResponseBody() = default;
};
class AddPersonalNumbersToUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPersonalNumbersToUserResponseBody> body{};

  AddPersonalNumbersToUserResponse() {}

  explicit AddPersonalNumbersToUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPersonalNumbersToUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPersonalNumbersToUserResponseBody>(model1);
      }
    }
  }


  virtual ~AddPersonalNumbersToUserResponse() = default;
};
class AddPhoneNumberToSkillGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> skillGroupIdList{};

  AddPhoneNumberToSkillGroupsRequest() {}

  explicit AddPhoneNumberToSkillGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
  }


  virtual ~AddPhoneNumberToSkillGroupsRequest() = default;
};
class AddPhoneNumberToSkillGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPhoneNumberToSkillGroupsResponseBody() {}

  explicit AddPhoneNumberToSkillGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPhoneNumberToSkillGroupsResponseBody() = default;
};
class AddPhoneNumberToSkillGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPhoneNumberToSkillGroupsResponseBody> body{};

  AddPhoneNumberToSkillGroupsResponse() {}

  explicit AddPhoneNumberToSkillGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPhoneNumberToSkillGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPhoneNumberToSkillGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~AddPhoneNumberToSkillGroupsResponse() = default;
};
class AddPhoneNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberGroupId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> usage{};

  AddPhoneNumbersRequest() {}

  explicit AddPhoneNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberGroupId) {
      res["NumberGroupId"] = boost::any(*numberGroupId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberGroupId") != m.end() && !m["NumberGroupId"].empty()) {
      numberGroupId = make_shared<string>(boost::any_cast<string>(m["NumberGroupId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~AddPhoneNumbersRequest() = default;
};
class AddPhoneNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPhoneNumbersResponseBody() {}

  explicit AddPhoneNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPhoneNumbersResponseBody() = default;
};
class AddPhoneNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPhoneNumbersResponseBody> body{};

  AddPhoneNumbersResponse() {}

  explicit AddPhoneNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPhoneNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPhoneNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~AddPhoneNumbersResponse() = default;
};
class AddSchemaPropertyRequestProperty : public Darabonba::Model {
public:
  shared_ptr<bool> array{};
  shared_ptr<string> attributes{};
  shared_ptr<string> dataType{};
  shared_ptr<string> description{};
  shared_ptr<bool> disabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> displayOrder{};
  shared_ptr<string> editorType{};
  shared_ptr<long> maxLength{};
  shared_ptr<double> maximum{};
  shared_ptr<long> minLength{};
  shared_ptr<double> minimum{};
  shared_ptr<string> name{};
  shared_ptr<string> pattern{};
  shared_ptr<string> patternErrorMessage{};
  shared_ptr<bool> readOnly{};
  shared_ptr<bool> required{};

  AddSchemaPropertyRequestProperty() {}

  explicit AddSchemaPropertyRequestProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (array) {
      res["Array"] = boost::any(*array);
    }
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayOrder) {
      res["DisplayOrder"] = boost::any(*displayOrder);
    }
    if (editorType) {
      res["EditorType"] = boost::any(*editorType);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minimum) {
      res["Minimum"] = boost::any(*minimum);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (patternErrorMessage) {
      res["PatternErrorMessage"] = boost::any(*patternErrorMessage);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Array") != m.end() && !m["Array"].empty()) {
      array = make_shared<bool>(boost::any_cast<bool>(m["Array"]));
    }
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      attributes = make_shared<string>(boost::any_cast<string>(m["Attributes"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayOrder") != m.end() && !m["DisplayOrder"].empty()) {
      displayOrder = make_shared<long>(boost::any_cast<long>(m["DisplayOrder"]));
    }
    if (m.find("EditorType") != m.end() && !m["EditorType"].empty()) {
      editorType = make_shared<string>(boost::any_cast<string>(m["EditorType"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<double>(boost::any_cast<double>(m["Maximum"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("Minimum") != m.end() && !m["Minimum"].empty()) {
      minimum = make_shared<double>(boost::any_cast<double>(m["Minimum"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("PatternErrorMessage") != m.end() && !m["PatternErrorMessage"].empty()) {
      patternErrorMessage = make_shared<string>(boost::any_cast<string>(m["PatternErrorMessage"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~AddSchemaPropertyRequestProperty() = default;
};
class AddSchemaPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<AddSchemaPropertyRequestProperty> property{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  AddSchemaPropertyRequest() {}

  explicit AddSchemaPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (property) {
      res["Property"] = property ? boost::any(property->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      if (typeid(map<string, boost::any>) == m["Property"].type()) {
        AddSchemaPropertyRequestProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Property"]));
        property = make_shared<AddSchemaPropertyRequestProperty>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~AddSchemaPropertyRequest() = default;
};
class AddSchemaPropertyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> propertyShrink{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  AddSchemaPropertyShrinkRequest() {}

  explicit AddSchemaPropertyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (propertyShrink) {
      res["Property"] = boost::any(*propertyShrink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      propertyShrink = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~AddSchemaPropertyShrinkRequest() = default;
};
class AddSchemaPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  AddSchemaPropertyResponseBody() {}

  explicit AddSchemaPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddSchemaPropertyResponseBody() = default;
};
class AddSchemaPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddSchemaPropertyResponseBody> body{};

  AddSchemaPropertyResponse() {}

  explicit AddSchemaPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSchemaPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSchemaPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~AddSchemaPropertyResponse() = default;
};
class AddSkillGroupsToUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillLevelList{};
  shared_ptr<string> userId{};

  AddSkillGroupsToUserRequest() {}

  explicit AddSkillGroupsToUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillLevelList) {
      res["SkillLevelList"] = boost::any(*skillLevelList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillLevelList") != m.end() && !m["SkillLevelList"].empty()) {
      skillLevelList = make_shared<string>(boost::any_cast<string>(m["SkillLevelList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AddSkillGroupsToUserRequest() = default;
};
class AddSkillGroupsToUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddSkillGroupsToUserResponseBody() {}

  explicit AddSkillGroupsToUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddSkillGroupsToUserResponseBody() = default;
};
class AddSkillGroupsToUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddSkillGroupsToUserResponseBody> body{};

  AddSkillGroupsToUserResponse() {}

  explicit AddSkillGroupsToUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSkillGroupsToUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSkillGroupsToUserResponseBody>(model1);
      }
    }
  }


  virtual ~AddSkillGroupsToUserResponse() = default;
};
class AddTicketTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> assignee{};
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> position{};
  shared_ptr<string> taskId{};
  shared_ptr<string> ticketId{};

  AddTicketTaskRequest() {}

  explicit AddTicketTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignee) {
      res["Assignee"] = boost::any(*assignee);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assignee") != m.end() && !m["Assignee"].empty()) {
      assignee = make_shared<string>(boost::any_cast<string>(m["Assignee"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["Position"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~AddTicketTaskRequest() = default;
};
class AddTicketTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  AddTicketTaskResponseBody() {}

  explicit AddTicketTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddTicketTaskResponseBody() = default;
};
class AddTicketTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTicketTaskResponseBody> body{};

  AddTicketTaskResponse() {}

  explicit AddTicketTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTicketTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTicketTaskResponseBody>(model1);
      }
    }
  }


  virtual ~AddTicketTaskResponse() = default;
};
class AddUsersToSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> userSkillLevelList{};

  AddUsersToSkillGroupRequest() {}

  explicit AddUsersToSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userSkillLevelList) {
      res["UserSkillLevelList"] = boost::any(*userSkillLevelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserSkillLevelList") != m.end() && !m["UserSkillLevelList"].empty()) {
      userSkillLevelList = make_shared<string>(boost::any_cast<string>(m["UserSkillLevelList"]));
    }
  }


  virtual ~AddUsersToSkillGroupRequest() = default;
};
class AddUsersToSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddUsersToSkillGroupResponseBody() {}

  explicit AddUsersToSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddUsersToSkillGroupResponseBody() = default;
};
class AddUsersToSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddUsersToSkillGroupResponseBody> body{};

  AddUsersToSkillGroupResponse() {}

  explicit AddUsersToSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddUsersToSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddUsersToSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddUsersToSkillGroupResponse() = default;
};
class AnalyzeConversationRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> fieldListJson{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskListJson{};

  AnalyzeConversationRequest() {}

  explicit AnalyzeConversationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (fieldListJson) {
      res["FieldListJson"] = boost::any(*fieldListJson);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskListJson) {
      res["TaskListJson"] = boost::any(*taskListJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("FieldListJson") != m.end() && !m["FieldListJson"].empty()) {
      fieldListJson = make_shared<string>(boost::any_cast<string>(m["FieldListJson"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskListJson") != m.end() && !m["TaskListJson"].empty()) {
      taskListJson = make_shared<string>(boost::any_cast<string>(m["TaskListJson"]));
    }
  }


  virtual ~AnalyzeConversationRequest() = default;
};
class AnalyzeConversationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AnalyzeConversationResponseBody() {}

  explicit AnalyzeConversationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AnalyzeConversationResponseBody() = default;
};
class AnalyzeConversationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AnalyzeConversationResponseBody> body{};

  AnalyzeConversationResponse() {}

  explicit AnalyzeConversationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AnalyzeConversationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AnalyzeConversationResponseBody>(model1);
      }
    }
  }


  virtual ~AnalyzeConversationResponse() = default;
};
class AnswerCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  AnswerCallRequest() {}

  explicit AnswerCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AnswerCallRequest() = default;
};
class AnswerCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> channelVariables{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  AnswerCallResponseBodyDataCallContextChannelContexts() {}

  explicit AnswerCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (channelVariables) {
      res["ChannelVariables"] = boost::any(*channelVariables);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("ChannelVariables") != m.end() && !m["ChannelVariables"].empty()) {
      channelVariables = make_shared<string>(boost::any_cast<string>(m["ChannelVariables"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AnswerCallResponseBodyDataCallContextChannelContexts() = default;
};
class AnswerCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<AnswerCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  AnswerCallResponseBodyDataCallContext() {}

  explicit AnswerCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<AnswerCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AnswerCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<AnswerCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~AnswerCallResponseBodyDataCallContext() = default;
};
class AnswerCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  AnswerCallResponseBodyDataUserContext() {}

  explicit AnswerCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~AnswerCallResponseBodyDataUserContext() = default;
};
class AnswerCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<AnswerCallResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<AnswerCallResponseBodyDataUserContext> userContext{};

  AnswerCallResponseBodyData() {}

  explicit AnswerCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        AnswerCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<AnswerCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        AnswerCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<AnswerCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~AnswerCallResponseBodyData() = default;
};
class AnswerCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<AnswerCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  AnswerCallResponseBody() {}

  explicit AnswerCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AnswerCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AnswerCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AnswerCallResponseBody() = default;
};
class AnswerCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AnswerCallResponseBody> body{};

  AnswerCallResponse() {}

  explicit AnswerCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AnswerCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AnswerCallResponseBody>(model1);
      }
    }
  }


  virtual ~AnswerCallResponse() = default;
};
class AppendCasesRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> caller{};
  shared_ptr<string> customVariables{};
  shared_ptr<string> maskedCallee{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};

  AppendCasesRequestBody() {}

  explicit AppendCasesRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (maskedCallee) {
      res["MaskedCallee"] = boost::any(*maskedCallee);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("MaskedCallee") != m.end() && !m["MaskedCallee"].empty()) {
      maskedCallee = make_shared<string>(boost::any_cast<string>(m["MaskedCallee"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~AppendCasesRequestBody() = default;
};
class AppendCasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<AppendCasesRequestBody>> body{};

  AppendCasesRequest() {}

  explicit AppendCasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<AppendCasesRequestBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppendCasesRequestBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<AppendCasesRequestBody>>(expect1);
      }
    }
  }


  virtual ~AppendCasesRequest() = default;
};
class AppendCasesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> bodyShrink{};

  AppendCasesShrinkRequest() {}

  explicit AppendCasesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (bodyShrink) {
      res["body"] = boost::any(*bodyShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      bodyShrink = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~AppendCasesShrinkRequest() = default;
};
class AppendCasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AppendCasesResponseBody() {}

  explicit AppendCasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AppendCasesResponseBody() = default;
};
class AppendCasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AppendCasesResponseBody> body{};

  AppendCasesResponse() {}

  explicit AppendCasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AppendCasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AppendCasesResponseBody>(model1);
      }
    }
  }


  virtual ~AppendCasesResponse() = default;
};
class AssignUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramIdList{};
  shared_ptr<string> roleId{};
  shared_ptr<string> skillLevelList{};
  shared_ptr<string> workMode{};

  AssignUsersRequest() {}

  explicit AssignUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramIdList) {
      res["RamIdList"] = boost::any(*ramIdList);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (skillLevelList) {
      res["SkillLevelList"] = boost::any(*skillLevelList);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamIdList") != m.end() && !m["RamIdList"].empty()) {
      ramIdList = make_shared<string>(boost::any_cast<string>(m["RamIdList"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("SkillLevelList") != m.end() && !m["SkillLevelList"].empty()) {
      skillLevelList = make_shared<string>(boost::any_cast<string>(m["SkillLevelList"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~AssignUsersRequest() = default;
};
class AssignUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> workflowId{};

  AssignUsersResponseBody() {}

  explicit AssignUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
  }


  virtual ~AssignUsersResponseBody() = default;
};
class AssignUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssignUsersResponseBody> body{};

  AssignUsersResponse() {}

  explicit AssignUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssignUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssignUsersResponseBody>(model1);
      }
    }
  }


  virtual ~AssignUsersResponse() = default;
};
class BargeInCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> bargedUserId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  BargeInCallRequest() {}

  explicit BargeInCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bargedUserId) {
      res["BargedUserId"] = boost::any(*bargedUserId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BargedUserId") != m.end() && !m["BargedUserId"].empty()) {
      bargedUserId = make_shared<string>(boost::any_cast<string>(m["BargedUserId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BargeInCallRequest() = default;
};
class BargeInCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  BargeInCallResponseBodyDataCallContextChannelContexts() {}

  explicit BargeInCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BargeInCallResponseBodyDataCallContextChannelContexts() = default;
};
class BargeInCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<BargeInCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  BargeInCallResponseBodyDataCallContext() {}

  explicit BargeInCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<BargeInCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BargeInCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<BargeInCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~BargeInCallResponseBodyDataCallContext() = default;
};
class BargeInCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  BargeInCallResponseBodyDataUserContext() {}

  explicit BargeInCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~BargeInCallResponseBodyDataUserContext() = default;
};
class BargeInCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<BargeInCallResponseBodyDataCallContext> callContext{};
  shared_ptr<BargeInCallResponseBodyDataUserContext> userContext{};

  BargeInCallResponseBodyData() {}

  explicit BargeInCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        BargeInCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<BargeInCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        BargeInCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<BargeInCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~BargeInCallResponseBodyData() = default;
};
class BargeInCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BargeInCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  BargeInCallResponseBody() {}

  explicit BargeInCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BargeInCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BargeInCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BargeInCallResponseBody() = default;
};
class BargeInCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BargeInCallResponseBody> body{};

  BargeInCallResponse() {}

  explicit BargeInCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BargeInCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BargeInCallResponseBody>(model1);
      }
    }
  }


  virtual ~BargeInCallResponse() = default;
};
class BlindTransferRequest : public Darabonba::Model {
public:
  shared_ptr<long> callPriority{};
  shared_ptr<string> contactFlowVariables{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> queuingOverflowThreshold{};
  shared_ptr<long> queuingTimeoutSeconds{};
  shared_ptr<string> routingType{};
  shared_ptr<string> strategyName{};
  shared_ptr<string> strategyParams{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> transferee{};
  shared_ptr<string> transfereeType{};
  shared_ptr<string> transferor{};
  shared_ptr<string> userId{};

  BlindTransferRequest() {}

  explicit BlindTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callPriority) {
      res["CallPriority"] = boost::any(*callPriority);
    }
    if (contactFlowVariables) {
      res["ContactFlowVariables"] = boost::any(*contactFlowVariables);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (queuingOverflowThreshold) {
      res["QueuingOverflowThreshold"] = boost::any(*queuingOverflowThreshold);
    }
    if (queuingTimeoutSeconds) {
      res["QueuingTimeoutSeconds"] = boost::any(*queuingTimeoutSeconds);
    }
    if (routingType) {
      res["RoutingType"] = boost::any(*routingType);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (strategyParams) {
      res["StrategyParams"] = boost::any(*strategyParams);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (transferee) {
      res["Transferee"] = boost::any(*transferee);
    }
    if (transfereeType) {
      res["TransfereeType"] = boost::any(*transfereeType);
    }
    if (transferor) {
      res["Transferor"] = boost::any(*transferor);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallPriority") != m.end() && !m["CallPriority"].empty()) {
      callPriority = make_shared<long>(boost::any_cast<long>(m["CallPriority"]));
    }
    if (m.find("ContactFlowVariables") != m.end() && !m["ContactFlowVariables"].empty()) {
      contactFlowVariables = make_shared<string>(boost::any_cast<string>(m["ContactFlowVariables"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("QueuingOverflowThreshold") != m.end() && !m["QueuingOverflowThreshold"].empty()) {
      queuingOverflowThreshold = make_shared<long>(boost::any_cast<long>(m["QueuingOverflowThreshold"]));
    }
    if (m.find("QueuingTimeoutSeconds") != m.end() && !m["QueuingTimeoutSeconds"].empty()) {
      queuingTimeoutSeconds = make_shared<long>(boost::any_cast<long>(m["QueuingTimeoutSeconds"]));
    }
    if (m.find("RoutingType") != m.end() && !m["RoutingType"].empty()) {
      routingType = make_shared<string>(boost::any_cast<string>(m["RoutingType"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("StrategyParams") != m.end() && !m["StrategyParams"].empty()) {
      strategyParams = make_shared<string>(boost::any_cast<string>(m["StrategyParams"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("Transferee") != m.end() && !m["Transferee"].empty()) {
      transferee = make_shared<string>(boost::any_cast<string>(m["Transferee"]));
    }
    if (m.find("TransfereeType") != m.end() && !m["TransfereeType"].empty()) {
      transfereeType = make_shared<string>(boost::any_cast<string>(m["TransfereeType"]));
    }
    if (m.find("Transferor") != m.end() && !m["Transferor"].empty()) {
      transferor = make_shared<string>(boost::any_cast<string>(m["Transferor"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BlindTransferRequest() = default;
};
class BlindTransferResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  BlindTransferResponseBodyDataCallContextChannelContexts() {}

  explicit BlindTransferResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BlindTransferResponseBodyDataCallContextChannelContexts() = default;
};
class BlindTransferResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<BlindTransferResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  BlindTransferResponseBodyDataCallContext() {}

  explicit BlindTransferResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<BlindTransferResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BlindTransferResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<BlindTransferResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~BlindTransferResponseBodyDataCallContext() = default;
};
class BlindTransferResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  BlindTransferResponseBodyDataUserContext() {}

  explicit BlindTransferResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~BlindTransferResponseBodyDataUserContext() = default;
};
class BlindTransferResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<BlindTransferResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<BlindTransferResponseBodyDataUserContext> userContext{};

  BlindTransferResponseBodyData() {}

  explicit BlindTransferResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        BlindTransferResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<BlindTransferResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        BlindTransferResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<BlindTransferResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~BlindTransferResponseBodyData() = default;
};
class BlindTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BlindTransferResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  BlindTransferResponseBody() {}

  explicit BlindTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BlindTransferResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BlindTransferResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BlindTransferResponseBody() = default;
};
class BlindTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BlindTransferResponseBody> body{};

  BlindTransferResponse() {}

  explicit BlindTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BlindTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BlindTransferResponseBody>(model1);
      }
    }
  }


  virtual ~BlindTransferResponse() = default;
};
class BridgeRtcCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> serviceProvider{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};
  shared_ptr<bool> videoEnabled{};

  BridgeRtcCallRequest() {}

  explicit BridgeRtcCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (serviceProvider) {
      res["ServiceProvider"] = boost::any(*serviceProvider);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (videoEnabled) {
      res["VideoEnabled"] = boost::any(*videoEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ServiceProvider") != m.end() && !m["ServiceProvider"].empty()) {
      serviceProvider = make_shared<string>(boost::any_cast<string>(m["ServiceProvider"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VideoEnabled") != m.end() && !m["VideoEnabled"].empty()) {
      videoEnabled = make_shared<bool>(boost::any_cast<bool>(m["VideoEnabled"]));
    }
  }


  virtual ~BridgeRtcCallRequest() = default;
};
class BridgeRtcCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> tokenInfo{};

  BridgeRtcCallResponseBodyData() {}

  explicit BridgeRtcCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (tokenInfo) {
      res["TokenInfo"] = boost::any(*tokenInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TokenInfo") != m.end() && !m["TokenInfo"].empty()) {
      tokenInfo = make_shared<string>(boost::any_cast<string>(m["TokenInfo"]));
    }
  }


  virtual ~BridgeRtcCallResponseBodyData() = default;
};
class BridgeRtcCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BridgeRtcCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  BridgeRtcCallResponseBody() {}

  explicit BridgeRtcCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BridgeRtcCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BridgeRtcCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BridgeRtcCallResponseBody() = default;
};
class BridgeRtcCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BridgeRtcCallResponseBody> body{};

  BridgeRtcCallResponse() {}

  explicit BridgeRtcCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BridgeRtcCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BridgeRtcCallResponseBody>(model1);
      }
    }
  }


  virtual ~BridgeRtcCallResponse() = default;
};
class CancelAttendedTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  CancelAttendedTransferRequest() {}

  explicit CancelAttendedTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CancelAttendedTransferRequest() = default;
};
class CancelAttendedTransferResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  CancelAttendedTransferResponseBodyDataCallContextChannelContexts() {}

  explicit CancelAttendedTransferResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CancelAttendedTransferResponseBodyDataCallContextChannelContexts() = default;
};
class CancelAttendedTransferResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<CancelAttendedTransferResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  CancelAttendedTransferResponseBodyDataCallContext() {}

  explicit CancelAttendedTransferResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<CancelAttendedTransferResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CancelAttendedTransferResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<CancelAttendedTransferResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelAttendedTransferResponseBodyDataCallContext() = default;
};
class CancelAttendedTransferResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  CancelAttendedTransferResponseBodyDataUserContext() {}

  explicit CancelAttendedTransferResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~CancelAttendedTransferResponseBodyDataUserContext() = default;
};
class CancelAttendedTransferResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<CancelAttendedTransferResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<CancelAttendedTransferResponseBodyDataUserContext> userContext{};

  CancelAttendedTransferResponseBodyData() {}

  explicit CancelAttendedTransferResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        CancelAttendedTransferResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<CancelAttendedTransferResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        CancelAttendedTransferResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<CancelAttendedTransferResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~CancelAttendedTransferResponseBodyData() = default;
};
class CancelAttendedTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CancelAttendedTransferResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  CancelAttendedTransferResponseBody() {}

  explicit CancelAttendedTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CancelAttendedTransferResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CancelAttendedTransferResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelAttendedTransferResponseBody() = default;
};
class CancelAttendedTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelAttendedTransferResponseBody> body{};

  CancelAttendedTransferResponse() {}

  explicit CancelAttendedTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelAttendedTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelAttendedTransferResponseBody>(model1);
      }
    }
  }


  virtual ~CancelAttendedTransferResponse() = default;
};
class ChangeVisibilityRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> invisible{};
  shared_ptr<string> userId{};

  ChangeVisibilityRequest() {}

  explicit ChangeVisibilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (invisible) {
      res["Invisible"] = boost::any(*invisible);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Invisible") != m.end() && !m["Invisible"].empty()) {
      invisible = make_shared<bool>(boost::any_cast<bool>(m["Invisible"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ChangeVisibilityRequest() = default;
};
class ChangeVisibilityResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  ChangeVisibilityResponseBodyData() {}

  explicit ChangeVisibilityResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ChangeVisibilityResponseBodyData() = default;
};
class ChangeVisibilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ChangeVisibilityResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ChangeVisibilityResponseBody() {}

  explicit ChangeVisibilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ChangeVisibilityResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ChangeVisibilityResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeVisibilityResponseBody() = default;
};
class ChangeVisibilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeVisibilityResponseBody> body{};

  ChangeVisibilityResponse() {}

  explicit ChangeVisibilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeVisibilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeVisibilityResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeVisibilityResponse() = default;
};
class ChangeWorkModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mobile{};
  shared_ptr<string> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  ChangeWorkModeRequest() {}

  explicit ChangeWorkModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      signedSkillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SignedSkillGroupIdList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ChangeWorkModeRequest() = default;
};
class ChangeWorkModeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  ChangeWorkModeResponseBodyData() {}

  explicit ChangeWorkModeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ChangeWorkModeResponseBodyData() = default;
};
class ChangeWorkModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ChangeWorkModeResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ChangeWorkModeResponseBody() {}

  explicit ChangeWorkModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ChangeWorkModeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ChangeWorkModeResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeWorkModeResponseBody() = default;
};
class ChangeWorkModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeWorkModeResponseBody> body{};

  ChangeWorkModeResponse() {}

  explicit ChangeWorkModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeWorkModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeWorkModeResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeWorkModeResponse() = default;
};
class ClaimChatRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> skillGroupId{};

  ClaimChatRequest() {}

  explicit ClaimChatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ClaimChatRequest() = default;
};
class ClaimChatResponseBodyDataChatContexts : public Darabonba::Model {
public:
  shared_ptr<string> accessChannelId{};
  shared_ptr<string> accessChannelName{};
  shared_ptr<string> accessChannelType{};
  shared_ptr<bool> beingAssigned{};
  shared_ptr<string> callVariables{};
  shared_ptr<string> chatType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  ClaimChatResponseBodyDataChatContexts() {}

  explicit ClaimChatResponseBodyDataChatContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelId) {
      res["AccessChannelId"] = boost::any(*accessChannelId);
    }
    if (accessChannelName) {
      res["AccessChannelName"] = boost::any(*accessChannelName);
    }
    if (accessChannelType) {
      res["AccessChannelType"] = boost::any(*accessChannelType);
    }
    if (beingAssigned) {
      res["BeingAssigned"] = boost::any(*beingAssigned);
    }
    if (callVariables) {
      res["CallVariables"] = boost::any(*callVariables);
    }
    if (chatType) {
      res["ChatType"] = boost::any(*chatType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelId") != m.end() && !m["AccessChannelId"].empty()) {
      accessChannelId = make_shared<string>(boost::any_cast<string>(m["AccessChannelId"]));
    }
    if (m.find("AccessChannelName") != m.end() && !m["AccessChannelName"].empty()) {
      accessChannelName = make_shared<string>(boost::any_cast<string>(m["AccessChannelName"]));
    }
    if (m.find("AccessChannelType") != m.end() && !m["AccessChannelType"].empty()) {
      accessChannelType = make_shared<string>(boost::any_cast<string>(m["AccessChannelType"]));
    }
    if (m.find("BeingAssigned") != m.end() && !m["BeingAssigned"].empty()) {
      beingAssigned = make_shared<bool>(boost::any_cast<bool>(m["BeingAssigned"]));
    }
    if (m.find("CallVariables") != m.end() && !m["CallVariables"].empty()) {
      callVariables = make_shared<string>(boost::any_cast<string>(m["CallVariables"]));
    }
    if (m.find("ChatType") != m.end() && !m["ChatType"].empty()) {
      chatType = make_shared<string>(boost::any_cast<string>(m["ChatType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ClaimChatResponseBodyDataChatContexts() = default;
};
class ClaimChatResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  ClaimChatResponseBodyDataUserContext() {}

  explicit ClaimChatResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ClaimChatResponseBodyDataUserContext() = default;
};
class ClaimChatResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ClaimChatResponseBodyDataChatContexts>> chatContexts{};
  shared_ptr<long> contextId{};
  shared_ptr<ClaimChatResponseBodyDataUserContext> userContext{};

  ClaimChatResponseBodyData() {}

  explicit ClaimChatResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chatContexts) {
      vector<boost::any> temp1;
      for(auto item1:*chatContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChatContexts"] = boost::any(temp1);
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChatContexts") != m.end() && !m["ChatContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChatContexts"].type()) {
        vector<ClaimChatResponseBodyDataChatContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChatContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ClaimChatResponseBodyDataChatContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        chatContexts = make_shared<vector<ClaimChatResponseBodyDataChatContexts>>(expect1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        ClaimChatResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<ClaimChatResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~ClaimChatResponseBodyData() = default;
};
class ClaimChatResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ClaimChatResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ClaimChatResponseBody() {}

  explicit ClaimChatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ClaimChatResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ClaimChatResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ClaimChatResponseBody() = default;
};
class ClaimChatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClaimChatResponseBody> body{};

  ClaimChatResponse() {}

  explicit ClaimChatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClaimChatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClaimChatResponseBody>(model1);
      }
    }
  }


  virtual ~ClaimChatResponse() = default;
};
class CoachCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> coachedUserId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  CoachCallRequest() {}

  explicit CoachCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coachedUserId) {
      res["CoachedUserId"] = boost::any(*coachedUserId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoachedUserId") != m.end() && !m["CoachedUserId"].empty()) {
      coachedUserId = make_shared<string>(boost::any_cast<string>(m["CoachedUserId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CoachCallRequest() = default;
};
class CoachCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  CoachCallResponseBodyDataCallContextChannelContexts() {}

  explicit CoachCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CoachCallResponseBodyDataCallContextChannelContexts() = default;
};
class CoachCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<CoachCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  CoachCallResponseBodyDataCallContext() {}

  explicit CoachCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<CoachCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CoachCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<CoachCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CoachCallResponseBodyDataCallContext() = default;
};
class CoachCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  CoachCallResponseBodyDataUserContext() {}

  explicit CoachCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~CoachCallResponseBodyDataUserContext() = default;
};
class CoachCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<CoachCallResponseBodyDataCallContext> callContext{};
  shared_ptr<CoachCallResponseBodyDataUserContext> userContext{};

  CoachCallResponseBodyData() {}

  explicit CoachCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        CoachCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<CoachCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        CoachCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<CoachCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~CoachCallResponseBodyData() = default;
};
class CoachCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CoachCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  CoachCallResponseBody() {}

  explicit CoachCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CoachCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CoachCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CoachCallResponseBody() = default;
};
class CoachCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CoachCallResponseBody> body{};

  CoachCallResponse() {}

  explicit CoachCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CoachCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CoachCallResponseBody>(model1);
      }
    }
  }


  virtual ~CoachCallResponse() = default;
};
class CommitContactFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> definition{};
  shared_ptr<string> description{};
  shared_ptr<string> draftId{};
  shared_ptr<string> instanceId{};

  CommitContactFlowRequest() {}

  explicit CommitContactFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (draftId) {
      res["DraftId"] = boost::any(*draftId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DraftId") != m.end() && !m["DraftId"].empty()) {
      draftId = make_shared<string>(boost::any_cast<string>(m["DraftId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CommitContactFlowRequest() = default;
};
class CommitContactFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CommitContactFlowResponseBody() {}

  explicit CommitContactFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CommitContactFlowResponseBody() = default;
};
class CommitContactFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CommitContactFlowResponseBody> body{};

  CommitContactFlowResponse() {}

  explicit CommitContactFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommitContactFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommitContactFlowResponseBody>(model1);
      }
    }
  }


  virtual ~CommitContactFlowResponse() = default;
};
class CompleteAttendedTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  CompleteAttendedTransferRequest() {}

  explicit CompleteAttendedTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CompleteAttendedTransferRequest() = default;
};
class CompleteAttendedTransferResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  CompleteAttendedTransferResponseBodyDataCallContextChannelContexts() {}

  explicit CompleteAttendedTransferResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CompleteAttendedTransferResponseBodyDataCallContextChannelContexts() = default;
};
class CompleteAttendedTransferResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<CompleteAttendedTransferResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  CompleteAttendedTransferResponseBodyDataCallContext() {}

  explicit CompleteAttendedTransferResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<CompleteAttendedTransferResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CompleteAttendedTransferResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<CompleteAttendedTransferResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CompleteAttendedTransferResponseBodyDataCallContext() = default;
};
class CompleteAttendedTransferResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  CompleteAttendedTransferResponseBodyDataUserContext() {}

  explicit CompleteAttendedTransferResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~CompleteAttendedTransferResponseBodyDataUserContext() = default;
};
class CompleteAttendedTransferResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<CompleteAttendedTransferResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<CompleteAttendedTransferResponseBodyDataUserContext> userContext{};

  CompleteAttendedTransferResponseBodyData() {}

  explicit CompleteAttendedTransferResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        CompleteAttendedTransferResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<CompleteAttendedTransferResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        CompleteAttendedTransferResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<CompleteAttendedTransferResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~CompleteAttendedTransferResponseBodyData() = default;
};
class CompleteAttendedTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CompleteAttendedTransferResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  CompleteAttendedTransferResponseBody() {}

  explicit CompleteAttendedTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CompleteAttendedTransferResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CompleteAttendedTransferResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CompleteAttendedTransferResponseBody() = default;
};
class CompleteAttendedTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CompleteAttendedTransferResponseBody> body{};

  CompleteAttendedTransferResponse() {}

  explicit CompleteAttendedTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CompleteAttendedTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CompleteAttendedTransferResponseBody>(model1);
      }
    }
  }


  virtual ~CompleteAttendedTransferResponse() = default;
};
class CreateAudioFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFileName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> ossFileKey{};
  shared_ptr<string> usage{};

  CreateAudioFileRequest() {}

  explicit CreateAudioFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFileName) {
      res["AudioFileName"] = boost::any(*audioFileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossFileKey) {
      res["OssFileKey"] = boost::any(*ossFileKey);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFileName") != m.end() && !m["AudioFileName"].empty()) {
      audioFileName = make_shared<string>(boost::any_cast<string>(m["AudioFileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssFileKey") != m.end() && !m["OssFileKey"].empty()) {
      ossFileKey = make_shared<string>(boost::any_cast<string>(m["OssFileKey"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~CreateAudioFileRequest() = default;
};
class CreateAudioFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateAudioFileResponseBody() {}

  explicit CreateAudioFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAudioFileResponseBody() = default;
};
class CreateAudioFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAudioFileResponseBody> body{};

  CreateAudioFileResponse() {}

  explicit CreateAudioFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAudioFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAudioFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAudioFileResponse() = default;
};
class CreateCallTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> callTagNameList{};
  shared_ptr<string> instanceId{};

  CreateCallTagsRequest() {}

  explicit CreateCallTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callTagNameList) {
      res["CallTagNameList"] = boost::any(*callTagNameList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallTagNameList") != m.end() && !m["CallTagNameList"].empty()) {
      callTagNameList = make_shared<string>(boost::any_cast<string>(m["CallTagNameList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateCallTagsRequest() = default;
};
class CreateCallTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> reason{};

  CreateCallTagsResponseBodyData() {}

  explicit CreateCallTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~CreateCallTagsResponseBodyData() = default;
};
class CreateCallTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<CreateCallTagsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateCallTagsResponseBody() {}

  explicit CreateCallTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<CreateCallTagsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCallTagsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<CreateCallTagsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCallTagsResponseBody() = default;
};
class CreateCallTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCallTagsResponseBody> body{};

  CreateCallTagsResponse() {}

  explicit CreateCallTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCallTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCallTagsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCallTagsResponse() = default;
};
class CreateCampaignRequestCaseList : public Darabonba::Model {
public:
  shared_ptr<string> customVariables{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};

  CreateCampaignRequestCaseList() {}

  explicit CreateCampaignRequestCaseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~CreateCampaignRequestCaseList() = default;
};
class CreateCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> callableTime{};
  shared_ptr<string> caseFileKey{};
  shared_ptr<vector<CreateCampaignRequestCaseList>> caseList{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> endTime{};
  shared_ptr<bool> executingUntilTimeout{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxAttemptCount{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> name{};
  shared_ptr<string> queueId{};
  shared_ptr<bool> simulation{};
  shared_ptr<string> simulationParameters{};
  shared_ptr<string> startTime{};
  shared_ptr<string> strategyParameters{};
  shared_ptr<string> strategyType{};

  CreateCampaignRequest() {}

  explicit CreateCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callableTime) {
      res["CallableTime"] = boost::any(*callableTime);
    }
    if (caseFileKey) {
      res["CaseFileKey"] = boost::any(*caseFileKey);
    }
    if (caseList) {
      vector<boost::any> temp1;
      for(auto item1:*caseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CaseList"] = boost::any(temp1);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (executingUntilTimeout) {
      res["ExecutingUntilTimeout"] = boost::any(*executingUntilTimeout);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxAttemptCount) {
      res["MaxAttemptCount"] = boost::any(*maxAttemptCount);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (simulation) {
      res["Simulation"] = boost::any(*simulation);
    }
    if (simulationParameters) {
      res["SimulationParameters"] = boost::any(*simulationParameters);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyParameters) {
      res["StrategyParameters"] = boost::any(*strategyParameters);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallableTime") != m.end() && !m["CallableTime"].empty()) {
      callableTime = make_shared<string>(boost::any_cast<string>(m["CallableTime"]));
    }
    if (m.find("CaseFileKey") != m.end() && !m["CaseFileKey"].empty()) {
      caseFileKey = make_shared<string>(boost::any_cast<string>(m["CaseFileKey"]));
    }
    if (m.find("CaseList") != m.end() && !m["CaseList"].empty()) {
      if (typeid(vector<boost::any>) == m["CaseList"].type()) {
        vector<CreateCampaignRequestCaseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CaseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCampaignRequestCaseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        caseList = make_shared<vector<CreateCampaignRequestCaseList>>(expect1);
      }
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExecutingUntilTimeout") != m.end() && !m["ExecutingUntilTimeout"].empty()) {
      executingUntilTimeout = make_shared<bool>(boost::any_cast<bool>(m["ExecutingUntilTimeout"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxAttemptCount") != m.end() && !m["MaxAttemptCount"].empty()) {
      maxAttemptCount = make_shared<long>(boost::any_cast<long>(m["MaxAttemptCount"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("Simulation") != m.end() && !m["Simulation"].empty()) {
      simulation = make_shared<bool>(boost::any_cast<bool>(m["Simulation"]));
    }
    if (m.find("SimulationParameters") != m.end() && !m["SimulationParameters"].empty()) {
      simulationParameters = make_shared<string>(boost::any_cast<string>(m["SimulationParameters"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StrategyParameters") != m.end() && !m["StrategyParameters"].empty()) {
      strategyParameters = make_shared<string>(boost::any_cast<string>(m["StrategyParameters"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<string>(boost::any_cast<string>(m["StrategyType"]));
    }
  }


  virtual ~CreateCampaignRequest() = default;
};
class CreateCampaignShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> callableTime{};
  shared_ptr<string> caseFileKey{};
  shared_ptr<string> caseListShrink{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> endTime{};
  shared_ptr<bool> executingUntilTimeout{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxAttemptCount{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> name{};
  shared_ptr<string> queueId{};
  shared_ptr<bool> simulation{};
  shared_ptr<string> simulationParameters{};
  shared_ptr<string> startTime{};
  shared_ptr<string> strategyParameters{};
  shared_ptr<string> strategyType{};

  CreateCampaignShrinkRequest() {}

  explicit CreateCampaignShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callableTime) {
      res["CallableTime"] = boost::any(*callableTime);
    }
    if (caseFileKey) {
      res["CaseFileKey"] = boost::any(*caseFileKey);
    }
    if (caseListShrink) {
      res["CaseList"] = boost::any(*caseListShrink);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (executingUntilTimeout) {
      res["ExecutingUntilTimeout"] = boost::any(*executingUntilTimeout);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxAttemptCount) {
      res["MaxAttemptCount"] = boost::any(*maxAttemptCount);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (simulation) {
      res["Simulation"] = boost::any(*simulation);
    }
    if (simulationParameters) {
      res["SimulationParameters"] = boost::any(*simulationParameters);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyParameters) {
      res["StrategyParameters"] = boost::any(*strategyParameters);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallableTime") != m.end() && !m["CallableTime"].empty()) {
      callableTime = make_shared<string>(boost::any_cast<string>(m["CallableTime"]));
    }
    if (m.find("CaseFileKey") != m.end() && !m["CaseFileKey"].empty()) {
      caseFileKey = make_shared<string>(boost::any_cast<string>(m["CaseFileKey"]));
    }
    if (m.find("CaseList") != m.end() && !m["CaseList"].empty()) {
      caseListShrink = make_shared<string>(boost::any_cast<string>(m["CaseList"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExecutingUntilTimeout") != m.end() && !m["ExecutingUntilTimeout"].empty()) {
      executingUntilTimeout = make_shared<bool>(boost::any_cast<bool>(m["ExecutingUntilTimeout"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxAttemptCount") != m.end() && !m["MaxAttemptCount"].empty()) {
      maxAttemptCount = make_shared<long>(boost::any_cast<long>(m["MaxAttemptCount"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("Simulation") != m.end() && !m["Simulation"].empty()) {
      simulation = make_shared<bool>(boost::any_cast<bool>(m["Simulation"]));
    }
    if (m.find("SimulationParameters") != m.end() && !m["SimulationParameters"].empty()) {
      simulationParameters = make_shared<string>(boost::any_cast<string>(m["SimulationParameters"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StrategyParameters") != m.end() && !m["StrategyParameters"].empty()) {
      strategyParameters = make_shared<string>(boost::any_cast<string>(m["StrategyParameters"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<string>(boost::any_cast<string>(m["StrategyType"]));
    }
  }


  virtual ~CreateCampaignShrinkRequest() = default;
};
class CreateCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateCampaignResponseBody() {}

  explicit CreateCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCampaignResponseBody() = default;
};
class CreateCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCampaignResponseBody> body{};

  CreateCampaignResponse() {}

  explicit CreateCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCampaignResponse() = default;
};
class CreateContactFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> definition{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  CreateContactFlowRequest() {}

  explicit CreateContactFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateContactFlowRequest() = default;
};
class CreateContactFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateContactFlowResponseBody() {}

  explicit CreateContactFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateContactFlowResponseBody() = default;
};
class CreateContactFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateContactFlowResponseBody> body{};

  CreateContactFlowResponse() {}

  explicit CreateContactFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateContactFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateContactFlowResponseBody>(model1);
      }
    }
  }


  virtual ~CreateContactFlowResponse() = default;
};
class CreateCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> customNumberList{};
  shared_ptr<string> instanceId{};

  CreateCustomCallTaggingRequest() {}

  explicit CreateCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customNumberList) {
      res["CustomNumberList"] = boost::any(*customNumberList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomNumberList") != m.end() && !m["CustomNumberList"].empty()) {
      customNumberList = make_shared<string>(boost::any_cast<string>(m["CustomNumberList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateCustomCallTaggingRequest() = default;
};
class CreateCustomCallTaggingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> reason{};

  CreateCustomCallTaggingResponseBodyData() {}

  explicit CreateCustomCallTaggingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~CreateCustomCallTaggingResponseBodyData() = default;
};
class CreateCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<CreateCustomCallTaggingResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateCustomCallTaggingResponseBody() {}

  explicit CreateCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<CreateCustomCallTaggingResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomCallTaggingResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<CreateCustomCallTaggingResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomCallTaggingResponseBody() = default;
};
class CreateCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomCallTaggingResponseBody> body{};

  CreateCustomCallTaggingResponse() {}

  explicit CreateCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomCallTaggingResponse() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> adminRamIdList{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> name{};
  shared_ptr<string> numberList{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminRamIdList) {
      res["AdminRamIdList"] = boost::any(*adminRamIdList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminRamIdList") != m.end() && !m["AdminRamIdList"].empty()) {
      adminRamIdList = make_shared<string>(boost::any_cast<string>(m["AdminRamIdList"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateSchemaRequestProperties : public Darabonba::Model {
public:
  shared_ptr<bool> array{};
  shared_ptr<string> attributes{};
  shared_ptr<string> dataType{};
  shared_ptr<string> description{};
  shared_ptr<bool> disabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> displayOrder{};
  shared_ptr<string> editorType{};
  shared_ptr<long> maxLength{};
  shared_ptr<double> maximum{};
  shared_ptr<long> minLength{};
  shared_ptr<double> minimum{};
  shared_ptr<string> name{};
  shared_ptr<string> pattern{};
  shared_ptr<string> patternErrorMessage{};
  shared_ptr<bool> readOnly{};
  shared_ptr<bool> required{};

  CreateSchemaRequestProperties() {}

  explicit CreateSchemaRequestProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (array) {
      res["Array"] = boost::any(*array);
    }
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayOrder) {
      res["DisplayOrder"] = boost::any(*displayOrder);
    }
    if (editorType) {
      res["EditorType"] = boost::any(*editorType);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minimum) {
      res["Minimum"] = boost::any(*minimum);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (patternErrorMessage) {
      res["PatternErrorMessage"] = boost::any(*patternErrorMessage);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Array") != m.end() && !m["Array"].empty()) {
      array = make_shared<bool>(boost::any_cast<bool>(m["Array"]));
    }
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      attributes = make_shared<string>(boost::any_cast<string>(m["Attributes"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayOrder") != m.end() && !m["DisplayOrder"].empty()) {
      displayOrder = make_shared<long>(boost::any_cast<long>(m["DisplayOrder"]));
    }
    if (m.find("EditorType") != m.end() && !m["EditorType"].empty()) {
      editorType = make_shared<string>(boost::any_cast<string>(m["EditorType"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<double>(boost::any_cast<double>(m["Maximum"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("Minimum") != m.end() && !m["Minimum"].empty()) {
      minimum = make_shared<double>(boost::any_cast<double>(m["Minimum"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("PatternErrorMessage") != m.end() && !m["PatternErrorMessage"].empty()) {
      patternErrorMessage = make_shared<string>(boost::any_cast<string>(m["PatternErrorMessage"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~CreateSchemaRequestProperties() = default;
};
class CreateSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<CreateSchemaRequestProperties>> properties{};
  shared_ptr<string> requestId{};

  CreateSchemaRequest() {}

  explicit CreateSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (properties) {
      vector<boost::any> temp1;
      for(auto item1:*properties){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Properties"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(vector<boost::any>) == m["Properties"].type()) {
        vector<CreateSchemaRequestProperties> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Properties"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSchemaRequestProperties model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        properties = make_shared<vector<CreateSchemaRequestProperties>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSchemaRequest() = default;
};
class CreateSchemaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> propertiesShrink{};
  shared_ptr<string> requestId{};

  CreateSchemaShrinkRequest() {}

  explicit CreateSchemaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (propertiesShrink) {
      res["Properties"] = boost::any(*propertiesShrink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      propertiesShrink = make_shared<string>(boost::any_cast<string>(m["Properties"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSchemaShrinkRequest() = default;
};
class CreateSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  CreateSchemaResponseBody() {}

  explicit CreateSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSchemaResponseBody() = default;
};
class CreateSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSchemaResponseBody> body{};

  CreateSchemaResponse() {}

  explicit CreateSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSchemaResponse() = default;
};
class CreateSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> name{};

  CreateSkillGroupRequest() {}

  explicit CreateSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateSkillGroupRequest() = default;
};
class CreateSkillGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> name{};
  shared_ptr<string> skillGroupId{};

  CreateSkillGroupResponseBodyData() {}

  explicit CreateSkillGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~CreateSkillGroupResponseBodyData() = default;
};
class CreateSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateSkillGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateSkillGroupResponseBody() {}

  explicit CreateSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateSkillGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateSkillGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSkillGroupResponseBody() = default;
};
class CreateSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSkillGroupResponseBody> body{};

  CreateSkillGroupResponse() {}

  explicit CreateSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSkillGroupResponse() = default;
};
class CreateTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> context{};
  shared_ptr<string> customerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> source{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};

  CreateTicketRequest() {}

  explicit CreateTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (context) {
      res["Context"] = boost::any(*context);
    }
    if (customerId) {
      res["CustomerId"] = boost::any(*customerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Context") != m.end() && !m["Context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["Context"]));
    }
    if (m.find("CustomerId") != m.end() && !m["CustomerId"].empty()) {
      customerId = make_shared<string>(boost::any_cast<string>(m["CustomerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateTicketRequest() = default;
};
class CreateTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateTicketResponseBody() {}

  explicit CreateTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateTicketResponseBody() = default;
};
class CreateTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTicketResponseBody> body{};

  CreateTicketResponse() {}

  explicit CreateTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTicketResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTicketResponse() = default;
};
class CreateUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> displayId{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> nickname{};
  shared_ptr<bool> resetPassword{};
  shared_ptr<string> roleId{};
  shared_ptr<string> skillLevelList{};
  shared_ptr<string> workMode{};

  CreateUserRequest() {}

  explicit CreateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (resetPassword) {
      res["ResetPassword"] = boost::any(*resetPassword);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (skillLevelList) {
      res["SkillLevelList"] = boost::any(*skillLevelList);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("ResetPassword") != m.end() && !m["ResetPassword"].empty()) {
      resetPassword = make_shared<bool>(boost::any_cast<bool>(m["ResetPassword"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("SkillLevelList") != m.end() && !m["SkillLevelList"].empty()) {
      skillLevelList = make_shared<string>(boost::any_cast<string>(m["SkillLevelList"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~CreateUserRequest() = default;
};
class CreateUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> nickname{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  CreateUserResponseBodyData() {}

  explicit CreateUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~CreateUserResponseBodyData() = default;
};
class CreateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  CreateUserResponseBody() {}

  explicit CreateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateUserResponseBody() = default;
};
class CreateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserResponseBody> body{};

  CreateUserResponse() {}

  explicit CreateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserResponse() = default;
};
class DeleteAudioFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> instanceId{};

  DeleteAudioFileRequest() {}

  explicit DeleteAudioFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteAudioFileRequest() = default;
};
class DeleteAudioFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteAudioFileResponseBody() {}

  explicit DeleteAudioFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAudioFileResponseBody() = default;
};
class DeleteAudioFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAudioFileResponseBody> body{};

  DeleteAudioFileResponse() {}

  explicit DeleteAudioFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAudioFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAudioFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAudioFileResponse() = default;
};
class DeleteCallTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tagName{};

  DeleteCallTagRequest() {}

  explicit DeleteCallTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~DeleteCallTagRequest() = default;
};
class DeleteCallTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteCallTagResponseBody() {}

  explicit DeleteCallTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCallTagResponseBody() = default;
};
class DeleteCallTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCallTagResponseBody> body{};

  DeleteCallTagResponse() {}

  explicit DeleteCallTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCallTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCallTagResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCallTagResponse() = default;
};
class DeleteContactFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};

  DeleteContactFlowRequest() {}

  explicit DeleteContactFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteContactFlowRequest() = default;
};
class DeleteContactFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteContactFlowResponseBody() {}

  explicit DeleteContactFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteContactFlowResponseBody() = default;
};
class DeleteContactFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactFlowResponseBody> body{};

  DeleteContactFlowResponse() {}

  explicit DeleteContactFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactFlowResponse() = default;
};
class DeleteCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};

  DeleteCustomCallTaggingRequest() {}

  explicit DeleteCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~DeleteCustomCallTaggingRequest() = default;
};
class DeleteCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteCustomCallTaggingResponseBody() {}

  explicit DeleteCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomCallTaggingResponseBody() = default;
};
class DeleteCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomCallTaggingResponseBody> body{};

  DeleteCustomCallTaggingResponse() {}

  explicit DeleteCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomCallTaggingResponse() = default;
};
class DeleteDocumentRequest : public Darabonba::Model {
public:
  shared_ptr<string> documentId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  DeleteDocumentRequest() {}

  explicit DeleteDocumentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (documentId) {
      res["DocumentId"] = boost::any(*documentId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocumentId") != m.end() && !m["DocumentId"].empty()) {
      documentId = make_shared<string>(boost::any_cast<string>(m["DocumentId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~DeleteDocumentRequest() = default;
};
class DeleteDocumentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  DeleteDocumentResponseBody() {}

  explicit DeleteDocumentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDocumentResponseBody() = default;
};
class DeleteDocumentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDocumentResponseBody> body{};

  DeleteDocumentResponse() {}

  explicit DeleteDocumentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDocumentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDocumentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDocumentResponse() = default;
};
class DeleteDocumentsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> documentIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  DeleteDocumentsRequest() {}

  explicit DeleteDocumentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (documentIds) {
      res["DocumentIds"] = boost::any(*documentIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocumentIds") != m.end() && !m["DocumentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocumentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocumentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      documentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~DeleteDocumentsRequest() = default;
};
class DeleteDocumentsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> documentIdsShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  DeleteDocumentsShrinkRequest() {}

  explicit DeleteDocumentsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (documentIdsShrink) {
      res["DocumentIds"] = boost::any(*documentIdsShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocumentIds") != m.end() && !m["DocumentIds"].empty()) {
      documentIdsShrink = make_shared<string>(boost::any_cast<string>(m["DocumentIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~DeleteDocumentsShrinkRequest() = default;
};
class DeleteDocumentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  DeleteDocumentsResponseBody() {}

  explicit DeleteDocumentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDocumentsResponseBody() = default;
};
class DeleteDocumentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDocumentsResponseBody> body{};

  DeleteDocumentsResponse() {}

  explicit DeleteDocumentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDocumentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDocumentsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDocumentsResponse() = default;
};
class DeleteSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  DeleteSchemaRequest() {}

  explicit DeleteSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~DeleteSchemaRequest() = default;
};
class DeleteSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  DeleteSchemaResponseBody() {}

  explicit DeleteSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSchemaResponseBody() = default;
};
class DeleteSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSchemaResponseBody> body{};

  DeleteSchemaResponse() {}

  explicit DeleteSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSchemaResponse() = default;
};
class DeleteSchemaPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> propertyName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  DeleteSchemaPropertyRequest() {}

  explicit DeleteSchemaPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (propertyName) {
      res["PropertyName"] = boost::any(*propertyName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PropertyName") != m.end() && !m["PropertyName"].empty()) {
      propertyName = make_shared<string>(boost::any_cast<string>(m["PropertyName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~DeleteSchemaPropertyRequest() = default;
};
class DeleteSchemaPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  DeleteSchemaPropertyResponseBody() {}

  explicit DeleteSchemaPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSchemaPropertyResponseBody() = default;
};
class DeleteSchemaPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSchemaPropertyResponseBody> body{};

  DeleteSchemaPropertyResponse() {}

  explicit DeleteSchemaPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSchemaPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSchemaPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSchemaPropertyResponse() = default;
};
class DeleteSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<bool> force{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};

  DeleteSkillGroupRequest() {}

  explicit DeleteSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~DeleteSkillGroupRequest() = default;
};
class DeleteSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteSkillGroupResponseBody() {}

  explicit DeleteSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSkillGroupResponseBody() = default;
};
class DeleteSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSkillGroupResponseBody> body{};

  DeleteSkillGroupResponse() {}

  explicit DeleteSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSkillGroupResponse() = default;
};
class DeleteTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ticketId{};

  DeleteTicketRequest() {}

  explicit DeleteTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~DeleteTicketRequest() = default;
};
class DeleteTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  DeleteTicketResponseBody() {}

  explicit DeleteTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTicketResponseBody() = default;
};
class DeleteTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTicketResponseBody> body{};

  DeleteTicketResponse() {}

  explicit DeleteTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTicketResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTicketResponse() = default;
};
class DeleteTicketTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> templateId{};

  DeleteTicketTemplateRequest() {}

  explicit DeleteTicketTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteTicketTemplateRequest() = default;
};
class DeleteTicketTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  DeleteTicketTemplateResponseBody() {}

  explicit DeleteTicketTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTicketTemplateResponseBody() = default;
};
class DeleteTicketTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTicketTemplateResponseBody> body{};

  DeleteTicketTemplateResponse() {}

  explicit DeleteTicketTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTicketTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTicketTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTicketTemplateResponse() = default;
};
class DisableSchemaPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> propertyName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  DisableSchemaPropertyRequest() {}

  explicit DisableSchemaPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (propertyName) {
      res["PropertyName"] = boost::any(*propertyName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PropertyName") != m.end() && !m["PropertyName"].empty()) {
      propertyName = make_shared<string>(boost::any_cast<string>(m["PropertyName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~DisableSchemaPropertyRequest() = default;
};
class DisableSchemaPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  DisableSchemaPropertyResponseBody() {}

  explicit DisableSchemaPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableSchemaPropertyResponseBody() = default;
};
class DisableSchemaPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableSchemaPropertyResponseBody> body{};

  DisableSchemaPropertyResponse() {}

  explicit DisableSchemaPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableSchemaPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableSchemaPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~DisableSchemaPropertyResponse() = default;
};
class DisableTicketTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> templateId{};

  DisableTicketTemplateRequest() {}

  explicit DisableTicketTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DisableTicketTemplateRequest() = default;
};
class DisableTicketTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  DisableTicketTemplateResponseBody() {}

  explicit DisableTicketTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableTicketTemplateResponseBody() = default;
};
class DisableTicketTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableTicketTemplateResponseBody> body{};

  DisableTicketTemplateResponse() {}

  explicit DisableTicketTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableTicketTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableTicketTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DisableTicketTemplateResponse() = default;
};
class DiscardEditingContactFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> draftId{};
  shared_ptr<string> instanceId{};

  DiscardEditingContactFlowRequest() {}

  explicit DiscardEditingContactFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (draftId) {
      res["DraftId"] = boost::any(*draftId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("DraftId") != m.end() && !m["DraftId"].empty()) {
      draftId = make_shared<string>(boost::any_cast<string>(m["DraftId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DiscardEditingContactFlowRequest() = default;
};
class DiscardEditingContactFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DiscardEditingContactFlowResponseBody() {}

  explicit DiscardEditingContactFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DiscardEditingContactFlowResponseBody() = default;
};
class DiscardEditingContactFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DiscardEditingContactFlowResponseBody> body{};

  DiscardEditingContactFlowResponse() {}

  explicit DiscardEditingContactFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DiscardEditingContactFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DiscardEditingContactFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DiscardEditingContactFlowResponse() = default;
};
class EnableSchemaPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> propertyName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  EnableSchemaPropertyRequest() {}

  explicit EnableSchemaPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (propertyName) {
      res["PropertyName"] = boost::any(*propertyName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PropertyName") != m.end() && !m["PropertyName"].empty()) {
      propertyName = make_shared<string>(boost::any_cast<string>(m["PropertyName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~EnableSchemaPropertyRequest() = default;
};
class EnableSchemaPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  EnableSchemaPropertyResponseBody() {}

  explicit EnableSchemaPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableSchemaPropertyResponseBody() = default;
};
class EnableSchemaPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableSchemaPropertyResponseBody> body{};

  EnableSchemaPropertyResponse() {}

  explicit EnableSchemaPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableSchemaPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableSchemaPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~EnableSchemaPropertyResponse() = default;
};
class EnableTicketTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> templateId{};

  EnableTicketTemplateRequest() {}

  explicit EnableTicketTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~EnableTicketTemplateRequest() = default;
};
class EnableTicketTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  EnableTicketTemplateResponseBody() {}

  explicit EnableTicketTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableTicketTemplateResponseBody() = default;
};
class EnableTicketTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableTicketTemplateResponseBody> body{};

  EnableTicketTemplateResponse() {}

  explicit EnableTicketTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableTicketTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableTicketTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~EnableTicketTemplateResponse() = default;
};
class EndConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  EndConferenceRequest() {}

  explicit EndConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~EndConferenceRequest() = default;
};
class EndConferenceResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  EndConferenceResponseBodyDataCallContextChannelContexts() {}

  explicit EndConferenceResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~EndConferenceResponseBodyDataCallContextChannelContexts() = default;
};
class EndConferenceResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<vector<EndConferenceResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  EndConferenceResponseBodyDataCallContext() {}

  explicit EndConferenceResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<EndConferenceResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EndConferenceResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<EndConferenceResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~EndConferenceResponseBodyDataCallContext() = default;
};
class EndConferenceResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  EndConferenceResponseBodyDataUserContext() {}

  explicit EndConferenceResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~EndConferenceResponseBodyDataUserContext() = default;
};
class EndConferenceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<EndConferenceResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<EndConferenceResponseBodyDataUserContext> userContext{};

  EndConferenceResponseBodyData() {}

  explicit EndConferenceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        EndConferenceResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<EndConferenceResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        EndConferenceResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<EndConferenceResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~EndConferenceResponseBodyData() = default;
};
class EndConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<EndConferenceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  EndConferenceResponseBody() {}

  explicit EndConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        EndConferenceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<EndConferenceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EndConferenceResponseBody() = default;
};
class EndConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EndConferenceResponseBody> body{};

  EndConferenceResponse() {}

  explicit EndConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EndConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EndConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~EndConferenceResponse() = default;
};
class ExportCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ExportCustomCallTaggingRequest() {}

  explicit ExportCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ExportCustomCallTaggingRequest() = default;
};
class ExportCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ExportCustomCallTaggingResponseBody() {}

  explicit ExportCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportCustomCallTaggingResponseBody() = default;
};
class ExportCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportCustomCallTaggingResponseBody> body{};

  ExportCustomCallTaggingResponse() {}

  explicit ExportCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~ExportCustomCallTaggingResponse() = default;
};
class ExportDoNotCallNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scope{};
  shared_ptr<string> searchPattern{};

  ExportDoNotCallNumbersRequest() {}

  explicit ExportDoNotCallNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ExportDoNotCallNumbersRequest() = default;
};
class ExportDoNotCallNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ExportDoNotCallNumbersResponseBody() {}

  explicit ExportDoNotCallNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportDoNotCallNumbersResponseBody() = default;
};
class ExportDoNotCallNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportDoNotCallNumbersResponseBody> body{};

  ExportDoNotCallNumbersResponse() {}

  explicit ExportDoNotCallNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportDoNotCallNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportDoNotCallNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ExportDoNotCallNumbersResponse() = default;
};
class FinishTicketTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> ticketId{};

  FinishTicketTaskRequest() {}

  explicit FinishTicketTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~FinishTicketTaskRequest() = default;
};
class FinishTicketTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  FinishTicketTaskResponseBody() {}

  explicit FinishTicketTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FinishTicketTaskResponseBody() = default;
};
class FinishTicketTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FinishTicketTaskResponseBody> body{};

  FinishTicketTaskResponse() {}

  explicit FinishTicketTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FinishTicketTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FinishTicketTaskResponseBody>(model1);
      }
    }
  }


  virtual ~FinishTicketTaskResponse() = default;
};
class GetAccessChannelOfStagingRequest : public Darabonba::Model {
public:
  shared_ptr<string> searchPattern{};

  GetAccessChannelOfStagingRequest() {}

  explicit GetAccessChannelOfStagingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~GetAccessChannelOfStagingRequest() = default;
};
class GetAccessChannelOfStagingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> token{};

  GetAccessChannelOfStagingResponseBodyData() {}

  explicit GetAccessChannelOfStagingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~GetAccessChannelOfStagingResponseBodyData() = default;
};
class GetAccessChannelOfStagingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAccessChannelOfStagingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetAccessChannelOfStagingResponseBody() {}

  explicit GetAccessChannelOfStagingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAccessChannelOfStagingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAccessChannelOfStagingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAccessChannelOfStagingResponseBody() = default;
};
class GetAccessChannelOfStagingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAccessChannelOfStagingResponseBody> body{};

  GetAccessChannelOfStagingResponse() {}

  explicit GetAccessChannelOfStagingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAccessChannelOfStagingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAccessChannelOfStagingResponseBody>(model1);
      }
    }
  }


  virtual ~GetAccessChannelOfStagingResponse() = default;
};
class GetAudioFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> instanceId{};

  GetAudioFileRequest() {}

  explicit GetAudioFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetAudioFileRequest() = default;
};
class GetAudioFileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> audioFileName{};
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> ossFileKey{};
  shared_ptr<string> updatedTime{};

  GetAudioFileResponseBodyData() {}

  explicit GetAudioFileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFileName) {
      res["AudioFileName"] = boost::any(*audioFileName);
    }
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossFileKey) {
      res["OssFileKey"] = boost::any(*ossFileKey);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFileName") != m.end() && !m["AudioFileName"].empty()) {
      audioFileName = make_shared<string>(boost::any_cast<string>(m["AudioFileName"]));
    }
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssFileKey") != m.end() && !m["OssFileKey"].empty()) {
      ossFileKey = make_shared<string>(boost::any_cast<string>(m["OssFileKey"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
  }


  virtual ~GetAudioFileResponseBodyData() = default;
};
class GetAudioFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAudioFileResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetAudioFileResponseBody() {}

  explicit GetAudioFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAudioFileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAudioFileResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAudioFileResponseBody() = default;
};
class GetAudioFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAudioFileResponseBody> body{};

  GetAudioFileResponse() {}

  explicit GetAudioFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAudioFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAudioFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetAudioFileResponse() = default;
};
class GetAudioFileDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> instanceId{};

  GetAudioFileDownloadUrlRequest() {}

  explicit GetAudioFileDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetAudioFileDownloadUrlRequest() = default;
};
class GetAudioFileDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetAudioFileDownloadUrlResponseBody() {}

  explicit GetAudioFileDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAudioFileDownloadUrlResponseBody() = default;
};
class GetAudioFileDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAudioFileDownloadUrlResponseBody> body{};

  GetAudioFileDownloadUrlResponse() {}

  explicit GetAudioFileDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAudioFileDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAudioFileDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetAudioFileDownloadUrlResponse() = default;
};
class GetAudioFileUploadParametersRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFileName{};
  shared_ptr<string> instanceId{};

  GetAudioFileUploadParametersRequest() {}

  explicit GetAudioFileUploadParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFileName) {
      res["AudioFileName"] = boost::any(*audioFileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFileName") != m.end() && !m["AudioFileName"].empty()) {
      audioFileName = make_shared<string>(boost::any_cast<string>(m["AudioFileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetAudioFileUploadParametersRequest() = default;
};
class GetAudioFileUploadParametersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> filePath{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GetAudioFileUploadParametersResponseBodyData() {}

  explicit GetAudioFileUploadParametersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GetAudioFileUploadParametersResponseBodyData() = default;
};
class GetAudioFileUploadParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAudioFileUploadParametersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetAudioFileUploadParametersResponseBody() {}

  explicit GetAudioFileUploadParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAudioFileUploadParametersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAudioFileUploadParametersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAudioFileUploadParametersResponseBody() = default;
};
class GetAudioFileUploadParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAudioFileUploadParametersResponseBody> body{};

  GetAudioFileUploadParametersResponse() {}

  explicit GetAudioFileUploadParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAudioFileUploadParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAudioFileUploadParametersResponseBody>(model1);
      }
    }
  }


  virtual ~GetAudioFileUploadParametersResponse() = default;
};
class GetCallDetailRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetCallDetailRecordRequest() {}

  explicit GetCallDetailRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetCallDetailRecordRequest() = default;
};
class GetCallDetailRecordResponseBodyDataAgentEventsEventSequence : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> event{};
  shared_ptr<long> eventTime{};

  GetCallDetailRecordResponseBodyDataAgentEventsEventSequence() {}

  explicit GetCallDetailRecordResponseBodyDataAgentEventsEventSequence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataAgentEventsEventSequence() = default;
};
class GetCallDetailRecordResponseBodyDataAgentEvents : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataAgentEventsEventSequence>> eventSequence{};
  shared_ptr<string> skillGroupId{};

  GetCallDetailRecordResponseBodyDataAgentEvents() {}

  explicit GetCallDetailRecordResponseBodyDataAgentEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (eventSequence) {
      vector<boost::any> temp1;
      for(auto item1:*eventSequence){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventSequence"] = boost::any(temp1);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("EventSequence") != m.end() && !m["EventSequence"].empty()) {
      if (typeid(vector<boost::any>) == m["EventSequence"].type()) {
        vector<GetCallDetailRecordResponseBodyDataAgentEventsEventSequence> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventSequence"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataAgentEventsEventSequence model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventSequence = make_shared<vector<GetCallDetailRecordResponseBodyDataAgentEventsEventSequence>>(expect1);
      }
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataAgentEvents() = default;
};
class GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence : public Darabonba::Model {
public:
  shared_ptr<string> event{};
  shared_ptr<long> eventTime{};

  GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence() {}

  explicit GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence() = default;
};
class GetCallDetailRecordResponseBodyDataCustomerEvents : public Darabonba::Model {
public:
  shared_ptr<string> customerId{};
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence>> eventSequence{};

  GetCallDetailRecordResponseBodyDataCustomerEvents() {}

  explicit GetCallDetailRecordResponseBodyDataCustomerEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerId) {
      res["CustomerId"] = boost::any(*customerId);
    }
    if (eventSequence) {
      vector<boost::any> temp1;
      for(auto item1:*eventSequence){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventSequence"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerId") != m.end() && !m["CustomerId"].empty()) {
      customerId = make_shared<string>(boost::any_cast<string>(m["CustomerId"]));
    }
    if (m.find("EventSequence") != m.end() && !m["EventSequence"].empty()) {
      if (typeid(vector<boost::any>) == m["EventSequence"].type()) {
        vector<GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventSequence"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventSequence = make_shared<vector<GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence>>(expect1);
      }
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataCustomerEvents() = default;
};
class GetCallDetailRecordResponseBodyDataIvrEventsEventSequence : public Darabonba::Model {
public:
  shared_ptr<string> event{};
  shared_ptr<long> eventTime{};

  GetCallDetailRecordResponseBodyDataIvrEventsEventSequence() {}

  explicit GetCallDetailRecordResponseBodyDataIvrEventsEventSequence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataIvrEventsEventSequence() = default;
};
class GetCallDetailRecordResponseBodyDataIvrEvents : public Darabonba::Model {
public:
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataIvrEventsEventSequence>> eventSequence{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowType{};

  GetCallDetailRecordResponseBodyDataIvrEvents() {}

  explicit GetCallDetailRecordResponseBodyDataIvrEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventSequence) {
      vector<boost::any> temp1;
      for(auto item1:*eventSequence){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventSequence"] = boost::any(temp1);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowType) {
      res["FlowType"] = boost::any(*flowType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventSequence") != m.end() && !m["EventSequence"].empty()) {
      if (typeid(vector<boost::any>) == m["EventSequence"].type()) {
        vector<GetCallDetailRecordResponseBodyDataIvrEventsEventSequence> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventSequence"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataIvrEventsEventSequence model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventSequence = make_shared<vector<GetCallDetailRecordResponseBodyDataIvrEventsEventSequence>>(expect1);
      }
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowType") != m.end() && !m["FlowType"].empty()) {
      flowType = make_shared<string>(boost::any_cast<string>(m["FlowType"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataIvrEvents() = default;
};
class GetCallDetailRecordResponseBodyDataQueueEventsEventSequence : public Darabonba::Model {
public:
  shared_ptr<string> event{};
  shared_ptr<long> eventTime{};

  GetCallDetailRecordResponseBodyDataQueueEventsEventSequence() {}

  explicit GetCallDetailRecordResponseBodyDataQueueEventsEventSequence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataQueueEventsEventSequence() = default;
};
class GetCallDetailRecordResponseBodyDataQueueEvents : public Darabonba::Model {
public:
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataQueueEventsEventSequence>> eventSequence{};
  shared_ptr<string> flowId{};
  shared_ptr<string> queueId{};
  shared_ptr<string> queueName{};
  shared_ptr<long> queueType{};

  GetCallDetailRecordResponseBodyDataQueueEvents() {}

  explicit GetCallDetailRecordResponseBodyDataQueueEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventSequence) {
      vector<boost::any> temp1;
      for(auto item1:*eventSequence){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventSequence"] = boost::any(temp1);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventSequence") != m.end() && !m["EventSequence"].empty()) {
      if (typeid(vector<boost::any>) == m["EventSequence"].type()) {
        vector<GetCallDetailRecordResponseBodyDataQueueEventsEventSequence> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventSequence"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataQueueEventsEventSequence model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventSequence = make_shared<vector<GetCallDetailRecordResponseBodyDataQueueEventsEventSequence>>(expect1);
      }
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<long>(boost::any_cast<long>(m["QueueType"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataQueueEvents() = default;
};
class GetCallDetailRecordResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataAgentEvents>> agentEvents{};
  shared_ptr<string> agentIds{};
  shared_ptr<string> agentNames{};
  shared_ptr<long> callDuration{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> calleeLocation{};
  shared_ptr<string> callerLocation{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> contactId{};
  shared_ptr<string> contactType{};
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataCustomerEvents>> customerEvents{};
  shared_ptr<string> earlyMediaState{};
  shared_ptr<long> establishedTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataIvrEvents>> ivrEvents{};
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataQueueEvents>> queueEvents{};
  shared_ptr<bool> recordingReady{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> releaseTime{};
  shared_ptr<long> satisfaction{};
  shared_ptr<string> satisfactionSurveyChannel{};
  shared_ptr<bool> satisfactionSurveyOffered{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<long> startTime{};

  GetCallDetailRecordResponseBodyData() {}

  explicit GetCallDetailRecordResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentEvents) {
      vector<boost::any> temp1;
      for(auto item1:*agentEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AgentEvents"] = boost::any(temp1);
    }
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (agentNames) {
      res["AgentNames"] = boost::any(*agentNames);
    }
    if (callDuration) {
      res["CallDuration"] = boost::any(*callDuration);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (calleeLocation) {
      res["CalleeLocation"] = boost::any(*calleeLocation);
    }
    if (callerLocation) {
      res["CallerLocation"] = boost::any(*callerLocation);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (customerEvents) {
      vector<boost::any> temp1;
      for(auto item1:*customerEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomerEvents"] = boost::any(temp1);
    }
    if (earlyMediaState) {
      res["EarlyMediaState"] = boost::any(*earlyMediaState);
    }
    if (establishedTime) {
      res["EstablishedTime"] = boost::any(*establishedTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ivrEvents) {
      vector<boost::any> temp1;
      for(auto item1:*ivrEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IvrEvents"] = boost::any(temp1);
    }
    if (queueEvents) {
      vector<boost::any> temp1;
      for(auto item1:*queueEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QueueEvents"] = boost::any(temp1);
    }
    if (recordingReady) {
      res["RecordingReady"] = boost::any(*recordingReady);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (satisfaction) {
      res["Satisfaction"] = boost::any(*satisfaction);
    }
    if (satisfactionSurveyChannel) {
      res["SatisfactionSurveyChannel"] = boost::any(*satisfactionSurveyChannel);
    }
    if (satisfactionSurveyOffered) {
      res["SatisfactionSurveyOffered"] = boost::any(*satisfactionSurveyOffered);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentEvents") != m.end() && !m["AgentEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["AgentEvents"].type()) {
        vector<GetCallDetailRecordResponseBodyDataAgentEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AgentEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataAgentEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        agentEvents = make_shared<vector<GetCallDetailRecordResponseBodyDataAgentEvents>>(expect1);
      }
    }
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("AgentNames") != m.end() && !m["AgentNames"].empty()) {
      agentNames = make_shared<string>(boost::any_cast<string>(m["AgentNames"]));
    }
    if (m.find("CallDuration") != m.end() && !m["CallDuration"].empty()) {
      callDuration = make_shared<long>(boost::any_cast<long>(m["CallDuration"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CalleeLocation") != m.end() && !m["CalleeLocation"].empty()) {
      calleeLocation = make_shared<string>(boost::any_cast<string>(m["CalleeLocation"]));
    }
    if (m.find("CallerLocation") != m.end() && !m["CallerLocation"].empty()) {
      callerLocation = make_shared<string>(boost::any_cast<string>(m["CallerLocation"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("CustomerEvents") != m.end() && !m["CustomerEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomerEvents"].type()) {
        vector<GetCallDetailRecordResponseBodyDataCustomerEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomerEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataCustomerEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customerEvents = make_shared<vector<GetCallDetailRecordResponseBodyDataCustomerEvents>>(expect1);
      }
    }
    if (m.find("EarlyMediaState") != m.end() && !m["EarlyMediaState"].empty()) {
      earlyMediaState = make_shared<string>(boost::any_cast<string>(m["EarlyMediaState"]));
    }
    if (m.find("EstablishedTime") != m.end() && !m["EstablishedTime"].empty()) {
      establishedTime = make_shared<long>(boost::any_cast<long>(m["EstablishedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IvrEvents") != m.end() && !m["IvrEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["IvrEvents"].type()) {
        vector<GetCallDetailRecordResponseBodyDataIvrEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IvrEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataIvrEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ivrEvents = make_shared<vector<GetCallDetailRecordResponseBodyDataIvrEvents>>(expect1);
      }
    }
    if (m.find("QueueEvents") != m.end() && !m["QueueEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["QueueEvents"].type()) {
        vector<GetCallDetailRecordResponseBodyDataQueueEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QueueEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataQueueEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queueEvents = make_shared<vector<GetCallDetailRecordResponseBodyDataQueueEvents>>(expect1);
      }
    }
    if (m.find("RecordingReady") != m.end() && !m["RecordingReady"].empty()) {
      recordingReady = make_shared<bool>(boost::any_cast<bool>(m["RecordingReady"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<long>(boost::any_cast<long>(m["ReleaseTime"]));
    }
    if (m.find("Satisfaction") != m.end() && !m["Satisfaction"].empty()) {
      satisfaction = make_shared<long>(boost::any_cast<long>(m["Satisfaction"]));
    }
    if (m.find("SatisfactionSurveyChannel") != m.end() && !m["SatisfactionSurveyChannel"].empty()) {
      satisfactionSurveyChannel = make_shared<string>(boost::any_cast<string>(m["SatisfactionSurveyChannel"]));
    }
    if (m.find("SatisfactionSurveyOffered") != m.end() && !m["SatisfactionSurveyOffered"].empty()) {
      satisfactionSurveyOffered = make_shared<bool>(boost::any_cast<bool>(m["SatisfactionSurveyOffered"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyData() = default;
};
class GetCallDetailRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetCallDetailRecordResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetCallDetailRecordResponseBody() {}

  explicit GetCallDetailRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCallDetailRecordResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCallDetailRecordResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBody() = default;
};
class GetCallDetailRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCallDetailRecordResponseBody> body{};

  GetCallDetailRecordResponse() {}

  explicit GetCallDetailRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCallDetailRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCallDetailRecordResponseBody>(model1);
      }
    }
  }


  virtual ~GetCallDetailRecordResponse() = default;
};
class GetCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  GetCampaignRequest() {}

  explicit GetCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetCampaignRequest() = default;
};
class GetCampaignResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> actualEndTime{};
  shared_ptr<long> actualStartTime{};
  shared_ptr<string> campaignId{};
  shared_ptr<long> casesAborted{};
  shared_ptr<long> casesConnected{};
  shared_ptr<long> casesUncompleted{};
  shared_ptr<string> casesUncompletedAfterAttempt{};
  shared_ptr<long> casesUncompletedAfterAttempted{};
  shared_ptr<double> completionRate{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<long> maxAttemptCount{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> name{};
  shared_ptr<long> planedEndTime{};
  shared_ptr<long> planedStartTime{};
  shared_ptr<string> queueId{};
  shared_ptr<string> queueName{};
  shared_ptr<bool> simulation{};
  shared_ptr<string> simulationParameters{};
  shared_ptr<string> state{};
  shared_ptr<string> strategyParameters{};
  shared_ptr<string> strategyType{};
  shared_ptr<long> totalCases{};

  GetCampaignResponseBodyData() {}

  explicit GetCampaignResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualEndTime) {
      res["ActualEndTime"] = boost::any(*actualEndTime);
    }
    if (actualStartTime) {
      res["ActualStartTime"] = boost::any(*actualStartTime);
    }
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (casesAborted) {
      res["CasesAborted"] = boost::any(*casesAborted);
    }
    if (casesConnected) {
      res["CasesConnected"] = boost::any(*casesConnected);
    }
    if (casesUncompleted) {
      res["CasesUncompleted"] = boost::any(*casesUncompleted);
    }
    if (casesUncompletedAfterAttempt) {
      res["CasesUncompletedAfterAttempt"] = boost::any(*casesUncompletedAfterAttempt);
    }
    if (casesUncompletedAfterAttempted) {
      res["CasesUncompletedAfterAttempted"] = boost::any(*casesUncompletedAfterAttempted);
    }
    if (completionRate) {
      res["CompletionRate"] = boost::any(*completionRate);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (maxAttemptCount) {
      res["MaxAttemptCount"] = boost::any(*maxAttemptCount);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (planedEndTime) {
      res["PlanedEndTime"] = boost::any(*planedEndTime);
    }
    if (planedStartTime) {
      res["PlanedStartTime"] = boost::any(*planedStartTime);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (simulation) {
      res["Simulation"] = boost::any(*simulation);
    }
    if (simulationParameters) {
      res["SimulationParameters"] = boost::any(*simulationParameters);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (strategyParameters) {
      res["StrategyParameters"] = boost::any(*strategyParameters);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (totalCases) {
      res["TotalCases"] = boost::any(*totalCases);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualEndTime") != m.end() && !m["ActualEndTime"].empty()) {
      actualEndTime = make_shared<long>(boost::any_cast<long>(m["ActualEndTime"]));
    }
    if (m.find("ActualStartTime") != m.end() && !m["ActualStartTime"].empty()) {
      actualStartTime = make_shared<long>(boost::any_cast<long>(m["ActualStartTime"]));
    }
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CasesAborted") != m.end() && !m["CasesAborted"].empty()) {
      casesAborted = make_shared<long>(boost::any_cast<long>(m["CasesAborted"]));
    }
    if (m.find("CasesConnected") != m.end() && !m["CasesConnected"].empty()) {
      casesConnected = make_shared<long>(boost::any_cast<long>(m["CasesConnected"]));
    }
    if (m.find("CasesUncompleted") != m.end() && !m["CasesUncompleted"].empty()) {
      casesUncompleted = make_shared<long>(boost::any_cast<long>(m["CasesUncompleted"]));
    }
    if (m.find("CasesUncompletedAfterAttempt") != m.end() && !m["CasesUncompletedAfterAttempt"].empty()) {
      casesUncompletedAfterAttempt = make_shared<string>(boost::any_cast<string>(m["CasesUncompletedAfterAttempt"]));
    }
    if (m.find("CasesUncompletedAfterAttempted") != m.end() && !m["CasesUncompletedAfterAttempted"].empty()) {
      casesUncompletedAfterAttempted = make_shared<long>(boost::any_cast<long>(m["CasesUncompletedAfterAttempted"]));
    }
    if (m.find("CompletionRate") != m.end() && !m["CompletionRate"].empty()) {
      completionRate = make_shared<double>(boost::any_cast<double>(m["CompletionRate"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("MaxAttemptCount") != m.end() && !m["MaxAttemptCount"].empty()) {
      maxAttemptCount = make_shared<long>(boost::any_cast<long>(m["MaxAttemptCount"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PlanedEndTime") != m.end() && !m["PlanedEndTime"].empty()) {
      planedEndTime = make_shared<long>(boost::any_cast<long>(m["PlanedEndTime"]));
    }
    if (m.find("PlanedStartTime") != m.end() && !m["PlanedStartTime"].empty()) {
      planedStartTime = make_shared<long>(boost::any_cast<long>(m["PlanedStartTime"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Simulation") != m.end() && !m["Simulation"].empty()) {
      simulation = make_shared<bool>(boost::any_cast<bool>(m["Simulation"]));
    }
    if (m.find("SimulationParameters") != m.end() && !m["SimulationParameters"].empty()) {
      simulationParameters = make_shared<string>(boost::any_cast<string>(m["SimulationParameters"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StrategyParameters") != m.end() && !m["StrategyParameters"].empty()) {
      strategyParameters = make_shared<string>(boost::any_cast<string>(m["StrategyParameters"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<string>(boost::any_cast<string>(m["StrategyType"]));
    }
    if (m.find("TotalCases") != m.end() && !m["TotalCases"].empty()) {
      totalCases = make_shared<long>(boost::any_cast<long>(m["TotalCases"]));
    }
  }


  virtual ~GetCampaignResponseBodyData() = default;
};
class GetCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetCampaignResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};

  GetCampaignResponseBody() {}

  explicit GetCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCampaignResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCampaignResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCampaignResponseBody() = default;
};
class GetCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCampaignResponseBody> body{};

  GetCampaignResponse() {}

  explicit GetCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~GetCampaignResponse() = default;
};
class GetCaseFileUploadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};

  GetCaseFileUploadUrlRequest() {}

  explicit GetCaseFileUploadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetCaseFileUploadUrlRequest() = default;
};
class GetCaseFileUploadUrlResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> caseFileKey{};
  shared_ptr<string> url{};

  GetCaseFileUploadUrlResponseBodyData() {}

  explicit GetCaseFileUploadUrlResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caseFileKey) {
      res["CaseFileKey"] = boost::any(*caseFileKey);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaseFileKey") != m.end() && !m["CaseFileKey"].empty()) {
      caseFileKey = make_shared<string>(boost::any_cast<string>(m["CaseFileKey"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetCaseFileUploadUrlResponseBodyData() = default;
};
class GetCaseFileUploadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetCaseFileUploadUrlResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetCaseFileUploadUrlResponseBody() {}

  explicit GetCaseFileUploadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCaseFileUploadUrlResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCaseFileUploadUrlResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCaseFileUploadUrlResponseBody() = default;
};
class GetCaseFileUploadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCaseFileUploadUrlResponseBody> body{};

  GetCaseFileUploadUrlResponse() {}

  explicit GetCaseFileUploadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCaseFileUploadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCaseFileUploadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetCaseFileUploadUrlResponse() = default;
};
class GetChatMediaUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  GetChatMediaUrlRequest() {}

  explicit GetChatMediaUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetChatMediaUrlRequest() = default;
};
class GetChatMediaUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetChatMediaUrlResponseBody() {}

  explicit GetChatMediaUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetChatMediaUrlResponseBody() = default;
};
class GetChatMediaUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetChatMediaUrlResponseBody> body{};

  GetChatMediaUrlResponse() {}

  explicit GetChatMediaUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetChatMediaUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetChatMediaUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetChatMediaUrlResponse() = default;
};
class GetContactFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> draftId{};
  shared_ptr<string> instanceId{};

  GetContactFlowRequest() {}

  explicit GetContactFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (draftId) {
      res["DraftId"] = boost::any(*draftId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("DraftId") != m.end() && !m["DraftId"].empty()) {
      draftId = make_shared<string>(boost::any_cast<string>(m["DraftId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetContactFlowRequest() = default;
};
class GetContactFlowResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> definition{};
  shared_ptr<string> description{};
  shared_ptr<string> draftId{};
  shared_ptr<string> editor{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<bool> published{};
  shared_ptr<string> type{};
  shared_ptr<string> updatedTime{};

  GetContactFlowResponseBodyData() {}

  explicit GetContactFlowResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (draftId) {
      res["DraftId"] = boost::any(*draftId);
    }
    if (editor) {
      res["Editor"] = boost::any(*editor);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (published) {
      res["Published"] = boost::any(*published);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DraftId") != m.end() && !m["DraftId"].empty()) {
      draftId = make_shared<string>(boost::any_cast<string>(m["DraftId"]));
    }
    if (m.find("Editor") != m.end() && !m["Editor"].empty()) {
      editor = make_shared<string>(boost::any_cast<string>(m["Editor"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Published") != m.end() && !m["Published"].empty()) {
      published = make_shared<bool>(boost::any_cast<bool>(m["Published"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
  }


  virtual ~GetContactFlowResponseBodyData() = default;
};
class GetContactFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetContactFlowResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetContactFlowResponseBody() {}

  explicit GetContactFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetContactFlowResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetContactFlowResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetContactFlowResponseBody() = default;
};
class GetContactFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetContactFlowResponseBody> body{};

  GetContactFlowResponse() {}

  explicit GetContactFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetContactFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetContactFlowResponseBody>(model1);
      }
    }
  }


  virtual ~GetContactFlowResponse() = default;
};
class GetConversationDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetConversationDetailRequest() {}

  explicit GetConversationDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetConversationDetailRequest() = default;
};
class GetConversationDetailResponseBodyPhrases : public Darabonba::Model {
public:
  shared_ptr<long> begin{};
  shared_ptr<long> end{};
  shared_ptr<string> identity{};
  shared_ptr<string> role{};
  shared_ptr<string> words{};

  GetConversationDetailResponseBodyPhrases() {}

  explicit GetConversationDetailResponseBodyPhrases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (begin) {
      res["Begin"] = boost::any(*begin);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (identity) {
      res["Identity"] = boost::any(*identity);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (words) {
      res["Words"] = boost::any(*words);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Begin") != m.end() && !m["Begin"].empty()) {
      begin = make_shared<long>(boost::any_cast<long>(m["Begin"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Identity") != m.end() && !m["Identity"].empty()) {
      identity = make_shared<string>(boost::any_cast<string>(m["Identity"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Words") != m.end() && !m["Words"].empty()) {
      words = make_shared<string>(boost::any_cast<string>(m["Words"]));
    }
  }


  virtual ~GetConversationDetailResponseBodyPhrases() = default;
};
class GetConversationDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<GetConversationDetailResponseBodyPhrases>> phrases{};
  shared_ptr<string> requestId{};

  GetConversationDetailResponseBody() {}

  explicit GetConversationDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (phrases) {
      vector<boost::any> temp1;
      for(auto item1:*phrases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Phrases"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Phrases") != m.end() && !m["Phrases"].empty()) {
      if (typeid(vector<boost::any>) == m["Phrases"].type()) {
        vector<GetConversationDetailResponseBodyPhrases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Phrases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConversationDetailResponseBodyPhrases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phrases = make_shared<vector<GetConversationDetailResponseBodyPhrases>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConversationDetailResponseBody() = default;
};
class GetConversationDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConversationDetailResponseBody> body{};

  GetConversationDetailResponse() {}

  explicit GetConversationDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConversationDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConversationDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetConversationDetailResponse() = default;
};
class GetDataChannelCredentialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};

  GetDataChannelCredentialsRequest() {}

  explicit GetDataChannelCredentialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDataChannelCredentialsRequest() = default;
};
class GetDataChannelCredentialsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clientId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> endpoint{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> password{};
  shared_ptr<string> topic{};
  shared_ptr<string> userName{};

  GetDataChannelCredentialsResponseBodyData() {}

  explicit GetDataChannelCredentialsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~GetDataChannelCredentialsResponseBodyData() = default;
};
class GetDataChannelCredentialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDataChannelCredentialsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetDataChannelCredentialsResponseBody() {}

  explicit GetDataChannelCredentialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataChannelCredentialsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataChannelCredentialsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDataChannelCredentialsResponseBody() = default;
};
class GetDataChannelCredentialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataChannelCredentialsResponseBody> body{};

  GetDataChannelCredentialsResponse() {}

  explicit GetDataChannelCredentialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataChannelCredentialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataChannelCredentialsResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataChannelCredentialsResponse() = default;
};
class GetDoNotCallFileUploadParametersRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};

  GetDoNotCallFileUploadParametersRequest() {}

  explicit GetDoNotCallFileUploadParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDoNotCallFileUploadParametersRequest() = default;
};
class GetDoNotCallFileUploadParametersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> filePath{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GetDoNotCallFileUploadParametersResponseBodyData() {}

  explicit GetDoNotCallFileUploadParametersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GetDoNotCallFileUploadParametersResponseBodyData() = default;
};
class GetDoNotCallFileUploadParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDoNotCallFileUploadParametersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDoNotCallFileUploadParametersResponseBody() {}

  explicit GetDoNotCallFileUploadParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoNotCallFileUploadParametersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoNotCallFileUploadParametersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDoNotCallFileUploadParametersResponseBody() = default;
};
class GetDoNotCallFileUploadParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoNotCallFileUploadParametersResponseBody> body{};

  GetDoNotCallFileUploadParametersResponse() {}

  explicit GetDoNotCallFileUploadParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoNotCallFileUploadParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoNotCallFileUploadParametersResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoNotCallFileUploadParametersResponse() = default;
};
class GetDocumentUploadParametersRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  GetDocumentUploadParametersRequest() {}

  explicit GetDocumentUploadParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDocumentUploadParametersRequest() = default;
};
class GetDocumentUploadParametersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> filePath{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GetDocumentUploadParametersResponseBodyData() {}

  explicit GetDocumentUploadParametersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GetDocumentUploadParametersResponseBodyData() = default;
};
class GetDocumentUploadParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDocumentUploadParametersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetDocumentUploadParametersResponseBody() {}

  explicit GetDocumentUploadParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDocumentUploadParametersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDocumentUploadParametersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDocumentUploadParametersResponseBody() = default;
};
class GetDocumentUploadParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDocumentUploadParametersResponseBody> body{};

  GetDocumentUploadParametersResponse() {}

  explicit GetDocumentUploadParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDocumentUploadParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDocumentUploadParametersResponseBody>(model1);
      }
    }
  }


  virtual ~GetDocumentUploadParametersResponse() = default;
};
class GetEarlyMediaRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetEarlyMediaRecordingRequest() {}

  explicit GetEarlyMediaRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetEarlyMediaRecordingRequest() = default;
};
class GetEarlyMediaRecordingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};

  GetEarlyMediaRecordingResponseBodyData() {}

  explicit GetEarlyMediaRecordingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~GetEarlyMediaRecordingResponseBodyData() = default;
};
class GetEarlyMediaRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetEarlyMediaRecordingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetEarlyMediaRecordingResponseBody() {}

  explicit GetEarlyMediaRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEarlyMediaRecordingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEarlyMediaRecordingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEarlyMediaRecordingResponseBody() = default;
};
class GetEarlyMediaRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEarlyMediaRecordingResponseBody> body{};

  GetEarlyMediaRecordingResponse() {}

  explicit GetEarlyMediaRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEarlyMediaRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEarlyMediaRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~GetEarlyMediaRecordingResponse() = default;
};
class GetHistoricalCallerReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> callingNumber{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> stopTime{};

  GetHistoricalCallerReportRequest() {}

  explicit GetHistoricalCallerReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
  }


  virtual ~GetHistoricalCallerReportRequest() = default;
};
class GetHistoricalCallerReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> lastCallingTime{};
  shared_ptr<long> totalCalls{};

  GetHistoricalCallerReportResponseBodyData() {}

  explicit GetHistoricalCallerReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastCallingTime) {
      res["LastCallingTime"] = boost::any(*lastCallingTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastCallingTime") != m.end() && !m["LastCallingTime"].empty()) {
      lastCallingTime = make_shared<long>(boost::any_cast<long>(m["LastCallingTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GetHistoricalCallerReportResponseBodyData() = default;
};
class GetHistoricalCallerReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHistoricalCallerReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetHistoricalCallerReportResponseBody() {}

  explicit GetHistoricalCallerReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHistoricalCallerReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHistoricalCallerReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHistoricalCallerReportResponseBody() = default;
};
class GetHistoricalCallerReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHistoricalCallerReportResponseBody> body{};

  GetHistoricalCallerReportResponse() {}

  explicit GetHistoricalCallerReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHistoricalCallerReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHistoricalCallerReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetHistoricalCallerReportResponse() = default;
};
class GetHistoricalCampaignReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  GetHistoricalCampaignReportRequest() {}

  explicit GetHistoricalCampaignReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetHistoricalCampaignReportRequest() = default;
};
class GetHistoricalCampaignReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<double> abandonRate{};
  shared_ptr<double> abandonedRate{};
  shared_ptr<double> answerRate{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsConnected{};
  shared_ptr<long> callsDialed{};
  shared_ptr<double> connectedRate{};
  shared_ptr<double> occupancyRate{};

  GetHistoricalCampaignReportResponseBodyData() {}

  explicit GetHistoricalCampaignReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonRate) {
      res["AbandonRate"] = boost::any(*abandonRate);
    }
    if (abandonedRate) {
      res["AbandonedRate"] = boost::any(*abandonedRate);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsConnected) {
      res["CallsConnected"] = boost::any(*callsConnected);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (connectedRate) {
      res["ConnectedRate"] = boost::any(*connectedRate);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonRate") != m.end() && !m["AbandonRate"].empty()) {
      abandonRate = make_shared<double>(boost::any_cast<double>(m["AbandonRate"]));
    }
    if (m.find("AbandonedRate") != m.end() && !m["AbandonedRate"].empty()) {
      abandonedRate = make_shared<double>(boost::any_cast<double>(m["AbandonedRate"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsConnected") != m.end() && !m["CallsConnected"].empty()) {
      callsConnected = make_shared<long>(boost::any_cast<long>(m["CallsConnected"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("ConnectedRate") != m.end() && !m["ConnectedRate"].empty()) {
      connectedRate = make_shared<double>(boost::any_cast<double>(m["ConnectedRate"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
  }


  virtual ~GetHistoricalCampaignReportResponseBodyData() = default;
};
class GetHistoricalCampaignReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHistoricalCampaignReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetHistoricalCampaignReportResponseBody() {}

  explicit GetHistoricalCampaignReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHistoricalCampaignReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHistoricalCampaignReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHistoricalCampaignReportResponseBody() = default;
};
class GetHistoricalCampaignReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHistoricalCampaignReportResponseBody> body{};

  GetHistoricalCampaignReportResponse() {}

  explicit GetHistoricalCampaignReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHistoricalCampaignReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHistoricalCampaignReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetHistoricalCampaignReportResponse() = default;
};
class GetHistoricalInstanceReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> startTime{};

  GetHistoricalInstanceReportRequest() {}

  explicit GetHistoricalInstanceReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetHistoricalInstanceReportRequest() = default;
};
class GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList : public Darabonba::Model {
public:
  shared_ptr<string> accessChannelType{};
  shared_ptr<long> callsOffered{};

  GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList() {}

  explicit GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelType) {
      res["AccessChannelType"] = boost::any(*accessChannelType);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelType") != m.end() && !m["AccessChannelType"].empty()) {
      accessChannelType = make_shared<string>(boost::any_cast<string>(m["AccessChannelType"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList() = default;
};
class GetHistoricalInstanceReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<double> abandonRate{};
  shared_ptr<vector<GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList>> accessChannelTypeDetailList{};
  shared_ptr<double> averageAbandonTime{};
  shared_ptr<double> averageAbandonedInIVRTime{};
  shared_ptr<double> averageAbandonedInQueueTime{};
  shared_ptr<double> averageAbandonedInRingTime{};
  shared_ptr<double> averageFirstResponseTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageResponseTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWaitTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsAbandonedInIVR{};
  shared_ptr<long> callsAbandonedInQueue{};
  shared_ptr<long> callsAbandonedInRing{};
  shared_ptr<long> callsAbandonedInVoiceNavigator{};
  shared_ptr<long> callsAttendedTransferred{};
  shared_ptr<long> callsBlindTransferred{};
  shared_ptr<long> callsCausedIVRException{};
  shared_ptr<long> callsForwardToOutsideNumber{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsIVRException{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsQueued{};
  shared_ptr<long> callsQueuingFailed{};
  shared_ptr<long> callsQueuingOverflow{};
  shared_ptr<long> callsQueuingTimeout{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> callsToVoicemail{};
  shared_ptr<long> callsVoicemail{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxAbandonTime{};
  shared_ptr<long> maxAbandonedInIVRTime{};
  shared_ptr<long> maxAbandonedInQueueTime{};
  shared_ptr<long> maxAbandonedInRingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel15{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<double> serviceLevel30{};
  shared_ptr<long> totalAbandonTime{};
  shared_ptr<long> totalAbandonedInIVRTime{};
  shared_ptr<long> totalAbandonedInQueueTime{};
  shared_ptr<long> totalAbandonedInRingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalMessagesSent{};
  shared_ptr<long> totalMessagesSentByAgent{};
  shared_ptr<long> totalMessagesSentByCustomer{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalWorkTime{};

  GetHistoricalInstanceReportResponseBodyDataInbound() {}

  explicit GetHistoricalInstanceReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonRate) {
      res["AbandonRate"] = boost::any(*abandonRate);
    }
    if (accessChannelTypeDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*accessChannelTypeDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessChannelTypeDetailList"] = boost::any(temp1);
    }
    if (averageAbandonTime) {
      res["AverageAbandonTime"] = boost::any(*averageAbandonTime);
    }
    if (averageAbandonedInIVRTime) {
      res["AverageAbandonedInIVRTime"] = boost::any(*averageAbandonedInIVRTime);
    }
    if (averageAbandonedInQueueTime) {
      res["AverageAbandonedInQueueTime"] = boost::any(*averageAbandonedInQueueTime);
    }
    if (averageAbandonedInRingTime) {
      res["AverageAbandonedInRingTime"] = boost::any(*averageAbandonedInRingTime);
    }
    if (averageFirstResponseTime) {
      res["AverageFirstResponseTime"] = boost::any(*averageFirstResponseTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageResponseTime) {
      res["AverageResponseTime"] = boost::any(*averageResponseTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsAbandonedInIVR) {
      res["CallsAbandonedInIVR"] = boost::any(*callsAbandonedInIVR);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    if (callsAbandonedInRing) {
      res["CallsAbandonedInRing"] = boost::any(*callsAbandonedInRing);
    }
    if (callsAbandonedInVoiceNavigator) {
      res["CallsAbandonedInVoiceNavigator"] = boost::any(*callsAbandonedInVoiceNavigator);
    }
    if (callsAttendedTransferred) {
      res["CallsAttendedTransferred"] = boost::any(*callsAttendedTransferred);
    }
    if (callsBlindTransferred) {
      res["CallsBlindTransferred"] = boost::any(*callsBlindTransferred);
    }
    if (callsCausedIVRException) {
      res["CallsCausedIVRException"] = boost::any(*callsCausedIVRException);
    }
    if (callsForwardToOutsideNumber) {
      res["CallsForwardToOutsideNumber"] = boost::any(*callsForwardToOutsideNumber);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsIVRException) {
      res["CallsIVRException"] = boost::any(*callsIVRException);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsQueued) {
      res["CallsQueued"] = boost::any(*callsQueued);
    }
    if (callsQueuingFailed) {
      res["CallsQueuingFailed"] = boost::any(*callsQueuingFailed);
    }
    if (callsQueuingOverflow) {
      res["CallsQueuingOverflow"] = boost::any(*callsQueuingOverflow);
    }
    if (callsQueuingTimeout) {
      res["CallsQueuingTimeout"] = boost::any(*callsQueuingTimeout);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (callsToVoicemail) {
      res["CallsToVoicemail"] = boost::any(*callsToVoicemail);
    }
    if (callsVoicemail) {
      res["CallsVoicemail"] = boost::any(*callsVoicemail);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxAbandonTime) {
      res["MaxAbandonTime"] = boost::any(*maxAbandonTime);
    }
    if (maxAbandonedInIVRTime) {
      res["MaxAbandonedInIVRTime"] = boost::any(*maxAbandonedInIVRTime);
    }
    if (maxAbandonedInQueueTime) {
      res["MaxAbandonedInQueueTime"] = boost::any(*maxAbandonedInQueueTime);
    }
    if (maxAbandonedInRingTime) {
      res["MaxAbandonedInRingTime"] = boost::any(*maxAbandonedInRingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel15) {
      res["ServiceLevel15"] = boost::any(*serviceLevel15);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (serviceLevel30) {
      res["ServiceLevel30"] = boost::any(*serviceLevel30);
    }
    if (totalAbandonTime) {
      res["TotalAbandonTime"] = boost::any(*totalAbandonTime);
    }
    if (totalAbandonedInIVRTime) {
      res["TotalAbandonedInIVRTime"] = boost::any(*totalAbandonedInIVRTime);
    }
    if (totalAbandonedInQueueTime) {
      res["TotalAbandonedInQueueTime"] = boost::any(*totalAbandonedInQueueTime);
    }
    if (totalAbandonedInRingTime) {
      res["TotalAbandonedInRingTime"] = boost::any(*totalAbandonedInRingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalMessagesSent) {
      res["TotalMessagesSent"] = boost::any(*totalMessagesSent);
    }
    if (totalMessagesSentByAgent) {
      res["TotalMessagesSentByAgent"] = boost::any(*totalMessagesSentByAgent);
    }
    if (totalMessagesSentByCustomer) {
      res["TotalMessagesSentByCustomer"] = boost::any(*totalMessagesSentByCustomer);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonRate") != m.end() && !m["AbandonRate"].empty()) {
      abandonRate = make_shared<double>(boost::any_cast<double>(m["AbandonRate"]));
    }
    if (m.find("AccessChannelTypeDetailList") != m.end() && !m["AccessChannelTypeDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessChannelTypeDetailList"].type()) {
        vector<GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessChannelTypeDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessChannelTypeDetailList = make_shared<vector<GetHistoricalInstanceReportResponseBodyDataInboundAccessChannelTypeDetailList>>(expect1);
      }
    }
    if (m.find("AverageAbandonTime") != m.end() && !m["AverageAbandonTime"].empty()) {
      averageAbandonTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonTime"]));
    }
    if (m.find("AverageAbandonedInIVRTime") != m.end() && !m["AverageAbandonedInIVRTime"].empty()) {
      averageAbandonedInIVRTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInIVRTime"]));
    }
    if (m.find("AverageAbandonedInQueueTime") != m.end() && !m["AverageAbandonedInQueueTime"].empty()) {
      averageAbandonedInQueueTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInQueueTime"]));
    }
    if (m.find("AverageAbandonedInRingTime") != m.end() && !m["AverageAbandonedInRingTime"].empty()) {
      averageAbandonedInRingTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInRingTime"]));
    }
    if (m.find("AverageFirstResponseTime") != m.end() && !m["AverageFirstResponseTime"].empty()) {
      averageFirstResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageFirstResponseTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageResponseTime") != m.end() && !m["AverageResponseTime"].empty()) {
      averageResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageResponseTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<double>(boost::any_cast<double>(m["AverageWaitTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsAbandonedInIVR") != m.end() && !m["CallsAbandonedInIVR"].empty()) {
      callsAbandonedInIVR = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInIVR"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
    if (m.find("CallsAbandonedInRing") != m.end() && !m["CallsAbandonedInRing"].empty()) {
      callsAbandonedInRing = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInRing"]));
    }
    if (m.find("CallsAbandonedInVoiceNavigator") != m.end() && !m["CallsAbandonedInVoiceNavigator"].empty()) {
      callsAbandonedInVoiceNavigator = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInVoiceNavigator"]));
    }
    if (m.find("CallsAttendedTransferred") != m.end() && !m["CallsAttendedTransferred"].empty()) {
      callsAttendedTransferred = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferred"]));
    }
    if (m.find("CallsBlindTransferred") != m.end() && !m["CallsBlindTransferred"].empty()) {
      callsBlindTransferred = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferred"]));
    }
    if (m.find("CallsCausedIVRException") != m.end() && !m["CallsCausedIVRException"].empty()) {
      callsCausedIVRException = make_shared<long>(boost::any_cast<long>(m["CallsCausedIVRException"]));
    }
    if (m.find("CallsForwardToOutsideNumber") != m.end() && !m["CallsForwardToOutsideNumber"].empty()) {
      callsForwardToOutsideNumber = make_shared<long>(boost::any_cast<long>(m["CallsForwardToOutsideNumber"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsIVRException") != m.end() && !m["CallsIVRException"].empty()) {
      callsIVRException = make_shared<long>(boost::any_cast<long>(m["CallsIVRException"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsQueued") != m.end() && !m["CallsQueued"].empty()) {
      callsQueued = make_shared<long>(boost::any_cast<long>(m["CallsQueued"]));
    }
    if (m.find("CallsQueuingFailed") != m.end() && !m["CallsQueuingFailed"].empty()) {
      callsQueuingFailed = make_shared<long>(boost::any_cast<long>(m["CallsQueuingFailed"]));
    }
    if (m.find("CallsQueuingOverflow") != m.end() && !m["CallsQueuingOverflow"].empty()) {
      callsQueuingOverflow = make_shared<long>(boost::any_cast<long>(m["CallsQueuingOverflow"]));
    }
    if (m.find("CallsQueuingTimeout") != m.end() && !m["CallsQueuingTimeout"].empty()) {
      callsQueuingTimeout = make_shared<long>(boost::any_cast<long>(m["CallsQueuingTimeout"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("CallsToVoicemail") != m.end() && !m["CallsToVoicemail"].empty()) {
      callsToVoicemail = make_shared<long>(boost::any_cast<long>(m["CallsToVoicemail"]));
    }
    if (m.find("CallsVoicemail") != m.end() && !m["CallsVoicemail"].empty()) {
      callsVoicemail = make_shared<long>(boost::any_cast<long>(m["CallsVoicemail"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxAbandonTime") != m.end() && !m["MaxAbandonTime"].empty()) {
      maxAbandonTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonTime"]));
    }
    if (m.find("MaxAbandonedInIVRTime") != m.end() && !m["MaxAbandonedInIVRTime"].empty()) {
      maxAbandonedInIVRTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInIVRTime"]));
    }
    if (m.find("MaxAbandonedInQueueTime") != m.end() && !m["MaxAbandonedInQueueTime"].empty()) {
      maxAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInQueueTime"]));
    }
    if (m.find("MaxAbandonedInRingTime") != m.end() && !m["MaxAbandonedInRingTime"].empty()) {
      maxAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInRingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel15") != m.end() && !m["ServiceLevel15"].empty()) {
      serviceLevel15 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel15"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("ServiceLevel30") != m.end() && !m["ServiceLevel30"].empty()) {
      serviceLevel30 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel30"]));
    }
    if (m.find("TotalAbandonTime") != m.end() && !m["TotalAbandonTime"].empty()) {
      totalAbandonTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonTime"]));
    }
    if (m.find("TotalAbandonedInIVRTime") != m.end() && !m["TotalAbandonedInIVRTime"].empty()) {
      totalAbandonedInIVRTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInIVRTime"]));
    }
    if (m.find("TotalAbandonedInQueueTime") != m.end() && !m["TotalAbandonedInQueueTime"].empty()) {
      totalAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInQueueTime"]));
    }
    if (m.find("TotalAbandonedInRingTime") != m.end() && !m["TotalAbandonedInRingTime"].empty()) {
      totalAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInRingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalMessagesSent") != m.end() && !m["TotalMessagesSent"].empty()) {
      totalMessagesSent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSent"]));
    }
    if (m.find("TotalMessagesSentByAgent") != m.end() && !m["TotalMessagesSentByAgent"].empty()) {
      totalMessagesSentByAgent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByAgent"]));
    }
    if (m.find("TotalMessagesSentByCustomer") != m.end() && !m["TotalMessagesSentByCustomer"].empty()) {
      totalMessagesSentByCustomer = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByCustomer"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBodyDataInbound() = default;
};
class GetHistoricalInstanceReportResponseBodyDataInternal : public Darabonba::Model {
public:
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsDialed{};

  GetHistoricalInstanceReportResponseBodyDataInternal() {}

  explicit GetHistoricalInstanceReportResponseBodyDataInternal(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBodyDataInternal() = default;
};
class GetHistoricalInstanceReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferred{};
  shared_ptr<long> callsBlindTransferred{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  GetHistoricalInstanceReportResponseBodyDataOutbound() {}

  explicit GetHistoricalInstanceReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferred) {
      res["CallsAttendedTransferred"] = boost::any(*callsAttendedTransferred);
    }
    if (callsBlindTransferred) {
      res["CallsBlindTransferred"] = boost::any(*callsBlindTransferred);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferred") != m.end() && !m["CallsAttendedTransferred"].empty()) {
      callsAttendedTransferred = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferred"]));
    }
    if (m.find("CallsBlindTransferred") != m.end() && !m["CallsBlindTransferred"].empty()) {
      callsBlindTransferred = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferred"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBodyDataOutbound() = default;
};
class GetHistoricalInstanceReportResponseBodyDataOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxLoggedInAgents{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  GetHistoricalInstanceReportResponseBodyDataOverall() {}

  explicit GetHistoricalInstanceReportResponseBodyDataOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxLoggedInAgents) {
      res["MaxLoggedInAgents"] = boost::any(*maxLoggedInAgents);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxLoggedInAgents") != m.end() && !m["MaxLoggedInAgents"].empty()) {
      maxLoggedInAgents = make_shared<long>(boost::any_cast<long>(m["MaxLoggedInAgents"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBodyDataOverall() = default;
};
class GetHistoricalInstanceReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetHistoricalInstanceReportResponseBodyDataInbound> inbound{};
  shared_ptr<GetHistoricalInstanceReportResponseBodyDataInternal> internal{};
  shared_ptr<GetHistoricalInstanceReportResponseBodyDataOutbound> outbound{};
  shared_ptr<GetHistoricalInstanceReportResponseBodyDataOverall> overall{};

  GetHistoricalInstanceReportResponseBodyData() {}

  explicit GetHistoricalInstanceReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internal) {
      res["Internal"] = internal ? boost::any(internal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        GetHistoricalInstanceReportResponseBodyDataInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<GetHistoricalInstanceReportResponseBodyDataInbound>(model1);
      }
    }
    if (m.find("Internal") != m.end() && !m["Internal"].empty()) {
      if (typeid(map<string, boost::any>) == m["Internal"].type()) {
        GetHistoricalInstanceReportResponseBodyDataInternal model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Internal"]));
        internal = make_shared<GetHistoricalInstanceReportResponseBodyDataInternal>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        GetHistoricalInstanceReportResponseBodyDataOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<GetHistoricalInstanceReportResponseBodyDataOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        GetHistoricalInstanceReportResponseBodyDataOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<GetHistoricalInstanceReportResponseBodyDataOverall>(model1);
      }
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBodyData() = default;
};
class GetHistoricalInstanceReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHistoricalInstanceReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetHistoricalInstanceReportResponseBody() {}

  explicit GetHistoricalInstanceReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHistoricalInstanceReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHistoricalInstanceReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBody() = default;
};
class GetHistoricalInstanceReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHistoricalInstanceReportResponseBody> body{};

  GetHistoricalInstanceReportResponse() {}

  explicit GetHistoricalInstanceReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHistoricalInstanceReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHistoricalInstanceReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetHistoricalInstanceReportResponse() = default;
};
class GetInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetInstanceRequest() {}

  explicit GetInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetInstanceRequest() = default;
};
class GetInstanceResponseBodyDataAdminList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  GetInstanceResponseBodyDataAdminList() {}

  explicit GetInstanceResponseBodyDataAdminList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~GetInstanceResponseBodyDataAdminList() = default;
};
class GetInstanceResponseBodyDataNumberListSkillGroups : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> phoneNumberCount{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> userCount{};

  GetInstanceResponseBodyDataNumberListSkillGroups() {}

  explicit GetInstanceResponseBodyDataNumberListSkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phoneNumberCount) {
      res["PhoneNumberCount"] = boost::any(*phoneNumberCount);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PhoneNumberCount") != m.end() && !m["PhoneNumberCount"].empty()) {
      phoneNumberCount = make_shared<long>(boost::any_cast<long>(m["PhoneNumberCount"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~GetInstanceResponseBodyDataNumberListSkillGroups() = default;
};
class GetInstanceResponseBodyDataNumberList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};
  shared_ptr<vector<GetInstanceResponseBodyDataNumberListSkillGroups>> skillGroups{};
  shared_ptr<string> usage{};
  shared_ptr<string> userId{};

  GetInstanceResponseBodyDataNumberList() {}

  explicit GetInstanceResponseBodyDataNumberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (skillGroups) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroups"] = boost::any(temp1);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroups"].type()) {
        vector<GetInstanceResponseBodyDataNumberListSkillGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceResponseBodyDataNumberListSkillGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroups = make_shared<vector<GetInstanceResponseBodyDataNumberListSkillGroups>>(expect1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetInstanceResponseBodyDataNumberList() = default;
};
class GetInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceResponseBodyDataAdminList>> adminList{};
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> consoleUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetInstanceResponseBodyDataNumberList>> numberList{};
  shared_ptr<string> status{};

  GetInstanceResponseBodyData() {}

  explicit GetInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminList) {
      vector<boost::any> temp1;
      for(auto item1:*adminList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdminList"] = boost::any(temp1);
    }
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (consoleUrl) {
      res["ConsoleUrl"] = boost::any(*consoleUrl);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numberList) {
      vector<boost::any> temp1;
      for(auto item1:*numberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NumberList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<GetInstanceResponseBodyDataAdminList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdminList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceResponseBodyDataAdminList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adminList = make_shared<vector<GetInstanceResponseBodyDataAdminList>>(expect1);
      }
    }
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("ConsoleUrl") != m.end() && !m["ConsoleUrl"].empty()) {
      consoleUrl = make_shared<string>(boost::any_cast<string>(m["ConsoleUrl"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      if (typeid(vector<boost::any>) == m["NumberList"].type()) {
        vector<GetInstanceResponseBodyDataNumberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NumberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceResponseBodyDataNumberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        numberList = make_shared<vector<GetInstanceResponseBodyDataNumberList>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetInstanceResponseBodyData() = default;
};
class GetInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInstanceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetInstanceResponseBody() {}

  explicit GetInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInstanceResponseBody() = default;
};
class GetInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceResponseBody> body{};

  GetInstanceResponse() {}

  explicit GetInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceResponse() = default;
};
class GetInstanceTrendingReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> startTime{};

  GetInstanceTrendingReportRequest() {}

  explicit GetInstanceTrendingReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetInstanceTrendingReportRequest() = default;
};
class GetInstanceTrendingReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<long> callsAbandonedInIVR{};
  shared_ptr<long> callsAbandonedInQueue{};
  shared_ptr<long> callsAbandonedInRing{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsQueued{};
  shared_ptr<long> statsTime{};
  shared_ptr<long> totalCalls{};

  GetInstanceTrendingReportResponseBodyDataInbound() {}

  explicit GetInstanceTrendingReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callsAbandonedInIVR) {
      res["CallsAbandonedInIVR"] = boost::any(*callsAbandonedInIVR);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    if (callsAbandonedInRing) {
      res["CallsAbandonedInRing"] = boost::any(*callsAbandonedInRing);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsQueued) {
      res["CallsQueued"] = boost::any(*callsQueued);
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallsAbandonedInIVR") != m.end() && !m["CallsAbandonedInIVR"].empty()) {
      callsAbandonedInIVR = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInIVR"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
    if (m.find("CallsAbandonedInRing") != m.end() && !m["CallsAbandonedInRing"].empty()) {
      callsAbandonedInRing = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInRing"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsQueued") != m.end() && !m["CallsQueued"].empty()) {
      callsQueued = make_shared<long>(boost::any_cast<long>(m["CallsQueued"]));
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GetInstanceTrendingReportResponseBodyDataInbound() = default;
};
class GetInstanceTrendingReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> statsTime{};
  shared_ptr<long> totalCalls{};

  GetInstanceTrendingReportResponseBodyDataOutbound() {}

  explicit GetInstanceTrendingReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GetInstanceTrendingReportResponseBodyDataOutbound() = default;
};
class GetInstanceTrendingReportResponseBodyDataOverall : public Darabonba::Model {
public:
  shared_ptr<long> maxLoggedInAgents{};
  shared_ptr<long> statsTime{};

  GetInstanceTrendingReportResponseBodyDataOverall() {}

  explicit GetInstanceTrendingReportResponseBodyDataOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxLoggedInAgents) {
      res["MaxLoggedInAgents"] = boost::any(*maxLoggedInAgents);
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxLoggedInAgents") != m.end() && !m["MaxLoggedInAgents"].empty()) {
      maxLoggedInAgents = make_shared<long>(boost::any_cast<long>(m["MaxLoggedInAgents"]));
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
  }


  virtual ~GetInstanceTrendingReportResponseBodyDataOverall() = default;
};
class GetInstanceTrendingReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceTrendingReportResponseBodyDataInbound>> inbound{};
  shared_ptr<vector<GetInstanceTrendingReportResponseBodyDataOutbound>> outbound{};
  shared_ptr<vector<GetInstanceTrendingReportResponseBodyDataOverall>> overall{};

  GetInstanceTrendingReportResponseBodyData() {}

  explicit GetInstanceTrendingReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      vector<boost::any> temp1;
      for(auto item1:*inbound){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inbound"] = boost::any(temp1);
    }
    if (outbound) {
      vector<boost::any> temp1;
      for(auto item1:*outbound){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outbound"] = boost::any(temp1);
    }
    if (overall) {
      vector<boost::any> temp1;
      for(auto item1:*overall){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Overall"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(vector<boost::any>) == m["Inbound"].type()) {
        vector<GetInstanceTrendingReportResponseBodyDataInbound> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inbound"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceTrendingReportResponseBodyDataInbound model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inbound = make_shared<vector<GetInstanceTrendingReportResponseBodyDataInbound>>(expect1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(vector<boost::any>) == m["Outbound"].type()) {
        vector<GetInstanceTrendingReportResponseBodyDataOutbound> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outbound"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceTrendingReportResponseBodyDataOutbound model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outbound = make_shared<vector<GetInstanceTrendingReportResponseBodyDataOutbound>>(expect1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(vector<boost::any>) == m["Overall"].type()) {
        vector<GetInstanceTrendingReportResponseBodyDataOverall> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Overall"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceTrendingReportResponseBodyDataOverall model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        overall = make_shared<vector<GetInstanceTrendingReportResponseBodyDataOverall>>(expect1);
      }
    }
  }


  virtual ~GetInstanceTrendingReportResponseBodyData() = default;
};
class GetInstanceTrendingReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInstanceTrendingReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetInstanceTrendingReportResponseBody() {}

  explicit GetInstanceTrendingReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInstanceTrendingReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInstanceTrendingReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInstanceTrendingReportResponseBody() = default;
};
class GetInstanceTrendingReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceTrendingReportResponseBody> body{};

  GetInstanceTrendingReportResponse() {}

  explicit GetInstanceTrendingReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceTrendingReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceTrendingReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceTrendingReportResponse() = default;
};
class GetLoginDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> chatDeviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  GetLoginDetailsRequest() {}

  explicit GetLoginDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chatDeviceId) {
      res["ChatDeviceId"] = boost::any(*chatDeviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChatDeviceId") != m.end() && !m["ChatDeviceId"].empty()) {
      chatDeviceId = make_shared<string>(boost::any_cast<string>(m["ChatDeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetLoginDetailsRequest() = default;
};
class GetLoginDetailsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentServerUrl{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> chatAppId{};
  shared_ptr<string> chatAppKey{};
  shared_ptr<string> chatDeviceId{};
  shared_ptr<string> chatLoginToken{};
  shared_ptr<string> chatServerUrl{};
  shared_ptr<string> chatUserId{};
  shared_ptr<string> deviceExt{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> displayName{};
  shared_ptr<string> extension{};
  shared_ptr<string> nickname{};
  shared_ptr<string> signature{};
  shared_ptr<string> signature2{};
  shared_ptr<string> sipServerUrl{};
  shared_ptr<string> userId{};
  shared_ptr<string> userKey{};
  shared_ptr<string> userKey2{};
  shared_ptr<string> workMode{};

  GetLoginDetailsResponseBodyData() {}

  explicit GetLoginDetailsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentServerUrl) {
      res["AgentServerUrl"] = boost::any(*agentServerUrl);
    }
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (chatAppId) {
      res["ChatAppId"] = boost::any(*chatAppId);
    }
    if (chatAppKey) {
      res["ChatAppKey"] = boost::any(*chatAppKey);
    }
    if (chatDeviceId) {
      res["ChatDeviceId"] = boost::any(*chatDeviceId);
    }
    if (chatLoginToken) {
      res["ChatLoginToken"] = boost::any(*chatLoginToken);
    }
    if (chatServerUrl) {
      res["ChatServerUrl"] = boost::any(*chatServerUrl);
    }
    if (chatUserId) {
      res["ChatUserId"] = boost::any(*chatUserId);
    }
    if (deviceExt) {
      res["DeviceExt"] = boost::any(*deviceExt);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (signature2) {
      res["Signature2"] = boost::any(*signature2);
    }
    if (sipServerUrl) {
      res["SipServerUrl"] = boost::any(*sipServerUrl);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userKey) {
      res["UserKey"] = boost::any(*userKey);
    }
    if (userKey2) {
      res["UserKey2"] = boost::any(*userKey2);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentServerUrl") != m.end() && !m["AgentServerUrl"].empty()) {
      agentServerUrl = make_shared<string>(boost::any_cast<string>(m["AgentServerUrl"]));
    }
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("ChatAppId") != m.end() && !m["ChatAppId"].empty()) {
      chatAppId = make_shared<string>(boost::any_cast<string>(m["ChatAppId"]));
    }
    if (m.find("ChatAppKey") != m.end() && !m["ChatAppKey"].empty()) {
      chatAppKey = make_shared<string>(boost::any_cast<string>(m["ChatAppKey"]));
    }
    if (m.find("ChatDeviceId") != m.end() && !m["ChatDeviceId"].empty()) {
      chatDeviceId = make_shared<string>(boost::any_cast<string>(m["ChatDeviceId"]));
    }
    if (m.find("ChatLoginToken") != m.end() && !m["ChatLoginToken"].empty()) {
      chatLoginToken = make_shared<string>(boost::any_cast<string>(m["ChatLoginToken"]));
    }
    if (m.find("ChatServerUrl") != m.end() && !m["ChatServerUrl"].empty()) {
      chatServerUrl = make_shared<string>(boost::any_cast<string>(m["ChatServerUrl"]));
    }
    if (m.find("ChatUserId") != m.end() && !m["ChatUserId"].empty()) {
      chatUserId = make_shared<string>(boost::any_cast<string>(m["ChatUserId"]));
    }
    if (m.find("DeviceExt") != m.end() && !m["DeviceExt"].empty()) {
      deviceExt = make_shared<string>(boost::any_cast<string>(m["DeviceExt"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("Signature2") != m.end() && !m["Signature2"].empty()) {
      signature2 = make_shared<string>(boost::any_cast<string>(m["Signature2"]));
    }
    if (m.find("SipServerUrl") != m.end() && !m["SipServerUrl"].empty()) {
      sipServerUrl = make_shared<string>(boost::any_cast<string>(m["SipServerUrl"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserKey") != m.end() && !m["UserKey"].empty()) {
      userKey = make_shared<string>(boost::any_cast<string>(m["UserKey"]));
    }
    if (m.find("UserKey2") != m.end() && !m["UserKey2"].empty()) {
      userKey2 = make_shared<string>(boost::any_cast<string>(m["UserKey2"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~GetLoginDetailsResponseBodyData() = default;
};
class GetLoginDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetLoginDetailsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetLoginDetailsResponseBody() {}

  explicit GetLoginDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetLoginDetailsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetLoginDetailsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLoginDetailsResponseBody() = default;
};
class GetLoginDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLoginDetailsResponseBody> body{};

  GetLoginDetailsResponse() {}

  explicit GetLoginDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLoginDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLoginDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~GetLoginDetailsResponse() = default;
};
class GetMonoRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<long> expireSeconds{};
  shared_ptr<string> instanceId{};

  GetMonoRecordingRequest() {}

  explicit GetMonoRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (expireSeconds) {
      res["ExpireSeconds"] = boost::any(*expireSeconds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ExpireSeconds") != m.end() && !m["ExpireSeconds"].empty()) {
      expireSeconds = make_shared<long>(boost::any_cast<long>(m["ExpireSeconds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetMonoRecordingRequest() = default;
};
class GetMonoRecordingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};

  GetMonoRecordingResponseBodyData() {}

  explicit GetMonoRecordingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~GetMonoRecordingResponseBodyData() = default;
};
class GetMonoRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetMonoRecordingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetMonoRecordingResponseBody() {}

  explicit GetMonoRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMonoRecordingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMonoRecordingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMonoRecordingResponseBody() = default;
};
class GetMonoRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMonoRecordingResponseBody> body{};

  GetMonoRecordingResponse() {}

  explicit GetMonoRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMonoRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMonoRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~GetMonoRecordingResponse() = default;
};
class GetMultiChannelRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetMultiChannelRecordingRequest() {}

  explicit GetMultiChannelRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetMultiChannelRecordingRequest() = default;
};
class GetMultiChannelRecordingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};

  GetMultiChannelRecordingResponseBodyData() {}

  explicit GetMultiChannelRecordingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~GetMultiChannelRecordingResponseBodyData() = default;
};
class GetMultiChannelRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetMultiChannelRecordingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetMultiChannelRecordingResponseBody() {}

  explicit GetMultiChannelRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMultiChannelRecordingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMultiChannelRecordingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMultiChannelRecordingResponseBody() = default;
};
class GetMultiChannelRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultiChannelRecordingResponseBody> body{};

  GetMultiChannelRecordingResponse() {}

  explicit GetMultiChannelRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultiChannelRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultiChannelRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultiChannelRecordingResponse() = default;
};
class GetNumberLocationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};

  GetNumberLocationRequest() {}

  explicit GetNumberLocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~GetNumberLocationRequest() = default;
};
class GetNumberLocationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  GetNumberLocationResponseBodyData() {}

  explicit GetNumberLocationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~GetNumberLocationResponseBodyData() = default;
};
class GetNumberLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetNumberLocationResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetNumberLocationResponseBody() {}

  explicit GetNumberLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetNumberLocationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetNumberLocationResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetNumberLocationResponseBody() = default;
};
class GetNumberLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNumberLocationResponseBody> body{};

  GetNumberLocationResponse() {}

  explicit GetNumberLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNumberLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNumberLocationResponseBody>(model1);
      }
    }
  }


  virtual ~GetNumberLocationResponse() = default;
};
class GetRealtimeCampaignStatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> queueId{};

  GetRealtimeCampaignStatsRequest() {}

  explicit GetRealtimeCampaignStatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
  }


  virtual ~GetRealtimeCampaignStatsRequest() = default;
};
class GetRealtimeCampaignStatsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> breakingAgents{};
  shared_ptr<long> caps{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> outboundScenarioBreakingAgents{};
  shared_ptr<long> outboundScenarioReadyAgents{};
  shared_ptr<long> outboundScenarioTalkingAgents{};
  shared_ptr<long> outboundScenarioWorkingAgents{};
  shared_ptr<long> readyAgents{};
  shared_ptr<long> talkingAgents{};
  shared_ptr<long> totalAgents{};
  shared_ptr<long> workingAgents{};

  GetRealtimeCampaignStatsResponseBodyData() {}

  explicit GetRealtimeCampaignStatsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakingAgents) {
      res["BreakingAgents"] = boost::any(*breakingAgents);
    }
    if (caps) {
      res["Caps"] = boost::any(*caps);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (outboundScenarioBreakingAgents) {
      res["OutboundScenarioBreakingAgents"] = boost::any(*outboundScenarioBreakingAgents);
    }
    if (outboundScenarioReadyAgents) {
      res["OutboundScenarioReadyAgents"] = boost::any(*outboundScenarioReadyAgents);
    }
    if (outboundScenarioTalkingAgents) {
      res["OutboundScenarioTalkingAgents"] = boost::any(*outboundScenarioTalkingAgents);
    }
    if (outboundScenarioWorkingAgents) {
      res["OutboundScenarioWorkingAgents"] = boost::any(*outboundScenarioWorkingAgents);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (talkingAgents) {
      res["TalkingAgents"] = boost::any(*talkingAgents);
    }
    if (totalAgents) {
      res["TotalAgents"] = boost::any(*totalAgents);
    }
    if (workingAgents) {
      res["WorkingAgents"] = boost::any(*workingAgents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakingAgents") != m.end() && !m["BreakingAgents"].empty()) {
      breakingAgents = make_shared<long>(boost::any_cast<long>(m["BreakingAgents"]));
    }
    if (m.find("Caps") != m.end() && !m["Caps"].empty()) {
      caps = make_shared<long>(boost::any_cast<long>(m["Caps"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("OutboundScenarioBreakingAgents") != m.end() && !m["OutboundScenarioBreakingAgents"].empty()) {
      outboundScenarioBreakingAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioBreakingAgents"]));
    }
    if (m.find("OutboundScenarioReadyAgents") != m.end() && !m["OutboundScenarioReadyAgents"].empty()) {
      outboundScenarioReadyAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioReadyAgents"]));
    }
    if (m.find("OutboundScenarioTalkingAgents") != m.end() && !m["OutboundScenarioTalkingAgents"].empty()) {
      outboundScenarioTalkingAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioTalkingAgents"]));
    }
    if (m.find("OutboundScenarioWorkingAgents") != m.end() && !m["OutboundScenarioWorkingAgents"].empty()) {
      outboundScenarioWorkingAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioWorkingAgents"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("TalkingAgents") != m.end() && !m["TalkingAgents"].empty()) {
      talkingAgents = make_shared<long>(boost::any_cast<long>(m["TalkingAgents"]));
    }
    if (m.find("TotalAgents") != m.end() && !m["TotalAgents"].empty()) {
      totalAgents = make_shared<long>(boost::any_cast<long>(m["TotalAgents"]));
    }
    if (m.find("WorkingAgents") != m.end() && !m["WorkingAgents"].empty()) {
      workingAgents = make_shared<long>(boost::any_cast<long>(m["WorkingAgents"]));
    }
  }


  virtual ~GetRealtimeCampaignStatsResponseBodyData() = default;
};
class GetRealtimeCampaignStatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetRealtimeCampaignStatsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetRealtimeCampaignStatsResponseBody() {}

  explicit GetRealtimeCampaignStatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRealtimeCampaignStatsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRealtimeCampaignStatsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRealtimeCampaignStatsResponseBody() = default;
};
class GetRealtimeCampaignStatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRealtimeCampaignStatsResponseBody> body{};

  GetRealtimeCampaignStatsResponse() {}

  explicit GetRealtimeCampaignStatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRealtimeCampaignStatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRealtimeCampaignStatsResponseBody>(model1);
      }
    }
  }


  virtual ~GetRealtimeCampaignStatsResponse() = default;
};
class GetRealtimeInstanceStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};

  GetRealtimeInstanceStatesRequest() {}

  explicit GetRealtimeInstanceStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~GetRealtimeInstanceStatesRequest() = default;
};
class GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<long> count{};

  GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList() {}

  explicit GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList() = default;
};
class GetRealtimeInstanceStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList>> breakCodeDetailList{};
  shared_ptr<long> breakingAgents{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> interactiveCalls{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> longestWaitingTime{};
  shared_ptr<long> readyAgents{};
  shared_ptr<long> talkingAgents{};
  shared_ptr<long> totalAgents{};
  shared_ptr<long> waitingCalls{};
  shared_ptr<long> workingAgents{};

  GetRealtimeInstanceStatesResponseBodyData() {}

  explicit GetRealtimeInstanceStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCodeDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*breakCodeDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BreakCodeDetailList"] = boost::any(temp1);
    }
    if (breakingAgents) {
      res["BreakingAgents"] = boost::any(*breakingAgents);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interactiveCalls) {
      res["InteractiveCalls"] = boost::any(*interactiveCalls);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (longestWaitingTime) {
      res["LongestWaitingTime"] = boost::any(*longestWaitingTime);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (talkingAgents) {
      res["TalkingAgents"] = boost::any(*talkingAgents);
    }
    if (totalAgents) {
      res["TotalAgents"] = boost::any(*totalAgents);
    }
    if (waitingCalls) {
      res["WaitingCalls"] = boost::any(*waitingCalls);
    }
    if (workingAgents) {
      res["WorkingAgents"] = boost::any(*workingAgents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCodeDetailList") != m.end() && !m["BreakCodeDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["BreakCodeDetailList"].type()) {
        vector<GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BreakCodeDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        breakCodeDetailList = make_shared<vector<GetRealtimeInstanceStatesResponseBodyDataBreakCodeDetailList>>(expect1);
      }
    }
    if (m.find("BreakingAgents") != m.end() && !m["BreakingAgents"].empty()) {
      breakingAgents = make_shared<long>(boost::any_cast<long>(m["BreakingAgents"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InteractiveCalls") != m.end() && !m["InteractiveCalls"].empty()) {
      interactiveCalls = make_shared<long>(boost::any_cast<long>(m["InteractiveCalls"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("LongestWaitingTime") != m.end() && !m["LongestWaitingTime"].empty()) {
      longestWaitingTime = make_shared<long>(boost::any_cast<long>(m["LongestWaitingTime"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("TalkingAgents") != m.end() && !m["TalkingAgents"].empty()) {
      talkingAgents = make_shared<long>(boost::any_cast<long>(m["TalkingAgents"]));
    }
    if (m.find("TotalAgents") != m.end() && !m["TotalAgents"].empty()) {
      totalAgents = make_shared<long>(boost::any_cast<long>(m["TotalAgents"]));
    }
    if (m.find("WaitingCalls") != m.end() && !m["WaitingCalls"].empty()) {
      waitingCalls = make_shared<long>(boost::any_cast<long>(m["WaitingCalls"]));
    }
    if (m.find("WorkingAgents") != m.end() && !m["WorkingAgents"].empty()) {
      workingAgents = make_shared<long>(boost::any_cast<long>(m["WorkingAgents"]));
    }
  }


  virtual ~GetRealtimeInstanceStatesResponseBodyData() = default;
};
class GetRealtimeInstanceStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetRealtimeInstanceStatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetRealtimeInstanceStatesResponseBody() {}

  explicit GetRealtimeInstanceStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRealtimeInstanceStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRealtimeInstanceStatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRealtimeInstanceStatesResponseBody() = default;
};
class GetRealtimeInstanceStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRealtimeInstanceStatesResponseBody> body{};

  GetRealtimeInstanceStatesResponse() {}

  explicit GetRealtimeInstanceStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRealtimeInstanceStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRealtimeInstanceStatesResponseBody>(model1);
      }
    }
  }


  virtual ~GetRealtimeInstanceStatesResponse() = default;
};
class GetSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  GetSchemaRequest() {}

  explicit GetSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~GetSchemaRequest() = default;
};
class GetSchemaResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<map<string, DataPropertiesValue>> properties{};
  shared_ptr<string> updatedTime{};

  GetSchemaResponseBodyData() {}

  explicit GetSchemaResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (properties) {
      map<string, boost::any> temp1;
      for(auto item1:*properties){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["Properties"] = boost::any(temp1);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        map<string, DataPropertiesValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["Properties"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            DataPropertiesValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        properties = make_shared<map<string, DataPropertiesValue>>(expect1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
  }


  virtual ~GetSchemaResponseBodyData() = default;
};
class GetSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSchemaResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetSchemaResponseBody() {}

  explicit GetSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSchemaResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSchemaResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSchemaResponseBody() = default;
};
class GetSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSchemaResponseBody> body{};

  GetSchemaResponse() {}

  explicit GetSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~GetSchemaResponse() = default;
};
class GetSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};

  GetSkillGroupRequest() {}

  explicit GetSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~GetSkillGroupRequest() = default;
};
class GetSkillGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> name{};
  shared_ptr<string> skillGroupId{};

  GetSkillGroupResponseBodyData() {}

  explicit GetSkillGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~GetSkillGroupResponseBodyData() = default;
};
class GetSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSkillGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetSkillGroupResponseBody() {}

  explicit GetSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSkillGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSkillGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSkillGroupResponseBody() = default;
};
class GetSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSkillGroupResponseBody> body{};

  GetSkillGroupResponse() {}

  explicit GetSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetSkillGroupResponse() = default;
};
class GetTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ticketId{};

  GetTicketRequest() {}

  explicit GetTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~GetTicketRequest() = default;
};
class GetTicketResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> assignee{};
  shared_ptr<string> assigneeName{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> closeCode{};
  shared_ptr<string> comment{};
  shared_ptr<string> context{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> currentTaskId{};
  shared_ptr<string> currentTaskName{};
  shared_ptr<long> currentTaskStartTime{};
  shared_ptr<string> customerId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> source{};
  shared_ptr<long> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateVersion{};
  shared_ptr<string> ticketId{};
  shared_ptr<string> title{};
  shared_ptr<long> updatedTime{};

  GetTicketResponseBodyData() {}

  explicit GetTicketResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignee) {
      res["Assignee"] = boost::any(*assignee);
    }
    if (assigneeName) {
      res["AssigneeName"] = boost::any(*assigneeName);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (closeCode) {
      res["CloseCode"] = boost::any(*closeCode);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (context) {
      res["Context"] = boost::any(*context);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (currentTaskId) {
      res["CurrentTaskId"] = boost::any(*currentTaskId);
    }
    if (currentTaskName) {
      res["CurrentTaskName"] = boost::any(*currentTaskName);
    }
    if (currentTaskStartTime) {
      res["CurrentTaskStartTime"] = boost::any(*currentTaskStartTime);
    }
    if (customerId) {
      res["CustomerId"] = boost::any(*customerId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateVersion) {
      res["TemplateVersion"] = boost::any(*templateVersion);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assignee") != m.end() && !m["Assignee"].empty()) {
      assignee = make_shared<string>(boost::any_cast<string>(m["Assignee"]));
    }
    if (m.find("AssigneeName") != m.end() && !m["AssigneeName"].empty()) {
      assigneeName = make_shared<string>(boost::any_cast<string>(m["AssigneeName"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("CloseCode") != m.end() && !m["CloseCode"].empty()) {
      closeCode = make_shared<string>(boost::any_cast<string>(m["CloseCode"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Context") != m.end() && !m["Context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["Context"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("CurrentTaskId") != m.end() && !m["CurrentTaskId"].empty()) {
      currentTaskId = make_shared<string>(boost::any_cast<string>(m["CurrentTaskId"]));
    }
    if (m.find("CurrentTaskName") != m.end() && !m["CurrentTaskName"].empty()) {
      currentTaskName = make_shared<string>(boost::any_cast<string>(m["CurrentTaskName"]));
    }
    if (m.find("CurrentTaskStartTime") != m.end() && !m["CurrentTaskStartTime"].empty()) {
      currentTaskStartTime = make_shared<long>(boost::any_cast<long>(m["CurrentTaskStartTime"]));
    }
    if (m.find("CustomerId") != m.end() && !m["CustomerId"].empty()) {
      customerId = make_shared<string>(boost::any_cast<string>(m["CustomerId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateVersion") != m.end() && !m["TemplateVersion"].empty()) {
      templateVersion = make_shared<string>(boost::any_cast<string>(m["TemplateVersion"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
  }


  virtual ~GetTicketResponseBodyData() = default;
};
class GetTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetTicketResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetTicketResponseBody() {}

  explicit GetTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTicketResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTicketResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTicketResponseBody() = default;
};
class GetTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTicketResponseBody> body{};

  GetTicketResponse() {}

  explicit GetTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTicketResponseBody>(model1);
      }
    }
  }


  virtual ~GetTicketResponse() = default;
};
class GetTicketSummaryReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> assignee{};
  shared_ptr<string> assigneeType{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> creator{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> participant{};
  shared_ptr<long> startTime{};
  shared_ptr<string> state{};

  GetTicketSummaryReportRequest() {}

  explicit GetTicketSummaryReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignee) {
      res["Assignee"] = boost::any(*assignee);
    }
    if (assigneeType) {
      res["AssigneeType"] = boost::any(*assigneeType);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (participant) {
      res["Participant"] = boost::any(*participant);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assignee") != m.end() && !m["Assignee"].empty()) {
      assignee = make_shared<string>(boost::any_cast<string>(m["Assignee"]));
    }
    if (m.find("AssigneeType") != m.end() && !m["AssigneeType"].empty()) {
      assigneeType = make_shared<string>(boost::any_cast<string>(m["AssigneeType"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Participant") != m.end() && !m["Participant"].empty()) {
      participant = make_shared<string>(boost::any_cast<string>(m["Participant"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~GetTicketSummaryReportRequest() = default;
};
class GetTicketSummaryReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> ticketsAssigned{};
  shared_ptr<string> ticketsCreated{};
  shared_ptr<string> ticketsParticipated{};

  GetTicketSummaryReportResponseBodyData() {}

  explicit GetTicketSummaryReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ticketsAssigned) {
      res["TicketsAssigned"] = boost::any(*ticketsAssigned);
    }
    if (ticketsCreated) {
      res["TicketsCreated"] = boost::any(*ticketsCreated);
    }
    if (ticketsParticipated) {
      res["TicketsParticipated"] = boost::any(*ticketsParticipated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TicketsAssigned") != m.end() && !m["TicketsAssigned"].empty()) {
      ticketsAssigned = make_shared<string>(boost::any_cast<string>(m["TicketsAssigned"]));
    }
    if (m.find("TicketsCreated") != m.end() && !m["TicketsCreated"].empty()) {
      ticketsCreated = make_shared<string>(boost::any_cast<string>(m["TicketsCreated"]));
    }
    if (m.find("TicketsParticipated") != m.end() && !m["TicketsParticipated"].empty()) {
      ticketsParticipated = make_shared<string>(boost::any_cast<string>(m["TicketsParticipated"]));
    }
  }


  virtual ~GetTicketSummaryReportResponseBodyData() = default;
};
class GetTicketSummaryReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetTicketSummaryReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetTicketSummaryReportResponseBody() {}

  explicit GetTicketSummaryReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTicketSummaryReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTicketSummaryReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTicketSummaryReportResponseBody() = default;
};
class GetTicketSummaryReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTicketSummaryReportResponseBody> body{};

  GetTicketSummaryReportResponse() {}

  explicit GetTicketSummaryReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTicketSummaryReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTicketSummaryReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetTicketSummaryReportResponse() = default;
};
class GetTicketTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateVersion{};

  GetTicketTemplateRequest() {}

  explicit GetTicketTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateVersion) {
      res["TemplateVersion"] = boost::any(*templateVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateVersion") != m.end() && !m["TemplateVersion"].empty()) {
      templateVersion = make_shared<string>(boost::any_cast<string>(m["TemplateVersion"]));
    }
  }


  virtual ~GetTicketTemplateRequest() = default;
};
class GetTicketTemplateResponseBodyDataTicketFields : public Darabonba::Model {
public:
  shared_ptr<bool> array{};
  shared_ptr<string> attributes{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> dataType{};
  shared_ptr<string> description{};
  shared_ptr<bool> disabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> displayOrder{};
  shared_ptr<string> editorType{};
  shared_ptr<long> maxLength{};
  shared_ptr<double> maximum{};
  shared_ptr<long> minLength{};
  shared_ptr<double> minimum{};
  shared_ptr<string> name{};
  shared_ptr<string> pattern{};
  shared_ptr<string> patternErrorMessage{};
  shared_ptr<bool> readOnly{};
  shared_ptr<bool> required{};
  shared_ptr<bool> system{};
  shared_ptr<long> updatedTime{};

  GetTicketTemplateResponseBodyDataTicketFields() {}

  explicit GetTicketTemplateResponseBodyDataTicketFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (array) {
      res["Array"] = boost::any(*array);
    }
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayOrder) {
      res["DisplayOrder"] = boost::any(*displayOrder);
    }
    if (editorType) {
      res["EditorType"] = boost::any(*editorType);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minimum) {
      res["Minimum"] = boost::any(*minimum);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (patternErrorMessage) {
      res["PatternErrorMessage"] = boost::any(*patternErrorMessage);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Array") != m.end() && !m["Array"].empty()) {
      array = make_shared<bool>(boost::any_cast<bool>(m["Array"]));
    }
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      attributes = make_shared<string>(boost::any_cast<string>(m["Attributes"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayOrder") != m.end() && !m["DisplayOrder"].empty()) {
      displayOrder = make_shared<long>(boost::any_cast<long>(m["DisplayOrder"]));
    }
    if (m.find("EditorType") != m.end() && !m["EditorType"].empty()) {
      editorType = make_shared<string>(boost::any_cast<string>(m["EditorType"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<double>(boost::any_cast<double>(m["Maximum"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("Minimum") != m.end() && !m["Minimum"].empty()) {
      minimum = make_shared<double>(boost::any_cast<double>(m["Minimum"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("PatternErrorMessage") != m.end() && !m["PatternErrorMessage"].empty()) {
      patternErrorMessage = make_shared<string>(boost::any_cast<string>(m["PatternErrorMessage"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
  }


  virtual ~GetTicketTemplateResponseBodyDataTicketFields() = default;
};
class GetTicketTemplateResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> editor{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> processDefinition{};
  shared_ptr<string> state{};
  shared_ptr<string> templateId{};
  shared_ptr<vector<GetTicketTemplateResponseBodyDataTicketFields>> ticketFields{};
  shared_ptr<long> updatedTime{};

  GetTicketTemplateResponseBodyData() {}

  explicit GetTicketTemplateResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (editor) {
      res["Editor"] = boost::any(*editor);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (processDefinition) {
      res["ProcessDefinition"] = boost::any(*processDefinition);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (ticketFields) {
      vector<boost::any> temp1;
      for(auto item1:*ticketFields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TicketFields"] = boost::any(temp1);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Editor") != m.end() && !m["Editor"].empty()) {
      editor = make_shared<string>(boost::any_cast<string>(m["Editor"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProcessDefinition") != m.end() && !m["ProcessDefinition"].empty()) {
      processDefinition = make_shared<string>(boost::any_cast<string>(m["ProcessDefinition"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TicketFields") != m.end() && !m["TicketFields"].empty()) {
      if (typeid(vector<boost::any>) == m["TicketFields"].type()) {
        vector<GetTicketTemplateResponseBodyDataTicketFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TicketFields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTicketTemplateResponseBodyDataTicketFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ticketFields = make_shared<vector<GetTicketTemplateResponseBodyDataTicketFields>>(expect1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
  }


  virtual ~GetTicketTemplateResponseBodyData() = default;
};
class GetTicketTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetTicketTemplateResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetTicketTemplateResponseBody() {}

  explicit GetTicketTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTicketTemplateResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTicketTemplateResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTicketTemplateResponseBody() = default;
};
class GetTicketTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTicketTemplateResponseBody> body{};

  GetTicketTemplateResponse() {}

  explicit GetTicketTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTicketTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTicketTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetTicketTemplateResponse() = default;
};
class GetTurnCredentialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  GetTurnCredentialsRequest() {}

  explicit GetTurnCredentialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetTurnCredentialsRequest() = default;
};
class GetTurnCredentialsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> userName{};

  GetTurnCredentialsResponseBodyData() {}

  explicit GetTurnCredentialsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~GetTurnCredentialsResponseBodyData() = default;
};
class GetTurnCredentialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetTurnCredentialsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetTurnCredentialsResponseBody() {}

  explicit GetTurnCredentialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTurnCredentialsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTurnCredentialsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTurnCredentialsResponseBody() = default;
};
class GetTurnCredentialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTurnCredentialsResponseBody> body{};

  GetTurnCredentialsResponse() {}

  explicit GetTurnCredentialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTurnCredentialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTurnCredentialsResponseBody>(model1);
      }
    }
  }


  virtual ~GetTurnCredentialsResponse() = default;
};
class GetTurnServerListRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetTurnServerListRequest() {}

  explicit GetTurnServerListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetTurnServerListRequest() = default;
};
class GetTurnServerListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetTurnServerListResponseBody() {}

  explicit GetTurnServerListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTurnServerListResponseBody() = default;
};
class GetTurnServerListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTurnServerListResponseBody> body{};

  GetTurnServerListResponse() {}

  explicit GetTurnServerListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTurnServerListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTurnServerListResponseBody>(model1);
      }
    }
  }


  virtual ~GetTurnServerListResponse() = default;
};
class GetUploadAudioDataParamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetUploadAudioDataParamsRequest() {}

  explicit GetUploadAudioDataParamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetUploadAudioDataParamsRequest() = default;
};
class GetUploadAudioDataParamsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> paramsStr{};

  GetUploadAudioDataParamsResponseBodyData() {}

  explicit GetUploadAudioDataParamsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramsStr) {
      res["ParamsStr"] = boost::any(*paramsStr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamsStr") != m.end() && !m["ParamsStr"].empty()) {
      paramsStr = make_shared<string>(boost::any_cast<string>(m["ParamsStr"]));
    }
  }


  virtual ~GetUploadAudioDataParamsResponseBodyData() = default;
};
class GetUploadAudioDataParamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetUploadAudioDataParamsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetUploadAudioDataParamsResponseBody() {}

  explicit GetUploadAudioDataParamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetUploadAudioDataParamsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetUploadAudioDataParamsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetUploadAudioDataParamsResponseBody() = default;
};
class GetUploadAudioDataParamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUploadAudioDataParamsResponseBody> body{};

  GetUploadAudioDataParamsResponse() {}

  explicit GetUploadAudioDataParamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUploadAudioDataParamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUploadAudioDataParamsResponseBody>(model1);
      }
    }
  }


  virtual ~GetUploadAudioDataParamsResponse() = default;
};
class GetUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  GetUserRequest() {}

  explicit GetUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetUserRequest() = default;
};
class GetUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> deviceExt{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> displayId{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> nickname{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  GetUserResponseBodyData() {}

  explicit GetUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (deviceExt) {
      res["DeviceExt"] = boost::any(*deviceExt);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("DeviceExt") != m.end() && !m["DeviceExt"].empty()) {
      deviceExt = make_shared<string>(boost::any_cast<string>(m["DeviceExt"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~GetUserResponseBodyData() = default;
};
class GetUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetUserResponseBody() {}

  explicit GetUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetUserResponseBody() = default;
};
class GetUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserResponseBody> body{};

  GetUserResponse() {}

  explicit GetUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserResponse() = default;
};
class GetVideoRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetVideoRequest() {}

  explicit GetVideoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetVideoRequest() = default;
};
class GetVideoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};

  GetVideoResponseBodyData() {}

  explicit GetVideoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~GetVideoResponseBodyData() = default;
};
class GetVideoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetVideoResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetVideoResponseBody() {}

  explicit GetVideoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetVideoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetVideoResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetVideoResponseBody() = default;
};
class GetVideoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVideoResponseBody> body{};

  GetVideoResponse() {}

  explicit GetVideoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVideoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVideoResponseBody>(model1);
      }
    }
  }


  virtual ~GetVideoResponse() = default;
};
class GetVisitorLoginDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> chatDeviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> token{};
  shared_ptr<string> visitorId{};

  GetVisitorLoginDetailsRequest() {}

  explicit GetVisitorLoginDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chatDeviceId) {
      res["ChatDeviceId"] = boost::any(*chatDeviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (visitorId) {
      res["VisitorId"] = boost::any(*visitorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChatDeviceId") != m.end() && !m["ChatDeviceId"].empty()) {
      chatDeviceId = make_shared<string>(boost::any_cast<string>(m["ChatDeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VisitorId") != m.end() && !m["VisitorId"].empty()) {
      visitorId = make_shared<string>(boost::any_cast<string>(m["VisitorId"]));
    }
  }


  virtual ~GetVisitorLoginDetailsRequest() = default;
};
class GetVisitorLoginDetailsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> chatAppId{};
  shared_ptr<string> chatAppKey{};
  shared_ptr<string> chatDeviceId{};
  shared_ptr<string> chatLoginToken{};
  shared_ptr<string> chatServerUrl{};
  shared_ptr<string> chatUserId{};

  GetVisitorLoginDetailsResponseBodyData() {}

  explicit GetVisitorLoginDetailsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chatAppId) {
      res["ChatAppId"] = boost::any(*chatAppId);
    }
    if (chatAppKey) {
      res["ChatAppKey"] = boost::any(*chatAppKey);
    }
    if (chatDeviceId) {
      res["ChatDeviceId"] = boost::any(*chatDeviceId);
    }
    if (chatLoginToken) {
      res["ChatLoginToken"] = boost::any(*chatLoginToken);
    }
    if (chatServerUrl) {
      res["ChatServerUrl"] = boost::any(*chatServerUrl);
    }
    if (chatUserId) {
      res["ChatUserId"] = boost::any(*chatUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChatAppId") != m.end() && !m["ChatAppId"].empty()) {
      chatAppId = make_shared<string>(boost::any_cast<string>(m["ChatAppId"]));
    }
    if (m.find("ChatAppKey") != m.end() && !m["ChatAppKey"].empty()) {
      chatAppKey = make_shared<string>(boost::any_cast<string>(m["ChatAppKey"]));
    }
    if (m.find("ChatDeviceId") != m.end() && !m["ChatDeviceId"].empty()) {
      chatDeviceId = make_shared<string>(boost::any_cast<string>(m["ChatDeviceId"]));
    }
    if (m.find("ChatLoginToken") != m.end() && !m["ChatLoginToken"].empty()) {
      chatLoginToken = make_shared<string>(boost::any_cast<string>(m["ChatLoginToken"]));
    }
    if (m.find("ChatServerUrl") != m.end() && !m["ChatServerUrl"].empty()) {
      chatServerUrl = make_shared<string>(boost::any_cast<string>(m["ChatServerUrl"]));
    }
    if (m.find("ChatUserId") != m.end() && !m["ChatUserId"].empty()) {
      chatUserId = make_shared<string>(boost::any_cast<string>(m["ChatUserId"]));
    }
  }


  virtual ~GetVisitorLoginDetailsResponseBodyData() = default;
};
class GetVisitorLoginDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetVisitorLoginDetailsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetVisitorLoginDetailsResponseBody() {}

  explicit GetVisitorLoginDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetVisitorLoginDetailsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetVisitorLoginDetailsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetVisitorLoginDetailsResponseBody() = default;
};
class GetVisitorLoginDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVisitorLoginDetailsResponseBody> body{};

  GetVisitorLoginDetailsResponse() {}

  explicit GetVisitorLoginDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVisitorLoginDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVisitorLoginDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~GetVisitorLoginDetailsResponse() = default;
};
class GetVoicemailRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetVoicemailRecordingRequest() {}

  explicit GetVoicemailRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetVoicemailRecordingRequest() = default;
};
class GetVoicemailRecordingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};

  GetVoicemailRecordingResponseBodyData() {}

  explicit GetVoicemailRecordingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~GetVoicemailRecordingResponseBodyData() = default;
};
class GetVoicemailRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetVoicemailRecordingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetVoicemailRecordingResponseBody() {}

  explicit GetVoicemailRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetVoicemailRecordingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetVoicemailRecordingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetVoicemailRecordingResponseBody() = default;
};
class GetVoicemailRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVoicemailRecordingResponseBody> body{};

  GetVoicemailRecordingResponse() {}

  explicit GetVoicemailRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVoicemailRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVoicemailRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~GetVoicemailRecordingResponse() = default;
};
class HoldCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> music{};
  shared_ptr<string> userId{};

  HoldCallRequest() {}

  explicit HoldCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (music) {
      res["Music"] = boost::any(*music);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Music") != m.end() && !m["Music"].empty()) {
      music = make_shared<string>(boost::any_cast<string>(m["Music"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~HoldCallRequest() = default;
};
class HoldCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  HoldCallResponseBodyDataCallContextChannelContexts() {}

  explicit HoldCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~HoldCallResponseBodyDataCallContextChannelContexts() = default;
};
class HoldCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<HoldCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  HoldCallResponseBodyDataCallContext() {}

  explicit HoldCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<HoldCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HoldCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<HoldCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~HoldCallResponseBodyDataCallContext() = default;
};
class HoldCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  HoldCallResponseBodyDataUserContext() {}

  explicit HoldCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~HoldCallResponseBodyDataUserContext() = default;
};
class HoldCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<HoldCallResponseBodyDataCallContext> callContext{};
  shared_ptr<HoldCallResponseBodyDataUserContext> userContext{};

  HoldCallResponseBodyData() {}

  explicit HoldCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        HoldCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<HoldCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        HoldCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<HoldCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~HoldCallResponseBodyData() = default;
};
class HoldCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<HoldCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  HoldCallResponseBody() {}

  explicit HoldCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        HoldCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<HoldCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~HoldCallResponseBody() = default;
};
class HoldCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HoldCallResponseBody> body{};

  HoldCallResponse() {}

  explicit HoldCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HoldCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HoldCallResponseBody>(model1);
      }
    }
  }


  virtual ~HoldCallResponse() = default;
};
class ImportAdminsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramIdList{};

  ImportAdminsRequest() {}

  explicit ImportAdminsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramIdList) {
      res["RamIdList"] = boost::any(*ramIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamIdList") != m.end() && !m["RamIdList"].empty()) {
      ramIdList = make_shared<string>(boost::any_cast<string>(m["RamIdList"]));
    }
  }


  virtual ~ImportAdminsRequest() = default;
};
class ImportAdminsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramId{};
  shared_ptr<string> roleId{};
  shared_ptr<string> userId{};

  ImportAdminsResponseBodyData() {}

  explicit ImportAdminsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ImportAdminsResponseBodyData() = default;
};
class ImportAdminsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ImportAdminsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ImportAdminsResponseBody() {}

  explicit ImportAdminsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ImportAdminsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportAdminsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ImportAdminsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportAdminsResponseBody() = default;
};
class ImportAdminsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportAdminsResponseBody> body{};

  ImportAdminsResponse() {}

  explicit ImportAdminsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportAdminsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportAdminsResponseBody>(model1);
      }
    }
  }


  virtual ~ImportAdminsResponse() = default;
};
class ImportCorpNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> corpName{};
  shared_ptr<string> numberList{};
  shared_ptr<string> provider{};
  shared_ptr<string> province{};
  shared_ptr<string> tagList{};

  ImportCorpNumbersRequest() {}

  explicit ImportCorpNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (corpName) {
      res["CorpName"] = boost::any(*corpName);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("CorpName") != m.end() && !m["CorpName"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["CorpName"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      tagList = make_shared<string>(boost::any_cast<string>(m["TagList"]));
    }
  }


  virtual ~ImportCorpNumbersRequest() = default;
};
class ImportCorpNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ImportCorpNumbersResponseBody() {}

  explicit ImportCorpNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportCorpNumbersResponseBody() = default;
};
class ImportCorpNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportCorpNumbersResponseBody> body{};

  ImportCorpNumbersResponse() {}

  explicit ImportCorpNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportCorpNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportCorpNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ImportCorpNumbersResponse() = default;
};
class ImportCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<string> instanceId{};

  ImportCustomCallTaggingRequest() {}

  explicit ImportCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ImportCustomCallTaggingRequest() = default;
};
class ImportCustomCallTaggingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> reason{};

  ImportCustomCallTaggingResponseBodyData() {}

  explicit ImportCustomCallTaggingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~ImportCustomCallTaggingResponseBodyData() = default;
};
class ImportCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ImportCustomCallTaggingResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ImportCustomCallTaggingResponseBody() {}

  explicit ImportCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ImportCustomCallTaggingResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportCustomCallTaggingResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ImportCustomCallTaggingResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportCustomCallTaggingResponseBody() = default;
};
class ImportCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportCustomCallTaggingResponseBody> body{};

  ImportCustomCallTaggingResponse() {}

  explicit ImportCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~ImportCustomCallTaggingResponse() = default;
};
class ImportDoNotCallNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> remark{};

  ImportDoNotCallNumbersRequest() {}

  explicit ImportDoNotCallNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~ImportDoNotCallNumbersRequest() = default;
};
class ImportDoNotCallNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ImportDoNotCallNumbersResponseBody() {}

  explicit ImportDoNotCallNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportDoNotCallNumbersResponseBody() = default;
};
class ImportDoNotCallNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportDoNotCallNumbersResponseBody> body{};

  ImportDoNotCallNumbersResponse() {}

  explicit ImportDoNotCallNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportDoNotCallNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportDoNotCallNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ImportDoNotCallNumbersResponse() = default;
};
class ImportDocumentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ossFileKey{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  ImportDocumentsRequest() {}

  explicit ImportDocumentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ossFileKey) {
      res["OssFileKey"] = boost::any(*ossFileKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OssFileKey") != m.end() && !m["OssFileKey"].empty()) {
      ossFileKey = make_shared<string>(boost::any_cast<string>(m["OssFileKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~ImportDocumentsRequest() = default;
};
class ImportDocumentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ImportDocumentsResponseBody() {}

  explicit ImportDocumentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportDocumentsResponseBody() = default;
};
class ImportDocumentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportDocumentsResponseBody> body{};

  ImportDocumentsResponse() {}

  explicit ImportDocumentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportDocumentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportDocumentsResponseBody>(model1);
      }
    }
  }


  virtual ~ImportDocumentsResponse() = default;
};
class InitiateAttendedTransferRequest : public Darabonba::Model {
public:
  shared_ptr<long> callPriority{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> queuingOverflowThreshold{};
  shared_ptr<long> queuingTimeoutSeconds{};
  shared_ptr<string> routingType{};
  shared_ptr<string> strategyName{};
  shared_ptr<string> strategyParams{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> transferee{};
  shared_ptr<string> transfereeType{};
  shared_ptr<string> transferor{};
  shared_ptr<string> userId{};

  InitiateAttendedTransferRequest() {}

  explicit InitiateAttendedTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callPriority) {
      res["CallPriority"] = boost::any(*callPriority);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (queuingOverflowThreshold) {
      res["QueuingOverflowThreshold"] = boost::any(*queuingOverflowThreshold);
    }
    if (queuingTimeoutSeconds) {
      res["QueuingTimeoutSeconds"] = boost::any(*queuingTimeoutSeconds);
    }
    if (routingType) {
      res["RoutingType"] = boost::any(*routingType);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (strategyParams) {
      res["StrategyParams"] = boost::any(*strategyParams);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (transferee) {
      res["Transferee"] = boost::any(*transferee);
    }
    if (transfereeType) {
      res["TransfereeType"] = boost::any(*transfereeType);
    }
    if (transferor) {
      res["Transferor"] = boost::any(*transferor);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallPriority") != m.end() && !m["CallPriority"].empty()) {
      callPriority = make_shared<long>(boost::any_cast<long>(m["CallPriority"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("QueuingOverflowThreshold") != m.end() && !m["QueuingOverflowThreshold"].empty()) {
      queuingOverflowThreshold = make_shared<long>(boost::any_cast<long>(m["QueuingOverflowThreshold"]));
    }
    if (m.find("QueuingTimeoutSeconds") != m.end() && !m["QueuingTimeoutSeconds"].empty()) {
      queuingTimeoutSeconds = make_shared<long>(boost::any_cast<long>(m["QueuingTimeoutSeconds"]));
    }
    if (m.find("RoutingType") != m.end() && !m["RoutingType"].empty()) {
      routingType = make_shared<string>(boost::any_cast<string>(m["RoutingType"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("StrategyParams") != m.end() && !m["StrategyParams"].empty()) {
      strategyParams = make_shared<string>(boost::any_cast<string>(m["StrategyParams"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("Transferee") != m.end() && !m["Transferee"].empty()) {
      transferee = make_shared<string>(boost::any_cast<string>(m["Transferee"]));
    }
    if (m.find("TransfereeType") != m.end() && !m["TransfereeType"].empty()) {
      transfereeType = make_shared<string>(boost::any_cast<string>(m["TransfereeType"]));
    }
    if (m.find("Transferor") != m.end() && !m["Transferor"].empty()) {
      transferor = make_shared<string>(boost::any_cast<string>(m["Transferor"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InitiateAttendedTransferRequest() = default;
};
class InitiateAttendedTransferResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  InitiateAttendedTransferResponseBodyDataCallContextChannelContexts() {}

  explicit InitiateAttendedTransferResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InitiateAttendedTransferResponseBodyDataCallContextChannelContexts() = default;
};
class InitiateAttendedTransferResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<InitiateAttendedTransferResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  InitiateAttendedTransferResponseBodyDataCallContext() {}

  explicit InitiateAttendedTransferResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<InitiateAttendedTransferResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InitiateAttendedTransferResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<InitiateAttendedTransferResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~InitiateAttendedTransferResponseBodyDataCallContext() = default;
};
class InitiateAttendedTransferResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  InitiateAttendedTransferResponseBodyDataUserContext() {}

  explicit InitiateAttendedTransferResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~InitiateAttendedTransferResponseBodyDataUserContext() = default;
};
class InitiateAttendedTransferResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<InitiateAttendedTransferResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<InitiateAttendedTransferResponseBodyDataUserContext> userContext{};

  InitiateAttendedTransferResponseBodyData() {}

  explicit InitiateAttendedTransferResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        InitiateAttendedTransferResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<InitiateAttendedTransferResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        InitiateAttendedTransferResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<InitiateAttendedTransferResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~InitiateAttendedTransferResponseBodyData() = default;
};
class InitiateAttendedTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<InitiateAttendedTransferResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  InitiateAttendedTransferResponseBody() {}

  explicit InitiateAttendedTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InitiateAttendedTransferResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InitiateAttendedTransferResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InitiateAttendedTransferResponseBody() = default;
};
class InitiateAttendedTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitiateAttendedTransferResponseBody> body{};

  InitiateAttendedTransferResponse() {}

  explicit InitiateAttendedTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitiateAttendedTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitiateAttendedTransferResponseBody>(model1);
      }
    }
  }


  virtual ~InitiateAttendedTransferResponse() = default;
};
class InterceptCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interceptedUserId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  InterceptCallRequest() {}

  explicit InterceptCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interceptedUserId) {
      res["InterceptedUserId"] = boost::any(*interceptedUserId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InterceptedUserId") != m.end() && !m["InterceptedUserId"].empty()) {
      interceptedUserId = make_shared<string>(boost::any_cast<string>(m["InterceptedUserId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InterceptCallRequest() = default;
};
class InterceptCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  InterceptCallResponseBodyDataCallContextChannelContexts() {}

  explicit InterceptCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InterceptCallResponseBodyDataCallContextChannelContexts() = default;
};
class InterceptCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<InterceptCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  InterceptCallResponseBodyDataCallContext() {}

  explicit InterceptCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<InterceptCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InterceptCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<InterceptCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~InterceptCallResponseBodyDataCallContext() = default;
};
class InterceptCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  InterceptCallResponseBodyDataUserContext() {}

  explicit InterceptCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~InterceptCallResponseBodyDataUserContext() = default;
};
class InterceptCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<InterceptCallResponseBodyDataCallContext> callContext{};
  shared_ptr<InterceptCallResponseBodyDataUserContext> userContext{};

  InterceptCallResponseBodyData() {}

  explicit InterceptCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        InterceptCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<InterceptCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        InterceptCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<InterceptCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~InterceptCallResponseBodyData() = default;
};
class InterceptCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<InterceptCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  InterceptCallResponseBody() {}

  explicit InterceptCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InterceptCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InterceptCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InterceptCallResponseBody() = default;
};
class InterceptCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InterceptCallResponseBody> body{};

  InterceptCallResponse() {}

  explicit InterceptCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InterceptCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InterceptCallResponseBody>(model1);
      }
    }
  }


  virtual ~InterceptCallResponse() = default;
};
class LaunchAuthenticationRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> contactFlowVariables{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  LaunchAuthenticationRequest() {}

  explicit LaunchAuthenticationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (contactFlowVariables) {
      res["ContactFlowVariables"] = boost::any(*contactFlowVariables);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("ContactFlowVariables") != m.end() && !m["ContactFlowVariables"].empty()) {
      contactFlowVariables = make_shared<string>(boost::any_cast<string>(m["ContactFlowVariables"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LaunchAuthenticationRequest() = default;
};
class LaunchAuthenticationResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  LaunchAuthenticationResponseBodyDataCallContextChannelContexts() {}

  explicit LaunchAuthenticationResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LaunchAuthenticationResponseBodyDataCallContextChannelContexts() = default;
};
class LaunchAuthenticationResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<LaunchAuthenticationResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  LaunchAuthenticationResponseBodyDataCallContext() {}

  explicit LaunchAuthenticationResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<LaunchAuthenticationResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LaunchAuthenticationResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<LaunchAuthenticationResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~LaunchAuthenticationResponseBodyDataCallContext() = default;
};
class LaunchAuthenticationResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  LaunchAuthenticationResponseBodyDataUserContext() {}

  explicit LaunchAuthenticationResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~LaunchAuthenticationResponseBodyDataUserContext() = default;
};
class LaunchAuthenticationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<LaunchAuthenticationResponseBodyDataCallContext> callContext{};
  shared_ptr<LaunchAuthenticationResponseBodyDataUserContext> userContext{};

  LaunchAuthenticationResponseBodyData() {}

  explicit LaunchAuthenticationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        LaunchAuthenticationResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<LaunchAuthenticationResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        LaunchAuthenticationResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<LaunchAuthenticationResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~LaunchAuthenticationResponseBodyData() = default;
};
class LaunchAuthenticationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<LaunchAuthenticationResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  LaunchAuthenticationResponseBody() {}

  explicit LaunchAuthenticationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        LaunchAuthenticationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<LaunchAuthenticationResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LaunchAuthenticationResponseBody() = default;
};
class LaunchAuthenticationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LaunchAuthenticationResponseBody> body{};

  LaunchAuthenticationResponse() {}

  explicit LaunchAuthenticationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LaunchAuthenticationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LaunchAuthenticationResponseBody>(model1);
      }
    }
  }


  virtual ~LaunchAuthenticationResponse() = default;
};
class LaunchSurveyRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> contactFlowVariables{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> smsMetadataId{};
  shared_ptr<string> surveyChannel{};
  shared_ptr<string> surveyTemplateId{};
  shared_ptr<string> surveyTemplateVariables{};
  shared_ptr<string> userId{};

  LaunchSurveyRequest() {}

  explicit LaunchSurveyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (contactFlowVariables) {
      res["ContactFlowVariables"] = boost::any(*contactFlowVariables);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (smsMetadataId) {
      res["SmsMetadataId"] = boost::any(*smsMetadataId);
    }
    if (surveyChannel) {
      res["SurveyChannel"] = boost::any(*surveyChannel);
    }
    if (surveyTemplateId) {
      res["SurveyTemplateId"] = boost::any(*surveyTemplateId);
    }
    if (surveyTemplateVariables) {
      res["SurveyTemplateVariables"] = boost::any(*surveyTemplateVariables);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("ContactFlowVariables") != m.end() && !m["ContactFlowVariables"].empty()) {
      contactFlowVariables = make_shared<string>(boost::any_cast<string>(m["ContactFlowVariables"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SmsMetadataId") != m.end() && !m["SmsMetadataId"].empty()) {
      smsMetadataId = make_shared<string>(boost::any_cast<string>(m["SmsMetadataId"]));
    }
    if (m.find("SurveyChannel") != m.end() && !m["SurveyChannel"].empty()) {
      surveyChannel = make_shared<string>(boost::any_cast<string>(m["SurveyChannel"]));
    }
    if (m.find("SurveyTemplateId") != m.end() && !m["SurveyTemplateId"].empty()) {
      surveyTemplateId = make_shared<string>(boost::any_cast<string>(m["SurveyTemplateId"]));
    }
    if (m.find("SurveyTemplateVariables") != m.end() && !m["SurveyTemplateVariables"].empty()) {
      surveyTemplateVariables = make_shared<string>(boost::any_cast<string>(m["SurveyTemplateVariables"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LaunchSurveyRequest() = default;
};
class LaunchSurveyResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  LaunchSurveyResponseBodyDataCallContextChannelContexts() {}

  explicit LaunchSurveyResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LaunchSurveyResponseBodyDataCallContextChannelContexts() = default;
};
class LaunchSurveyResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<LaunchSurveyResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  LaunchSurveyResponseBodyDataCallContext() {}

  explicit LaunchSurveyResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<LaunchSurveyResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LaunchSurveyResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<LaunchSurveyResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~LaunchSurveyResponseBodyDataCallContext() = default;
};
class LaunchSurveyResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  LaunchSurveyResponseBodyDataUserContext() {}

  explicit LaunchSurveyResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~LaunchSurveyResponseBodyDataUserContext() = default;
};
class LaunchSurveyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<LaunchSurveyResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<LaunchSurveyResponseBodyDataUserContext> userContext{};

  LaunchSurveyResponseBodyData() {}

  explicit LaunchSurveyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        LaunchSurveyResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<LaunchSurveyResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        LaunchSurveyResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<LaunchSurveyResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~LaunchSurveyResponseBodyData() = default;
};
class LaunchSurveyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<LaunchSurveyResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  LaunchSurveyResponseBody() {}

  explicit LaunchSurveyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        LaunchSurveyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<LaunchSurveyResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LaunchSurveyResponseBody() = default;
};
class LaunchSurveyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LaunchSurveyResponseBody> body{};

  LaunchSurveyResponse() {}

  explicit LaunchSurveyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LaunchSurveyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LaunchSurveyResponseBody>(model1);
      }
    }
  }


  virtual ~LaunchSurveyResponse() = default;
};
class ListAgentStateLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};

  ListAgentStateLogsRequest() {}

  explicit ListAgentStateLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListAgentStateLogsRequest() = default;
};
class ListAgentStateLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<long> duration{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> stateCode{};
  shared_ptr<string> workMode{};

  ListAgentStateLogsResponseBodyData() {}

  explicit ListAgentStateLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (stateCode) {
      res["StateCode"] = boost::any(*stateCode);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StateCode") != m.end() && !m["StateCode"].empty()) {
      stateCode = make_shared<string>(boost::any_cast<string>(m["StateCode"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ListAgentStateLogsResponseBodyData() = default;
};
class ListAgentStateLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListAgentStateLogsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListAgentStateLogsResponseBody() {}

  explicit ListAgentStateLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAgentStateLogsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentStateLogsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAgentStateLogsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAgentStateLogsResponseBody() = default;
};
class ListAgentStateLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAgentStateLogsResponseBody> body{};

  ListAgentStateLogsResponse() {}

  explicit ListAgentStateLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentStateLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentStateLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentStateLogsResponse() = default;
};
class ListAgentStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentIds{};
  shared_ptr<bool> excludeOfflineUsers{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> state{};

  ListAgentStatesRequest() {}

  explicit ListAgentStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (excludeOfflineUsers) {
      res["ExcludeOfflineUsers"] = boost::any(*excludeOfflineUsers);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("ExcludeOfflineUsers") != m.end() && !m["ExcludeOfflineUsers"].empty()) {
      excludeOfflineUsers = make_shared<bool>(boost::any_cast<bool>(m["ExcludeOfflineUsers"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListAgentStatesRequest() = default;
};
class ListAgentStatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> breakCode{};
  shared_ptr<string> dn{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<string> state{};
  shared_ptr<string> stateDuration{};

  ListAgentStatesResponseBodyDataList() {}

  explicit ListAgentStatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (dn) {
      res["Dn"] = boost::any(*dn);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (stateDuration) {
      res["StateDuration"] = boost::any(*stateDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Dn") != m.end() && !m["Dn"].empty()) {
      dn = make_shared<string>(boost::any_cast<string>(m["Dn"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StateDuration") != m.end() && !m["StateDuration"].empty()) {
      stateDuration = make_shared<string>(boost::any_cast<string>(m["StateDuration"]));
    }
  }


  virtual ~ListAgentStatesResponseBodyDataList() = default;
};
class ListAgentStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentStatesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAgentStatesResponseBodyData() {}

  explicit ListAgentStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListAgentStatesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentStatesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListAgentStatesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAgentStatesResponseBodyData() = default;
};
class ListAgentStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAgentStatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAgentStatesResponseBody() {}

  explicit ListAgentStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAgentStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAgentStatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAgentStatesResponseBody() = default;
};
class ListAgentStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAgentStatesResponseBody> body{};

  ListAgentStatesResponse() {}

  explicit ListAgentStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentStatesResponse() = default;
};
class ListAgentSummaryReportsSinceMidnightRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupId{};

  ListAgentSummaryReportsSinceMidnightRequest() {}

  explicit ListAgentSummaryReportsSinceMidnightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightRequest() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound : public Darabonba::Model {
public:
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<long> averageDialingTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<string> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<string>(boost::any_cast<string>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall : public Darabonba::Model {
public:
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> oneTransferCalls{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (oneTransferCalls) {
      res["OneTransferCalls"] = boost::any(*oneTransferCalls);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("OneTransferCalls") != m.end() && !m["OneTransferCalls"].empty()) {
      oneTransferCalls = make_shared<long>(boost::any_cast<long>(m["OneTransferCalls"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound> inbound{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound> outbound{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall> overall{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<string> timestamp{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall>(model1);
      }
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport> pagedAgentSummaryReport{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAgentSummaryReportsSinceMidnightResponseBody() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pagedAgentSummaryReport) {
      res["PagedAgentSummaryReport"] = pagedAgentSummaryReport ? boost::any(pagedAgentSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PagedAgentSummaryReport") != m.end() && !m["PagedAgentSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagedAgentSummaryReport"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagedAgentSummaryReport"]));
        pagedAgentSummaryReport = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBody() = default;
};
class ListAgentSummaryReportsSinceMidnightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBody> body{};

  ListAgentSummaryReportsSinceMidnightResponse() {}

  explicit ListAgentSummaryReportsSinceMidnightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentSummaryReportsSinceMidnightResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponse() = default;
};
class ListAttemptsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> attemptId{};
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> campaignId{};
  shared_ptr<string> caseId{};
  shared_ptr<string> contactId{};
  shared_ptr<string> criteria{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queueId{};
  shared_ptr<long> startTime{};

  ListAttemptsRequest() {}

  explicit ListAttemptsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (attemptId) {
      res["AttemptId"] = boost::any(*attemptId);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (caseId) {
      res["CaseId"] = boost::any(*caseId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AttemptId") != m.end() && !m["AttemptId"].empty()) {
      attemptId = make_shared<string>(boost::any_cast<string>(m["AttemptId"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CaseId") != m.end() && !m["CaseId"].empty()) {
      caseId = make_shared<string>(boost::any_cast<string>(m["CaseId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListAttemptsRequest() = default;
};
class ListAttemptsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> agentEstablishedTime{};
  shared_ptr<string> agentId{};
  shared_ptr<long> agentRingDuration{};
  shared_ptr<long> assignAgentTime{};
  shared_ptr<string> attemptId{};
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> campaignId{};
  shared_ptr<string> caseId{};
  shared_ptr<string> contactId{};
  shared_ptr<long> customerEstablishedTime{};
  shared_ptr<long> customerReleasedTime{};
  shared_ptr<long> dialDuration{};
  shared_ptr<long> dialTime{};
  shared_ptr<long> enqueueTime{};
  shared_ptr<long> enterIvrTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ivrDuration{};
  shared_ptr<long> queueDuration{};
  shared_ptr<string> queueId{};

  ListAttemptsResponseBodyDataList() {}

  explicit ListAttemptsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentEstablishedTime) {
      res["AgentEstablishedTime"] = boost::any(*agentEstablishedTime);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentRingDuration) {
      res["AgentRingDuration"] = boost::any(*agentRingDuration);
    }
    if (assignAgentTime) {
      res["AssignAgentTime"] = boost::any(*assignAgentTime);
    }
    if (attemptId) {
      res["AttemptId"] = boost::any(*attemptId);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (caseId) {
      res["CaseId"] = boost::any(*caseId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (customerEstablishedTime) {
      res["CustomerEstablishedTime"] = boost::any(*customerEstablishedTime);
    }
    if (customerReleasedTime) {
      res["CustomerReleasedTime"] = boost::any(*customerReleasedTime);
    }
    if (dialDuration) {
      res["DialDuration"] = boost::any(*dialDuration);
    }
    if (dialTime) {
      res["DialTime"] = boost::any(*dialTime);
    }
    if (enqueueTime) {
      res["EnqueueTime"] = boost::any(*enqueueTime);
    }
    if (enterIvrTime) {
      res["EnterIvrTime"] = boost::any(*enterIvrTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ivrDuration) {
      res["IvrDuration"] = boost::any(*ivrDuration);
    }
    if (queueDuration) {
      res["QueueDuration"] = boost::any(*queueDuration);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentEstablishedTime") != m.end() && !m["AgentEstablishedTime"].empty()) {
      agentEstablishedTime = make_shared<long>(boost::any_cast<long>(m["AgentEstablishedTime"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentRingDuration") != m.end() && !m["AgentRingDuration"].empty()) {
      agentRingDuration = make_shared<long>(boost::any_cast<long>(m["AgentRingDuration"]));
    }
    if (m.find("AssignAgentTime") != m.end() && !m["AssignAgentTime"].empty()) {
      assignAgentTime = make_shared<long>(boost::any_cast<long>(m["AssignAgentTime"]));
    }
    if (m.find("AttemptId") != m.end() && !m["AttemptId"].empty()) {
      attemptId = make_shared<string>(boost::any_cast<string>(m["AttemptId"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CaseId") != m.end() && !m["CaseId"].empty()) {
      caseId = make_shared<string>(boost::any_cast<string>(m["CaseId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("CustomerEstablishedTime") != m.end() && !m["CustomerEstablishedTime"].empty()) {
      customerEstablishedTime = make_shared<long>(boost::any_cast<long>(m["CustomerEstablishedTime"]));
    }
    if (m.find("CustomerReleasedTime") != m.end() && !m["CustomerReleasedTime"].empty()) {
      customerReleasedTime = make_shared<long>(boost::any_cast<long>(m["CustomerReleasedTime"]));
    }
    if (m.find("DialDuration") != m.end() && !m["DialDuration"].empty()) {
      dialDuration = make_shared<long>(boost::any_cast<long>(m["DialDuration"]));
    }
    if (m.find("DialTime") != m.end() && !m["DialTime"].empty()) {
      dialTime = make_shared<long>(boost::any_cast<long>(m["DialTime"]));
    }
    if (m.find("EnqueueTime") != m.end() && !m["EnqueueTime"].empty()) {
      enqueueTime = make_shared<long>(boost::any_cast<long>(m["EnqueueTime"]));
    }
    if (m.find("EnterIvrTime") != m.end() && !m["EnterIvrTime"].empty()) {
      enterIvrTime = make_shared<long>(boost::any_cast<long>(m["EnterIvrTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IvrDuration") != m.end() && !m["IvrDuration"].empty()) {
      ivrDuration = make_shared<long>(boost::any_cast<long>(m["IvrDuration"]));
    }
    if (m.find("QueueDuration") != m.end() && !m["QueueDuration"].empty()) {
      queueDuration = make_shared<long>(boost::any_cast<long>(m["QueueDuration"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
  }


  virtual ~ListAttemptsResponseBodyDataList() = default;
};
class ListAttemptsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAttemptsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAttemptsResponseBodyData() {}

  explicit ListAttemptsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListAttemptsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAttemptsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListAttemptsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAttemptsResponseBodyData() = default;
};
class ListAttemptsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAttemptsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListAttemptsResponseBody() {}

  explicit ListAttemptsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAttemptsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAttemptsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAttemptsResponseBody() = default;
};
class ListAttemptsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAttemptsResponseBody> body{};

  ListAttemptsResponse() {}

  explicit ListAttemptsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAttemptsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAttemptsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAttemptsResponse() = default;
};
class ListAudioFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};
  shared_ptr<string> usage{};

  ListAudioFilesRequest() {}

  explicit ListAudioFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ListAudioFilesRequest() = default;
};
class ListAudioFilesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> audioFileName{};
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> auditResult{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> ossFileKey{};
  shared_ptr<string> status{};
  shared_ptr<string> updatedTime{};
  shared_ptr<string> usage{};

  ListAudioFilesResponseBodyDataList() {}

  explicit ListAudioFilesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFileName) {
      res["AudioFileName"] = boost::any(*audioFileName);
    }
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (auditResult) {
      res["AuditResult"] = boost::any(*auditResult);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossFileKey) {
      res["OssFileKey"] = boost::any(*ossFileKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFileName") != m.end() && !m["AudioFileName"].empty()) {
      audioFileName = make_shared<string>(boost::any_cast<string>(m["AudioFileName"]));
    }
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("AuditResult") != m.end() && !m["AuditResult"].empty()) {
      auditResult = make_shared<string>(boost::any_cast<string>(m["AuditResult"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssFileKey") != m.end() && !m["OssFileKey"].empty()) {
      ossFileKey = make_shared<string>(boost::any_cast<string>(m["OssFileKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ListAudioFilesResponseBodyDataList() = default;
};
class ListAudioFilesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAudioFilesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAudioFilesResponseBodyData() {}

  explicit ListAudioFilesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListAudioFilesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAudioFilesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListAudioFilesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAudioFilesResponseBodyData() = default;
};
class ListAudioFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAudioFilesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListAudioFilesResponseBody() {}

  explicit ListAudioFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAudioFilesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAudioFilesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAudioFilesResponseBody() = default;
};
class ListAudioFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAudioFilesResponseBody> body{};

  ListAudioFilesResponse() {}

  explicit ListAudioFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAudioFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAudioFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAudioFilesResponse() = default;
};
class ListBlacklistCallTaggingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};

  ListBlacklistCallTaggingsRequest() {}

  explicit ListBlacklistCallTaggingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
  }


  virtual ~ListBlacklistCallTaggingsRequest() = default;
};
class ListBlacklistCallTaggingsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> blacklisted{};
  shared_ptr<string> jobId{};
  shared_ptr<string> number{};

  ListBlacklistCallTaggingsResponseBodyData() {}

  explicit ListBlacklistCallTaggingsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blacklisted) {
      res["Blacklisted"] = boost::any(*blacklisted);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Blacklisted") != m.end() && !m["Blacklisted"].empty()) {
      blacklisted = make_shared<bool>(boost::any_cast<bool>(m["Blacklisted"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~ListBlacklistCallTaggingsResponseBodyData() = default;
};
class ListBlacklistCallTaggingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListBlacklistCallTaggingsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListBlacklistCallTaggingsResponseBody() {}

  explicit ListBlacklistCallTaggingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListBlacklistCallTaggingsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBlacklistCallTaggingsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListBlacklistCallTaggingsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListBlacklistCallTaggingsResponseBody() = default;
};
class ListBlacklistCallTaggingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBlacklistCallTaggingsResponseBody> body{};

  ListBlacklistCallTaggingsResponse() {}

  explicit ListBlacklistCallTaggingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBlacklistCallTaggingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBlacklistCallTaggingsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBlacklistCallTaggingsResponse() = default;
};
class ListBriefSkillGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListBriefSkillGroupsRequest() {}

  explicit ListBriefSkillGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListBriefSkillGroupsRequest() = default;
};
class ListBriefSkillGroupsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> phoneNumberCount{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> userCount{};

  ListBriefSkillGroupsResponseBodyDataList() {}

  explicit ListBriefSkillGroupsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (phoneNumberCount) {
      res["PhoneNumberCount"] = boost::any(*phoneNumberCount);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("PhoneNumberCount") != m.end() && !m["PhoneNumberCount"].empty()) {
      phoneNumberCount = make_shared<long>(boost::any_cast<long>(m["PhoneNumberCount"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~ListBriefSkillGroupsResponseBodyDataList() = default;
};
class ListBriefSkillGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListBriefSkillGroupsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListBriefSkillGroupsResponseBodyData() {}

  explicit ListBriefSkillGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListBriefSkillGroupsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBriefSkillGroupsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListBriefSkillGroupsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBriefSkillGroupsResponseBodyData() = default;
};
class ListBriefSkillGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListBriefSkillGroupsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListBriefSkillGroupsResponseBody() {}

  explicit ListBriefSkillGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListBriefSkillGroupsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListBriefSkillGroupsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListBriefSkillGroupsResponseBody() = default;
};
class ListBriefSkillGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBriefSkillGroupsResponseBody> body{};

  ListBriefSkillGroupsResponse() {}

  explicit ListBriefSkillGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBriefSkillGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBriefSkillGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBriefSkillGroupsResponse() = default;
};
class ListCallDetailRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> contactDispositionList{};
  shared_ptr<string> contactId{};
  shared_ptr<string> contactType{};
  shared_ptr<string> contactTypeList{};
  shared_ptr<string> criteria{};
  shared_ptr<string> earlyMediaStateList{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderByField{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> satisfactionDescriptionList{};
  shared_ptr<string> satisfactionList{};
  shared_ptr<string> satisfactionSurveyChannel{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> sortOrder{};
  shared_ptr<long> startTime{};

  ListCallDetailRecordsRequest() {}

  explicit ListCallDetailRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (contactDispositionList) {
      res["ContactDispositionList"] = boost::any(*contactDispositionList);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (contactTypeList) {
      res["ContactTypeList"] = boost::any(*contactTypeList);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (earlyMediaStateList) {
      res["EarlyMediaStateList"] = boost::any(*earlyMediaStateList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderByField) {
      res["OrderByField"] = boost::any(*orderByField);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (satisfactionDescriptionList) {
      res["SatisfactionDescriptionList"] = boost::any(*satisfactionDescriptionList);
    }
    if (satisfactionList) {
      res["SatisfactionList"] = boost::any(*satisfactionList);
    }
    if (satisfactionSurveyChannel) {
      res["SatisfactionSurveyChannel"] = boost::any(*satisfactionSurveyChannel);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("ContactDispositionList") != m.end() && !m["ContactDispositionList"].empty()) {
      contactDispositionList = make_shared<string>(boost::any_cast<string>(m["ContactDispositionList"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("ContactTypeList") != m.end() && !m["ContactTypeList"].empty()) {
      contactTypeList = make_shared<string>(boost::any_cast<string>(m["ContactTypeList"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("EarlyMediaStateList") != m.end() && !m["EarlyMediaStateList"].empty()) {
      earlyMediaStateList = make_shared<string>(boost::any_cast<string>(m["EarlyMediaStateList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderByField") != m.end() && !m["OrderByField"].empty()) {
      orderByField = make_shared<string>(boost::any_cast<string>(m["OrderByField"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SatisfactionDescriptionList") != m.end() && !m["SatisfactionDescriptionList"].empty()) {
      satisfactionDescriptionList = make_shared<string>(boost::any_cast<string>(m["SatisfactionDescriptionList"]));
    }
    if (m.find("SatisfactionList") != m.end() && !m["SatisfactionList"].empty()) {
      satisfactionList = make_shared<string>(boost::any_cast<string>(m["SatisfactionList"]));
    }
    if (m.find("SatisfactionSurveyChannel") != m.end() && !m["SatisfactionSurveyChannel"].empty()) {
      satisfactionSurveyChannel = make_shared<string>(boost::any_cast<string>(m["SatisfactionSurveyChannel"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListCallDetailRecordsRequest() = default;
};
class ListCallDetailRecordsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> additionalBroker{};
  shared_ptr<string> agentIds{};
  shared_ptr<string> agentNames{};
  shared_ptr<string> broker{};
  shared_ptr<string> callDuration{};
  shared_ptr<string> callIds{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> calleeLocation{};
  shared_ptr<string> callerLocation{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> contactId{};
  shared_ptr<string> contactType{};
  shared_ptr<long> dialingTime{};
  shared_ptr<string> earlyMediaState{};
  shared_ptr<long> establishedTime{};
  shared_ptr<long> heldTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ivrTime{};
  shared_ptr<long> queueTime{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<bool> recordingReady{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> releaseTime{};
  shared_ptr<long> ringTime{};
  shared_ptr<string> satisfactionDescription{};
  shared_ptr<long> satisfactionIndex{};
  shared_ptr<string> satisfactionSurveyChannel{};
  shared_ptr<bool> satisfactionSurveyOffered{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<long> startTime{};
  shared_ptr<long> talkTime{};
  shared_ptr<long> waitTime{};

  ListCallDetailRecordsResponseBodyDataList() {}

  explicit ListCallDetailRecordsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalBroker) {
      res["AdditionalBroker"] = boost::any(*additionalBroker);
    }
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (agentNames) {
      res["AgentNames"] = boost::any(*agentNames);
    }
    if (broker) {
      res["Broker"] = boost::any(*broker);
    }
    if (callDuration) {
      res["CallDuration"] = boost::any(*callDuration);
    }
    if (callIds) {
      res["CallIds"] = boost::any(*callIds);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (calleeLocation) {
      res["CalleeLocation"] = boost::any(*calleeLocation);
    }
    if (callerLocation) {
      res["CallerLocation"] = boost::any(*callerLocation);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (dialingTime) {
      res["DialingTime"] = boost::any(*dialingTime);
    }
    if (earlyMediaState) {
      res["EarlyMediaState"] = boost::any(*earlyMediaState);
    }
    if (establishedTime) {
      res["EstablishedTime"] = boost::any(*establishedTime);
    }
    if (heldTime) {
      res["HeldTime"] = boost::any(*heldTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ivrTime) {
      res["IvrTime"] = boost::any(*ivrTime);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (recordingReady) {
      res["RecordingReady"] = boost::any(*recordingReady);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (ringTime) {
      res["RingTime"] = boost::any(*ringTime);
    }
    if (satisfactionDescription) {
      res["SatisfactionDescription"] = boost::any(*satisfactionDescription);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveyChannel) {
      res["SatisfactionSurveyChannel"] = boost::any(*satisfactionSurveyChannel);
    }
    if (satisfactionSurveyOffered) {
      res["SatisfactionSurveyOffered"] = boost::any(*satisfactionSurveyOffered);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (talkTime) {
      res["TalkTime"] = boost::any(*talkTime);
    }
    if (waitTime) {
      res["WaitTime"] = boost::any(*waitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalBroker") != m.end() && !m["AdditionalBroker"].empty()) {
      additionalBroker = make_shared<string>(boost::any_cast<string>(m["AdditionalBroker"]));
    }
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("AgentNames") != m.end() && !m["AgentNames"].empty()) {
      agentNames = make_shared<string>(boost::any_cast<string>(m["AgentNames"]));
    }
    if (m.find("Broker") != m.end() && !m["Broker"].empty()) {
      broker = make_shared<string>(boost::any_cast<string>(m["Broker"]));
    }
    if (m.find("CallDuration") != m.end() && !m["CallDuration"].empty()) {
      callDuration = make_shared<string>(boost::any_cast<string>(m["CallDuration"]));
    }
    if (m.find("CallIds") != m.end() && !m["CallIds"].empty()) {
      callIds = make_shared<string>(boost::any_cast<string>(m["CallIds"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CalleeLocation") != m.end() && !m["CalleeLocation"].empty()) {
      calleeLocation = make_shared<string>(boost::any_cast<string>(m["CalleeLocation"]));
    }
    if (m.find("CallerLocation") != m.end() && !m["CallerLocation"].empty()) {
      callerLocation = make_shared<string>(boost::any_cast<string>(m["CallerLocation"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("DialingTime") != m.end() && !m["DialingTime"].empty()) {
      dialingTime = make_shared<long>(boost::any_cast<long>(m["DialingTime"]));
    }
    if (m.find("EarlyMediaState") != m.end() && !m["EarlyMediaState"].empty()) {
      earlyMediaState = make_shared<string>(boost::any_cast<string>(m["EarlyMediaState"]));
    }
    if (m.find("EstablishedTime") != m.end() && !m["EstablishedTime"].empty()) {
      establishedTime = make_shared<long>(boost::any_cast<long>(m["EstablishedTime"]));
    }
    if (m.find("HeldTime") != m.end() && !m["HeldTime"].empty()) {
      heldTime = make_shared<long>(boost::any_cast<long>(m["HeldTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IvrTime") != m.end() && !m["IvrTime"].empty()) {
      ivrTime = make_shared<long>(boost::any_cast<long>(m["IvrTime"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<long>(boost::any_cast<long>(m["QueueTime"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("RecordingReady") != m.end() && !m["RecordingReady"].empty()) {
      recordingReady = make_shared<bool>(boost::any_cast<bool>(m["RecordingReady"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<long>(boost::any_cast<long>(m["ReleaseTime"]));
    }
    if (m.find("RingTime") != m.end() && !m["RingTime"].empty()) {
      ringTime = make_shared<long>(boost::any_cast<long>(m["RingTime"]));
    }
    if (m.find("SatisfactionDescription") != m.end() && !m["SatisfactionDescription"].empty()) {
      satisfactionDescription = make_shared<string>(boost::any_cast<string>(m["SatisfactionDescription"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<long>(boost::any_cast<long>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveyChannel") != m.end() && !m["SatisfactionSurveyChannel"].empty()) {
      satisfactionSurveyChannel = make_shared<string>(boost::any_cast<string>(m["SatisfactionSurveyChannel"]));
    }
    if (m.find("SatisfactionSurveyOffered") != m.end() && !m["SatisfactionSurveyOffered"].empty()) {
      satisfactionSurveyOffered = make_shared<bool>(boost::any_cast<bool>(m["SatisfactionSurveyOffered"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TalkTime") != m.end() && !m["TalkTime"].empty()) {
      talkTime = make_shared<long>(boost::any_cast<long>(m["TalkTime"]));
    }
    if (m.find("WaitTime") != m.end() && !m["WaitTime"].empty()) {
      waitTime = make_shared<long>(boost::any_cast<long>(m["WaitTime"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyDataList() = default;
};
class ListCallDetailRecordsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCallDetailRecordsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCallDetailRecordsResponseBodyData() {}

  explicit ListCallDetailRecordsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCallDetailRecordsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallDetailRecordsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCallDetailRecordsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyData() = default;
};
class ListCallDetailRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCallDetailRecordsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCallDetailRecordsResponseBody() {}

  explicit ListCallDetailRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCallDetailRecordsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCallDetailRecordsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBody() = default;
};
class ListCallDetailRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCallDetailRecordsResponseBody> body{};

  ListCallDetailRecordsResponse() {}

  explicit ListCallDetailRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCallDetailRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCallDetailRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCallDetailRecordsResponse() = default;
};
class ListCallDetailRecordsV2Request : public Darabonba::Model {
public:
  shared_ptr<string> accessChannelTypeList{};
  shared_ptr<string> agentId{};
  shared_ptr<string> broker{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> contactDispositionList{};
  shared_ptr<string> contactIdList{};
  shared_ptr<string> contactTypeList{};
  shared_ptr<string> earlyMediaStateList{};
  shared_ptr<long> endTime{};
  shared_ptr<string> firstAgentId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> number{};
  shared_ptr<string> orderByField{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> releaseInitiatorList{};
  shared_ptr<string> releaseReasonList{};
  shared_ptr<string> satisfactionDescriptionList{};
  shared_ptr<string> satisfactionRateList{};
  shared_ptr<string> satisfactionSurveyChannel{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> skillGroupIdList{};
  shared_ptr<string> sortOrder{};
  shared_ptr<long> startTime{};

  ListCallDetailRecordsV2Request() {}

  explicit ListCallDetailRecordsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelTypeList) {
      res["AccessChannelTypeList"] = boost::any(*accessChannelTypeList);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (broker) {
      res["Broker"] = boost::any(*broker);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (contactDispositionList) {
      res["ContactDispositionList"] = boost::any(*contactDispositionList);
    }
    if (contactIdList) {
      res["ContactIdList"] = boost::any(*contactIdList);
    }
    if (contactTypeList) {
      res["ContactTypeList"] = boost::any(*contactTypeList);
    }
    if (earlyMediaStateList) {
      res["EarlyMediaStateList"] = boost::any(*earlyMediaStateList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (firstAgentId) {
      res["FirstAgentId"] = boost::any(*firstAgentId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (orderByField) {
      res["OrderByField"] = boost::any(*orderByField);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (releaseInitiatorList) {
      res["ReleaseInitiatorList"] = boost::any(*releaseInitiatorList);
    }
    if (releaseReasonList) {
      res["ReleaseReasonList"] = boost::any(*releaseReasonList);
    }
    if (satisfactionDescriptionList) {
      res["SatisfactionDescriptionList"] = boost::any(*satisfactionDescriptionList);
    }
    if (satisfactionRateList) {
      res["SatisfactionRateList"] = boost::any(*satisfactionRateList);
    }
    if (satisfactionSurveyChannel) {
      res["SatisfactionSurveyChannel"] = boost::any(*satisfactionSurveyChannel);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelTypeList") != m.end() && !m["AccessChannelTypeList"].empty()) {
      accessChannelTypeList = make_shared<string>(boost::any_cast<string>(m["AccessChannelTypeList"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("Broker") != m.end() && !m["Broker"].empty()) {
      broker = make_shared<string>(boost::any_cast<string>(m["Broker"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ContactDispositionList") != m.end() && !m["ContactDispositionList"].empty()) {
      contactDispositionList = make_shared<string>(boost::any_cast<string>(m["ContactDispositionList"]));
    }
    if (m.find("ContactIdList") != m.end() && !m["ContactIdList"].empty()) {
      contactIdList = make_shared<string>(boost::any_cast<string>(m["ContactIdList"]));
    }
    if (m.find("ContactTypeList") != m.end() && !m["ContactTypeList"].empty()) {
      contactTypeList = make_shared<string>(boost::any_cast<string>(m["ContactTypeList"]));
    }
    if (m.find("EarlyMediaStateList") != m.end() && !m["EarlyMediaStateList"].empty()) {
      earlyMediaStateList = make_shared<string>(boost::any_cast<string>(m["EarlyMediaStateList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FirstAgentId") != m.end() && !m["FirstAgentId"].empty()) {
      firstAgentId = make_shared<string>(boost::any_cast<string>(m["FirstAgentId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("OrderByField") != m.end() && !m["OrderByField"].empty()) {
      orderByField = make_shared<string>(boost::any_cast<string>(m["OrderByField"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ReleaseInitiatorList") != m.end() && !m["ReleaseInitiatorList"].empty()) {
      releaseInitiatorList = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiatorList"]));
    }
    if (m.find("ReleaseReasonList") != m.end() && !m["ReleaseReasonList"].empty()) {
      releaseReasonList = make_shared<string>(boost::any_cast<string>(m["ReleaseReasonList"]));
    }
    if (m.find("SatisfactionDescriptionList") != m.end() && !m["SatisfactionDescriptionList"].empty()) {
      satisfactionDescriptionList = make_shared<string>(boost::any_cast<string>(m["SatisfactionDescriptionList"]));
    }
    if (m.find("SatisfactionRateList") != m.end() && !m["SatisfactionRateList"].empty()) {
      satisfactionRateList = make_shared<string>(boost::any_cast<string>(m["SatisfactionRateList"]));
    }
    if (m.find("SatisfactionSurveyChannel") != m.end() && !m["SatisfactionSurveyChannel"].empty()) {
      satisfactionSurveyChannel = make_shared<string>(boost::any_cast<string>(m["SatisfactionSurveyChannel"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListCallDetailRecordsV2Request() = default;
};
class ListCallDetailRecordsV2ResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> accessChannelName{};
  shared_ptr<string> accessChannelType{};
  shared_ptr<string> accessChannelUserId{};
  shared_ptr<string> accessChannelUserName{};
  shared_ptr<string> additionalBroker{};
  shared_ptr<string> agentIds{};
  shared_ptr<string> agentNames{};
  shared_ptr<string> broker{};
  shared_ptr<string> callDuration{};
  shared_ptr<string> callIds{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> calleeLocation{};
  shared_ptr<string> callerLocation{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> clientAppName{};
  shared_ptr<string> clientIpAddress{};
  shared_ptr<string> clientLocation{};
  shared_ptr<string> clientUserAgent{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> contactId{};
  shared_ptr<string> contactType{};
  shared_ptr<long> dialingTime{};
  shared_ptr<string> earlyMediaState{};
  shared_ptr<string> earlyMediaText{};
  shared_ptr<long> establishedTime{};
  shared_ptr<long> firstResponseTime{};
  shared_ptr<long> heldTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ivrTime{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> messagesSent{};
  shared_ptr<long> messagesSentByAgent{};
  shared_ptr<long> messagesSentByCustomer{};
  shared_ptr<string> offSiteAgentIds{};
  shared_ptr<string> offsiteAgentDestinationNumbers{};
  shared_ptr<string> offsiteAgentOriginatorNumbers{};
  shared_ptr<long> queueTime{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<bool> recordingReady{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> releaseTime{};
  shared_ptr<long> ringTime{};
  shared_ptr<string> satisfactionDescription{};
  shared_ptr<long> satisfactionIndex{};
  shared_ptr<string> satisfactionSurveyChannel{};
  shared_ptr<bool> satisfactionSurveyOffered{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<long> startTime{};
  shared_ptr<long> talkTime{};
  shared_ptr<long> transferCount{};
  shared_ptr<long> waitTime{};

  ListCallDetailRecordsV2ResponseBodyDataList() {}

  explicit ListCallDetailRecordsV2ResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelName) {
      res["AccessChannelName"] = boost::any(*accessChannelName);
    }
    if (accessChannelType) {
      res["AccessChannelType"] = boost::any(*accessChannelType);
    }
    if (accessChannelUserId) {
      res["AccessChannelUserId"] = boost::any(*accessChannelUserId);
    }
    if (accessChannelUserName) {
      res["AccessChannelUserName"] = boost::any(*accessChannelUserName);
    }
    if (additionalBroker) {
      res["AdditionalBroker"] = boost::any(*additionalBroker);
    }
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (agentNames) {
      res["AgentNames"] = boost::any(*agentNames);
    }
    if (broker) {
      res["Broker"] = boost::any(*broker);
    }
    if (callDuration) {
      res["CallDuration"] = boost::any(*callDuration);
    }
    if (callIds) {
      res["CallIds"] = boost::any(*callIds);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (calleeLocation) {
      res["CalleeLocation"] = boost::any(*calleeLocation);
    }
    if (callerLocation) {
      res["CallerLocation"] = boost::any(*callerLocation);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (clientAppName) {
      res["ClientAppName"] = boost::any(*clientAppName);
    }
    if (clientIpAddress) {
      res["ClientIpAddress"] = boost::any(*clientIpAddress);
    }
    if (clientLocation) {
      res["ClientLocation"] = boost::any(*clientLocation);
    }
    if (clientUserAgent) {
      res["ClientUserAgent"] = boost::any(*clientUserAgent);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (dialingTime) {
      res["DialingTime"] = boost::any(*dialingTime);
    }
    if (earlyMediaState) {
      res["EarlyMediaState"] = boost::any(*earlyMediaState);
    }
    if (earlyMediaText) {
      res["EarlyMediaText"] = boost::any(*earlyMediaText);
    }
    if (establishedTime) {
      res["EstablishedTime"] = boost::any(*establishedTime);
    }
    if (firstResponseTime) {
      res["FirstResponseTime"] = boost::any(*firstResponseTime);
    }
    if (heldTime) {
      res["HeldTime"] = boost::any(*heldTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ivrTime) {
      res["IvrTime"] = boost::any(*ivrTime);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (messagesSent) {
      res["MessagesSent"] = boost::any(*messagesSent);
    }
    if (messagesSentByAgent) {
      res["MessagesSentByAgent"] = boost::any(*messagesSentByAgent);
    }
    if (messagesSentByCustomer) {
      res["MessagesSentByCustomer"] = boost::any(*messagesSentByCustomer);
    }
    if (offSiteAgentIds) {
      res["OffSiteAgentIds"] = boost::any(*offSiteAgentIds);
    }
    if (offsiteAgentDestinationNumbers) {
      res["OffsiteAgentDestinationNumbers"] = boost::any(*offsiteAgentDestinationNumbers);
    }
    if (offsiteAgentOriginatorNumbers) {
      res["OffsiteAgentOriginatorNumbers"] = boost::any(*offsiteAgentOriginatorNumbers);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (recordingReady) {
      res["RecordingReady"] = boost::any(*recordingReady);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (ringTime) {
      res["RingTime"] = boost::any(*ringTime);
    }
    if (satisfactionDescription) {
      res["SatisfactionDescription"] = boost::any(*satisfactionDescription);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveyChannel) {
      res["SatisfactionSurveyChannel"] = boost::any(*satisfactionSurveyChannel);
    }
    if (satisfactionSurveyOffered) {
      res["SatisfactionSurveyOffered"] = boost::any(*satisfactionSurveyOffered);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (talkTime) {
      res["TalkTime"] = boost::any(*talkTime);
    }
    if (transferCount) {
      res["TransferCount"] = boost::any(*transferCount);
    }
    if (waitTime) {
      res["WaitTime"] = boost::any(*waitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelName") != m.end() && !m["AccessChannelName"].empty()) {
      accessChannelName = make_shared<string>(boost::any_cast<string>(m["AccessChannelName"]));
    }
    if (m.find("AccessChannelType") != m.end() && !m["AccessChannelType"].empty()) {
      accessChannelType = make_shared<string>(boost::any_cast<string>(m["AccessChannelType"]));
    }
    if (m.find("AccessChannelUserId") != m.end() && !m["AccessChannelUserId"].empty()) {
      accessChannelUserId = make_shared<string>(boost::any_cast<string>(m["AccessChannelUserId"]));
    }
    if (m.find("AccessChannelUserName") != m.end() && !m["AccessChannelUserName"].empty()) {
      accessChannelUserName = make_shared<string>(boost::any_cast<string>(m["AccessChannelUserName"]));
    }
    if (m.find("AdditionalBroker") != m.end() && !m["AdditionalBroker"].empty()) {
      additionalBroker = make_shared<string>(boost::any_cast<string>(m["AdditionalBroker"]));
    }
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("AgentNames") != m.end() && !m["AgentNames"].empty()) {
      agentNames = make_shared<string>(boost::any_cast<string>(m["AgentNames"]));
    }
    if (m.find("Broker") != m.end() && !m["Broker"].empty()) {
      broker = make_shared<string>(boost::any_cast<string>(m["Broker"]));
    }
    if (m.find("CallDuration") != m.end() && !m["CallDuration"].empty()) {
      callDuration = make_shared<string>(boost::any_cast<string>(m["CallDuration"]));
    }
    if (m.find("CallIds") != m.end() && !m["CallIds"].empty()) {
      callIds = make_shared<string>(boost::any_cast<string>(m["CallIds"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CalleeLocation") != m.end() && !m["CalleeLocation"].empty()) {
      calleeLocation = make_shared<string>(boost::any_cast<string>(m["CalleeLocation"]));
    }
    if (m.find("CallerLocation") != m.end() && !m["CallerLocation"].empty()) {
      callerLocation = make_shared<string>(boost::any_cast<string>(m["CallerLocation"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ClientAppName") != m.end() && !m["ClientAppName"].empty()) {
      clientAppName = make_shared<string>(boost::any_cast<string>(m["ClientAppName"]));
    }
    if (m.find("ClientIpAddress") != m.end() && !m["ClientIpAddress"].empty()) {
      clientIpAddress = make_shared<string>(boost::any_cast<string>(m["ClientIpAddress"]));
    }
    if (m.find("ClientLocation") != m.end() && !m["ClientLocation"].empty()) {
      clientLocation = make_shared<string>(boost::any_cast<string>(m["ClientLocation"]));
    }
    if (m.find("ClientUserAgent") != m.end() && !m["ClientUserAgent"].empty()) {
      clientUserAgent = make_shared<string>(boost::any_cast<string>(m["ClientUserAgent"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("DialingTime") != m.end() && !m["DialingTime"].empty()) {
      dialingTime = make_shared<long>(boost::any_cast<long>(m["DialingTime"]));
    }
    if (m.find("EarlyMediaState") != m.end() && !m["EarlyMediaState"].empty()) {
      earlyMediaState = make_shared<string>(boost::any_cast<string>(m["EarlyMediaState"]));
    }
    if (m.find("EarlyMediaText") != m.end() && !m["EarlyMediaText"].empty()) {
      earlyMediaText = make_shared<string>(boost::any_cast<string>(m["EarlyMediaText"]));
    }
    if (m.find("EstablishedTime") != m.end() && !m["EstablishedTime"].empty()) {
      establishedTime = make_shared<long>(boost::any_cast<long>(m["EstablishedTime"]));
    }
    if (m.find("FirstResponseTime") != m.end() && !m["FirstResponseTime"].empty()) {
      firstResponseTime = make_shared<long>(boost::any_cast<long>(m["FirstResponseTime"]));
    }
    if (m.find("HeldTime") != m.end() && !m["HeldTime"].empty()) {
      heldTime = make_shared<long>(boost::any_cast<long>(m["HeldTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IvrTime") != m.end() && !m["IvrTime"].empty()) {
      ivrTime = make_shared<long>(boost::any_cast<long>(m["IvrTime"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("MessagesSent") != m.end() && !m["MessagesSent"].empty()) {
      messagesSent = make_shared<long>(boost::any_cast<long>(m["MessagesSent"]));
    }
    if (m.find("MessagesSentByAgent") != m.end() && !m["MessagesSentByAgent"].empty()) {
      messagesSentByAgent = make_shared<long>(boost::any_cast<long>(m["MessagesSentByAgent"]));
    }
    if (m.find("MessagesSentByCustomer") != m.end() && !m["MessagesSentByCustomer"].empty()) {
      messagesSentByCustomer = make_shared<long>(boost::any_cast<long>(m["MessagesSentByCustomer"]));
    }
    if (m.find("OffSiteAgentIds") != m.end() && !m["OffSiteAgentIds"].empty()) {
      offSiteAgentIds = make_shared<string>(boost::any_cast<string>(m["OffSiteAgentIds"]));
    }
    if (m.find("OffsiteAgentDestinationNumbers") != m.end() && !m["OffsiteAgentDestinationNumbers"].empty()) {
      offsiteAgentDestinationNumbers = make_shared<string>(boost::any_cast<string>(m["OffsiteAgentDestinationNumbers"]));
    }
    if (m.find("OffsiteAgentOriginatorNumbers") != m.end() && !m["OffsiteAgentOriginatorNumbers"].empty()) {
      offsiteAgentOriginatorNumbers = make_shared<string>(boost::any_cast<string>(m["OffsiteAgentOriginatorNumbers"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<long>(boost::any_cast<long>(m["QueueTime"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("RecordingReady") != m.end() && !m["RecordingReady"].empty()) {
      recordingReady = make_shared<bool>(boost::any_cast<bool>(m["RecordingReady"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<long>(boost::any_cast<long>(m["ReleaseTime"]));
    }
    if (m.find("RingTime") != m.end() && !m["RingTime"].empty()) {
      ringTime = make_shared<long>(boost::any_cast<long>(m["RingTime"]));
    }
    if (m.find("SatisfactionDescription") != m.end() && !m["SatisfactionDescription"].empty()) {
      satisfactionDescription = make_shared<string>(boost::any_cast<string>(m["SatisfactionDescription"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<long>(boost::any_cast<long>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveyChannel") != m.end() && !m["SatisfactionSurveyChannel"].empty()) {
      satisfactionSurveyChannel = make_shared<string>(boost::any_cast<string>(m["SatisfactionSurveyChannel"]));
    }
    if (m.find("SatisfactionSurveyOffered") != m.end() && !m["SatisfactionSurveyOffered"].empty()) {
      satisfactionSurveyOffered = make_shared<bool>(boost::any_cast<bool>(m["SatisfactionSurveyOffered"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TalkTime") != m.end() && !m["TalkTime"].empty()) {
      talkTime = make_shared<long>(boost::any_cast<long>(m["TalkTime"]));
    }
    if (m.find("TransferCount") != m.end() && !m["TransferCount"].empty()) {
      transferCount = make_shared<long>(boost::any_cast<long>(m["TransferCount"]));
    }
    if (m.find("WaitTime") != m.end() && !m["WaitTime"].empty()) {
      waitTime = make_shared<long>(boost::any_cast<long>(m["WaitTime"]));
    }
  }


  virtual ~ListCallDetailRecordsV2ResponseBodyDataList() = default;
};
class ListCallDetailRecordsV2ResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCallDetailRecordsV2ResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCallDetailRecordsV2ResponseBodyData() {}

  explicit ListCallDetailRecordsV2ResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCallDetailRecordsV2ResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallDetailRecordsV2ResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCallDetailRecordsV2ResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCallDetailRecordsV2ResponseBodyData() = default;
};
class ListCallDetailRecordsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCallDetailRecordsV2ResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCallDetailRecordsV2ResponseBody() {}

  explicit ListCallDetailRecordsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCallDetailRecordsV2ResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCallDetailRecordsV2ResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCallDetailRecordsV2ResponseBody() = default;
};
class ListCallDetailRecordsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCallDetailRecordsV2ResponseBody> body{};

  ListCallDetailRecordsV2Response() {}

  explicit ListCallDetailRecordsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCallDetailRecordsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCallDetailRecordsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~ListCallDetailRecordsV2Response() = default;
};
class ListCallSummariesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactIdList{};
  shared_ptr<string> instanceId{};

  ListCallSummariesRequest() {}

  explicit ListCallSummariesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIdList) {
      res["ContactIdList"] = boost::any(*contactIdList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIdList") != m.end() && !m["ContactIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListCallSummariesRequest() = default;
};
class ListCallSummariesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactIdListShrink{};
  shared_ptr<string> instanceId{};

  ListCallSummariesShrinkRequest() {}

  explicit ListCallSummariesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIdListShrink) {
      res["ContactIdList"] = boost::any(*contactIdListShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIdList") != m.end() && !m["ContactIdList"].empty()) {
      contactIdListShrink = make_shared<string>(boost::any_cast<string>(m["ContactIdList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListCallSummariesShrinkRequest() = default;
};
class ListCallSummariesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> context{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> editor{};
  shared_ptr<string> ticketId{};

  ListCallSummariesResponseBodyData() {}

  explicit ListCallSummariesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (context) {
      res["Context"] = boost::any(*context);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (editor) {
      res["Editor"] = boost::any(*editor);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Context") != m.end() && !m["Context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["Context"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Editor") != m.end() && !m["Editor"].empty()) {
      editor = make_shared<string>(boost::any_cast<string>(m["Editor"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~ListCallSummariesResponseBodyData() = default;
};
class ListCallSummariesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListCallSummariesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListCallSummariesResponseBody() {}

  explicit ListCallSummariesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListCallSummariesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallSummariesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListCallSummariesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCallSummariesResponseBody() = default;
};
class ListCallSummariesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCallSummariesResponseBody> body{};

  ListCallSummariesResponse() {}

  explicit ListCallSummariesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCallSummariesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCallSummariesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCallSummariesResponse() = default;
};
class ListCallTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListCallTagsRequest() {}

  explicit ListCallTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListCallTagsRequest() = default;
};
class ListCallTagsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tagName{};

  ListCallTagsResponseBodyDataList() {}

  explicit ListCallTagsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~ListCallTagsResponseBodyDataList() = default;
};
class ListCallTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCallTagsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCallTagsResponseBodyData() {}

  explicit ListCallTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCallTagsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallTagsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCallTagsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCallTagsResponseBodyData() = default;
};
class ListCallTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCallTagsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCallTagsResponseBody() {}

  explicit ListCallTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCallTagsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCallTagsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCallTagsResponseBody() = default;
};
class ListCallTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCallTagsResponseBody> body{};

  ListCallTagsResponse() {}

  explicit ListCallTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCallTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCallTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCallTagsResponse() = default;
};
class ListCampaignTrendingReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};

  ListCampaignTrendingReportRequest() {}

  explicit ListCampaignTrendingReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListCampaignTrendingReportRequest() = default;
};
class ListCampaignTrendingReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> breakAgents{};
  shared_ptr<long> breakingAgents{};
  shared_ptr<long> concurrency{};
  shared_ptr<long> datetime{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> outboundScenarioBreakingAgents{};
  shared_ptr<long> outboundScenarioReadyAgents{};
  shared_ptr<long> outboundScenarioTalkingAgents{};
  shared_ptr<long> outboundScenarioWorkingAgents{};
  shared_ptr<long> readyAgents{};
  shared_ptr<long> statsTime{};
  shared_ptr<long> talkAgents{};
  shared_ptr<long> talkingAgents{};
  shared_ptr<long> workAgents{};
  shared_ptr<long> workingAgents{};

  ListCampaignTrendingReportResponseBodyData() {}

  explicit ListCampaignTrendingReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakAgents) {
      res["BreakAgents"] = boost::any(*breakAgents);
    }
    if (breakingAgents) {
      res["BreakingAgents"] = boost::any(*breakingAgents);
    }
    if (concurrency) {
      res["Concurrency"] = boost::any(*concurrency);
    }
    if (datetime) {
      res["Datetime"] = boost::any(*datetime);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (outboundScenarioBreakingAgents) {
      res["OutboundScenarioBreakingAgents"] = boost::any(*outboundScenarioBreakingAgents);
    }
    if (outboundScenarioReadyAgents) {
      res["OutboundScenarioReadyAgents"] = boost::any(*outboundScenarioReadyAgents);
    }
    if (outboundScenarioTalkingAgents) {
      res["OutboundScenarioTalkingAgents"] = boost::any(*outboundScenarioTalkingAgents);
    }
    if (outboundScenarioWorkingAgents) {
      res["OutboundScenarioWorkingAgents"] = boost::any(*outboundScenarioWorkingAgents);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    if (talkAgents) {
      res["TalkAgents"] = boost::any(*talkAgents);
    }
    if (talkingAgents) {
      res["TalkingAgents"] = boost::any(*talkingAgents);
    }
    if (workAgents) {
      res["WorkAgents"] = boost::any(*workAgents);
    }
    if (workingAgents) {
      res["WorkingAgents"] = boost::any(*workingAgents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakAgents") != m.end() && !m["BreakAgents"].empty()) {
      breakAgents = make_shared<long>(boost::any_cast<long>(m["BreakAgents"]));
    }
    if (m.find("BreakingAgents") != m.end() && !m["BreakingAgents"].empty()) {
      breakingAgents = make_shared<long>(boost::any_cast<long>(m["BreakingAgents"]));
    }
    if (m.find("Concurrency") != m.end() && !m["Concurrency"].empty()) {
      concurrency = make_shared<long>(boost::any_cast<long>(m["Concurrency"]));
    }
    if (m.find("Datetime") != m.end() && !m["Datetime"].empty()) {
      datetime = make_shared<long>(boost::any_cast<long>(m["Datetime"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("OutboundScenarioBreakingAgents") != m.end() && !m["OutboundScenarioBreakingAgents"].empty()) {
      outboundScenarioBreakingAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioBreakingAgents"]));
    }
    if (m.find("OutboundScenarioReadyAgents") != m.end() && !m["OutboundScenarioReadyAgents"].empty()) {
      outboundScenarioReadyAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioReadyAgents"]));
    }
    if (m.find("OutboundScenarioTalkingAgents") != m.end() && !m["OutboundScenarioTalkingAgents"].empty()) {
      outboundScenarioTalkingAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioTalkingAgents"]));
    }
    if (m.find("OutboundScenarioWorkingAgents") != m.end() && !m["OutboundScenarioWorkingAgents"].empty()) {
      outboundScenarioWorkingAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioWorkingAgents"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
    if (m.find("TalkAgents") != m.end() && !m["TalkAgents"].empty()) {
      talkAgents = make_shared<long>(boost::any_cast<long>(m["TalkAgents"]));
    }
    if (m.find("TalkingAgents") != m.end() && !m["TalkingAgents"].empty()) {
      talkingAgents = make_shared<long>(boost::any_cast<long>(m["TalkingAgents"]));
    }
    if (m.find("WorkAgents") != m.end() && !m["WorkAgents"].empty()) {
      workAgents = make_shared<long>(boost::any_cast<long>(m["WorkAgents"]));
    }
    if (m.find("WorkingAgents") != m.end() && !m["WorkingAgents"].empty()) {
      workingAgents = make_shared<long>(boost::any_cast<long>(m["WorkingAgents"]));
    }
  }


  virtual ~ListCampaignTrendingReportResponseBodyData() = default;
};
class ListCampaignTrendingReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListCampaignTrendingReportResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCampaignTrendingReportResponseBody() {}

  explicit ListCampaignTrendingReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListCampaignTrendingReportResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCampaignTrendingReportResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListCampaignTrendingReportResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCampaignTrendingReportResponseBody() = default;
};
class ListCampaignTrendingReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCampaignTrendingReportResponseBody> body{};

  ListCampaignTrendingReportResponse() {}

  explicit ListCampaignTrendingReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCampaignTrendingReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCampaignTrendingReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListCampaignTrendingReportResponse() = default;
};
class ListCampaignsRequest : public Darabonba::Model {
public:
  shared_ptr<string> actualStartTimeFrom{};
  shared_ptr<string> actualStartTimeTo{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> planedStartTimeFrom{};
  shared_ptr<string> planedStartTimeTo{};
  shared_ptr<string> queueId{};
  shared_ptr<string> state{};

  ListCampaignsRequest() {}

  explicit ListCampaignsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualStartTimeFrom) {
      res["ActualStartTimeFrom"] = boost::any(*actualStartTimeFrom);
    }
    if (actualStartTimeTo) {
      res["ActualStartTimeTo"] = boost::any(*actualStartTimeTo);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (planedStartTimeFrom) {
      res["PlanedStartTimeFrom"] = boost::any(*planedStartTimeFrom);
    }
    if (planedStartTimeTo) {
      res["PlanedStartTimeTo"] = boost::any(*planedStartTimeTo);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualStartTimeFrom") != m.end() && !m["ActualStartTimeFrom"].empty()) {
      actualStartTimeFrom = make_shared<string>(boost::any_cast<string>(m["ActualStartTimeFrom"]));
    }
    if (m.find("ActualStartTimeTo") != m.end() && !m["ActualStartTimeTo"].empty()) {
      actualStartTimeTo = make_shared<string>(boost::any_cast<string>(m["ActualStartTimeTo"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlanedStartTimeFrom") != m.end() && !m["PlanedStartTimeFrom"].empty()) {
      planedStartTimeFrom = make_shared<string>(boost::any_cast<string>(m["PlanedStartTimeFrom"]));
    }
    if (m.find("PlanedStartTimeTo") != m.end() && !m["PlanedStartTimeTo"].empty()) {
      planedStartTimeTo = make_shared<string>(boost::any_cast<string>(m["PlanedStartTimeTo"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListCampaignsRequest() = default;
};
class ListCampaignsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> actualEndTime{};
  shared_ptr<long> actualStartTime{};
  shared_ptr<string> campaignId{};
  shared_ptr<long> casesAborted{};
  shared_ptr<long> casesConnected{};
  shared_ptr<long> casesUncompleted{};
  shared_ptr<double> completionRate{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<long> maxAttemptCount{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> name{};
  shared_ptr<long> planedEndTime{};
  shared_ptr<long> planedStartTime{};
  shared_ptr<string> queueId{};
  shared_ptr<string> queueName{};
  shared_ptr<bool> simulation{};
  shared_ptr<string> state{};
  shared_ptr<string> strategyParameters{};
  shared_ptr<string> strategyType{};
  shared_ptr<long> totalCases{};

  ListCampaignsResponseBodyDataList() {}

  explicit ListCampaignsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualEndTime) {
      res["ActualEndTime"] = boost::any(*actualEndTime);
    }
    if (actualStartTime) {
      res["ActualStartTime"] = boost::any(*actualStartTime);
    }
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (casesAborted) {
      res["CasesAborted"] = boost::any(*casesAborted);
    }
    if (casesConnected) {
      res["CasesConnected"] = boost::any(*casesConnected);
    }
    if (casesUncompleted) {
      res["CasesUncompleted"] = boost::any(*casesUncompleted);
    }
    if (completionRate) {
      res["CompletionRate"] = boost::any(*completionRate);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (maxAttemptCount) {
      res["MaxAttemptCount"] = boost::any(*maxAttemptCount);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (planedEndTime) {
      res["PlanedEndTime"] = boost::any(*planedEndTime);
    }
    if (planedStartTime) {
      res["PlanedStartTime"] = boost::any(*planedStartTime);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (simulation) {
      res["Simulation"] = boost::any(*simulation);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (strategyParameters) {
      res["StrategyParameters"] = boost::any(*strategyParameters);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (totalCases) {
      res["TotalCases"] = boost::any(*totalCases);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualEndTime") != m.end() && !m["ActualEndTime"].empty()) {
      actualEndTime = make_shared<long>(boost::any_cast<long>(m["ActualEndTime"]));
    }
    if (m.find("ActualStartTime") != m.end() && !m["ActualStartTime"].empty()) {
      actualStartTime = make_shared<long>(boost::any_cast<long>(m["ActualStartTime"]));
    }
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CasesAborted") != m.end() && !m["CasesAborted"].empty()) {
      casesAborted = make_shared<long>(boost::any_cast<long>(m["CasesAborted"]));
    }
    if (m.find("CasesConnected") != m.end() && !m["CasesConnected"].empty()) {
      casesConnected = make_shared<long>(boost::any_cast<long>(m["CasesConnected"]));
    }
    if (m.find("CasesUncompleted") != m.end() && !m["CasesUncompleted"].empty()) {
      casesUncompleted = make_shared<long>(boost::any_cast<long>(m["CasesUncompleted"]));
    }
    if (m.find("CompletionRate") != m.end() && !m["CompletionRate"].empty()) {
      completionRate = make_shared<double>(boost::any_cast<double>(m["CompletionRate"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("MaxAttemptCount") != m.end() && !m["MaxAttemptCount"].empty()) {
      maxAttemptCount = make_shared<long>(boost::any_cast<long>(m["MaxAttemptCount"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PlanedEndTime") != m.end() && !m["PlanedEndTime"].empty()) {
      planedEndTime = make_shared<long>(boost::any_cast<long>(m["PlanedEndTime"]));
    }
    if (m.find("PlanedStartTime") != m.end() && !m["PlanedStartTime"].empty()) {
      planedStartTime = make_shared<long>(boost::any_cast<long>(m["PlanedStartTime"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Simulation") != m.end() && !m["Simulation"].empty()) {
      simulation = make_shared<bool>(boost::any_cast<bool>(m["Simulation"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StrategyParameters") != m.end() && !m["StrategyParameters"].empty()) {
      strategyParameters = make_shared<string>(boost::any_cast<string>(m["StrategyParameters"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<string>(boost::any_cast<string>(m["StrategyType"]));
    }
    if (m.find("TotalCases") != m.end() && !m["TotalCases"].empty()) {
      totalCases = make_shared<long>(boost::any_cast<long>(m["TotalCases"]));
    }
  }


  virtual ~ListCampaignsResponseBodyDataList() = default;
};
class ListCampaignsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCampaignsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCampaignsResponseBodyData() {}

  explicit ListCampaignsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCampaignsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCampaignsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCampaignsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCampaignsResponseBodyData() = default;
};
class ListCampaignsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCampaignsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListCampaignsResponseBody() {}

  explicit ListCampaignsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCampaignsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCampaignsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCampaignsResponseBody() = default;
};
class ListCampaignsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCampaignsResponseBody> body{};

  ListCampaignsResponse() {}

  explicit ListCampaignsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCampaignsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCampaignsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCampaignsResponse() = default;
};
class ListCasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> state{};

  ListCasesRequest() {}

  explicit ListCasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListCasesRequest() = default;
};
class ListCasesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> abandonPhase{};
  shared_ptr<string> abandonType{};
  shared_ptr<long> attemptCount{};
  shared_ptr<string> caseId{};
  shared_ptr<string> customVariables{};
  shared_ptr<string> failureReason{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> state{};

  ListCasesResponseBodyDataList() {}

  explicit ListCasesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonPhase) {
      res["AbandonPhase"] = boost::any(*abandonPhase);
    }
    if (abandonType) {
      res["AbandonType"] = boost::any(*abandonType);
    }
    if (attemptCount) {
      res["AttemptCount"] = boost::any(*attemptCount);
    }
    if (caseId) {
      res["CaseId"] = boost::any(*caseId);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonPhase") != m.end() && !m["AbandonPhase"].empty()) {
      abandonPhase = make_shared<string>(boost::any_cast<string>(m["AbandonPhase"]));
    }
    if (m.find("AbandonType") != m.end() && !m["AbandonType"].empty()) {
      abandonType = make_shared<string>(boost::any_cast<string>(m["AbandonType"]));
    }
    if (m.find("AttemptCount") != m.end() && !m["AttemptCount"].empty()) {
      attemptCount = make_shared<long>(boost::any_cast<long>(m["AttemptCount"]));
    }
    if (m.find("CaseId") != m.end() && !m["CaseId"].empty()) {
      caseId = make_shared<string>(boost::any_cast<string>(m["CaseId"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListCasesResponseBodyDataList() = default;
};
class ListCasesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCasesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCasesResponseBodyData() {}

  explicit ListCasesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCasesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCasesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCasesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCasesResponseBodyData() = default;
};
class ListCasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCasesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCasesResponseBody() {}

  explicit ListCasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCasesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCasesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCasesResponseBody() = default;
};
class ListCasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCasesResponseBody> body{};

  ListCasesResponse() {}

  explicit ListCasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCasesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCasesResponse() = default;
};
class ListCategoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> type{};

  ListCategoriesRequest() {}

  explicit ListCategoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCategoriesRequest() = default;
};
class ListCategoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListCategoriesResponseBody() {}

  explicit ListCategoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCategoriesResponseBody() = default;
};
class ListCategoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCategoriesResponseBody> body{};

  ListCategoriesResponse() {}

  explicit ListCategoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCategoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCategoriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCategoriesResponse() = default;
};
class ListCommonTicketFieldsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListCommonTicketFieldsRequest() {}

  explicit ListCommonTicketFieldsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListCommonTicketFieldsRequest() = default;
};
class ListCommonTicketFieldsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<map<string, DataPropertiesValue>> properties{};
  shared_ptr<string> updatedTime{};

  ListCommonTicketFieldsResponseBodyData() {}

  explicit ListCommonTicketFieldsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (properties) {
      map<string, boost::any> temp1;
      for(auto item1:*properties){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["Properties"] = boost::any(temp1);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        map<string, DataPropertiesValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["Properties"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            DataPropertiesValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        properties = make_shared<map<string, DataPropertiesValue>>(expect1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
  }


  virtual ~ListCommonTicketFieldsResponseBodyData() = default;
};
class ListCommonTicketFieldsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCommonTicketFieldsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListCommonTicketFieldsResponseBody() {}

  explicit ListCommonTicketFieldsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCommonTicketFieldsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCommonTicketFieldsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCommonTicketFieldsResponseBody() = default;
};
class ListCommonTicketFieldsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCommonTicketFieldsResponseBody> body{};

  ListCommonTicketFieldsResponse() {}

  explicit ListCommonTicketFieldsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCommonTicketFieldsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCommonTicketFieldsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCommonTicketFieldsResponse() = default;
};
class ListConfigItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};

  ListConfigItemsRequest() {}

  explicit ListConfigItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~ListConfigItemsRequest() = default;
};
class ListConfigItemsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};
  shared_ptr<string> value{};

  ListConfigItemsResponseBodyData() {}

  explicit ListConfigItemsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListConfigItemsResponseBodyData() = default;
};
class ListConfigItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListConfigItemsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListConfigItemsResponseBody() {}

  explicit ListConfigItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListConfigItemsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigItemsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListConfigItemsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListConfigItemsResponseBody() = default;
};
class ListConfigItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigItemsResponseBody> body{};

  ListConfigItemsResponse() {}

  explicit ListConfigItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigItemsResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigItemsResponse() = default;
};
class ListContactFlowsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderByField{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> type{};

  ListContactFlowsRequest() {}

  explicit ListContactFlowsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderByField) {
      res["OrderByField"] = boost::any(*orderByField);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderByField") != m.end() && !m["OrderByField"].empty()) {
      orderByField = make_shared<string>(boost::any_cast<string>(m["OrderByField"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListContactFlowsRequest() = default;
};
class ListContactFlowsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> definition{};
  shared_ptr<string> description{};
  shared_ptr<string> draftId{};
  shared_ptr<string> editor{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> numberList{};
  shared_ptr<bool> published{};
  shared_ptr<string> type{};
  shared_ptr<string> updatedTime{};

  ListContactFlowsResponseBodyDataList() {}

  explicit ListContactFlowsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (draftId) {
      res["DraftId"] = boost::any(*draftId);
    }
    if (editor) {
      res["Editor"] = boost::any(*editor);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (published) {
      res["Published"] = boost::any(*published);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DraftId") != m.end() && !m["DraftId"].empty()) {
      draftId = make_shared<string>(boost::any_cast<string>(m["DraftId"]));
    }
    if (m.find("Editor") != m.end() && !m["Editor"].empty()) {
      editor = make_shared<string>(boost::any_cast<string>(m["Editor"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NumberList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NumberList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      numberList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Published") != m.end() && !m["Published"].empty()) {
      published = make_shared<bool>(boost::any_cast<bool>(m["Published"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
  }


  virtual ~ListContactFlowsResponseBodyDataList() = default;
};
class ListContactFlowsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListContactFlowsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListContactFlowsResponseBodyData() {}

  explicit ListContactFlowsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListContactFlowsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListContactFlowsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListContactFlowsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListContactFlowsResponseBodyData() = default;
};
class ListContactFlowsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListContactFlowsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListContactFlowsResponseBody() {}

  explicit ListContactFlowsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListContactFlowsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListContactFlowsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListContactFlowsResponseBody() = default;
};
class ListContactFlowsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListContactFlowsResponseBody> body{};

  ListContactFlowsResponse() {}

  explicit ListContactFlowsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListContactFlowsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListContactFlowsResponseBody>(model1);
      }
    }
  }


  virtual ~ListContactFlowsResponse() = default;
};
class ListCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> callTagNameList{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListCustomCallTaggingRequest() {}

  explicit ListCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callTagNameList) {
      res["CallTagNameList"] = boost::any(*callTagNameList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallTagNameList") != m.end() && !m["CallTagNameList"].empty()) {
      callTagNameList = make_shared<string>(boost::any_cast<string>(m["CallTagNameList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListCustomCallTaggingRequest() = default;
};
class ListCustomCallTaggingResponseBodyDataListCallTagList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tagName{};

  ListCustomCallTaggingResponseBodyDataListCallTagList() {}

  explicit ListCustomCallTaggingResponseBodyDataListCallTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~ListCustomCallTaggingResponseBodyDataListCallTagList() = default;
};
class ListCustomCallTaggingResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomCallTaggingResponseBodyDataListCallTagList>> callTagList{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> updateTime{};

  ListCustomCallTaggingResponseBodyDataList() {}

  explicit ListCustomCallTaggingResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callTagList) {
      vector<boost::any> temp1;
      for(auto item1:*callTagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallTagList"] = boost::any(temp1);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallTagList") != m.end() && !m["CallTagList"].empty()) {
      if (typeid(vector<boost::any>) == m["CallTagList"].type()) {
        vector<ListCustomCallTaggingResponseBodyDataListCallTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallTagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomCallTaggingResponseBodyDataListCallTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callTagList = make_shared<vector<ListCustomCallTaggingResponseBodyDataListCallTagList>>(expect1);
      }
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListCustomCallTaggingResponseBodyDataList() = default;
};
class ListCustomCallTaggingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomCallTaggingResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCustomCallTaggingResponseBodyData() {}

  explicit ListCustomCallTaggingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCustomCallTaggingResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomCallTaggingResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCustomCallTaggingResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomCallTaggingResponseBodyData() = default;
};
class ListCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCustomCallTaggingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCustomCallTaggingResponseBody() {}

  explicit ListCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCustomCallTaggingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCustomCallTaggingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCustomCallTaggingResponseBody() = default;
};
class ListCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomCallTaggingResponseBody> body{};

  ListCustomCallTaggingResponse() {}

  explicit ListCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomCallTaggingResponse() = default;
};
class ListDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  ListDevicesRequest() {}

  explicit ListDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListDevicesRequest() = default;
};
class ListDevicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> callId{};
  shared_ptr<string> contact{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceType{};
  shared_ptr<long> expires{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  ListDevicesResponseBodyData() {}

  explicit ListDevicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (contact) {
      res["Contact"] = boost::any(*contact);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (expires) {
      res["Expires"] = boost::any(*expires);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      contact = make_shared<string>(boost::any_cast<string>(m["Contact"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("Expires") != m.end() && !m["Expires"].empty()) {
      expires = make_shared<long>(boost::any_cast<long>(m["Expires"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListDevicesResponseBodyData() = default;
};
class ListDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListDevicesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListDevicesResponseBody() {}

  explicit ListDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDevicesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDevicesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDevicesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDevicesResponseBody() = default;
};
class ListDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDevicesResponseBody> body{};

  ListDevicesResponse() {}

  explicit ListDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDevicesResponse() = default;
};
class ListDoNotCallNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scope{};
  shared_ptr<string> searchPattern{};

  ListDoNotCallNumbersRequest() {}

  explicit ListDoNotCallNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListDoNotCallNumbersRequest() = default;
};
class ListDoNotCallNumbersResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> number{};
  shared_ptr<string> remark{};
  shared_ptr<string> scope{};

  ListDoNotCallNumbersResponseBodyDataList() {}

  explicit ListDoNotCallNumbersResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~ListDoNotCallNumbersResponseBodyDataList() = default;
};
class ListDoNotCallNumbersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoNotCallNumbersResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDoNotCallNumbersResponseBodyData() {}

  explicit ListDoNotCallNumbersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListDoNotCallNumbersResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoNotCallNumbersResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListDoNotCallNumbersResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoNotCallNumbersResponseBodyData() = default;
};
class ListDoNotCallNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListDoNotCallNumbersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListDoNotCallNumbersResponseBody() {}

  explicit ListDoNotCallNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDoNotCallNumbersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDoNotCallNumbersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDoNotCallNumbersResponseBody() = default;
};
class ListDoNotCallNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoNotCallNumbersResponseBody> body{};

  ListDoNotCallNumbersResponse() {}

  explicit ListDoNotCallNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoNotCallNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoNotCallNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoNotCallNumbersResponse() = default;
};
class ListDocumentsRequestSorts : public Darabonba::Model {
public:
  shared_ptr<string> order{};
  shared_ptr<string> propertyName{};

  ListDocumentsRequestSorts() {}

  explicit ListDocumentsRequestSorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (propertyName) {
      res["PropertyName"] = boost::any(*propertyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PropertyName") != m.end() && !m["PropertyName"].empty()) {
      propertyName = make_shared<string>(boost::any_cast<string>(m["PropertyName"]));
    }
  }


  virtual ~ListDocumentsRequestSorts() = default;
};
class ListDocumentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};
  shared_ptr<string> searchPattern{};
  shared_ptr<vector<ListDocumentsRequestSorts>> sorts{};

  ListDocumentsRequest() {}

  explicit ListDocumentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (sorts) {
      vector<boost::any> temp1;
      for(auto item1:*sorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sorts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("Sorts") != m.end() && !m["Sorts"].empty()) {
      if (typeid(vector<boost::any>) == m["Sorts"].type()) {
        vector<ListDocumentsRequestSorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDocumentsRequestSorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sorts = make_shared<vector<ListDocumentsRequestSorts>>(expect1);
      }
    }
  }


  virtual ~ListDocumentsRequest() = default;
};
class ListDocumentsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> sortsShrink{};

  ListDocumentsShrinkRequest() {}

  explicit ListDocumentsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (sortsShrink) {
      res["Sorts"] = boost::any(*sortsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("Sorts") != m.end() && !m["Sorts"].empty()) {
      sortsShrink = make_shared<string>(boost::any_cast<string>(m["Sorts"]));
    }
  }


  virtual ~ListDocumentsShrinkRequest() = default;
};
class ListDocumentsResponseBodyDataSchema : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<map<string, DataSchemaPropertiesValue>> properties{};
  shared_ptr<string> updatedTime{};

  ListDocumentsResponseBodyDataSchema() {}

  explicit ListDocumentsResponseBodyDataSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (properties) {
      map<string, boost::any> temp1;
      for(auto item1:*properties){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["Properties"] = boost::any(temp1);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        map<string, DataSchemaPropertiesValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["Properties"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            DataSchemaPropertiesValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        properties = make_shared<map<string, DataSchemaPropertiesValue>>(expect1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
  }


  virtual ~ListDocumentsResponseBodyDataSchema() = default;
};
class ListDocumentsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> documents{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<ListDocumentsResponseBodyDataSchema> schema{};
  shared_ptr<long> totalCount{};

  ListDocumentsResponseBodyData() {}

  explicit ListDocumentsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (documents) {
      res["Documents"] = boost::any(*documents);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (schema) {
      res["Schema"] = schema ? boost::any(schema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Documents") != m.end() && !m["Documents"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Documents"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Documents"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      documents = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schema"].type()) {
        ListDocumentsResponseBodyDataSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schema"]));
        schema = make_shared<ListDocumentsResponseBodyDataSchema>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDocumentsResponseBodyData() = default;
};
class ListDocumentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListDocumentsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListDocumentsResponseBody() {}

  explicit ListDocumentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDocumentsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDocumentsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDocumentsResponseBody() = default;
};
class ListDocumentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDocumentsResponseBody> body{};

  ListDocumentsResponse() {}

  explicit ListDocumentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDocumentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDocumentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDocumentsResponse() = default;
};
class ListFlashSmsApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> providerId{};

  ListFlashSmsApplicationsRequest() {}

  explicit ListFlashSmsApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
  }


  virtual ~ListFlashSmsApplicationsRequest() = default;
};
class ListFlashSmsApplicationsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> providerId{};
  shared_ptr<string> value{};

  ListFlashSmsApplicationsResponseBodyDataList() {}

  explicit ListFlashSmsApplicationsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListFlashSmsApplicationsResponseBodyDataList() = default;
};
class ListFlashSmsApplicationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlashSmsApplicationsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListFlashSmsApplicationsResponseBodyData() {}

  explicit ListFlashSmsApplicationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListFlashSmsApplicationsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlashSmsApplicationsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListFlashSmsApplicationsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFlashSmsApplicationsResponseBodyData() = default;
};
class ListFlashSmsApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListFlashSmsApplicationsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListFlashSmsApplicationsResponseBody() {}

  explicit ListFlashSmsApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFlashSmsApplicationsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFlashSmsApplicationsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFlashSmsApplicationsResponseBody() = default;
};
class ListFlashSmsApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlashSmsApplicationsResponseBody> body{};

  ListFlashSmsApplicationsResponse() {}

  explicit ListFlashSmsApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlashSmsApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlashSmsApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlashSmsApplicationsResponse() = default;
};
class ListFlashSmsTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> providerId{};

  ListFlashSmsTemplatesRequest() {}

  explicit ListFlashSmsTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
  }


  virtual ~ListFlashSmsTemplatesRequest() = default;
};
class ListFlashSmsTemplatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  ListFlashSmsTemplatesResponseBodyData() {}

  explicit ListFlashSmsTemplatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ListFlashSmsTemplatesResponseBodyData() = default;
};
class ListFlashSmsTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListFlashSmsTemplatesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListFlashSmsTemplatesResponseBody() {}

  explicit ListFlashSmsTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListFlashSmsTemplatesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlashSmsTemplatesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListFlashSmsTemplatesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFlashSmsTemplatesResponseBody() = default;
};
class ListFlashSmsTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlashSmsTemplatesResponseBody> body{};

  ListFlashSmsTemplatesResponse() {}

  explicit ListFlashSmsTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlashSmsTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlashSmsTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlashSmsTemplatesResponse() = default;
};
class ListGroupChatMessagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortOrder{};

  ListGroupChatMessagesRequest() {}

  explicit ListGroupChatMessagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
  }


  virtual ~ListGroupChatMessagesRequest() = default;
};
class ListGroupChatMessagesResponseBodyDataMessages : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> recalled{};
  shared_ptr<string> senderAvatarUrl{};
  shared_ptr<string> senderId{};
  shared_ptr<string> senderName{};
  shared_ptr<string> senderType{};
  shared_ptr<long> timestamp{};

  ListGroupChatMessagesResponseBodyDataMessages() {}

  explicit ListGroupChatMessagesResponseBodyDataMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (recalled) {
      res["Recalled"] = boost::any(*recalled);
    }
    if (senderAvatarUrl) {
      res["SenderAvatarUrl"] = boost::any(*senderAvatarUrl);
    }
    if (senderId) {
      res["SenderId"] = boost::any(*senderId);
    }
    if (senderName) {
      res["SenderName"] = boost::any(*senderName);
    }
    if (senderType) {
      res["SenderType"] = boost::any(*senderType);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Recalled") != m.end() && !m["Recalled"].empty()) {
      recalled = make_shared<bool>(boost::any_cast<bool>(m["Recalled"]));
    }
    if (m.find("SenderAvatarUrl") != m.end() && !m["SenderAvatarUrl"].empty()) {
      senderAvatarUrl = make_shared<string>(boost::any_cast<string>(m["SenderAvatarUrl"]));
    }
    if (m.find("SenderId") != m.end() && !m["SenderId"].empty()) {
      senderId = make_shared<string>(boost::any_cast<string>(m["SenderId"]));
    }
    if (m.find("SenderName") != m.end() && !m["SenderName"].empty()) {
      senderName = make_shared<string>(boost::any_cast<string>(m["SenderName"]));
    }
    if (m.find("SenderType") != m.end() && !m["SenderType"].empty()) {
      senderType = make_shared<string>(boost::any_cast<string>(m["SenderType"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~ListGroupChatMessagesResponseBodyDataMessages() = default;
};
class ListGroupChatMessagesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListGroupChatMessagesResponseBodyDataMessages>> messages{};
  shared_ptr<string> nextPageToken{};

  ListGroupChatMessagesResponseBodyData() {}

  explicit ListGroupChatMessagesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Messages"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Messages") != m.end() && !m["Messages"].empty()) {
      if (typeid(vector<boost::any>) == m["Messages"].type()) {
        vector<ListGroupChatMessagesResponseBodyDataMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGroupChatMessagesResponseBodyDataMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<ListGroupChatMessagesResponseBodyDataMessages>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
  }


  virtual ~ListGroupChatMessagesResponseBodyData() = default;
};
class ListGroupChatMessagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListGroupChatMessagesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListGroupChatMessagesResponseBody() {}

  explicit ListGroupChatMessagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListGroupChatMessagesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListGroupChatMessagesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListGroupChatMessagesResponseBody() = default;
};
class ListGroupChatMessagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGroupChatMessagesResponseBody> body{};

  ListGroupChatMessagesResponse() {}

  explicit ListGroupChatMessagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGroupChatMessagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGroupChatMessagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListGroupChatMessagesResponse() = default;
};
class ListHistoricalAgentReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentIdList{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> stopTime{};

  ListHistoricalAgentReportRequest() {}

  explicit ListHistoricalAgentReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIdList) {
      res["AgentIdList"] = boost::any(*agentIdList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIdList") != m.end() && !m["AgentIdList"].empty()) {
      agentIdList = make_shared<string>(boost::any_cast<string>(m["AgentIdList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
  }


  virtual ~ListHistoricalAgentReportRequest() = default;
};
class ListHistoricalAgentReportResponseBodyDataListBack2Back : public Darabonba::Model {
public:
  shared_ptr<string> agentHandleRate{};
  shared_ptr<string> answerRate{};
  shared_ptr<string> averageCustomerRingTime{};
  shared_ptr<string> averageRingTime{};
  shared_ptr<string> averageTalkTime{};
  shared_ptr<string> callsAgentHandled{};
  shared_ptr<string> callsAnswered{};
  shared_ptr<string> callsCustomerAnswered{};
  shared_ptr<string> callsDialed{};
  shared_ptr<string> customerAnswerRate{};
  shared_ptr<string> maxCustomerRingTime{};
  shared_ptr<string> maxRingTime{};
  shared_ptr<string> maxTalkTime{};
  shared_ptr<string> totalCustomerRingTime{};
  shared_ptr<string> totalRingTime{};
  shared_ptr<string> totalTalkTime{};

  ListHistoricalAgentReportResponseBodyDataListBack2Back() {}

  explicit ListHistoricalAgentReportResponseBodyDataListBack2Back(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentHandleRate) {
      res["AgentHandleRate"] = boost::any(*agentHandleRate);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageCustomerRingTime) {
      res["AverageCustomerRingTime"] = boost::any(*averageCustomerRingTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (callsAgentHandled) {
      res["CallsAgentHandled"] = boost::any(*callsAgentHandled);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsCustomerAnswered) {
      res["CallsCustomerAnswered"] = boost::any(*callsCustomerAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (customerAnswerRate) {
      res["CustomerAnswerRate"] = boost::any(*customerAnswerRate);
    }
    if (maxCustomerRingTime) {
      res["MaxCustomerRingTime"] = boost::any(*maxCustomerRingTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCustomerRingTime) {
      res["TotalCustomerRingTime"] = boost::any(*totalCustomerRingTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentHandleRate") != m.end() && !m["AgentHandleRate"].empty()) {
      agentHandleRate = make_shared<string>(boost::any_cast<string>(m["AgentHandleRate"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<string>(boost::any_cast<string>(m["AnswerRate"]));
    }
    if (m.find("AverageCustomerRingTime") != m.end() && !m["AverageCustomerRingTime"].empty()) {
      averageCustomerRingTime = make_shared<string>(boost::any_cast<string>(m["AverageCustomerRingTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<string>(boost::any_cast<string>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<string>(boost::any_cast<string>(m["AverageTalkTime"]));
    }
    if (m.find("CallsAgentHandled") != m.end() && !m["CallsAgentHandled"].empty()) {
      callsAgentHandled = make_shared<string>(boost::any_cast<string>(m["CallsAgentHandled"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<string>(boost::any_cast<string>(m["CallsAnswered"]));
    }
    if (m.find("CallsCustomerAnswered") != m.end() && !m["CallsCustomerAnswered"].empty()) {
      callsCustomerAnswered = make_shared<string>(boost::any_cast<string>(m["CallsCustomerAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<string>(boost::any_cast<string>(m["CallsDialed"]));
    }
    if (m.find("CustomerAnswerRate") != m.end() && !m["CustomerAnswerRate"].empty()) {
      customerAnswerRate = make_shared<string>(boost::any_cast<string>(m["CustomerAnswerRate"]));
    }
    if (m.find("MaxCustomerRingTime") != m.end() && !m["MaxCustomerRingTime"].empty()) {
      maxCustomerRingTime = make_shared<string>(boost::any_cast<string>(m["MaxCustomerRingTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<string>(boost::any_cast<string>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<string>(boost::any_cast<string>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCustomerRingTime") != m.end() && !m["TotalCustomerRingTime"].empty()) {
      totalCustomerRingTime = make_shared<string>(boost::any_cast<string>(m["TotalCustomerRingTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<string>(boost::any_cast<string>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<string>(boost::any_cast<string>(m["TotalTalkTime"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataListBack2Back() = default;
};
class ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails : public Darabonba::Model {
public:
  shared_ptr<string> accessChannelType{};
  shared_ptr<long> callsOffered{};

  ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails() {}

  explicit ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelType) {
      res["AccessChannelType"] = boost::any(*accessChannelType);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelType") != m.end() && !m["AccessChannelType"].empty()) {
      accessChannelType = make_shared<string>(boost::any_cast<string>(m["AccessChannelType"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails() = default;
};
class ListHistoricalAgentReportResponseBodyDataListInbound : public Darabonba::Model {
public:
  shared_ptr<vector<ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails>> accessChannelTypeDetails{};
  shared_ptr<double> averageFirstResponseTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageResponseTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsRinged{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel15{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalMessagesSent{};
  shared_ptr<long> totalMessagesSentByAgent{};
  shared_ptr<string> totalMessagesSentByCustomer{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalAgentReportResponseBodyDataListInbound() {}

  explicit ListHistoricalAgentReportResponseBodyDataListInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelTypeDetails) {
      vector<boost::any> temp1;
      for(auto item1:*accessChannelTypeDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessChannelTypeDetails"] = boost::any(temp1);
    }
    if (averageFirstResponseTime) {
      res["AverageFirstResponseTime"] = boost::any(*averageFirstResponseTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageResponseTime) {
      res["AverageResponseTime"] = boost::any(*averageResponseTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel15) {
      res["ServiceLevel15"] = boost::any(*serviceLevel15);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalMessagesSent) {
      res["TotalMessagesSent"] = boost::any(*totalMessagesSent);
    }
    if (totalMessagesSentByAgent) {
      res["TotalMessagesSentByAgent"] = boost::any(*totalMessagesSentByAgent);
    }
    if (totalMessagesSentByCustomer) {
      res["TotalMessagesSentByCustomer"] = boost::any(*totalMessagesSentByCustomer);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelTypeDetails") != m.end() && !m["AccessChannelTypeDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessChannelTypeDetails"].type()) {
        vector<ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessChannelTypeDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessChannelTypeDetails = make_shared<vector<ListHistoricalAgentReportResponseBodyDataListInboundAccessChannelTypeDetails>>(expect1);
      }
    }
    if (m.find("AverageFirstResponseTime") != m.end() && !m["AverageFirstResponseTime"].empty()) {
      averageFirstResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageFirstResponseTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageResponseTime") != m.end() && !m["AverageResponseTime"].empty()) {
      averageResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageResponseTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel15") != m.end() && !m["ServiceLevel15"].empty()) {
      serviceLevel15 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel15"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalMessagesSent") != m.end() && !m["TotalMessagesSent"].empty()) {
      totalMessagesSent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSent"]));
    }
    if (m.find("TotalMessagesSentByAgent") != m.end() && !m["TotalMessagesSentByAgent"].empty()) {
      totalMessagesSentByAgent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByAgent"]));
    }
    if (m.find("TotalMessagesSentByCustomer") != m.end() && !m["TotalMessagesSentByCustomer"].empty()) {
      totalMessagesSentByCustomer = make_shared<string>(boost::any_cast<string>(m["TotalMessagesSentByCustomer"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataListInbound() = default;
};
class ListHistoricalAgentReportResponseBodyDataListInternal : public Darabonba::Model {
public:
  shared_ptr<double> averageTalkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsTalked{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalTalkTime{};

  ListHistoricalAgentReportResponseBodyDataListInternal() {}

  explicit ListHistoricalAgentReportResponseBodyDataListInternal(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsTalked) {
      res["CallsTalked"] = boost::any(*callsTalked);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsTalked") != m.end() && !m["CallsTalked"].empty()) {
      callsTalked = make_shared<long>(boost::any_cast<long>(m["CallsTalked"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataListInternal() = default;
};
class ListHistoricalAgentReportResponseBodyDataListOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalAgentReportResponseBodyDataListOutbound() {}

  explicit ListHistoricalAgentReportResponseBodyDataListOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataListOutbound() = default;
};
class ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<long> count{};
  shared_ptr<long> duration{};

  ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList() {}

  explicit ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList() = default;
};
class ListHistoricalAgentReportResponseBodyDataListOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<vector<ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList>> breakCodeDetailList{};
  shared_ptr<long> firstCheckInTime{};
  shared_ptr<long> lastCheckOutTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalOffSiteLoggedInTime{};
  shared_ptr<long> totalOffSiteOnlineTime{};
  shared_ptr<long> totalOfficePhoneLoggedInTime{};
  shared_ptr<long> totalOfficePhoneOnlineTime{};
  shared_ptr<long> totalOnSiteLoggedInTime{};
  shared_ptr<long> totalOnSiteOnlineTime{};
  shared_ptr<long> totalOutboundScenarioLoggedInTime{};
  shared_ptr<long> totalOutboundScenarioReadyTime{};
  shared_ptr<long> totalOutboundScenarioTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalAgentReportResponseBodyDataListOverall() {}

  explicit ListHistoricalAgentReportResponseBodyDataListOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (breakCodeDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*breakCodeDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BreakCodeDetailList"] = boost::any(temp1);
    }
    if (firstCheckInTime) {
      res["FirstCheckInTime"] = boost::any(*firstCheckInTime);
    }
    if (lastCheckOutTime) {
      res["LastCheckOutTime"] = boost::any(*lastCheckOutTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalOffSiteLoggedInTime) {
      res["TotalOffSiteLoggedInTime"] = boost::any(*totalOffSiteLoggedInTime);
    }
    if (totalOffSiteOnlineTime) {
      res["TotalOffSiteOnlineTime"] = boost::any(*totalOffSiteOnlineTime);
    }
    if (totalOfficePhoneLoggedInTime) {
      res["TotalOfficePhoneLoggedInTime"] = boost::any(*totalOfficePhoneLoggedInTime);
    }
    if (totalOfficePhoneOnlineTime) {
      res["TotalOfficePhoneOnlineTime"] = boost::any(*totalOfficePhoneOnlineTime);
    }
    if (totalOnSiteLoggedInTime) {
      res["TotalOnSiteLoggedInTime"] = boost::any(*totalOnSiteLoggedInTime);
    }
    if (totalOnSiteOnlineTime) {
      res["TotalOnSiteOnlineTime"] = boost::any(*totalOnSiteOnlineTime);
    }
    if (totalOutboundScenarioLoggedInTime) {
      res["TotalOutboundScenarioLoggedInTime"] = boost::any(*totalOutboundScenarioLoggedInTime);
    }
    if (totalOutboundScenarioReadyTime) {
      res["TotalOutboundScenarioReadyTime"] = boost::any(*totalOutboundScenarioReadyTime);
    }
    if (totalOutboundScenarioTime) {
      res["TotalOutboundScenarioTime"] = boost::any(*totalOutboundScenarioTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("BreakCodeDetailList") != m.end() && !m["BreakCodeDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["BreakCodeDetailList"].type()) {
        vector<ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BreakCodeDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        breakCodeDetailList = make_shared<vector<ListHistoricalAgentReportResponseBodyDataListOverallBreakCodeDetailList>>(expect1);
      }
    }
    if (m.find("FirstCheckInTime") != m.end() && !m["FirstCheckInTime"].empty()) {
      firstCheckInTime = make_shared<long>(boost::any_cast<long>(m["FirstCheckInTime"]));
    }
    if (m.find("LastCheckOutTime") != m.end() && !m["LastCheckOutTime"].empty()) {
      lastCheckOutTime = make_shared<long>(boost::any_cast<long>(m["LastCheckOutTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalOffSiteLoggedInTime") != m.end() && !m["TotalOffSiteLoggedInTime"].empty()) {
      totalOffSiteLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOffSiteLoggedInTime"]));
    }
    if (m.find("TotalOffSiteOnlineTime") != m.end() && !m["TotalOffSiteOnlineTime"].empty()) {
      totalOffSiteOnlineTime = make_shared<long>(boost::any_cast<long>(m["TotalOffSiteOnlineTime"]));
    }
    if (m.find("TotalOfficePhoneLoggedInTime") != m.end() && !m["TotalOfficePhoneLoggedInTime"].empty()) {
      totalOfficePhoneLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOfficePhoneLoggedInTime"]));
    }
    if (m.find("TotalOfficePhoneOnlineTime") != m.end() && !m["TotalOfficePhoneOnlineTime"].empty()) {
      totalOfficePhoneOnlineTime = make_shared<long>(boost::any_cast<long>(m["TotalOfficePhoneOnlineTime"]));
    }
    if (m.find("TotalOnSiteLoggedInTime") != m.end() && !m["TotalOnSiteLoggedInTime"].empty()) {
      totalOnSiteLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOnSiteLoggedInTime"]));
    }
    if (m.find("TotalOnSiteOnlineTime") != m.end() && !m["TotalOnSiteOnlineTime"].empty()) {
      totalOnSiteOnlineTime = make_shared<long>(boost::any_cast<long>(m["TotalOnSiteOnlineTime"]));
    }
    if (m.find("TotalOutboundScenarioLoggedInTime") != m.end() && !m["TotalOutboundScenarioLoggedInTime"].empty()) {
      totalOutboundScenarioLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioLoggedInTime"]));
    }
    if (m.find("TotalOutboundScenarioReadyTime") != m.end() && !m["TotalOutboundScenarioReadyTime"].empty()) {
      totalOutboundScenarioReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioReadyTime"]));
    }
    if (m.find("TotalOutboundScenarioTime") != m.end() && !m["TotalOutboundScenarioTime"].empty()) {
      totalOutboundScenarioTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataListOverall() = default;
};
class ListHistoricalAgentReportResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<ListHistoricalAgentReportResponseBodyDataListBack2Back> back2Back{};
  shared_ptr<string> displayId{};
  shared_ptr<ListHistoricalAgentReportResponseBodyDataListInbound> inbound{};
  shared_ptr<ListHistoricalAgentReportResponseBodyDataListInternal> internal{};
  shared_ptr<ListHistoricalAgentReportResponseBodyDataListOutbound> outbound{};
  shared_ptr<ListHistoricalAgentReportResponseBodyDataListOverall> overall{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};

  ListHistoricalAgentReportResponseBodyDataList() {}

  explicit ListHistoricalAgentReportResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (back2Back) {
      res["Back2Back"] = back2Back ? boost::any(back2Back->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internal) {
      res["Internal"] = internal ? boost::any(internal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("Back2Back") != m.end() && !m["Back2Back"].empty()) {
      if (typeid(map<string, boost::any>) == m["Back2Back"].type()) {
        ListHistoricalAgentReportResponseBodyDataListBack2Back model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Back2Back"]));
        back2Back = make_shared<ListHistoricalAgentReportResponseBodyDataListBack2Back>(model1);
      }
    }
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListHistoricalAgentReportResponseBodyDataListInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListHistoricalAgentReportResponseBodyDataListInbound>(model1);
      }
    }
    if (m.find("Internal") != m.end() && !m["Internal"].empty()) {
      if (typeid(map<string, boost::any>) == m["Internal"].type()) {
        ListHistoricalAgentReportResponseBodyDataListInternal model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Internal"]));
        internal = make_shared<ListHistoricalAgentReportResponseBodyDataListInternal>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListHistoricalAgentReportResponseBodyDataListOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListHistoricalAgentReportResponseBodyDataListOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListHistoricalAgentReportResponseBodyDataListOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListHistoricalAgentReportResponseBodyDataListOverall>(model1);
      }
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataList() = default;
};
class ListHistoricalAgentReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListHistoricalAgentReportResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListHistoricalAgentReportResponseBodyData() {}

  explicit ListHistoricalAgentReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListHistoricalAgentReportResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoricalAgentReportResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListHistoricalAgentReportResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyData() = default;
};
class ListHistoricalAgentReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListHistoricalAgentReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListHistoricalAgentReportResponseBody() {}

  explicit ListHistoricalAgentReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListHistoricalAgentReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListHistoricalAgentReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBody() = default;
};
class ListHistoricalAgentReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHistoricalAgentReportResponseBody> body{};

  ListHistoricalAgentReportResponse() {}

  explicit ListHistoricalAgentReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHistoricalAgentReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHistoricalAgentReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListHistoricalAgentReportResponse() = default;
};
class ListHistoricalAgentSkillGroupReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentIdList{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupIdList{};
  shared_ptr<long> startTime{};

  ListHistoricalAgentSkillGroupReportRequest() {}

  explicit ListHistoricalAgentSkillGroupReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIdList) {
      res["AgentIdList"] = boost::any(*agentIdList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIdList") != m.end() && !m["AgentIdList"].empty()) {
      agentIdList = make_shared<string>(boost::any_cast<string>(m["AgentIdList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportRequest() = default;
};
class ListHistoricalAgentSkillGroupReportResponseBodyDataListBack2Back : public Darabonba::Model {
public:
  shared_ptr<double> agentAnswerRate{};
  shared_ptr<double> agentHandleRate{};
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageCustomerRingTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> callsAgentHandled{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsCustomerAnswered{};
  shared_ptr<long> callsCustomerHandled{};
  shared_ptr<long> callsDialed{};
  shared_ptr<double> customerAnswerRate{};
  shared_ptr<double> customerHandleRate{};
  shared_ptr<long> maxCustomerRingTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalCustomerRingTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};

  ListHistoricalAgentSkillGroupReportResponseBodyDataListBack2Back() {}

  explicit ListHistoricalAgentSkillGroupReportResponseBodyDataListBack2Back(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentAnswerRate) {
      res["AgentAnswerRate"] = boost::any(*agentAnswerRate);
    }
    if (agentHandleRate) {
      res["AgentHandleRate"] = boost::any(*agentHandleRate);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageCustomerRingTime) {
      res["AverageCustomerRingTime"] = boost::any(*averageCustomerRingTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (callsAgentHandled) {
      res["CallsAgentHandled"] = boost::any(*callsAgentHandled);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsCustomerAnswered) {
      res["CallsCustomerAnswered"] = boost::any(*callsCustomerAnswered);
    }
    if (callsCustomerHandled) {
      res["CallsCustomerHandled"] = boost::any(*callsCustomerHandled);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (customerAnswerRate) {
      res["CustomerAnswerRate"] = boost::any(*customerAnswerRate);
    }
    if (customerHandleRate) {
      res["CustomerHandleRate"] = boost::any(*customerHandleRate);
    }
    if (maxCustomerRingTime) {
      res["MaxCustomerRingTime"] = boost::any(*maxCustomerRingTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCustomerRingTime) {
      res["TotalCustomerRingTime"] = boost::any(*totalCustomerRingTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentAnswerRate") != m.end() && !m["AgentAnswerRate"].empty()) {
      agentAnswerRate = make_shared<double>(boost::any_cast<double>(m["AgentAnswerRate"]));
    }
    if (m.find("AgentHandleRate") != m.end() && !m["AgentHandleRate"].empty()) {
      agentHandleRate = make_shared<double>(boost::any_cast<double>(m["AgentHandleRate"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageCustomerRingTime") != m.end() && !m["AverageCustomerRingTime"].empty()) {
      averageCustomerRingTime = make_shared<double>(boost::any_cast<double>(m["AverageCustomerRingTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("CallsAgentHandled") != m.end() && !m["CallsAgentHandled"].empty()) {
      callsAgentHandled = make_shared<long>(boost::any_cast<long>(m["CallsAgentHandled"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsCustomerAnswered") != m.end() && !m["CallsCustomerAnswered"].empty()) {
      callsCustomerAnswered = make_shared<long>(boost::any_cast<long>(m["CallsCustomerAnswered"]));
    }
    if (m.find("CallsCustomerHandled") != m.end() && !m["CallsCustomerHandled"].empty()) {
      callsCustomerHandled = make_shared<long>(boost::any_cast<long>(m["CallsCustomerHandled"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CustomerAnswerRate") != m.end() && !m["CustomerAnswerRate"].empty()) {
      customerAnswerRate = make_shared<double>(boost::any_cast<double>(m["CustomerAnswerRate"]));
    }
    if (m.find("CustomerHandleRate") != m.end() && !m["CustomerHandleRate"].empty()) {
      customerHandleRate = make_shared<double>(boost::any_cast<double>(m["CustomerHandleRate"]));
    }
    if (m.find("MaxCustomerRingTime") != m.end() && !m["MaxCustomerRingTime"].empty()) {
      maxCustomerRingTime = make_shared<long>(boost::any_cast<long>(m["MaxCustomerRingTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCustomerRingTime") != m.end() && !m["TotalCustomerRingTime"].empty()) {
      totalCustomerRingTime = make_shared<long>(boost::any_cast<long>(m["TotalCustomerRingTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportResponseBodyDataListBack2Back() = default;
};
class ListHistoricalAgentSkillGroupReportResponseBodyDataListInbound : public Darabonba::Model {
public:
  shared_ptr<double> averageFirstResponseTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageResponseTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsRinged{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalMessagesSent{};
  shared_ptr<long> totalMessagesSentByAgent{};
  shared_ptr<long> totalMessagesSentByCustomer{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalAgentSkillGroupReportResponseBodyDataListInbound() {}

  explicit ListHistoricalAgentSkillGroupReportResponseBodyDataListInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageFirstResponseTime) {
      res["AverageFirstResponseTime"] = boost::any(*averageFirstResponseTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageResponseTime) {
      res["AverageResponseTime"] = boost::any(*averageResponseTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalMessagesSent) {
      res["TotalMessagesSent"] = boost::any(*totalMessagesSent);
    }
    if (totalMessagesSentByAgent) {
      res["TotalMessagesSentByAgent"] = boost::any(*totalMessagesSentByAgent);
    }
    if (totalMessagesSentByCustomer) {
      res["TotalMessagesSentByCustomer"] = boost::any(*totalMessagesSentByCustomer);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageFirstResponseTime") != m.end() && !m["AverageFirstResponseTime"].empty()) {
      averageFirstResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageFirstResponseTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageResponseTime") != m.end() && !m["AverageResponseTime"].empty()) {
      averageResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageResponseTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalMessagesSent") != m.end() && !m["TotalMessagesSent"].empty()) {
      totalMessagesSent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSent"]));
    }
    if (m.find("TotalMessagesSentByAgent") != m.end() && !m["TotalMessagesSentByAgent"].empty()) {
      totalMessagesSentByAgent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByAgent"]));
    }
    if (m.find("TotalMessagesSentByCustomer") != m.end() && !m["TotalMessagesSentByCustomer"].empty()) {
      totalMessagesSentByCustomer = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByCustomer"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportResponseBodyDataListInbound() = default;
};
class ListHistoricalAgentSkillGroupReportResponseBodyDataListInternal : public Darabonba::Model {
public:
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsTalk{};
  shared_ptr<long> callsTalked{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalTalkTime{};

  ListHistoricalAgentSkillGroupReportResponseBodyDataListInternal() {}

  explicit ListHistoricalAgentSkillGroupReportResponseBodyDataListInternal(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsTalk) {
      res["CallsTalk"] = boost::any(*callsTalk);
    }
    if (callsTalked) {
      res["CallsTalked"] = boost::any(*callsTalked);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsTalk") != m.end() && !m["CallsTalk"].empty()) {
      callsTalk = make_shared<long>(boost::any_cast<long>(m["CallsTalk"]));
    }
    if (m.find("CallsTalked") != m.end() && !m["CallsTalked"].empty()) {
      callsTalked = make_shared<long>(boost::any_cast<long>(m["CallsTalked"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportResponseBodyDataListInternal() = default;
};
class ListHistoricalAgentSkillGroupReportResponseBodyDataListOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalAgentSkillGroupReportResponseBodyDataListOutbound() {}

  explicit ListHistoricalAgentSkillGroupReportResponseBodyDataListOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportResponseBodyDataListOutbound() = default;
};
class ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<long> count{};
  shared_ptr<long> duration{};

  ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList() {}

  explicit ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList() = default;
};
class ListHistoricalAgentSkillGroupReportResponseBodyDataListOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<vector<ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList>> breakCodeDetailList{};
  shared_ptr<long> firstCheckInTime{};
  shared_ptr<long> lastCheckOutTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalOffSiteLggedInTime{};
  shared_ptr<long> totalOfficePhoneLoggedInTime{};
  shared_ptr<string> totalOnSiteLoggedInTime{};
  shared_ptr<long> totalOutboundScenarioLoggedInTime{};
  shared_ptr<long> totalOutboundScenarioReadyTime{};
  shared_ptr<long> totalOutboundScenarioTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalAgentSkillGroupReportResponseBodyDataListOverall() {}

  explicit ListHistoricalAgentSkillGroupReportResponseBodyDataListOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (breakCodeDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*breakCodeDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BreakCodeDetailList"] = boost::any(temp1);
    }
    if (firstCheckInTime) {
      res["FirstCheckInTime"] = boost::any(*firstCheckInTime);
    }
    if (lastCheckOutTime) {
      res["LastCheckOutTime"] = boost::any(*lastCheckOutTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalOffSiteLggedInTime) {
      res["TotalOffSiteLggedInTime"] = boost::any(*totalOffSiteLggedInTime);
    }
    if (totalOfficePhoneLoggedInTime) {
      res["TotalOfficePhoneLoggedInTime"] = boost::any(*totalOfficePhoneLoggedInTime);
    }
    if (totalOnSiteLoggedInTime) {
      res["TotalOnSiteLoggedInTime"] = boost::any(*totalOnSiteLoggedInTime);
    }
    if (totalOutboundScenarioLoggedInTime) {
      res["TotalOutboundScenarioLoggedInTime"] = boost::any(*totalOutboundScenarioLoggedInTime);
    }
    if (totalOutboundScenarioReadyTime) {
      res["TotalOutboundScenarioReadyTime"] = boost::any(*totalOutboundScenarioReadyTime);
    }
    if (totalOutboundScenarioTime) {
      res["TotalOutboundScenarioTime"] = boost::any(*totalOutboundScenarioTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("BreakCodeDetailList") != m.end() && !m["BreakCodeDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["BreakCodeDetailList"].type()) {
        vector<ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BreakCodeDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        breakCodeDetailList = make_shared<vector<ListHistoricalAgentSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList>>(expect1);
      }
    }
    if (m.find("FirstCheckInTime") != m.end() && !m["FirstCheckInTime"].empty()) {
      firstCheckInTime = make_shared<long>(boost::any_cast<long>(m["FirstCheckInTime"]));
    }
    if (m.find("LastCheckOutTime") != m.end() && !m["LastCheckOutTime"].empty()) {
      lastCheckOutTime = make_shared<long>(boost::any_cast<long>(m["LastCheckOutTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalOffSiteLggedInTime") != m.end() && !m["TotalOffSiteLggedInTime"].empty()) {
      totalOffSiteLggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOffSiteLggedInTime"]));
    }
    if (m.find("TotalOfficePhoneLoggedInTime") != m.end() && !m["TotalOfficePhoneLoggedInTime"].empty()) {
      totalOfficePhoneLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOfficePhoneLoggedInTime"]));
    }
    if (m.find("TotalOnSiteLoggedInTime") != m.end() && !m["TotalOnSiteLoggedInTime"].empty()) {
      totalOnSiteLoggedInTime = make_shared<string>(boost::any_cast<string>(m["TotalOnSiteLoggedInTime"]));
    }
    if (m.find("TotalOutboundScenarioLoggedInTime") != m.end() && !m["TotalOutboundScenarioLoggedInTime"].empty()) {
      totalOutboundScenarioLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioLoggedInTime"]));
    }
    if (m.find("TotalOutboundScenarioReadyTime") != m.end() && !m["TotalOutboundScenarioReadyTime"].empty()) {
      totalOutboundScenarioReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioReadyTime"]));
    }
    if (m.find("TotalOutboundScenarioTime") != m.end() && !m["TotalOutboundScenarioTime"].empty()) {
      totalOutboundScenarioTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportResponseBodyDataListOverall() = default;
};
class ListHistoricalAgentSkillGroupReportResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<ListHistoricalAgentSkillGroupReportResponseBodyDataListBack2Back> back2Back{};
  shared_ptr<string> displayId{};
  shared_ptr<ListHistoricalAgentSkillGroupReportResponseBodyDataListInbound> inbound{};
  shared_ptr<ListHistoricalAgentSkillGroupReportResponseBodyDataListInternal> internal{};
  shared_ptr<ListHistoricalAgentSkillGroupReportResponseBodyDataListOutbound> outbound{};
  shared_ptr<ListHistoricalAgentSkillGroupReportResponseBodyDataListOverall> overall{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};

  ListHistoricalAgentSkillGroupReportResponseBodyDataList() {}

  explicit ListHistoricalAgentSkillGroupReportResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (back2Back) {
      res["Back2Back"] = back2Back ? boost::any(back2Back->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internal) {
      res["Internal"] = internal ? boost::any(internal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("Back2Back") != m.end() && !m["Back2Back"].empty()) {
      if (typeid(map<string, boost::any>) == m["Back2Back"].type()) {
        ListHistoricalAgentSkillGroupReportResponseBodyDataListBack2Back model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Back2Back"]));
        back2Back = make_shared<ListHistoricalAgentSkillGroupReportResponseBodyDataListBack2Back>(model1);
      }
    }
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListHistoricalAgentSkillGroupReportResponseBodyDataListInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListHistoricalAgentSkillGroupReportResponseBodyDataListInbound>(model1);
      }
    }
    if (m.find("Internal") != m.end() && !m["Internal"].empty()) {
      if (typeid(map<string, boost::any>) == m["Internal"].type()) {
        ListHistoricalAgentSkillGroupReportResponseBodyDataListInternal model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Internal"]));
        internal = make_shared<ListHistoricalAgentSkillGroupReportResponseBodyDataListInternal>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListHistoricalAgentSkillGroupReportResponseBodyDataListOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListHistoricalAgentSkillGroupReportResponseBodyDataListOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListHistoricalAgentSkillGroupReportResponseBodyDataListOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListHistoricalAgentSkillGroupReportResponseBodyDataListOverall>(model1);
      }
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportResponseBodyDataList() = default;
};
class ListHistoricalAgentSkillGroupReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListHistoricalAgentSkillGroupReportResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListHistoricalAgentSkillGroupReportResponseBodyData() {}

  explicit ListHistoricalAgentSkillGroupReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListHistoricalAgentSkillGroupReportResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoricalAgentSkillGroupReportResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListHistoricalAgentSkillGroupReportResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportResponseBodyData() = default;
};
class ListHistoricalAgentSkillGroupReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListHistoricalAgentSkillGroupReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListHistoricalAgentSkillGroupReportResponseBody() {}

  explicit ListHistoricalAgentSkillGroupReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListHistoricalAgentSkillGroupReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListHistoricalAgentSkillGroupReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportResponseBody() = default;
};
class ListHistoricalAgentSkillGroupReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHistoricalAgentSkillGroupReportResponseBody> body{};

  ListHistoricalAgentSkillGroupReportResponse() {}

  explicit ListHistoricalAgentSkillGroupReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHistoricalAgentSkillGroupReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHistoricalAgentSkillGroupReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListHistoricalAgentSkillGroupReportResponse() = default;
};
class ListHistoricalSkillGroupReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupIdList{};
  shared_ptr<long> startTime{};

  ListHistoricalSkillGroupReportRequest() {}

  explicit ListHistoricalSkillGroupReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportRequest() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataListBack2Back : public Darabonba::Model {
public:
  shared_ptr<double> agentHandleRate{};
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageCustomerRingTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsCustomerAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<double> customerAnswerRate{};
  shared_ptr<long> maxCustomerRingTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalCustomerRingTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};

  ListHistoricalSkillGroupReportResponseBodyDataListBack2Back() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataListBack2Back(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentHandleRate) {
      res["AgentHandleRate"] = boost::any(*agentHandleRate);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageCustomerRingTime) {
      res["AverageCustomerRingTime"] = boost::any(*averageCustomerRingTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsCustomerAnswered) {
      res["CallsCustomerAnswered"] = boost::any(*callsCustomerAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (customerAnswerRate) {
      res["CustomerAnswerRate"] = boost::any(*customerAnswerRate);
    }
    if (maxCustomerRingTime) {
      res["MaxCustomerRingTime"] = boost::any(*maxCustomerRingTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCustomerRingTime) {
      res["TotalCustomerRingTime"] = boost::any(*totalCustomerRingTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentHandleRate") != m.end() && !m["AgentHandleRate"].empty()) {
      agentHandleRate = make_shared<double>(boost::any_cast<double>(m["AgentHandleRate"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageCustomerRingTime") != m.end() && !m["AverageCustomerRingTime"].empty()) {
      averageCustomerRingTime = make_shared<double>(boost::any_cast<double>(m["AverageCustomerRingTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsCustomerAnswered") != m.end() && !m["CallsCustomerAnswered"].empty()) {
      callsCustomerAnswered = make_shared<long>(boost::any_cast<long>(m["CallsCustomerAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CustomerAnswerRate") != m.end() && !m["CustomerAnswerRate"].empty()) {
      customerAnswerRate = make_shared<double>(boost::any_cast<double>(m["CustomerAnswerRate"]));
    }
    if (m.find("MaxCustomerRingTime") != m.end() && !m["MaxCustomerRingTime"].empty()) {
      maxCustomerRingTime = make_shared<long>(boost::any_cast<long>(m["MaxCustomerRingTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCustomerRingTime") != m.end() && !m["TotalCustomerRingTime"].empty()) {
      totalCustomerRingTime = make_shared<long>(boost::any_cast<long>(m["TotalCustomerRingTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataListBack2Back() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails : public Darabonba::Model {
public:
  shared_ptr<string> accessChannelType{};
  shared_ptr<long> callsOffered{};

  ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelType) {
      res["AccessChannelType"] = boost::any(*accessChannelType);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelType") != m.end() && !m["AccessChannelType"].empty()) {
      accessChannelType = make_shared<string>(boost::any_cast<string>(m["AccessChannelType"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataListInbound : public Darabonba::Model {
public:
  shared_ptr<double> abandonRate{};
  shared_ptr<vector<ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails>> accessChannelTypeDetails{};
  shared_ptr<double> averageAbandonTime{};
  shared_ptr<double> averageAbandonedInQueueTime{};
  shared_ptr<double> averageAbandonedInRingTime{};
  shared_ptr<double> averageFirstResponseTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageResponseTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWaitTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsAbandonedInQueue{};
  shared_ptr<long> callsAbandonedInRing{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsOverflow{};
  shared_ptr<long> callsQueued{};
  shared_ptr<long> callsQueuingFailed{};
  shared_ptr<long> callsQueuingOverflow{};
  shared_ptr<long> callsQueuingTimeout{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> callsTimeout{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxAbandonTime{};
  shared_ptr<long> maxAbandonedInQueueTime{};
  shared_ptr<long> maxAbandonedInRingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel15{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<double> serviceLevel30{};
  shared_ptr<long> totalAbandonTime{};
  shared_ptr<long> totalAbandonedInQueueTime{};
  shared_ptr<long> totalAbandonedInRingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalMessagesSent{};
  shared_ptr<long> totalMessagesSentByAgent{};
  shared_ptr<long> totalMessagesSentByCustomer{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalSkillGroupReportResponseBodyDataListInbound() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataListInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonRate) {
      res["AbandonRate"] = boost::any(*abandonRate);
    }
    if (accessChannelTypeDetails) {
      vector<boost::any> temp1;
      for(auto item1:*accessChannelTypeDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessChannelTypeDetails"] = boost::any(temp1);
    }
    if (averageAbandonTime) {
      res["AverageAbandonTime"] = boost::any(*averageAbandonTime);
    }
    if (averageAbandonedInQueueTime) {
      res["AverageAbandonedInQueueTime"] = boost::any(*averageAbandonedInQueueTime);
    }
    if (averageAbandonedInRingTime) {
      res["AverageAbandonedInRingTime"] = boost::any(*averageAbandonedInRingTime);
    }
    if (averageFirstResponseTime) {
      res["AverageFirstResponseTime"] = boost::any(*averageFirstResponseTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageResponseTime) {
      res["AverageResponseTime"] = boost::any(*averageResponseTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    if (callsAbandonedInRing) {
      res["CallsAbandonedInRing"] = boost::any(*callsAbandonedInRing);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsOverflow) {
      res["CallsOverflow"] = boost::any(*callsOverflow);
    }
    if (callsQueued) {
      res["CallsQueued"] = boost::any(*callsQueued);
    }
    if (callsQueuingFailed) {
      res["CallsQueuingFailed"] = boost::any(*callsQueuingFailed);
    }
    if (callsQueuingOverflow) {
      res["CallsQueuingOverflow"] = boost::any(*callsQueuingOverflow);
    }
    if (callsQueuingTimeout) {
      res["CallsQueuingTimeout"] = boost::any(*callsQueuingTimeout);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (callsTimeout) {
      res["CallsTimeout"] = boost::any(*callsTimeout);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxAbandonTime) {
      res["MaxAbandonTime"] = boost::any(*maxAbandonTime);
    }
    if (maxAbandonedInQueueTime) {
      res["MaxAbandonedInQueueTime"] = boost::any(*maxAbandonedInQueueTime);
    }
    if (maxAbandonedInRingTime) {
      res["MaxAbandonedInRingTime"] = boost::any(*maxAbandonedInRingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel15) {
      res["ServiceLevel15"] = boost::any(*serviceLevel15);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (serviceLevel30) {
      res["ServiceLevel30"] = boost::any(*serviceLevel30);
    }
    if (totalAbandonTime) {
      res["TotalAbandonTime"] = boost::any(*totalAbandonTime);
    }
    if (totalAbandonedInQueueTime) {
      res["TotalAbandonedInQueueTime"] = boost::any(*totalAbandonedInQueueTime);
    }
    if (totalAbandonedInRingTime) {
      res["TotalAbandonedInRingTime"] = boost::any(*totalAbandonedInRingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalMessagesSent) {
      res["TotalMessagesSent"] = boost::any(*totalMessagesSent);
    }
    if (totalMessagesSentByAgent) {
      res["TotalMessagesSentByAgent"] = boost::any(*totalMessagesSentByAgent);
    }
    if (totalMessagesSentByCustomer) {
      res["TotalMessagesSentByCustomer"] = boost::any(*totalMessagesSentByCustomer);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonRate") != m.end() && !m["AbandonRate"].empty()) {
      abandonRate = make_shared<double>(boost::any_cast<double>(m["AbandonRate"]));
    }
    if (m.find("AccessChannelTypeDetails") != m.end() && !m["AccessChannelTypeDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessChannelTypeDetails"].type()) {
        vector<ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessChannelTypeDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessChannelTypeDetails = make_shared<vector<ListHistoricalSkillGroupReportResponseBodyDataListInboundAccessChannelTypeDetails>>(expect1);
      }
    }
    if (m.find("AverageAbandonTime") != m.end() && !m["AverageAbandonTime"].empty()) {
      averageAbandonTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonTime"]));
    }
    if (m.find("AverageAbandonedInQueueTime") != m.end() && !m["AverageAbandonedInQueueTime"].empty()) {
      averageAbandonedInQueueTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInQueueTime"]));
    }
    if (m.find("AverageAbandonedInRingTime") != m.end() && !m["AverageAbandonedInRingTime"].empty()) {
      averageAbandonedInRingTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInRingTime"]));
    }
    if (m.find("AverageFirstResponseTime") != m.end() && !m["AverageFirstResponseTime"].empty()) {
      averageFirstResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageFirstResponseTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageResponseTime") != m.end() && !m["AverageResponseTime"].empty()) {
      averageResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageResponseTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<double>(boost::any_cast<double>(m["AverageWaitTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
    if (m.find("CallsAbandonedInRing") != m.end() && !m["CallsAbandonedInRing"].empty()) {
      callsAbandonedInRing = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInRing"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsOverflow") != m.end() && !m["CallsOverflow"].empty()) {
      callsOverflow = make_shared<long>(boost::any_cast<long>(m["CallsOverflow"]));
    }
    if (m.find("CallsQueued") != m.end() && !m["CallsQueued"].empty()) {
      callsQueued = make_shared<long>(boost::any_cast<long>(m["CallsQueued"]));
    }
    if (m.find("CallsQueuingFailed") != m.end() && !m["CallsQueuingFailed"].empty()) {
      callsQueuingFailed = make_shared<long>(boost::any_cast<long>(m["CallsQueuingFailed"]));
    }
    if (m.find("CallsQueuingOverflow") != m.end() && !m["CallsQueuingOverflow"].empty()) {
      callsQueuingOverflow = make_shared<long>(boost::any_cast<long>(m["CallsQueuingOverflow"]));
    }
    if (m.find("CallsQueuingTimeout") != m.end() && !m["CallsQueuingTimeout"].empty()) {
      callsQueuingTimeout = make_shared<long>(boost::any_cast<long>(m["CallsQueuingTimeout"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("CallsTimeout") != m.end() && !m["CallsTimeout"].empty()) {
      callsTimeout = make_shared<long>(boost::any_cast<long>(m["CallsTimeout"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxAbandonTime") != m.end() && !m["MaxAbandonTime"].empty()) {
      maxAbandonTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonTime"]));
    }
    if (m.find("MaxAbandonedInQueueTime") != m.end() && !m["MaxAbandonedInQueueTime"].empty()) {
      maxAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInQueueTime"]));
    }
    if (m.find("MaxAbandonedInRingTime") != m.end() && !m["MaxAbandonedInRingTime"].empty()) {
      maxAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInRingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel15") != m.end() && !m["ServiceLevel15"].empty()) {
      serviceLevel15 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel15"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("ServiceLevel30") != m.end() && !m["ServiceLevel30"].empty()) {
      serviceLevel30 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel30"]));
    }
    if (m.find("TotalAbandonTime") != m.end() && !m["TotalAbandonTime"].empty()) {
      totalAbandonTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonTime"]));
    }
    if (m.find("TotalAbandonedInQueueTime") != m.end() && !m["TotalAbandonedInQueueTime"].empty()) {
      totalAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInQueueTime"]));
    }
    if (m.find("TotalAbandonedInRingTime") != m.end() && !m["TotalAbandonedInRingTime"].empty()) {
      totalAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInRingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalMessagesSent") != m.end() && !m["TotalMessagesSent"].empty()) {
      totalMessagesSent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSent"]));
    }
    if (m.find("TotalMessagesSentByAgent") != m.end() && !m["TotalMessagesSentByAgent"].empty()) {
      totalMessagesSentByAgent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByAgent"]));
    }
    if (m.find("TotalMessagesSentByCustomer") != m.end() && !m["TotalMessagesSentByCustomer"].empty()) {
      totalMessagesSentByCustomer = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByCustomer"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataListInbound() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataListOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalSkillGroupReportResponseBodyDataListOutbound() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataListOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataListOutbound() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<long> count{};
  shared_ptr<long> duration{};

  ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataListOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<vector<ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList>> breakCodeDetailList{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalSkillGroupReportResponseBodyDataListOverall() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataListOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (breakCodeDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*breakCodeDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BreakCodeDetailList"] = boost::any(temp1);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("BreakCodeDetailList") != m.end() && !m["BreakCodeDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["BreakCodeDetailList"].type()) {
        vector<ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BreakCodeDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        breakCodeDetailList = make_shared<vector<ListHistoricalSkillGroupReportResponseBodyDataListOverallBreakCodeDetailList>>(expect1);
      }
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataListOverall() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<ListHistoricalSkillGroupReportResponseBodyDataListBack2Back> back2Back{};
  shared_ptr<ListHistoricalSkillGroupReportResponseBodyDataListInbound> inbound{};
  shared_ptr<ListHistoricalSkillGroupReportResponseBodyDataListOutbound> outbound{};
  shared_ptr<ListHistoricalSkillGroupReportResponseBodyDataListOverall> overall{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};

  ListHistoricalSkillGroupReportResponseBodyDataList() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (back2Back) {
      res["Back2Back"] = back2Back ? boost::any(back2Back->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Back2Back") != m.end() && !m["Back2Back"].empty()) {
      if (typeid(map<string, boost::any>) == m["Back2Back"].type()) {
        ListHistoricalSkillGroupReportResponseBodyDataListBack2Back model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Back2Back"]));
        back2Back = make_shared<ListHistoricalSkillGroupReportResponseBodyDataListBack2Back>(model1);
      }
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListHistoricalSkillGroupReportResponseBodyDataListInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListHistoricalSkillGroupReportResponseBodyDataListInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListHistoricalSkillGroupReportResponseBodyDataListOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListHistoricalSkillGroupReportResponseBodyDataListOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListHistoricalSkillGroupReportResponseBodyDataListOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListHistoricalSkillGroupReportResponseBodyDataListOverall>(model1);
      }
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataList() = default;
};
class ListHistoricalSkillGroupReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListHistoricalSkillGroupReportResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListHistoricalSkillGroupReportResponseBodyData() {}

  explicit ListHistoricalSkillGroupReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListHistoricalSkillGroupReportResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoricalSkillGroupReportResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListHistoricalSkillGroupReportResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyData() = default;
};
class ListHistoricalSkillGroupReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListHistoricalSkillGroupReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListHistoricalSkillGroupReportResponseBody() {}

  explicit ListHistoricalSkillGroupReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListHistoricalSkillGroupReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListHistoricalSkillGroupReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBody() = default;
};
class ListHistoricalSkillGroupReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHistoricalSkillGroupReportResponseBody> body{};

  ListHistoricalSkillGroupReportResponse() {}

  explicit ListHistoricalSkillGroupReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHistoricalSkillGroupReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHistoricalSkillGroupReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponse() = default;
};
class ListInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListInstancesRequest() {}

  explicit ListInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListInstancesRequest() = default;
};
class ListInstancesResponseBodyDataListAdminList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  ListInstancesResponseBodyDataListAdminList() {}

  explicit ListInstancesResponseBodyDataListAdminList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ListInstancesResponseBodyDataListAdminList() = default;
};
class ListInstancesResponseBodyDataListNumberList : public Darabonba::Model {
public:
  shared_ptr<string> number{};

  ListInstancesResponseBodyDataListNumberList() {}

  explicit ListInstancesResponseBodyDataListNumberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~ListInstancesResponseBodyDataListNumberList() = default;
};
class ListInstancesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesResponseBodyDataListAdminList>> adminList{};
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> consoleUrl{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListInstancesResponseBodyDataListNumberList>> numberList{};
  shared_ptr<string> status{};

  ListInstancesResponseBodyDataList() {}

  explicit ListInstancesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminList) {
      vector<boost::any> temp1;
      for(auto item1:*adminList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdminList"] = boost::any(temp1);
    }
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (consoleUrl) {
      res["ConsoleUrl"] = boost::any(*consoleUrl);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numberList) {
      vector<boost::any> temp1;
      for(auto item1:*numberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NumberList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<ListInstancesResponseBodyDataListAdminList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdminList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyDataListAdminList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adminList = make_shared<vector<ListInstancesResponseBodyDataListAdminList>>(expect1);
      }
    }
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("ConsoleUrl") != m.end() && !m["ConsoleUrl"].empty()) {
      consoleUrl = make_shared<string>(boost::any_cast<string>(m["ConsoleUrl"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      if (typeid(vector<boost::any>) == m["NumberList"].type()) {
        vector<ListInstancesResponseBodyDataListNumberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NumberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyDataListNumberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        numberList = make_shared<vector<ListInstancesResponseBodyDataListNumberList>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListInstancesResponseBodyDataList() = default;
};
class ListInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListInstancesResponseBodyData() {}

  explicit ListInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListInstancesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListInstancesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInstancesResponseBodyData() = default;
};
class ListInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListInstancesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListInstancesResponseBody() {}

  explicit ListInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListInstancesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListInstancesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInstancesResponseBody() = default;
};
class ListInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstancesResponseBody> body{};

  ListInstancesResponse() {}

  explicit ListInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesResponse() = default;
};
class ListInstancesOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListInstancesOfUserRequest() {}

  explicit ListInstancesOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListInstancesOfUserRequest() = default;
};
class ListInstancesOfUserResponseBodyDataListAdminList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  ListInstancesOfUserResponseBodyDataListAdminList() {}

  explicit ListInstancesOfUserResponseBodyDataListAdminList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyDataListAdminList() = default;
};
class ListInstancesOfUserResponseBodyDataListNumberListSkillGroups : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> phoneNumberCount{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> userCount{};

  ListInstancesOfUserResponseBodyDataListNumberListSkillGroups() {}

  explicit ListInstancesOfUserResponseBodyDataListNumberListSkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phoneNumberCount) {
      res["PhoneNumberCount"] = boost::any(*phoneNumberCount);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PhoneNumberCount") != m.end() && !m["PhoneNumberCount"].empty()) {
      phoneNumberCount = make_shared<long>(boost::any_cast<long>(m["PhoneNumberCount"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyDataListNumberListSkillGroups() = default;
};
class ListInstancesOfUserResponseBodyDataListNumberList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};
  shared_ptr<vector<ListInstancesOfUserResponseBodyDataListNumberListSkillGroups>> skillGroups{};
  shared_ptr<string> usage{};
  shared_ptr<string> userId{};

  ListInstancesOfUserResponseBodyDataListNumberList() {}

  explicit ListInstancesOfUserResponseBodyDataListNumberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (skillGroups) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroups"] = boost::any(temp1);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroups"].type()) {
        vector<ListInstancesOfUserResponseBodyDataListNumberListSkillGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyDataListNumberListSkillGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroups = make_shared<vector<ListInstancesOfUserResponseBodyDataListNumberListSkillGroups>>(expect1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyDataListNumberList() = default;
};
class ListInstancesOfUserResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesOfUserResponseBodyDataListAdminList>> adminList{};
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> consoleUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListInstancesOfUserResponseBodyDataListNumberList>> numberList{};
  shared_ptr<string> status{};

  ListInstancesOfUserResponseBodyDataList() {}

  explicit ListInstancesOfUserResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminList) {
      vector<boost::any> temp1;
      for(auto item1:*adminList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdminList"] = boost::any(temp1);
    }
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (consoleUrl) {
      res["ConsoleUrl"] = boost::any(*consoleUrl);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numberList) {
      vector<boost::any> temp1;
      for(auto item1:*numberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NumberList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<ListInstancesOfUserResponseBodyDataListAdminList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdminList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyDataListAdminList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adminList = make_shared<vector<ListInstancesOfUserResponseBodyDataListAdminList>>(expect1);
      }
    }
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("ConsoleUrl") != m.end() && !m["ConsoleUrl"].empty()) {
      consoleUrl = make_shared<string>(boost::any_cast<string>(m["ConsoleUrl"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      if (typeid(vector<boost::any>) == m["NumberList"].type()) {
        vector<ListInstancesOfUserResponseBodyDataListNumberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NumberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyDataListNumberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        numberList = make_shared<vector<ListInstancesOfUserResponseBodyDataListNumberList>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyDataList() = default;
};
class ListInstancesOfUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesOfUserResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListInstancesOfUserResponseBodyData() {}

  explicit ListInstancesOfUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListInstancesOfUserResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListInstancesOfUserResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyData() = default;
};
class ListInstancesOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListInstancesOfUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListInstancesOfUserResponseBody() {}

  explicit ListInstancesOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListInstancesOfUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListInstancesOfUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBody() = default;
};
class ListInstancesOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstancesOfUserResponseBody> body{};

  ListInstancesOfUserResponse() {}

  explicit ListInstancesOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesOfUserResponse() = default;
};
class ListIntervalAgentReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> startTime{};

  ListIntervalAgentReportRequest() {}

  explicit ListIntervalAgentReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListIntervalAgentReportRequest() = default;
};
class ListIntervalAgentReportResponseBodyDataBack2Back : public Darabonba::Model {
public:
  shared_ptr<double> agentHandleRate{};
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageCustomerRingTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<long> callsAgentHandled{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsCustomerAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<double> customerAnswerRate{};
  shared_ptr<long> maxCustomerRingTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalCustomerRingTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};

  ListIntervalAgentReportResponseBodyDataBack2Back() {}

  explicit ListIntervalAgentReportResponseBodyDataBack2Back(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentHandleRate) {
      res["AgentHandleRate"] = boost::any(*agentHandleRate);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageCustomerRingTime) {
      res["AverageCustomerRingTime"] = boost::any(*averageCustomerRingTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (callsAgentHandled) {
      res["CallsAgentHandled"] = boost::any(*callsAgentHandled);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsCustomerAnswered) {
      res["CallsCustomerAnswered"] = boost::any(*callsCustomerAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (customerAnswerRate) {
      res["CustomerAnswerRate"] = boost::any(*customerAnswerRate);
    }
    if (maxCustomerRingTime) {
      res["MaxCustomerRingTime"] = boost::any(*maxCustomerRingTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCustomerRingTime) {
      res["TotalCustomerRingTime"] = boost::any(*totalCustomerRingTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentHandleRate") != m.end() && !m["AgentHandleRate"].empty()) {
      agentHandleRate = make_shared<double>(boost::any_cast<double>(m["AgentHandleRate"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageCustomerRingTime") != m.end() && !m["AverageCustomerRingTime"].empty()) {
      averageCustomerRingTime = make_shared<double>(boost::any_cast<double>(m["AverageCustomerRingTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("CallsAgentHandled") != m.end() && !m["CallsAgentHandled"].empty()) {
      callsAgentHandled = make_shared<long>(boost::any_cast<long>(m["CallsAgentHandled"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsCustomerAnswered") != m.end() && !m["CallsCustomerAnswered"].empty()) {
      callsCustomerAnswered = make_shared<long>(boost::any_cast<long>(m["CallsCustomerAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CustomerAnswerRate") != m.end() && !m["CustomerAnswerRate"].empty()) {
      customerAnswerRate = make_shared<double>(boost::any_cast<double>(m["CustomerAnswerRate"]));
    }
    if (m.find("MaxCustomerRingTime") != m.end() && !m["MaxCustomerRingTime"].empty()) {
      maxCustomerRingTime = make_shared<long>(boost::any_cast<long>(m["MaxCustomerRingTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCustomerRingTime") != m.end() && !m["TotalCustomerRingTime"].empty()) {
      totalCustomerRingTime = make_shared<long>(boost::any_cast<long>(m["TotalCustomerRingTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyDataBack2Back() = default;
};
class ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails : public Darabonba::Model {
public:
  shared_ptr<string> accessChannelType{};
  shared_ptr<long> callsOffered{};

  ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails() {}

  explicit ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelType) {
      res["AccessChannelType"] = boost::any(*accessChannelType);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelType") != m.end() && !m["AccessChannelType"].empty()) {
      accessChannelType = make_shared<string>(boost::any_cast<string>(m["AccessChannelType"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails() = default;
};
class ListIntervalAgentReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<vector<ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails>> accessChannelTypeDetails{};
  shared_ptr<double> averageFirstResponseTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageResponseTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsRinged{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel15{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalMessagesSent{};
  shared_ptr<long> totalMessagesSentByAgent{};
  shared_ptr<long> totalMessagesSentByCustomer{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalAgentReportResponseBodyDataInbound() {}

  explicit ListIntervalAgentReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelTypeDetails) {
      vector<boost::any> temp1;
      for(auto item1:*accessChannelTypeDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessChannelTypeDetails"] = boost::any(temp1);
    }
    if (averageFirstResponseTime) {
      res["AverageFirstResponseTime"] = boost::any(*averageFirstResponseTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageResponseTime) {
      res["AverageResponseTime"] = boost::any(*averageResponseTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel15) {
      res["ServiceLevel15"] = boost::any(*serviceLevel15);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalMessagesSent) {
      res["TotalMessagesSent"] = boost::any(*totalMessagesSent);
    }
    if (totalMessagesSentByAgent) {
      res["TotalMessagesSentByAgent"] = boost::any(*totalMessagesSentByAgent);
    }
    if (totalMessagesSentByCustomer) {
      res["TotalMessagesSentByCustomer"] = boost::any(*totalMessagesSentByCustomer);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelTypeDetails") != m.end() && !m["AccessChannelTypeDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessChannelTypeDetails"].type()) {
        vector<ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessChannelTypeDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessChannelTypeDetails = make_shared<vector<ListIntervalAgentReportResponseBodyDataInboundAccessChannelTypeDetails>>(expect1);
      }
    }
    if (m.find("AverageFirstResponseTime") != m.end() && !m["AverageFirstResponseTime"].empty()) {
      averageFirstResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageFirstResponseTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageResponseTime") != m.end() && !m["AverageResponseTime"].empty()) {
      averageResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageResponseTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel15") != m.end() && !m["ServiceLevel15"].empty()) {
      serviceLevel15 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel15"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalMessagesSent") != m.end() && !m["TotalMessagesSent"].empty()) {
      totalMessagesSent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSent"]));
    }
    if (m.find("TotalMessagesSentByAgent") != m.end() && !m["TotalMessagesSentByAgent"].empty()) {
      totalMessagesSentByAgent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByAgent"]));
    }
    if (m.find("TotalMessagesSentByCustomer") != m.end() && !m["TotalMessagesSentByCustomer"].empty()) {
      totalMessagesSentByCustomer = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByCustomer"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyDataInbound() = default;
};
class ListIntervalAgentReportResponseBodyDataInternal : public Darabonba::Model {
public:
  shared_ptr<double> averageTalkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsTalked{};

  ListIntervalAgentReportResponseBodyDataInternal() {}

  explicit ListIntervalAgentReportResponseBodyDataInternal(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsTalked) {
      res["CallsTalked"] = boost::any(*callsTalked);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsTalked") != m.end() && !m["CallsTalked"].empty()) {
      callsTalked = make_shared<long>(boost::any_cast<long>(m["CallsTalked"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyDataInternal() = default;
};
class ListIntervalAgentReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalAgentReportResponseBodyDataOutbound() {}

  explicit ListIntervalAgentReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyDataOutbound() = default;
};
class ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<long> count{};
  shared_ptr<long> duration{};

  ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList() {}

  explicit ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList() = default;
};
class ListIntervalAgentReportResponseBodyDataOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<vector<ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList>> breakCodeDetailList{};
  shared_ptr<long> firstCheckInTime{};
  shared_ptr<long> lastCheckOutTime{};
  shared_ptr<long> lastCheckoutTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalOffSiteLoggedInTime{};
  shared_ptr<long> totalOffSiteOnlineTime{};
  shared_ptr<long> totalOfficePhoneLoggedInTime{};
  shared_ptr<long> totalOfficePhoneOnlineTime{};
  shared_ptr<long> totalOnSiteLoggedInTime{};
  shared_ptr<long> totalOnSiteOnlineTime{};
  shared_ptr<long> totalOutboundScenarioLoggedInTime{};
  shared_ptr<long> totalOutboundScenarioReadyTime{};
  shared_ptr<long> totalOutboundScenarioTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalAgentReportResponseBodyDataOverall() {}

  explicit ListIntervalAgentReportResponseBodyDataOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (breakCodeDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*breakCodeDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BreakCodeDetailList"] = boost::any(temp1);
    }
    if (firstCheckInTime) {
      res["FirstCheckInTime"] = boost::any(*firstCheckInTime);
    }
    if (lastCheckOutTime) {
      res["LastCheckOutTime"] = boost::any(*lastCheckOutTime);
    }
    if (lastCheckoutTime) {
      res["LastCheckoutTime"] = boost::any(*lastCheckoutTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalOffSiteLoggedInTime) {
      res["TotalOffSiteLoggedInTime"] = boost::any(*totalOffSiteLoggedInTime);
    }
    if (totalOffSiteOnlineTime) {
      res["TotalOffSiteOnlineTime"] = boost::any(*totalOffSiteOnlineTime);
    }
    if (totalOfficePhoneLoggedInTime) {
      res["TotalOfficePhoneLoggedInTime"] = boost::any(*totalOfficePhoneLoggedInTime);
    }
    if (totalOfficePhoneOnlineTime) {
      res["TotalOfficePhoneOnlineTime"] = boost::any(*totalOfficePhoneOnlineTime);
    }
    if (totalOnSiteLoggedInTime) {
      res["TotalOnSiteLoggedInTime"] = boost::any(*totalOnSiteLoggedInTime);
    }
    if (totalOnSiteOnlineTime) {
      res["TotalOnSiteOnlineTime"] = boost::any(*totalOnSiteOnlineTime);
    }
    if (totalOutboundScenarioLoggedInTime) {
      res["TotalOutboundScenarioLoggedInTime"] = boost::any(*totalOutboundScenarioLoggedInTime);
    }
    if (totalOutboundScenarioReadyTime) {
      res["TotalOutboundScenarioReadyTime"] = boost::any(*totalOutboundScenarioReadyTime);
    }
    if (totalOutboundScenarioTime) {
      res["TotalOutboundScenarioTime"] = boost::any(*totalOutboundScenarioTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("BreakCodeDetailList") != m.end() && !m["BreakCodeDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["BreakCodeDetailList"].type()) {
        vector<ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BreakCodeDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        breakCodeDetailList = make_shared<vector<ListIntervalAgentReportResponseBodyDataOverallBreakCodeDetailList>>(expect1);
      }
    }
    if (m.find("FirstCheckInTime") != m.end() && !m["FirstCheckInTime"].empty()) {
      firstCheckInTime = make_shared<long>(boost::any_cast<long>(m["FirstCheckInTime"]));
    }
    if (m.find("LastCheckOutTime") != m.end() && !m["LastCheckOutTime"].empty()) {
      lastCheckOutTime = make_shared<long>(boost::any_cast<long>(m["LastCheckOutTime"]));
    }
    if (m.find("LastCheckoutTime") != m.end() && !m["LastCheckoutTime"].empty()) {
      lastCheckoutTime = make_shared<long>(boost::any_cast<long>(m["LastCheckoutTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalOffSiteLoggedInTime") != m.end() && !m["TotalOffSiteLoggedInTime"].empty()) {
      totalOffSiteLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOffSiteLoggedInTime"]));
    }
    if (m.find("TotalOffSiteOnlineTime") != m.end() && !m["TotalOffSiteOnlineTime"].empty()) {
      totalOffSiteOnlineTime = make_shared<long>(boost::any_cast<long>(m["TotalOffSiteOnlineTime"]));
    }
    if (m.find("TotalOfficePhoneLoggedInTime") != m.end() && !m["TotalOfficePhoneLoggedInTime"].empty()) {
      totalOfficePhoneLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOfficePhoneLoggedInTime"]));
    }
    if (m.find("TotalOfficePhoneOnlineTime") != m.end() && !m["TotalOfficePhoneOnlineTime"].empty()) {
      totalOfficePhoneOnlineTime = make_shared<long>(boost::any_cast<long>(m["TotalOfficePhoneOnlineTime"]));
    }
    if (m.find("TotalOnSiteLoggedInTime") != m.end() && !m["TotalOnSiteLoggedInTime"].empty()) {
      totalOnSiteLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOnSiteLoggedInTime"]));
    }
    if (m.find("TotalOnSiteOnlineTime") != m.end() && !m["TotalOnSiteOnlineTime"].empty()) {
      totalOnSiteOnlineTime = make_shared<long>(boost::any_cast<long>(m["TotalOnSiteOnlineTime"]));
    }
    if (m.find("TotalOutboundScenarioLoggedInTime") != m.end() && !m["TotalOutboundScenarioLoggedInTime"].empty()) {
      totalOutboundScenarioLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioLoggedInTime"]));
    }
    if (m.find("TotalOutboundScenarioReadyTime") != m.end() && !m["TotalOutboundScenarioReadyTime"].empty()) {
      totalOutboundScenarioReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioReadyTime"]));
    }
    if (m.find("TotalOutboundScenarioTime") != m.end() && !m["TotalOutboundScenarioTime"].empty()) {
      totalOutboundScenarioTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyDataOverall() = default;
};
class ListIntervalAgentReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListIntervalAgentReportResponseBodyDataBack2Back> back2Back{};
  shared_ptr<ListIntervalAgentReportResponseBodyDataInbound> inbound{};
  shared_ptr<ListIntervalAgentReportResponseBodyDataInternal> internal{};
  shared_ptr<ListIntervalAgentReportResponseBodyDataOutbound> outbound{};
  shared_ptr<ListIntervalAgentReportResponseBodyDataOverall> overall{};
  shared_ptr<long> statsTime{};

  ListIntervalAgentReportResponseBodyData() {}

  explicit ListIntervalAgentReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (back2Back) {
      res["Back2Back"] = back2Back ? boost::any(back2Back->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internal) {
      res["Internal"] = internal ? boost::any(internal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Back2Back") != m.end() && !m["Back2Back"].empty()) {
      if (typeid(map<string, boost::any>) == m["Back2Back"].type()) {
        ListIntervalAgentReportResponseBodyDataBack2Back model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Back2Back"]));
        back2Back = make_shared<ListIntervalAgentReportResponseBodyDataBack2Back>(model1);
      }
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListIntervalAgentReportResponseBodyDataInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListIntervalAgentReportResponseBodyDataInbound>(model1);
      }
    }
    if (m.find("Internal") != m.end() && !m["Internal"].empty()) {
      if (typeid(map<string, boost::any>) == m["Internal"].type()) {
        ListIntervalAgentReportResponseBodyDataInternal model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Internal"]));
        internal = make_shared<ListIntervalAgentReportResponseBodyDataInternal>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListIntervalAgentReportResponseBodyDataOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListIntervalAgentReportResponseBodyDataOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListIntervalAgentReportResponseBodyDataOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListIntervalAgentReportResponseBodyDataOverall>(model1);
      }
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyData() = default;
};
class ListIntervalAgentReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListIntervalAgentReportResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListIntervalAgentReportResponseBody() {}

  explicit ListIntervalAgentReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListIntervalAgentReportResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalAgentReportResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIntervalAgentReportResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBody() = default;
};
class ListIntervalAgentReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntervalAgentReportResponseBody> body{};

  ListIntervalAgentReportResponse() {}

  explicit ListIntervalAgentReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntervalAgentReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntervalAgentReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntervalAgentReportResponse() = default;
};
class ListIntervalAgentSkillGroupReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> startTime{};

  ListIntervalAgentSkillGroupReportRequest() {}

  explicit ListIntervalAgentSkillGroupReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListIntervalAgentSkillGroupReportRequest() = default;
};
class ListIntervalAgentSkillGroupReportResponseBodyDataBack2Back : public Darabonba::Model {
public:
  shared_ptr<double> agentAnswerRate{};
  shared_ptr<double> agentHandleRate{};
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageCustomerRingTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> callsAgentHandled{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsCustomerAnswered{};
  shared_ptr<long> callsCustomerHandled{};
  shared_ptr<long> callsDialed{};
  shared_ptr<double> customerAnswerRate{};
  shared_ptr<double> customerHandleRate{};
  shared_ptr<long> maxCustomerRingTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalCustomerRingTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};

  ListIntervalAgentSkillGroupReportResponseBodyDataBack2Back() {}

  explicit ListIntervalAgentSkillGroupReportResponseBodyDataBack2Back(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentAnswerRate) {
      res["AgentAnswerRate"] = boost::any(*agentAnswerRate);
    }
    if (agentHandleRate) {
      res["AgentHandleRate"] = boost::any(*agentHandleRate);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageCustomerRingTime) {
      res["AverageCustomerRingTime"] = boost::any(*averageCustomerRingTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (callsAgentHandled) {
      res["CallsAgentHandled"] = boost::any(*callsAgentHandled);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsCustomerAnswered) {
      res["CallsCustomerAnswered"] = boost::any(*callsCustomerAnswered);
    }
    if (callsCustomerHandled) {
      res["CallsCustomerHandled"] = boost::any(*callsCustomerHandled);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (customerAnswerRate) {
      res["CustomerAnswerRate"] = boost::any(*customerAnswerRate);
    }
    if (customerHandleRate) {
      res["CustomerHandleRate"] = boost::any(*customerHandleRate);
    }
    if (maxCustomerRingTime) {
      res["MaxCustomerRingTime"] = boost::any(*maxCustomerRingTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCustomerRingTime) {
      res["TotalCustomerRingTime"] = boost::any(*totalCustomerRingTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentAnswerRate") != m.end() && !m["AgentAnswerRate"].empty()) {
      agentAnswerRate = make_shared<double>(boost::any_cast<double>(m["AgentAnswerRate"]));
    }
    if (m.find("AgentHandleRate") != m.end() && !m["AgentHandleRate"].empty()) {
      agentHandleRate = make_shared<double>(boost::any_cast<double>(m["AgentHandleRate"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageCustomerRingTime") != m.end() && !m["AverageCustomerRingTime"].empty()) {
      averageCustomerRingTime = make_shared<double>(boost::any_cast<double>(m["AverageCustomerRingTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("CallsAgentHandled") != m.end() && !m["CallsAgentHandled"].empty()) {
      callsAgentHandled = make_shared<long>(boost::any_cast<long>(m["CallsAgentHandled"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsCustomerAnswered") != m.end() && !m["CallsCustomerAnswered"].empty()) {
      callsCustomerAnswered = make_shared<long>(boost::any_cast<long>(m["CallsCustomerAnswered"]));
    }
    if (m.find("CallsCustomerHandled") != m.end() && !m["CallsCustomerHandled"].empty()) {
      callsCustomerHandled = make_shared<long>(boost::any_cast<long>(m["CallsCustomerHandled"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CustomerAnswerRate") != m.end() && !m["CustomerAnswerRate"].empty()) {
      customerAnswerRate = make_shared<double>(boost::any_cast<double>(m["CustomerAnswerRate"]));
    }
    if (m.find("CustomerHandleRate") != m.end() && !m["CustomerHandleRate"].empty()) {
      customerHandleRate = make_shared<double>(boost::any_cast<double>(m["CustomerHandleRate"]));
    }
    if (m.find("MaxCustomerRingTime") != m.end() && !m["MaxCustomerRingTime"].empty()) {
      maxCustomerRingTime = make_shared<long>(boost::any_cast<long>(m["MaxCustomerRingTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCustomerRingTime") != m.end() && !m["TotalCustomerRingTime"].empty()) {
      totalCustomerRingTime = make_shared<long>(boost::any_cast<long>(m["TotalCustomerRingTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
  }


  virtual ~ListIntervalAgentSkillGroupReportResponseBodyDataBack2Back() = default;
};
class ListIntervalAgentSkillGroupReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<double> averageFirstResponseTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageResponseTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsRinged{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalMessagesSent{};
  shared_ptr<long> totalMessagesSentByAgent{};
  shared_ptr<long> totalMessagesSentByCustomer{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalAgentSkillGroupReportResponseBodyDataInbound() {}

  explicit ListIntervalAgentSkillGroupReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageFirstResponseTime) {
      res["AverageFirstResponseTime"] = boost::any(*averageFirstResponseTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageResponseTime) {
      res["AverageResponseTime"] = boost::any(*averageResponseTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalMessagesSent) {
      res["TotalMessagesSent"] = boost::any(*totalMessagesSent);
    }
    if (totalMessagesSentByAgent) {
      res["TotalMessagesSentByAgent"] = boost::any(*totalMessagesSentByAgent);
    }
    if (totalMessagesSentByCustomer) {
      res["TotalMessagesSentByCustomer"] = boost::any(*totalMessagesSentByCustomer);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageFirstResponseTime") != m.end() && !m["AverageFirstResponseTime"].empty()) {
      averageFirstResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageFirstResponseTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageResponseTime") != m.end() && !m["AverageResponseTime"].empty()) {
      averageResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageResponseTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalMessagesSent") != m.end() && !m["TotalMessagesSent"].empty()) {
      totalMessagesSent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSent"]));
    }
    if (m.find("TotalMessagesSentByAgent") != m.end() && !m["TotalMessagesSentByAgent"].empty()) {
      totalMessagesSentByAgent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByAgent"]));
    }
    if (m.find("TotalMessagesSentByCustomer") != m.end() && !m["TotalMessagesSentByCustomer"].empty()) {
      totalMessagesSentByCustomer = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByCustomer"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalAgentSkillGroupReportResponseBodyDataInbound() = default;
};
class ListIntervalAgentSkillGroupReportResponseBodyDataInternal : public Darabonba::Model {
public:
  shared_ptr<double> averageTalkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsTalk{};
  shared_ptr<long> callsTalked{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalTalkTime{};

  ListIntervalAgentSkillGroupReportResponseBodyDataInternal() {}

  explicit ListIntervalAgentSkillGroupReportResponseBodyDataInternal(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsTalk) {
      res["CallsTalk"] = boost::any(*callsTalk);
    }
    if (callsTalked) {
      res["CallsTalked"] = boost::any(*callsTalked);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsTalk") != m.end() && !m["CallsTalk"].empty()) {
      callsTalk = make_shared<long>(boost::any_cast<long>(m["CallsTalk"]));
    }
    if (m.find("CallsTalked") != m.end() && !m["CallsTalked"].empty()) {
      callsTalked = make_shared<long>(boost::any_cast<long>(m["CallsTalked"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
  }


  virtual ~ListIntervalAgentSkillGroupReportResponseBodyDataInternal() = default;
};
class ListIntervalAgentSkillGroupReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalAgentSkillGroupReportResponseBodyDataOutbound() {}

  explicit ListIntervalAgentSkillGroupReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalAgentSkillGroupReportResponseBodyDataOutbound() = default;
};
class ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<long> count{};
  shared_ptr<long> duration{};

  ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList() {}

  explicit ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList() = default;
};
class ListIntervalAgentSkillGroupReportResponseBodyDataOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<vector<ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList>> breakCodeDetailList{};
  shared_ptr<long> firstCheckInTime{};
  shared_ptr<long> lastCheckOutTime{};
  shared_ptr<long> lastCheckoutTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<string> totalOffSiteLoggedInTime{};
  shared_ptr<string> totalOfficePhoneLoggedInTime{};
  shared_ptr<string> totalOnSiteLoggedInTime{};
  shared_ptr<long> totalOutboundScenarioLoggedInTime{};
  shared_ptr<long> totalOutboundScenarioReadyTime{};
  shared_ptr<long> totalOutboundScenarioTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalAgentSkillGroupReportResponseBodyDataOverall() {}

  explicit ListIntervalAgentSkillGroupReportResponseBodyDataOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (breakCodeDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*breakCodeDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BreakCodeDetailList"] = boost::any(temp1);
    }
    if (firstCheckInTime) {
      res["FirstCheckInTime"] = boost::any(*firstCheckInTime);
    }
    if (lastCheckOutTime) {
      res["LastCheckOutTime"] = boost::any(*lastCheckOutTime);
    }
    if (lastCheckoutTime) {
      res["LastCheckoutTime"] = boost::any(*lastCheckoutTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalOffSiteLoggedInTime) {
      res["TotalOffSiteLoggedInTime"] = boost::any(*totalOffSiteLoggedInTime);
    }
    if (totalOfficePhoneLoggedInTime) {
      res["TotalOfficePhoneLoggedInTime"] = boost::any(*totalOfficePhoneLoggedInTime);
    }
    if (totalOnSiteLoggedInTime) {
      res["TotalOnSiteLoggedInTime"] = boost::any(*totalOnSiteLoggedInTime);
    }
    if (totalOutboundScenarioLoggedInTime) {
      res["TotalOutboundScenarioLoggedInTime"] = boost::any(*totalOutboundScenarioLoggedInTime);
    }
    if (totalOutboundScenarioReadyTime) {
      res["TotalOutboundScenarioReadyTime"] = boost::any(*totalOutboundScenarioReadyTime);
    }
    if (totalOutboundScenarioTime) {
      res["TotalOutboundScenarioTime"] = boost::any(*totalOutboundScenarioTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("BreakCodeDetailList") != m.end() && !m["BreakCodeDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["BreakCodeDetailList"].type()) {
        vector<ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BreakCodeDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        breakCodeDetailList = make_shared<vector<ListIntervalAgentSkillGroupReportResponseBodyDataOverallBreakCodeDetailList>>(expect1);
      }
    }
    if (m.find("FirstCheckInTime") != m.end() && !m["FirstCheckInTime"].empty()) {
      firstCheckInTime = make_shared<long>(boost::any_cast<long>(m["FirstCheckInTime"]));
    }
    if (m.find("LastCheckOutTime") != m.end() && !m["LastCheckOutTime"].empty()) {
      lastCheckOutTime = make_shared<long>(boost::any_cast<long>(m["LastCheckOutTime"]));
    }
    if (m.find("LastCheckoutTime") != m.end() && !m["LastCheckoutTime"].empty()) {
      lastCheckoutTime = make_shared<long>(boost::any_cast<long>(m["LastCheckoutTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalOffSiteLoggedInTime") != m.end() && !m["TotalOffSiteLoggedInTime"].empty()) {
      totalOffSiteLoggedInTime = make_shared<string>(boost::any_cast<string>(m["TotalOffSiteLoggedInTime"]));
    }
    if (m.find("TotalOfficePhoneLoggedInTime") != m.end() && !m["TotalOfficePhoneLoggedInTime"].empty()) {
      totalOfficePhoneLoggedInTime = make_shared<string>(boost::any_cast<string>(m["TotalOfficePhoneLoggedInTime"]));
    }
    if (m.find("TotalOnSiteLoggedInTime") != m.end() && !m["TotalOnSiteLoggedInTime"].empty()) {
      totalOnSiteLoggedInTime = make_shared<string>(boost::any_cast<string>(m["TotalOnSiteLoggedInTime"]));
    }
    if (m.find("TotalOutboundScenarioLoggedInTime") != m.end() && !m["TotalOutboundScenarioLoggedInTime"].empty()) {
      totalOutboundScenarioLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioLoggedInTime"]));
    }
    if (m.find("TotalOutboundScenarioReadyTime") != m.end() && !m["TotalOutboundScenarioReadyTime"].empty()) {
      totalOutboundScenarioReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioReadyTime"]));
    }
    if (m.find("TotalOutboundScenarioTime") != m.end() && !m["TotalOutboundScenarioTime"].empty()) {
      totalOutboundScenarioTime = make_shared<long>(boost::any_cast<long>(m["TotalOutboundScenarioTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalAgentSkillGroupReportResponseBodyDataOverall() = default;
};
class ListIntervalAgentSkillGroupReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListIntervalAgentSkillGroupReportResponseBodyDataBack2Back> back2Back{};
  shared_ptr<ListIntervalAgentSkillGroupReportResponseBodyDataInbound> inbound{};
  shared_ptr<ListIntervalAgentSkillGroupReportResponseBodyDataInternal> internal{};
  shared_ptr<ListIntervalAgentSkillGroupReportResponseBodyDataOutbound> outbound{};
  shared_ptr<ListIntervalAgentSkillGroupReportResponseBodyDataOverall> overall{};
  shared_ptr<long> statsTime{};

  ListIntervalAgentSkillGroupReportResponseBodyData() {}

  explicit ListIntervalAgentSkillGroupReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (back2Back) {
      res["Back2Back"] = back2Back ? boost::any(back2Back->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internal) {
      res["Internal"] = internal ? boost::any(internal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Back2Back") != m.end() && !m["Back2Back"].empty()) {
      if (typeid(map<string, boost::any>) == m["Back2Back"].type()) {
        ListIntervalAgentSkillGroupReportResponseBodyDataBack2Back model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Back2Back"]));
        back2Back = make_shared<ListIntervalAgentSkillGroupReportResponseBodyDataBack2Back>(model1);
      }
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListIntervalAgentSkillGroupReportResponseBodyDataInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListIntervalAgentSkillGroupReportResponseBodyDataInbound>(model1);
      }
    }
    if (m.find("Internal") != m.end() && !m["Internal"].empty()) {
      if (typeid(map<string, boost::any>) == m["Internal"].type()) {
        ListIntervalAgentSkillGroupReportResponseBodyDataInternal model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Internal"]));
        internal = make_shared<ListIntervalAgentSkillGroupReportResponseBodyDataInternal>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListIntervalAgentSkillGroupReportResponseBodyDataOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListIntervalAgentSkillGroupReportResponseBodyDataOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListIntervalAgentSkillGroupReportResponseBodyDataOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListIntervalAgentSkillGroupReportResponseBodyDataOverall>(model1);
      }
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
  }


  virtual ~ListIntervalAgentSkillGroupReportResponseBodyData() = default;
};
class ListIntervalAgentSkillGroupReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListIntervalAgentSkillGroupReportResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListIntervalAgentSkillGroupReportResponseBody() {}

  explicit ListIntervalAgentSkillGroupReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListIntervalAgentSkillGroupReportResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalAgentSkillGroupReportResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIntervalAgentSkillGroupReportResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIntervalAgentSkillGroupReportResponseBody() = default;
};
class ListIntervalAgentSkillGroupReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntervalAgentSkillGroupReportResponseBody> body{};

  ListIntervalAgentSkillGroupReportResponse() {}

  explicit ListIntervalAgentSkillGroupReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntervalAgentSkillGroupReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntervalAgentSkillGroupReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntervalAgentSkillGroupReportResponse() = default;
};
class ListIntervalInstanceReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<long> startTime{};

  ListIntervalInstanceReportRequest() {}

  explicit ListIntervalInstanceReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListIntervalInstanceReportRequest() = default;
};
class ListIntervalInstanceReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<double> abandonRate{};
  shared_ptr<double> abandonedRate{};
  shared_ptr<double> averageAbandonTime{};
  shared_ptr<double> averageAbandonedInIVRTime{};
  shared_ptr<double> averageAbandonedInQueueTime{};
  shared_ptr<double> averageAbandonedInRingTime{};
  shared_ptr<double> averageFirstResponseTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageResponseTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWaitTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsAbandonedInIVR{};
  shared_ptr<long> callsAbandonedInQueue{};
  shared_ptr<long> callsAbandonedInRing{};
  shared_ptr<long> callsAbandonedInVoiceNavigator{};
  shared_ptr<long> callsAttendedTransferred{};
  shared_ptr<long> callsBlindTransferred{};
  shared_ptr<long> callsCausedIVRException{};
  shared_ptr<long> callsForwardToOutsideNumber{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsIVRException{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsQueued{};
  shared_ptr<long> callsQueuingFailed{};
  shared_ptr<long> callsQueuingOverflow{};
  shared_ptr<long> callsQueuingTimeout{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> callsToVoicemail{};
  shared_ptr<long> callsVoicemail{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxAbandonTime{};
  shared_ptr<long> maxAbandonedInIVRTime{};
  shared_ptr<long> maxAbandonedInQueueTime{};
  shared_ptr<long> maxAbandonedInRingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalAbandonTime{};
  shared_ptr<long> totalAbandonedInIVRTime{};
  shared_ptr<long> totalAbandonedInQueueTime{};
  shared_ptr<long> totalAbandonedInRingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalMessagesSent{};
  shared_ptr<long> totalMessagesSentByAgent{};
  shared_ptr<long> totalMessagesSentByCustomer{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalInstanceReportResponseBodyDataInbound() {}

  explicit ListIntervalInstanceReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonRate) {
      res["AbandonRate"] = boost::any(*abandonRate);
    }
    if (abandonedRate) {
      res["AbandonedRate"] = boost::any(*abandonedRate);
    }
    if (averageAbandonTime) {
      res["AverageAbandonTime"] = boost::any(*averageAbandonTime);
    }
    if (averageAbandonedInIVRTime) {
      res["AverageAbandonedInIVRTime"] = boost::any(*averageAbandonedInIVRTime);
    }
    if (averageAbandonedInQueueTime) {
      res["AverageAbandonedInQueueTime"] = boost::any(*averageAbandonedInQueueTime);
    }
    if (averageAbandonedInRingTime) {
      res["AverageAbandonedInRingTime"] = boost::any(*averageAbandonedInRingTime);
    }
    if (averageFirstResponseTime) {
      res["AverageFirstResponseTime"] = boost::any(*averageFirstResponseTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageResponseTime) {
      res["AverageResponseTime"] = boost::any(*averageResponseTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsAbandonedInIVR) {
      res["CallsAbandonedInIVR"] = boost::any(*callsAbandonedInIVR);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    if (callsAbandonedInRing) {
      res["CallsAbandonedInRing"] = boost::any(*callsAbandonedInRing);
    }
    if (callsAbandonedInVoiceNavigator) {
      res["CallsAbandonedInVoiceNavigator"] = boost::any(*callsAbandonedInVoiceNavigator);
    }
    if (callsAttendedTransferred) {
      res["CallsAttendedTransferred"] = boost::any(*callsAttendedTransferred);
    }
    if (callsBlindTransferred) {
      res["CallsBlindTransferred"] = boost::any(*callsBlindTransferred);
    }
    if (callsCausedIVRException) {
      res["CallsCausedIVRException"] = boost::any(*callsCausedIVRException);
    }
    if (callsForwardToOutsideNumber) {
      res["CallsForwardToOutsideNumber"] = boost::any(*callsForwardToOutsideNumber);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsIVRException) {
      res["CallsIVRException"] = boost::any(*callsIVRException);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsQueued) {
      res["CallsQueued"] = boost::any(*callsQueued);
    }
    if (callsQueuingFailed) {
      res["CallsQueuingFailed"] = boost::any(*callsQueuingFailed);
    }
    if (callsQueuingOverflow) {
      res["CallsQueuingOverflow"] = boost::any(*callsQueuingOverflow);
    }
    if (callsQueuingTimeout) {
      res["CallsQueuingTimeout"] = boost::any(*callsQueuingTimeout);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (callsToVoicemail) {
      res["CallsToVoicemail"] = boost::any(*callsToVoicemail);
    }
    if (callsVoicemail) {
      res["CallsVoicemail"] = boost::any(*callsVoicemail);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxAbandonTime) {
      res["MaxAbandonTime"] = boost::any(*maxAbandonTime);
    }
    if (maxAbandonedInIVRTime) {
      res["MaxAbandonedInIVRTime"] = boost::any(*maxAbandonedInIVRTime);
    }
    if (maxAbandonedInQueueTime) {
      res["MaxAbandonedInQueueTime"] = boost::any(*maxAbandonedInQueueTime);
    }
    if (maxAbandonedInRingTime) {
      res["MaxAbandonedInRingTime"] = boost::any(*maxAbandonedInRingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalAbandonTime) {
      res["TotalAbandonTime"] = boost::any(*totalAbandonTime);
    }
    if (totalAbandonedInIVRTime) {
      res["TotalAbandonedInIVRTime"] = boost::any(*totalAbandonedInIVRTime);
    }
    if (totalAbandonedInQueueTime) {
      res["TotalAbandonedInQueueTime"] = boost::any(*totalAbandonedInQueueTime);
    }
    if (totalAbandonedInRingTime) {
      res["TotalAbandonedInRingTime"] = boost::any(*totalAbandonedInRingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalMessagesSent) {
      res["TotalMessagesSent"] = boost::any(*totalMessagesSent);
    }
    if (totalMessagesSentByAgent) {
      res["TotalMessagesSentByAgent"] = boost::any(*totalMessagesSentByAgent);
    }
    if (totalMessagesSentByCustomer) {
      res["TotalMessagesSentByCustomer"] = boost::any(*totalMessagesSentByCustomer);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonRate") != m.end() && !m["AbandonRate"].empty()) {
      abandonRate = make_shared<double>(boost::any_cast<double>(m["AbandonRate"]));
    }
    if (m.find("AbandonedRate") != m.end() && !m["AbandonedRate"].empty()) {
      abandonedRate = make_shared<double>(boost::any_cast<double>(m["AbandonedRate"]));
    }
    if (m.find("AverageAbandonTime") != m.end() && !m["AverageAbandonTime"].empty()) {
      averageAbandonTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonTime"]));
    }
    if (m.find("AverageAbandonedInIVRTime") != m.end() && !m["AverageAbandonedInIVRTime"].empty()) {
      averageAbandonedInIVRTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInIVRTime"]));
    }
    if (m.find("AverageAbandonedInQueueTime") != m.end() && !m["AverageAbandonedInQueueTime"].empty()) {
      averageAbandonedInQueueTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInQueueTime"]));
    }
    if (m.find("AverageAbandonedInRingTime") != m.end() && !m["AverageAbandonedInRingTime"].empty()) {
      averageAbandonedInRingTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInRingTime"]));
    }
    if (m.find("AverageFirstResponseTime") != m.end() && !m["AverageFirstResponseTime"].empty()) {
      averageFirstResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageFirstResponseTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageResponseTime") != m.end() && !m["AverageResponseTime"].empty()) {
      averageResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageResponseTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<double>(boost::any_cast<double>(m["AverageWaitTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsAbandonedInIVR") != m.end() && !m["CallsAbandonedInIVR"].empty()) {
      callsAbandonedInIVR = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInIVR"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
    if (m.find("CallsAbandonedInRing") != m.end() && !m["CallsAbandonedInRing"].empty()) {
      callsAbandonedInRing = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInRing"]));
    }
    if (m.find("CallsAbandonedInVoiceNavigator") != m.end() && !m["CallsAbandonedInVoiceNavigator"].empty()) {
      callsAbandonedInVoiceNavigator = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInVoiceNavigator"]));
    }
    if (m.find("CallsAttendedTransferred") != m.end() && !m["CallsAttendedTransferred"].empty()) {
      callsAttendedTransferred = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferred"]));
    }
    if (m.find("CallsBlindTransferred") != m.end() && !m["CallsBlindTransferred"].empty()) {
      callsBlindTransferred = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferred"]));
    }
    if (m.find("CallsCausedIVRException") != m.end() && !m["CallsCausedIVRException"].empty()) {
      callsCausedIVRException = make_shared<long>(boost::any_cast<long>(m["CallsCausedIVRException"]));
    }
    if (m.find("CallsForwardToOutsideNumber") != m.end() && !m["CallsForwardToOutsideNumber"].empty()) {
      callsForwardToOutsideNumber = make_shared<long>(boost::any_cast<long>(m["CallsForwardToOutsideNumber"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsIVRException") != m.end() && !m["CallsIVRException"].empty()) {
      callsIVRException = make_shared<long>(boost::any_cast<long>(m["CallsIVRException"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsQueued") != m.end() && !m["CallsQueued"].empty()) {
      callsQueued = make_shared<long>(boost::any_cast<long>(m["CallsQueued"]));
    }
    if (m.find("CallsQueuingFailed") != m.end() && !m["CallsQueuingFailed"].empty()) {
      callsQueuingFailed = make_shared<long>(boost::any_cast<long>(m["CallsQueuingFailed"]));
    }
    if (m.find("CallsQueuingOverflow") != m.end() && !m["CallsQueuingOverflow"].empty()) {
      callsQueuingOverflow = make_shared<long>(boost::any_cast<long>(m["CallsQueuingOverflow"]));
    }
    if (m.find("CallsQueuingTimeout") != m.end() && !m["CallsQueuingTimeout"].empty()) {
      callsQueuingTimeout = make_shared<long>(boost::any_cast<long>(m["CallsQueuingTimeout"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("CallsToVoicemail") != m.end() && !m["CallsToVoicemail"].empty()) {
      callsToVoicemail = make_shared<long>(boost::any_cast<long>(m["CallsToVoicemail"]));
    }
    if (m.find("CallsVoicemail") != m.end() && !m["CallsVoicemail"].empty()) {
      callsVoicemail = make_shared<long>(boost::any_cast<long>(m["CallsVoicemail"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxAbandonTime") != m.end() && !m["MaxAbandonTime"].empty()) {
      maxAbandonTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonTime"]));
    }
    if (m.find("MaxAbandonedInIVRTime") != m.end() && !m["MaxAbandonedInIVRTime"].empty()) {
      maxAbandonedInIVRTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInIVRTime"]));
    }
    if (m.find("MaxAbandonedInQueueTime") != m.end() && !m["MaxAbandonedInQueueTime"].empty()) {
      maxAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInQueueTime"]));
    }
    if (m.find("MaxAbandonedInRingTime") != m.end() && !m["MaxAbandonedInRingTime"].empty()) {
      maxAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInRingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalAbandonTime") != m.end() && !m["TotalAbandonTime"].empty()) {
      totalAbandonTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonTime"]));
    }
    if (m.find("TotalAbandonedInIVRTime") != m.end() && !m["TotalAbandonedInIVRTime"].empty()) {
      totalAbandonedInIVRTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInIVRTime"]));
    }
    if (m.find("TotalAbandonedInQueueTime") != m.end() && !m["TotalAbandonedInQueueTime"].empty()) {
      totalAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInQueueTime"]));
    }
    if (m.find("TotalAbandonedInRingTime") != m.end() && !m["TotalAbandonedInRingTime"].empty()) {
      totalAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInRingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalMessagesSent") != m.end() && !m["TotalMessagesSent"].empty()) {
      totalMessagesSent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSent"]));
    }
    if (m.find("TotalMessagesSentByAgent") != m.end() && !m["TotalMessagesSentByAgent"].empty()) {
      totalMessagesSentByAgent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByAgent"]));
    }
    if (m.find("TotalMessagesSentByCustomer") != m.end() && !m["TotalMessagesSentByCustomer"].empty()) {
      totalMessagesSentByCustomer = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByCustomer"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalInstanceReportResponseBodyDataInbound() = default;
};
class ListIntervalInstanceReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferred{};
  shared_ptr<long> callsBlindTransferred{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalInstanceReportResponseBodyDataOutbound() {}

  explicit ListIntervalInstanceReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferred) {
      res["CallsAttendedTransferred"] = boost::any(*callsAttendedTransferred);
    }
    if (callsBlindTransferred) {
      res["CallsBlindTransferred"] = boost::any(*callsBlindTransferred);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferred") != m.end() && !m["CallsAttendedTransferred"].empty()) {
      callsAttendedTransferred = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferred"]));
    }
    if (m.find("CallsBlindTransferred") != m.end() && !m["CallsBlindTransferred"].empty()) {
      callsBlindTransferred = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferred"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalInstanceReportResponseBodyDataOutbound() = default;
};
class ListIntervalInstanceReportResponseBodyDataOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalInstanceReportResponseBodyDataOverall() {}

  explicit ListIntervalInstanceReportResponseBodyDataOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalInstanceReportResponseBodyDataOverall() = default;
};
class ListIntervalInstanceReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListIntervalInstanceReportResponseBodyDataInbound> inbound{};
  shared_ptr<ListIntervalInstanceReportResponseBodyDataOutbound> outbound{};
  shared_ptr<ListIntervalInstanceReportResponseBodyDataOverall> overall{};
  shared_ptr<long> statsTime{};

  ListIntervalInstanceReportResponseBodyData() {}

  explicit ListIntervalInstanceReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListIntervalInstanceReportResponseBodyDataInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListIntervalInstanceReportResponseBodyDataInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListIntervalInstanceReportResponseBodyDataOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListIntervalInstanceReportResponseBodyDataOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListIntervalInstanceReportResponseBodyDataOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListIntervalInstanceReportResponseBodyDataOverall>(model1);
      }
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
  }


  virtual ~ListIntervalInstanceReportResponseBodyData() = default;
};
class ListIntervalInstanceReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListIntervalInstanceReportResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListIntervalInstanceReportResponseBody() {}

  explicit ListIntervalInstanceReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListIntervalInstanceReportResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalInstanceReportResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIntervalInstanceReportResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIntervalInstanceReportResponseBody() = default;
};
class ListIntervalInstanceReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntervalInstanceReportResponseBody> body{};

  ListIntervalInstanceReportResponse() {}

  explicit ListIntervalInstanceReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntervalInstanceReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntervalInstanceReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntervalInstanceReportResponse() = default;
};
class ListIntervalSkillGroupReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> startTime{};

  ListIntervalSkillGroupReportRequest() {}

  explicit ListIntervalSkillGroupReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportRequest() = default;
};
class ListIntervalSkillGroupReportResponseBodyDataBack2Back : public Darabonba::Model {
public:
  shared_ptr<double> agentHandleRate{};
  shared_ptr<string> answerRate{};
  shared_ptr<double> averageCustomerRingTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<string> averageTalkTime{};
  shared_ptr<long> callsAgentHandled{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsCustomerAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<double> customerAnswerRate{};
  shared_ptr<long> maxCustomerRingTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<string> maxTalkTime{};
  shared_ptr<long> totalCustomerRingTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};

  ListIntervalSkillGroupReportResponseBodyDataBack2Back() {}

  explicit ListIntervalSkillGroupReportResponseBodyDataBack2Back(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentHandleRate) {
      res["AgentHandleRate"] = boost::any(*agentHandleRate);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageCustomerRingTime) {
      res["AverageCustomerRingTime"] = boost::any(*averageCustomerRingTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (callsAgentHandled) {
      res["CallsAgentHandled"] = boost::any(*callsAgentHandled);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsCustomerAnswered) {
      res["CallsCustomerAnswered"] = boost::any(*callsCustomerAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (customerAnswerRate) {
      res["CustomerAnswerRate"] = boost::any(*customerAnswerRate);
    }
    if (maxCustomerRingTime) {
      res["MaxCustomerRingTime"] = boost::any(*maxCustomerRingTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCustomerRingTime) {
      res["TotalCustomerRingTime"] = boost::any(*totalCustomerRingTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentHandleRate") != m.end() && !m["AgentHandleRate"].empty()) {
      agentHandleRate = make_shared<double>(boost::any_cast<double>(m["AgentHandleRate"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<string>(boost::any_cast<string>(m["AnswerRate"]));
    }
    if (m.find("AverageCustomerRingTime") != m.end() && !m["AverageCustomerRingTime"].empty()) {
      averageCustomerRingTime = make_shared<double>(boost::any_cast<double>(m["AverageCustomerRingTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<string>(boost::any_cast<string>(m["AverageTalkTime"]));
    }
    if (m.find("CallsAgentHandled") != m.end() && !m["CallsAgentHandled"].empty()) {
      callsAgentHandled = make_shared<long>(boost::any_cast<long>(m["CallsAgentHandled"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsCustomerAnswered") != m.end() && !m["CallsCustomerAnswered"].empty()) {
      callsCustomerAnswered = make_shared<long>(boost::any_cast<long>(m["CallsCustomerAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CustomerAnswerRate") != m.end() && !m["CustomerAnswerRate"].empty()) {
      customerAnswerRate = make_shared<double>(boost::any_cast<double>(m["CustomerAnswerRate"]));
    }
    if (m.find("MaxCustomerRingTime") != m.end() && !m["MaxCustomerRingTime"].empty()) {
      maxCustomerRingTime = make_shared<long>(boost::any_cast<long>(m["MaxCustomerRingTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<string>(boost::any_cast<string>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCustomerRingTime") != m.end() && !m["TotalCustomerRingTime"].empty()) {
      totalCustomerRingTime = make_shared<long>(boost::any_cast<long>(m["TotalCustomerRingTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBodyDataBack2Back() = default;
};
class ListIntervalSkillGroupReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<double> abandonRate{};
  shared_ptr<double> averageAbandonTime{};
  shared_ptr<double> averageAbandonedInQueueTime{};
  shared_ptr<double> averageAbandonedInRingTime{};
  shared_ptr<double> averageFirstResponseTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageResponseTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWaitTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsAbandonedInQueue{};
  shared_ptr<long> callsAbandonedInRing{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsOverflow{};
  shared_ptr<long> callsQueued{};
  shared_ptr<long> callsQueuingOverflow{};
  shared_ptr<long> callsQueuingTimeout{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> callsTimeout{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxAbandonTime{};
  shared_ptr<long> maxAbandonedInQueueTime{};
  shared_ptr<long> maxAbandonedInRingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalAbandonTime{};
  shared_ptr<long> totalAbandonedInQueueTime{};
  shared_ptr<long> totalAbandonedInRingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalMessagesSent{};
  shared_ptr<long> totalMessagesSentByAgent{};
  shared_ptr<long> totalMessagesSentByCustomer{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalSkillGroupReportResponseBodyDataInbound() {}

  explicit ListIntervalSkillGroupReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonRate) {
      res["AbandonRate"] = boost::any(*abandonRate);
    }
    if (averageAbandonTime) {
      res["AverageAbandonTime"] = boost::any(*averageAbandonTime);
    }
    if (averageAbandonedInQueueTime) {
      res["AverageAbandonedInQueueTime"] = boost::any(*averageAbandonedInQueueTime);
    }
    if (averageAbandonedInRingTime) {
      res["AverageAbandonedInRingTime"] = boost::any(*averageAbandonedInRingTime);
    }
    if (averageFirstResponseTime) {
      res["AverageFirstResponseTime"] = boost::any(*averageFirstResponseTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageResponseTime) {
      res["AverageResponseTime"] = boost::any(*averageResponseTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    if (callsAbandonedInRing) {
      res["CallsAbandonedInRing"] = boost::any(*callsAbandonedInRing);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsOverflow) {
      res["CallsOverflow"] = boost::any(*callsOverflow);
    }
    if (callsQueued) {
      res["CallsQueued"] = boost::any(*callsQueued);
    }
    if (callsQueuingOverflow) {
      res["CallsQueuingOverflow"] = boost::any(*callsQueuingOverflow);
    }
    if (callsQueuingTimeout) {
      res["CallsQueuingTimeout"] = boost::any(*callsQueuingTimeout);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (callsTimeout) {
      res["CallsTimeout"] = boost::any(*callsTimeout);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxAbandonTime) {
      res["MaxAbandonTime"] = boost::any(*maxAbandonTime);
    }
    if (maxAbandonedInQueueTime) {
      res["MaxAbandonedInQueueTime"] = boost::any(*maxAbandonedInQueueTime);
    }
    if (maxAbandonedInRingTime) {
      res["MaxAbandonedInRingTime"] = boost::any(*maxAbandonedInRingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalAbandonTime) {
      res["TotalAbandonTime"] = boost::any(*totalAbandonTime);
    }
    if (totalAbandonedInQueueTime) {
      res["TotalAbandonedInQueueTime"] = boost::any(*totalAbandonedInQueueTime);
    }
    if (totalAbandonedInRingTime) {
      res["TotalAbandonedInRingTime"] = boost::any(*totalAbandonedInRingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalMessagesSent) {
      res["TotalMessagesSent"] = boost::any(*totalMessagesSent);
    }
    if (totalMessagesSentByAgent) {
      res["TotalMessagesSentByAgent"] = boost::any(*totalMessagesSentByAgent);
    }
    if (totalMessagesSentByCustomer) {
      res["TotalMessagesSentByCustomer"] = boost::any(*totalMessagesSentByCustomer);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonRate") != m.end() && !m["AbandonRate"].empty()) {
      abandonRate = make_shared<double>(boost::any_cast<double>(m["AbandonRate"]));
    }
    if (m.find("AverageAbandonTime") != m.end() && !m["AverageAbandonTime"].empty()) {
      averageAbandonTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonTime"]));
    }
    if (m.find("AverageAbandonedInQueueTime") != m.end() && !m["AverageAbandonedInQueueTime"].empty()) {
      averageAbandonedInQueueTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInQueueTime"]));
    }
    if (m.find("AverageAbandonedInRingTime") != m.end() && !m["AverageAbandonedInRingTime"].empty()) {
      averageAbandonedInRingTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInRingTime"]));
    }
    if (m.find("AverageFirstResponseTime") != m.end() && !m["AverageFirstResponseTime"].empty()) {
      averageFirstResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageFirstResponseTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageResponseTime") != m.end() && !m["AverageResponseTime"].empty()) {
      averageResponseTime = make_shared<double>(boost::any_cast<double>(m["AverageResponseTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<double>(boost::any_cast<double>(m["AverageWaitTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
    if (m.find("CallsAbandonedInRing") != m.end() && !m["CallsAbandonedInRing"].empty()) {
      callsAbandonedInRing = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInRing"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsOverflow") != m.end() && !m["CallsOverflow"].empty()) {
      callsOverflow = make_shared<long>(boost::any_cast<long>(m["CallsOverflow"]));
    }
    if (m.find("CallsQueued") != m.end() && !m["CallsQueued"].empty()) {
      callsQueued = make_shared<long>(boost::any_cast<long>(m["CallsQueued"]));
    }
    if (m.find("CallsQueuingOverflow") != m.end() && !m["CallsQueuingOverflow"].empty()) {
      callsQueuingOverflow = make_shared<long>(boost::any_cast<long>(m["CallsQueuingOverflow"]));
    }
    if (m.find("CallsQueuingTimeout") != m.end() && !m["CallsQueuingTimeout"].empty()) {
      callsQueuingTimeout = make_shared<long>(boost::any_cast<long>(m["CallsQueuingTimeout"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("CallsTimeout") != m.end() && !m["CallsTimeout"].empty()) {
      callsTimeout = make_shared<long>(boost::any_cast<long>(m["CallsTimeout"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxAbandonTime") != m.end() && !m["MaxAbandonTime"].empty()) {
      maxAbandonTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonTime"]));
    }
    if (m.find("MaxAbandonedInQueueTime") != m.end() && !m["MaxAbandonedInQueueTime"].empty()) {
      maxAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInQueueTime"]));
    }
    if (m.find("MaxAbandonedInRingTime") != m.end() && !m["MaxAbandonedInRingTime"].empty()) {
      maxAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInRingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalAbandonTime") != m.end() && !m["TotalAbandonTime"].empty()) {
      totalAbandonTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonTime"]));
    }
    if (m.find("TotalAbandonedInQueueTime") != m.end() && !m["TotalAbandonedInQueueTime"].empty()) {
      totalAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInQueueTime"]));
    }
    if (m.find("TotalAbandonedInRingTime") != m.end() && !m["TotalAbandonedInRingTime"].empty()) {
      totalAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInRingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalMessagesSent") != m.end() && !m["TotalMessagesSent"].empty()) {
      totalMessagesSent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSent"]));
    }
    if (m.find("TotalMessagesSentByAgent") != m.end() && !m["TotalMessagesSentByAgent"].empty()) {
      totalMessagesSentByAgent = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByAgent"]));
    }
    if (m.find("TotalMessagesSentByCustomer") != m.end() && !m["TotalMessagesSentByCustomer"].empty()) {
      totalMessagesSentByCustomer = make_shared<long>(boost::any_cast<long>(m["TotalMessagesSentByCustomer"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBodyDataInbound() = default;
};
class ListIntervalSkillGroupReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalSkillGroupReportResponseBodyDataOutbound() {}

  explicit ListIntervalSkillGroupReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBodyDataOutbound() = default;
};
class ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<long> count{};
  shared_ptr<long> duration{};

  ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList() {}

  explicit ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList() = default;
};
class ListIntervalSkillGroupReportResponseBodyDataOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<vector<ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList>> breakCodeDetailList{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalSkillGroupReportResponseBodyDataOverall() {}

  explicit ListIntervalSkillGroupReportResponseBodyDataOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (breakCodeDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*breakCodeDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BreakCodeDetailList"] = boost::any(temp1);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("BreakCodeDetailList") != m.end() && !m["BreakCodeDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["BreakCodeDetailList"].type()) {
        vector<ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BreakCodeDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        breakCodeDetailList = make_shared<vector<ListIntervalSkillGroupReportResponseBodyDataOverallBreakCodeDetailList>>(expect1);
      }
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBodyDataOverall() = default;
};
class ListIntervalSkillGroupReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListIntervalSkillGroupReportResponseBodyDataBack2Back> back2Back{};
  shared_ptr<ListIntervalSkillGroupReportResponseBodyDataInbound> inbound{};
  shared_ptr<ListIntervalSkillGroupReportResponseBodyDataOutbound> outbound{};
  shared_ptr<ListIntervalSkillGroupReportResponseBodyDataOverall> overall{};
  shared_ptr<long> statsTime{};

  ListIntervalSkillGroupReportResponseBodyData() {}

  explicit ListIntervalSkillGroupReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (back2Back) {
      res["Back2Back"] = back2Back ? boost::any(back2Back->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Back2Back") != m.end() && !m["Back2Back"].empty()) {
      if (typeid(map<string, boost::any>) == m["Back2Back"].type()) {
        ListIntervalSkillGroupReportResponseBodyDataBack2Back model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Back2Back"]));
        back2Back = make_shared<ListIntervalSkillGroupReportResponseBodyDataBack2Back>(model1);
      }
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListIntervalSkillGroupReportResponseBodyDataInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListIntervalSkillGroupReportResponseBodyDataInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListIntervalSkillGroupReportResponseBodyDataOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListIntervalSkillGroupReportResponseBodyDataOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListIntervalSkillGroupReportResponseBodyDataOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListIntervalSkillGroupReportResponseBodyDataOverall>(model1);
      }
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBodyData() = default;
};
class ListIntervalSkillGroupReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListIntervalSkillGroupReportResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListIntervalSkillGroupReportResponseBody() {}

  explicit ListIntervalSkillGroupReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListIntervalSkillGroupReportResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalSkillGroupReportResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIntervalSkillGroupReportResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBody() = default;
};
class ListIntervalSkillGroupReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntervalSkillGroupReportResponseBody> body{};

  ListIntervalSkillGroupReportResponse() {}

  explicit ListIntervalSkillGroupReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntervalSkillGroupReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntervalSkillGroupReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntervalSkillGroupReportResponse() = default;
};
class ListIvrTrackingDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListIvrTrackingDetailsRequest() {}

  explicit ListIvrTrackingDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListIvrTrackingDetailsRequest() = default;
};
class ListIvrTrackingDetailsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelVariables{};
  shared_ptr<string> contactId{};
  shared_ptr<long> enterTime{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowName{};
  shared_ptr<string> instance{};
  shared_ptr<long> leaveTime{};
  shared_ptr<string> nodeExitCode{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<map<string, boost::any>> nodeProperties{};
  shared_ptr<string> nodeType{};
  shared_ptr<map<string, boost::any>> nodeVariables{};

  ListIvrTrackingDetailsResponseBodyDataList() {}

  explicit ListIvrTrackingDetailsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelVariables) {
      res["ChannelVariables"] = boost::any(*channelVariables);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (enterTime) {
      res["EnterTime"] = boost::any(*enterTime);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (leaveTime) {
      res["LeaveTime"] = boost::any(*leaveTime);
    }
    if (nodeExitCode) {
      res["NodeExitCode"] = boost::any(*nodeExitCode);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeProperties) {
      res["NodeProperties"] = boost::any(*nodeProperties);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (nodeVariables) {
      res["NodeVariables"] = boost::any(*nodeVariables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelVariables") != m.end() && !m["ChannelVariables"].empty()) {
      channelVariables = make_shared<string>(boost::any_cast<string>(m["ChannelVariables"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("EnterTime") != m.end() && !m["EnterTime"].empty()) {
      enterTime = make_shared<long>(boost::any_cast<long>(m["EnterTime"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("LeaveTime") != m.end() && !m["LeaveTime"].empty()) {
      leaveTime = make_shared<long>(boost::any_cast<long>(m["LeaveTime"]));
    }
    if (m.find("NodeExitCode") != m.end() && !m["NodeExitCode"].empty()) {
      nodeExitCode = make_shared<string>(boost::any_cast<string>(m["NodeExitCode"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeProperties") != m.end() && !m["NodeProperties"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["NodeProperties"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      nodeProperties = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("NodeVariables") != m.end() && !m["NodeVariables"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["NodeVariables"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      nodeVariables = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListIvrTrackingDetailsResponseBodyDataList() = default;
};
class ListIvrTrackingDetailsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListIvrTrackingDetailsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListIvrTrackingDetailsResponseBodyData() {}

  explicit ListIvrTrackingDetailsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListIvrTrackingDetailsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIvrTrackingDetailsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListIvrTrackingDetailsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListIvrTrackingDetailsResponseBodyData() = default;
};
class ListIvrTrackingDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListIvrTrackingDetailsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListIvrTrackingDetailsResponseBody() {}

  explicit ListIvrTrackingDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListIvrTrackingDetailsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListIvrTrackingDetailsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIvrTrackingDetailsResponseBody() = default;
};
class ListIvrTrackingDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIvrTrackingDetailsResponseBody> body{};

  ListIvrTrackingDetailsResponse() {}

  explicit ListIvrTrackingDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIvrTrackingDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIvrTrackingDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~ListIvrTrackingDetailsResponse() = default;
};
class ListLegacyAgentEventLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListLegacyAgentEventLogsRequest() {}

  explicit ListLegacyAgentEventLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListLegacyAgentEventLogsRequest() = default;
};
class ListLegacyAgentEventLogsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentDropCall{};
  shared_ptr<string> agentNo{};
  shared_ptr<string> callDir{};
  shared_ptr<string> callId{};
  shared_ptr<string> callMode{};
  shared_ptr<string> callType{};
  shared_ptr<string> calleeId{};
  shared_ptr<string> callerId{};
  shared_ptr<string> connId{};
  shared_ptr<string> event{};
  shared_ptr<string> groupNo{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<string> phoneNo{};
  shared_ptr<string> statisticDate{};
  shared_ptr<string> targetRequest{};
  shared_ptr<string> targetSelect{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> transferNumber{};

  ListLegacyAgentEventLogsResponseBodyDataList() {}

  explicit ListLegacyAgentEventLogsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentDropCall) {
      res["AgentDropCall"] = boost::any(*agentDropCall);
    }
    if (agentNo) {
      res["AgentNo"] = boost::any(*agentNo);
    }
    if (callDir) {
      res["CallDir"] = boost::any(*callDir);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callMode) {
      res["CallMode"] = boost::any(*callMode);
    }
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (calleeId) {
      res["CalleeId"] = boost::any(*calleeId);
    }
    if (callerId) {
      res["CallerId"] = boost::any(*callerId);
    }
    if (connId) {
      res["ConnId"] = boost::any(*connId);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (groupNo) {
      res["GroupNo"] = boost::any(*groupNo);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (phoneNo) {
      res["PhoneNo"] = boost::any(*phoneNo);
    }
    if (statisticDate) {
      res["StatisticDate"] = boost::any(*statisticDate);
    }
    if (targetRequest) {
      res["TargetRequest"] = boost::any(*targetRequest);
    }
    if (targetSelect) {
      res["TargetSelect"] = boost::any(*targetSelect);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (transferNumber) {
      res["TransferNumber"] = boost::any(*transferNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentDropCall") != m.end() && !m["AgentDropCall"].empty()) {
      agentDropCall = make_shared<string>(boost::any_cast<string>(m["AgentDropCall"]));
    }
    if (m.find("AgentNo") != m.end() && !m["AgentNo"].empty()) {
      agentNo = make_shared<string>(boost::any_cast<string>(m["AgentNo"]));
    }
    if (m.find("CallDir") != m.end() && !m["CallDir"].empty()) {
      callDir = make_shared<string>(boost::any_cast<string>(m["CallDir"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallMode") != m.end() && !m["CallMode"].empty()) {
      callMode = make_shared<string>(boost::any_cast<string>(m["CallMode"]));
    }
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("CalleeId") != m.end() && !m["CalleeId"].empty()) {
      calleeId = make_shared<string>(boost::any_cast<string>(m["CalleeId"]));
    }
    if (m.find("CallerId") != m.end() && !m["CallerId"].empty()) {
      callerId = make_shared<string>(boost::any_cast<string>(m["CallerId"]));
    }
    if (m.find("ConnId") != m.end() && !m["ConnId"].empty()) {
      connId = make_shared<string>(boost::any_cast<string>(m["ConnId"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("GroupNo") != m.end() && !m["GroupNo"].empty()) {
      groupNo = make_shared<string>(boost::any_cast<string>(m["GroupNo"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("PhoneNo") != m.end() && !m["PhoneNo"].empty()) {
      phoneNo = make_shared<string>(boost::any_cast<string>(m["PhoneNo"]));
    }
    if (m.find("StatisticDate") != m.end() && !m["StatisticDate"].empty()) {
      statisticDate = make_shared<string>(boost::any_cast<string>(m["StatisticDate"]));
    }
    if (m.find("TargetRequest") != m.end() && !m["TargetRequest"].empty()) {
      targetRequest = make_shared<string>(boost::any_cast<string>(m["TargetRequest"]));
    }
    if (m.find("TargetSelect") != m.end() && !m["TargetSelect"].empty()) {
      targetSelect = make_shared<string>(boost::any_cast<string>(m["TargetSelect"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TransferNumber") != m.end() && !m["TransferNumber"].empty()) {
      transferNumber = make_shared<string>(boost::any_cast<string>(m["TransferNumber"]));
    }
  }


  virtual ~ListLegacyAgentEventLogsResponseBodyDataList() = default;
};
class ListLegacyAgentEventLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListLegacyAgentEventLogsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListLegacyAgentEventLogsResponseBodyData() {}

  explicit ListLegacyAgentEventLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListLegacyAgentEventLogsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLegacyAgentEventLogsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListLegacyAgentEventLogsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLegacyAgentEventLogsResponseBodyData() = default;
};
class ListLegacyAgentEventLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListLegacyAgentEventLogsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLegacyAgentEventLogsResponseBody() {}

  explicit ListLegacyAgentEventLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListLegacyAgentEventLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListLegacyAgentEventLogsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLegacyAgentEventLogsResponseBody() = default;
};
class ListLegacyAgentEventLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLegacyAgentEventLogsResponseBody> body{};

  ListLegacyAgentEventLogsResponse() {}

  explicit ListLegacyAgentEventLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLegacyAgentEventLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLegacyAgentEventLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLegacyAgentEventLogsResponse() = default;
};
class ListLegacyAgentStatusLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListLegacyAgentStatusLogsRequest() {}

  explicit ListLegacyAgentStatusLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListLegacyAgentStatusLogsRequest() = default;
};
class ListLegacyAgentStatusLogsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentDropCall{};
  shared_ptr<string> agentNo{};
  shared_ptr<string> aliHangupCause{};
  shared_ptr<string> callDir{};
  shared_ptr<string> callId{};
  shared_ptr<string> callType{};
  shared_ptr<string> calleeId{};
  shared_ptr<string> callerId{};
  shared_ptr<string> connId{};
  shared_ptr<string> extend1{};
  shared_ptr<string> extend2{};
  shared_ptr<string> extend3{};
  shared_ptr<string> extend4{};
  shared_ptr<string> groupNo{};
  shared_ptr<string> monitedAgentNo{};
  shared_ptr<string> monitedAgentPhoneNo{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<string> phoneNo{};
  shared_ptr<string> statisticDate{};
  shared_ptr<long> statisticTime{};
  shared_ptr<string> status{};
  shared_ptr<string> targetRequest{};
  shared_ptr<string> targetSelect{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> transferNo{};
  shared_ptr<string> transferNumber{};

  ListLegacyAgentStatusLogsResponseBodyDataList() {}

  explicit ListLegacyAgentStatusLogsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentDropCall) {
      res["AgentDropCall"] = boost::any(*agentDropCall);
    }
    if (agentNo) {
      res["AgentNo"] = boost::any(*agentNo);
    }
    if (aliHangupCause) {
      res["AliHangupCause"] = boost::any(*aliHangupCause);
    }
    if (callDir) {
      res["CallDir"] = boost::any(*callDir);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (calleeId) {
      res["CalleeId"] = boost::any(*calleeId);
    }
    if (callerId) {
      res["CallerId"] = boost::any(*callerId);
    }
    if (connId) {
      res["ConnId"] = boost::any(*connId);
    }
    if (extend1) {
      res["Extend1"] = boost::any(*extend1);
    }
    if (extend2) {
      res["Extend2"] = boost::any(*extend2);
    }
    if (extend3) {
      res["Extend3"] = boost::any(*extend3);
    }
    if (extend4) {
      res["Extend4"] = boost::any(*extend4);
    }
    if (groupNo) {
      res["GroupNo"] = boost::any(*groupNo);
    }
    if (monitedAgentNo) {
      res["MonitedAgentNo"] = boost::any(*monitedAgentNo);
    }
    if (monitedAgentPhoneNo) {
      res["MonitedAgentPhoneNo"] = boost::any(*monitedAgentPhoneNo);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (phoneNo) {
      res["PhoneNo"] = boost::any(*phoneNo);
    }
    if (statisticDate) {
      res["StatisticDate"] = boost::any(*statisticDate);
    }
    if (statisticTime) {
      res["StatisticTime"] = boost::any(*statisticTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetRequest) {
      res["TargetRequest"] = boost::any(*targetRequest);
    }
    if (targetSelect) {
      res["TargetSelect"] = boost::any(*targetSelect);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (transferNo) {
      res["TransferNo"] = boost::any(*transferNo);
    }
    if (transferNumber) {
      res["TransferNumber"] = boost::any(*transferNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentDropCall") != m.end() && !m["AgentDropCall"].empty()) {
      agentDropCall = make_shared<string>(boost::any_cast<string>(m["AgentDropCall"]));
    }
    if (m.find("AgentNo") != m.end() && !m["AgentNo"].empty()) {
      agentNo = make_shared<string>(boost::any_cast<string>(m["AgentNo"]));
    }
    if (m.find("AliHangupCause") != m.end() && !m["AliHangupCause"].empty()) {
      aliHangupCause = make_shared<string>(boost::any_cast<string>(m["AliHangupCause"]));
    }
    if (m.find("CallDir") != m.end() && !m["CallDir"].empty()) {
      callDir = make_shared<string>(boost::any_cast<string>(m["CallDir"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("CalleeId") != m.end() && !m["CalleeId"].empty()) {
      calleeId = make_shared<string>(boost::any_cast<string>(m["CalleeId"]));
    }
    if (m.find("CallerId") != m.end() && !m["CallerId"].empty()) {
      callerId = make_shared<string>(boost::any_cast<string>(m["CallerId"]));
    }
    if (m.find("ConnId") != m.end() && !m["ConnId"].empty()) {
      connId = make_shared<string>(boost::any_cast<string>(m["ConnId"]));
    }
    if (m.find("Extend1") != m.end() && !m["Extend1"].empty()) {
      extend1 = make_shared<string>(boost::any_cast<string>(m["Extend1"]));
    }
    if (m.find("Extend2") != m.end() && !m["Extend2"].empty()) {
      extend2 = make_shared<string>(boost::any_cast<string>(m["Extend2"]));
    }
    if (m.find("Extend3") != m.end() && !m["Extend3"].empty()) {
      extend3 = make_shared<string>(boost::any_cast<string>(m["Extend3"]));
    }
    if (m.find("Extend4") != m.end() && !m["Extend4"].empty()) {
      extend4 = make_shared<string>(boost::any_cast<string>(m["Extend4"]));
    }
    if (m.find("GroupNo") != m.end() && !m["GroupNo"].empty()) {
      groupNo = make_shared<string>(boost::any_cast<string>(m["GroupNo"]));
    }
    if (m.find("MonitedAgentNo") != m.end() && !m["MonitedAgentNo"].empty()) {
      monitedAgentNo = make_shared<string>(boost::any_cast<string>(m["MonitedAgentNo"]));
    }
    if (m.find("MonitedAgentPhoneNo") != m.end() && !m["MonitedAgentPhoneNo"].empty()) {
      monitedAgentPhoneNo = make_shared<string>(boost::any_cast<string>(m["MonitedAgentPhoneNo"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("PhoneNo") != m.end() && !m["PhoneNo"].empty()) {
      phoneNo = make_shared<string>(boost::any_cast<string>(m["PhoneNo"]));
    }
    if (m.find("StatisticDate") != m.end() && !m["StatisticDate"].empty()) {
      statisticDate = make_shared<string>(boost::any_cast<string>(m["StatisticDate"]));
    }
    if (m.find("StatisticTime") != m.end() && !m["StatisticTime"].empty()) {
      statisticTime = make_shared<long>(boost::any_cast<long>(m["StatisticTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetRequest") != m.end() && !m["TargetRequest"].empty()) {
      targetRequest = make_shared<string>(boost::any_cast<string>(m["TargetRequest"]));
    }
    if (m.find("TargetSelect") != m.end() && !m["TargetSelect"].empty()) {
      targetSelect = make_shared<string>(boost::any_cast<string>(m["TargetSelect"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TransferNo") != m.end() && !m["TransferNo"].empty()) {
      transferNo = make_shared<string>(boost::any_cast<string>(m["TransferNo"]));
    }
    if (m.find("TransferNumber") != m.end() && !m["TransferNumber"].empty()) {
      transferNumber = make_shared<string>(boost::any_cast<string>(m["TransferNumber"]));
    }
  }


  virtual ~ListLegacyAgentStatusLogsResponseBodyDataList() = default;
};
class ListLegacyAgentStatusLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListLegacyAgentStatusLogsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListLegacyAgentStatusLogsResponseBodyData() {}

  explicit ListLegacyAgentStatusLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListLegacyAgentStatusLogsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLegacyAgentStatusLogsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListLegacyAgentStatusLogsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLegacyAgentStatusLogsResponseBodyData() = default;
};
class ListLegacyAgentStatusLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListLegacyAgentStatusLogsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLegacyAgentStatusLogsResponseBody() {}

  explicit ListLegacyAgentStatusLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListLegacyAgentStatusLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListLegacyAgentStatusLogsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLegacyAgentStatusLogsResponseBody() = default;
};
class ListLegacyAgentStatusLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLegacyAgentStatusLogsResponseBody> body{};

  ListLegacyAgentStatusLogsResponse() {}

  explicit ListLegacyAgentStatusLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLegacyAgentStatusLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLegacyAgentStatusLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLegacyAgentStatusLogsResponse() = default;
};
class ListLegacyAppraiseLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListLegacyAppraiseLogsRequest() {}

  explicit ListLegacyAppraiseLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListLegacyAppraiseLogsRequest() = default;
};
class ListLegacyAppraiseLogsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> acid{};
  shared_ptr<string> contactType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> keyMarkRelation{};
  shared_ptr<string> note{};
  shared_ptr<string> parentNote{};
  shared_ptr<string> pressKey{};
  shared_ptr<string> ramId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> statisticDate{};
  shared_ptr<string> type{};

  ListLegacyAppraiseLogsResponseBodyDataList() {}

  explicit ListLegacyAppraiseLogsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acid) {
      res["Acid"] = boost::any(*acid);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (keyMarkRelation) {
      res["KeyMarkRelation"] = boost::any(*keyMarkRelation);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (parentNote) {
      res["ParentNote"] = boost::any(*parentNote);
    }
    if (pressKey) {
      res["PressKey"] = boost::any(*pressKey);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (statisticDate) {
      res["StatisticDate"] = boost::any(*statisticDate);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acid") != m.end() && !m["Acid"].empty()) {
      acid = make_shared<string>(boost::any_cast<string>(m["Acid"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("KeyMarkRelation") != m.end() && !m["KeyMarkRelation"].empty()) {
      keyMarkRelation = make_shared<string>(boost::any_cast<string>(m["KeyMarkRelation"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("ParentNote") != m.end() && !m["ParentNote"].empty()) {
      parentNote = make_shared<string>(boost::any_cast<string>(m["ParentNote"]));
    }
    if (m.find("PressKey") != m.end() && !m["PressKey"].empty()) {
      pressKey = make_shared<string>(boost::any_cast<string>(m["PressKey"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StatisticDate") != m.end() && !m["StatisticDate"].empty()) {
      statisticDate = make_shared<string>(boost::any_cast<string>(m["StatisticDate"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLegacyAppraiseLogsResponseBodyDataList() = default;
};
class ListLegacyAppraiseLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListLegacyAppraiseLogsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListLegacyAppraiseLogsResponseBodyData() {}

  explicit ListLegacyAppraiseLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListLegacyAppraiseLogsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLegacyAppraiseLogsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListLegacyAppraiseLogsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLegacyAppraiseLogsResponseBodyData() = default;
};
class ListLegacyAppraiseLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListLegacyAppraiseLogsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLegacyAppraiseLogsResponseBody() {}

  explicit ListLegacyAppraiseLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListLegacyAppraiseLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListLegacyAppraiseLogsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLegacyAppraiseLogsResponseBody() = default;
};
class ListLegacyAppraiseLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLegacyAppraiseLogsResponseBody> body{};

  ListLegacyAppraiseLogsResponse() {}

  explicit ListLegacyAppraiseLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLegacyAppraiseLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLegacyAppraiseLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLegacyAppraiseLogsResponse() = default;
};
class ListLegacyQueueEventLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> startTime{};

  ListLegacyQueueEventLogsRequest() {}

  explicit ListLegacyQueueEventLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListLegacyQueueEventLogsRequest() = default;
};
class ListLegacyQueueEventLogsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> acid{};
  shared_ptr<string> ani{};
  shared_ptr<string> answerPhone{};
  shared_ptr<long> answerTime{};
  shared_ptr<string> cause{};
  shared_ptr<string> dnis{};
  shared_ptr<long> id{};
  shared_ptr<long> queueTime{};
  shared_ptr<string> statisticDate{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> vq{};

  ListLegacyQueueEventLogsResponseBodyDataList() {}

  explicit ListLegacyQueueEventLogsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acid) {
      res["Acid"] = boost::any(*acid);
    }
    if (ani) {
      res["Ani"] = boost::any(*ani);
    }
    if (answerPhone) {
      res["AnswerPhone"] = boost::any(*answerPhone);
    }
    if (answerTime) {
      res["AnswerTime"] = boost::any(*answerTime);
    }
    if (cause) {
      res["Cause"] = boost::any(*cause);
    }
    if (dnis) {
      res["Dnis"] = boost::any(*dnis);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (statisticDate) {
      res["StatisticDate"] = boost::any(*statisticDate);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (vq) {
      res["Vq"] = boost::any(*vq);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acid") != m.end() && !m["Acid"].empty()) {
      acid = make_shared<string>(boost::any_cast<string>(m["Acid"]));
    }
    if (m.find("Ani") != m.end() && !m["Ani"].empty()) {
      ani = make_shared<string>(boost::any_cast<string>(m["Ani"]));
    }
    if (m.find("AnswerPhone") != m.end() && !m["AnswerPhone"].empty()) {
      answerPhone = make_shared<string>(boost::any_cast<string>(m["AnswerPhone"]));
    }
    if (m.find("AnswerTime") != m.end() && !m["AnswerTime"].empty()) {
      answerTime = make_shared<long>(boost::any_cast<long>(m["AnswerTime"]));
    }
    if (m.find("Cause") != m.end() && !m["Cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["Cause"]));
    }
    if (m.find("Dnis") != m.end() && !m["Dnis"].empty()) {
      dnis = make_shared<string>(boost::any_cast<string>(m["Dnis"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<long>(boost::any_cast<long>(m["QueueTime"]));
    }
    if (m.find("StatisticDate") != m.end() && !m["StatisticDate"].empty()) {
      statisticDate = make_shared<string>(boost::any_cast<string>(m["StatisticDate"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Vq") != m.end() && !m["Vq"].empty()) {
      vq = make_shared<string>(boost::any_cast<string>(m["Vq"]));
    }
  }


  virtual ~ListLegacyQueueEventLogsResponseBodyDataList() = default;
};
class ListLegacyQueueEventLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListLegacyQueueEventLogsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListLegacyQueueEventLogsResponseBodyData() {}

  explicit ListLegacyQueueEventLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListLegacyQueueEventLogsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLegacyQueueEventLogsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListLegacyQueueEventLogsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLegacyQueueEventLogsResponseBodyData() = default;
};
class ListLegacyQueueEventLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListLegacyQueueEventLogsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLegacyQueueEventLogsResponseBody() {}

  explicit ListLegacyQueueEventLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListLegacyQueueEventLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListLegacyQueueEventLogsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLegacyQueueEventLogsResponseBody() = default;
};
class ListLegacyQueueEventLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLegacyQueueEventLogsResponseBody> body{};

  ListLegacyQueueEventLogsResponse() {}

  explicit ListLegacyQueueEventLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLegacyQueueEventLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLegacyQueueEventLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLegacyQueueEventLogsResponse() = default;
};
class ListMonoRecordingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  ListMonoRecordingsRequest() {}

  explicit ListMonoRecordingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListMonoRecordingsRequest() = default;
};
class ListMonoRecordingsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> contactId{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> ramId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> startTime{};

  ListMonoRecordingsResponseBodyData() {}

  explicit ListMonoRecordingsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListMonoRecordingsResponseBodyData() = default;
};
class ListMonoRecordingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListMonoRecordingsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListMonoRecordingsResponseBody() {}

  explicit ListMonoRecordingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListMonoRecordingsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMonoRecordingsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListMonoRecordingsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMonoRecordingsResponseBody() = default;
};
class ListMonoRecordingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMonoRecordingsResponseBody> body{};

  ListMonoRecordingsResponse() {}

  explicit ListMonoRecordingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMonoRecordingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMonoRecordingsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMonoRecordingsResponse() = default;
};
class ListMultiChannelRecordingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  ListMultiChannelRecordingsRequest() {}

  explicit ListMultiChannelRecordingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListMultiChannelRecordingsRequest() = default;
};
class ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments() {}

  explicit ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments() = default;
};
class ListMultiChannelRecordingsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentChannelId{};
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> contactId{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};
  shared_ptr<vector<ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments>> holdTimeSegments{};
  shared_ptr<string> ramId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> startTime{};

  ListMultiChannelRecordingsResponseBodyData() {}

  explicit ListMultiChannelRecordingsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentChannelId) {
      res["AgentChannelId"] = boost::any(*agentChannelId);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (holdTimeSegments) {
      vector<boost::any> temp1;
      for(auto item1:*holdTimeSegments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HoldTimeSegments"] = boost::any(temp1);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentChannelId") != m.end() && !m["AgentChannelId"].empty()) {
      agentChannelId = make_shared<string>(boost::any_cast<string>(m["AgentChannelId"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("HoldTimeSegments") != m.end() && !m["HoldTimeSegments"].empty()) {
      if (typeid(vector<boost::any>) == m["HoldTimeSegments"].type()) {
        vector<ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HoldTimeSegments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        holdTimeSegments = make_shared<vector<ListMultiChannelRecordingsResponseBodyDataHoldTimeSegments>>(expect1);
      }
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListMultiChannelRecordingsResponseBodyData() = default;
};
class ListMultiChannelRecordingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListMultiChannelRecordingsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListMultiChannelRecordingsResponseBody() {}

  explicit ListMultiChannelRecordingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListMultiChannelRecordingsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMultiChannelRecordingsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListMultiChannelRecordingsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMultiChannelRecordingsResponseBody() = default;
};
class ListMultiChannelRecordingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMultiChannelRecordingsResponseBody> body{};

  ListMultiChannelRecordingsResponse() {}

  explicit ListMultiChannelRecordingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMultiChannelRecordingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMultiChannelRecordingsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMultiChannelRecordingsResponse() = default;
};
class ListOutboundNumbersOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupIdList{};
  shared_ptr<string> userId{};

  ListOutboundNumbersOfUserRequest() {}

  explicit ListOutboundNumbersOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListOutboundNumbersOfUserRequest() = default;
};
class ListOutboundNumbersOfUserResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  ListOutboundNumbersOfUserResponseBodyDataList() {}

  explicit ListOutboundNumbersOfUserResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~ListOutboundNumbersOfUserResponseBodyDataList() = default;
};
class ListOutboundNumbersOfUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOutboundNumbersOfUserResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListOutboundNumbersOfUserResponseBodyData() {}

  explicit ListOutboundNumbersOfUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListOutboundNumbersOfUserResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOutboundNumbersOfUserResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListOutboundNumbersOfUserResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOutboundNumbersOfUserResponseBodyData() = default;
};
class ListOutboundNumbersOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListOutboundNumbersOfUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListOutboundNumbersOfUserResponseBody() {}

  explicit ListOutboundNumbersOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOutboundNumbersOfUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOutboundNumbersOfUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListOutboundNumbersOfUserResponseBody() = default;
};
class ListOutboundNumbersOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOutboundNumbersOfUserResponseBody> body{};

  ListOutboundNumbersOfUserResponse() {}

  explicit ListOutboundNumbersOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOutboundNumbersOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOutboundNumbersOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListOutboundNumbersOfUserResponse() = default;
};
class ListPersonalNumbersOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isMember{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> userId{};

  ListPersonalNumbersOfUserRequest() {}

  explicit ListPersonalNumbersOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isMember) {
      res["IsMember"] = boost::any(*isMember);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsMember") != m.end() && !m["IsMember"].empty()) {
      isMember = make_shared<bool>(boost::any_cast<bool>(m["IsMember"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListPersonalNumbersOfUserRequest() = default;
};
class ListPersonalNumbersOfUserResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  ListPersonalNumbersOfUserResponseBodyDataList() {}

  explicit ListPersonalNumbersOfUserResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~ListPersonalNumbersOfUserResponseBodyDataList() = default;
};
class ListPersonalNumbersOfUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListPersonalNumbersOfUserResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListPersonalNumbersOfUserResponseBodyData() {}

  explicit ListPersonalNumbersOfUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListPersonalNumbersOfUserResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPersonalNumbersOfUserResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListPersonalNumbersOfUserResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPersonalNumbersOfUserResponseBodyData() = default;
};
class ListPersonalNumbersOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListPersonalNumbersOfUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPersonalNumbersOfUserResponseBody() {}

  explicit ListPersonalNumbersOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListPersonalNumbersOfUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListPersonalNumbersOfUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPersonalNumbersOfUserResponseBody() = default;
};
class ListPersonalNumbersOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPersonalNumbersOfUserResponseBody> body{};

  ListPersonalNumbersOfUserResponse() {}

  explicit ListPersonalNumbersOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPersonalNumbersOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPersonalNumbersOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListPersonalNumbersOfUserResponse() = default;
};
class ListPhoneNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> usage{};

  ListPhoneNumbersRequest() {}

  explicit ListPhoneNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ListPhoneNumbersRequest() = default;
};
class ListPhoneNumbersResponseBodyDataListSkillGroups : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> skillGroupId{};

  ListPhoneNumbersResponseBodyDataListSkillGroups() {}

  explicit ListPhoneNumbersResponseBodyDataListSkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBodyDataListSkillGroups() = default;
};
class ListPhoneNumbersResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> contactFlowName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> provider{};
  shared_ptr<string> province{};
  shared_ptr<vector<ListPhoneNumbersResponseBodyDataListSkillGroups>> skillGroups{};
  shared_ptr<string> tags{};
  shared_ptr<string> usage{};
  shared_ptr<string> userId{};

  ListPhoneNumbersResponseBodyDataList() {}

  explicit ListPhoneNumbersResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (contactFlowName) {
      res["ContactFlowName"] = boost::any(*contactFlowName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (skillGroups) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroups"] = boost::any(temp1);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("ContactFlowName") != m.end() && !m["ContactFlowName"].empty()) {
      contactFlowName = make_shared<string>(boost::any_cast<string>(m["ContactFlowName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroups"].type()) {
        vector<ListPhoneNumbersResponseBodyDataListSkillGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPhoneNumbersResponseBodyDataListSkillGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroups = make_shared<vector<ListPhoneNumbersResponseBodyDataListSkillGroups>>(expect1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBodyDataList() = default;
};
class ListPhoneNumbersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListPhoneNumbersResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListPhoneNumbersResponseBodyData() {}

  explicit ListPhoneNumbersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListPhoneNumbersResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPhoneNumbersResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListPhoneNumbersResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBodyData() = default;
};
class ListPhoneNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListPhoneNumbersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPhoneNumbersResponseBody() {}

  explicit ListPhoneNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListPhoneNumbersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListPhoneNumbersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBody() = default;
};
class ListPhoneNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPhoneNumbersResponseBody> body{};

  ListPhoneNumbersResponse() {}

  explicit ListPhoneNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPhoneNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPhoneNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ListPhoneNumbersResponse() = default;
};
class ListPhoneNumbersOfSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isMember{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> skillGroupId{};

  ListPhoneNumbersOfSkillGroupRequest() {}

  explicit ListPhoneNumbersOfSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isMember) {
      res["IsMember"] = boost::any(*isMember);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsMember") != m.end() && !m["IsMember"].empty()) {
      isMember = make_shared<bool>(boost::any_cast<bool>(m["IsMember"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListPhoneNumbersOfSkillGroupRequest() = default;
};
class ListPhoneNumbersOfSkillGroupResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};
  shared_ptr<string> usage{};

  ListPhoneNumbersOfSkillGroupResponseBodyDataList() {}

  explicit ListPhoneNumbersOfSkillGroupResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ListPhoneNumbersOfSkillGroupResponseBodyDataList() = default;
};
class ListPhoneNumbersOfSkillGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListPhoneNumbersOfSkillGroupResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListPhoneNumbersOfSkillGroupResponseBodyData() {}

  explicit ListPhoneNumbersOfSkillGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListPhoneNumbersOfSkillGroupResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPhoneNumbersOfSkillGroupResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListPhoneNumbersOfSkillGroupResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPhoneNumbersOfSkillGroupResponseBodyData() = default;
};
class ListPhoneNumbersOfSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListPhoneNumbersOfSkillGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPhoneNumbersOfSkillGroupResponseBody() {}

  explicit ListPhoneNumbersOfSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListPhoneNumbersOfSkillGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListPhoneNumbersOfSkillGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPhoneNumbersOfSkillGroupResponseBody() = default;
};
class ListPhoneNumbersOfSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPhoneNumbersOfSkillGroupResponseBody> body{};

  ListPhoneNumbersOfSkillGroupResponse() {}

  explicit ListPhoneNumbersOfSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPhoneNumbersOfSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPhoneNumbersOfSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListPhoneNumbersOfSkillGroupResponse() = default;
};
class ListPrivilegesOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListPrivilegesOfUserRequest() {}

  explicit ListPrivilegesOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListPrivilegesOfUserRequest() = default;
};
class ListPrivilegesOfUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> scope{};

  ListPrivilegesOfUserResponseBodyData() {}

  explicit ListPrivilegesOfUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~ListPrivilegesOfUserResponseBodyData() = default;
};
class ListPrivilegesOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListPrivilegesOfUserResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrivilegesOfUserResponseBody() {}

  explicit ListPrivilegesOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListPrivilegesOfUserResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrivilegesOfUserResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListPrivilegesOfUserResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrivilegesOfUserResponseBody() = default;
};
class ListPrivilegesOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrivilegesOfUserResponseBody> body{};

  ListPrivilegesOfUserResponse() {}

  explicit ListPrivilegesOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrivilegesOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrivilegesOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrivilegesOfUserResponse() = default;
};
class ListRamUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListRamUsersRequest() {}

  explicit ListRamUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListRamUsersRequest() = default;
};
class ListRamUsersResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> aliyunUid{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> primary{};
  shared_ptr<string> ramId{};

  ListRamUsersResponseBodyDataList() {}

  explicit ListRamUsersResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<long>(boost::any_cast<long>(m["AliyunUid"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
  }


  virtual ~ListRamUsersResponseBodyDataList() = default;
};
class ListRamUsersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRamUsersResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRamUsersResponseBodyData() {}

  explicit ListRamUsersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListRamUsersResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRamUsersResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListRamUsersResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRamUsersResponseBodyData() = default;
};
class ListRamUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListRamUsersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListRamUsersResponseBody() {}

  explicit ListRamUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRamUsersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRamUsersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRamUsersResponseBody() = default;
};
class ListRamUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRamUsersResponseBody> body{};

  ListRamUsersResponse() {}

  explicit ListRamUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRamUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRamUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListRamUsersResponse() = default;
};
class ListRealtimeAgentStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentIdList{};
  shared_ptr<string> agentName{};
  shared_ptr<string> callTypeList{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> stateList{};
  shared_ptr<string> workModeList{};

  ListRealtimeAgentStatesRequest() {}

  explicit ListRealtimeAgentStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIdList) {
      res["AgentIdList"] = boost::any(*agentIdList);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (callTypeList) {
      res["CallTypeList"] = boost::any(*callTypeList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (stateList) {
      res["StateList"] = boost::any(*stateList);
    }
    if (workModeList) {
      res["WorkModeList"] = boost::any(*workModeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIdList") != m.end() && !m["AgentIdList"].empty()) {
      agentIdList = make_shared<string>(boost::any_cast<string>(m["AgentIdList"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("CallTypeList") != m.end() && !m["CallTypeList"].empty()) {
      callTypeList = make_shared<string>(boost::any_cast<string>(m["CallTypeList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StateList") != m.end() && !m["StateList"].empty()) {
      stateList = make_shared<string>(boost::any_cast<string>(m["StateList"]));
    }
    if (m.find("WorkModeList") != m.end() && !m["WorkModeList"].empty()) {
      workModeList = make_shared<string>(boost::any_cast<string>(m["WorkModeList"]));
    }
  }


  virtual ~ListRealtimeAgentStatesRequest() = default;
};
class ListRealtimeAgentStatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> callType{};
  shared_ptr<string> counterParty{};
  shared_ptr<long> duration{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> skillGroupIdList{};
  shared_ptr<vector<string>> skillGroupNameList{};
  shared_ptr<string> state{};
  shared_ptr<string> stateCode{};
  shared_ptr<long> stateTime{};
  shared_ptr<string> workMode{};

  ListRealtimeAgentStatesResponseBodyDataList() {}

  explicit ListRealtimeAgentStatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (counterParty) {
      res["CounterParty"] = boost::any(*counterParty);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (skillGroupNameList) {
      res["SkillGroupNameList"] = boost::any(*skillGroupNameList);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (stateCode) {
      res["StateCode"] = boost::any(*stateCode);
    }
    if (stateTime) {
      res["StateTime"] = boost::any(*stateTime);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("CounterParty") != m.end() && !m["CounterParty"].empty()) {
      counterParty = make_shared<string>(boost::any_cast<string>(m["CounterParty"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillGroupNameList") != m.end() && !m["SkillGroupNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StateCode") != m.end() && !m["StateCode"].empty()) {
      stateCode = make_shared<string>(boost::any_cast<string>(m["StateCode"]));
    }
    if (m.find("StateTime") != m.end() && !m["StateTime"].empty()) {
      stateTime = make_shared<long>(boost::any_cast<long>(m["StateTime"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ListRealtimeAgentStatesResponseBodyDataList() = default;
};
class ListRealtimeAgentStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRealtimeAgentStatesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRealtimeAgentStatesResponseBodyData() {}

  explicit ListRealtimeAgentStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListRealtimeAgentStatesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRealtimeAgentStatesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListRealtimeAgentStatesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRealtimeAgentStatesResponseBodyData() = default;
};
class ListRealtimeAgentStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListRealtimeAgentStatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListRealtimeAgentStatesResponseBody() {}

  explicit ListRealtimeAgentStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRealtimeAgentStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRealtimeAgentStatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRealtimeAgentStatesResponseBody() = default;
};
class ListRealtimeAgentStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRealtimeAgentStatesResponseBody> body{};

  ListRealtimeAgentStatesResponse() {}

  explicit ListRealtimeAgentStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRealtimeAgentStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRealtimeAgentStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRealtimeAgentStatesResponse() = default;
};
class ListRealtimeSkillGroupStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupIdList{};

  ListRealtimeSkillGroupStatesRequest() {}

  explicit ListRealtimeSkillGroupStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
  }


  virtual ~ListRealtimeSkillGroupStatesRequest() = default;
};
class ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<long> count{};

  ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList() {}

  explicit ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList() = default;
};
class ListRealtimeSkillGroupStatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList>> breakCodeDetailList{};
  shared_ptr<long> breakingAgents{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> longestWaitingTime{};
  shared_ptr<long> outboundScenarioReadyAgents{};
  shared_ptr<long> readyAgents{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> talkingAgents{};
  shared_ptr<long> totalAgents{};
  shared_ptr<long> waitingCalls{};
  shared_ptr<long> workingAgents{};

  ListRealtimeSkillGroupStatesResponseBodyDataList() {}

  explicit ListRealtimeSkillGroupStatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCodeDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*breakCodeDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BreakCodeDetailList"] = boost::any(temp1);
    }
    if (breakingAgents) {
      res["BreakingAgents"] = boost::any(*breakingAgents);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (longestWaitingTime) {
      res["LongestWaitingTime"] = boost::any(*longestWaitingTime);
    }
    if (outboundScenarioReadyAgents) {
      res["OutboundScenarioReadyAgents"] = boost::any(*outboundScenarioReadyAgents);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (talkingAgents) {
      res["TalkingAgents"] = boost::any(*talkingAgents);
    }
    if (totalAgents) {
      res["TotalAgents"] = boost::any(*totalAgents);
    }
    if (waitingCalls) {
      res["WaitingCalls"] = boost::any(*waitingCalls);
    }
    if (workingAgents) {
      res["WorkingAgents"] = boost::any(*workingAgents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCodeDetailList") != m.end() && !m["BreakCodeDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["BreakCodeDetailList"].type()) {
        vector<ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BreakCodeDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        breakCodeDetailList = make_shared<vector<ListRealtimeSkillGroupStatesResponseBodyDataListBreakCodeDetailList>>(expect1);
      }
    }
    if (m.find("BreakingAgents") != m.end() && !m["BreakingAgents"].empty()) {
      breakingAgents = make_shared<long>(boost::any_cast<long>(m["BreakingAgents"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("LongestWaitingTime") != m.end() && !m["LongestWaitingTime"].empty()) {
      longestWaitingTime = make_shared<long>(boost::any_cast<long>(m["LongestWaitingTime"]));
    }
    if (m.find("OutboundScenarioReadyAgents") != m.end() && !m["OutboundScenarioReadyAgents"].empty()) {
      outboundScenarioReadyAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioReadyAgents"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("TalkingAgents") != m.end() && !m["TalkingAgents"].empty()) {
      talkingAgents = make_shared<long>(boost::any_cast<long>(m["TalkingAgents"]));
    }
    if (m.find("TotalAgents") != m.end() && !m["TotalAgents"].empty()) {
      totalAgents = make_shared<long>(boost::any_cast<long>(m["TotalAgents"]));
    }
    if (m.find("WaitingCalls") != m.end() && !m["WaitingCalls"].empty()) {
      waitingCalls = make_shared<long>(boost::any_cast<long>(m["WaitingCalls"]));
    }
    if (m.find("WorkingAgents") != m.end() && !m["WorkingAgents"].empty()) {
      workingAgents = make_shared<long>(boost::any_cast<long>(m["WorkingAgents"]));
    }
  }


  virtual ~ListRealtimeSkillGroupStatesResponseBodyDataList() = default;
};
class ListRealtimeSkillGroupStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRealtimeSkillGroupStatesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRealtimeSkillGroupStatesResponseBodyData() {}

  explicit ListRealtimeSkillGroupStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListRealtimeSkillGroupStatesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRealtimeSkillGroupStatesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListRealtimeSkillGroupStatesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRealtimeSkillGroupStatesResponseBodyData() = default;
};
class ListRealtimeSkillGroupStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListRealtimeSkillGroupStatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListRealtimeSkillGroupStatesResponseBody() {}

  explicit ListRealtimeSkillGroupStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRealtimeSkillGroupStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRealtimeSkillGroupStatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRealtimeSkillGroupStatesResponseBody() = default;
};
class ListRealtimeSkillGroupStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRealtimeSkillGroupStatesResponseBody> body{};

  ListRealtimeSkillGroupStatesResponse() {}

  explicit ListRealtimeSkillGroupStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRealtimeSkillGroupStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRealtimeSkillGroupStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRealtimeSkillGroupStatesResponse() = default;
};
class ListRecentCallDetailRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListRecentCallDetailRecordsRequest() {}

  explicit ListRecentCallDetailRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListRecentCallDetailRecordsRequest() = default;
};
class ListRecentCallDetailRecordsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentIds{};
  shared_ptr<string> callDuration{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> contactId{};
  shared_ptr<string> contactType{};
  shared_ptr<long> duration{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<long> startTime{};

  ListRecentCallDetailRecordsResponseBodyDataList() {}

  explicit ListRecentCallDetailRecordsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (callDuration) {
      res["CallDuration"] = boost::any(*callDuration);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("CallDuration") != m.end() && !m["CallDuration"].empty()) {
      callDuration = make_shared<string>(boost::any_cast<string>(m["CallDuration"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListRecentCallDetailRecordsResponseBodyDataList() = default;
};
class ListRecentCallDetailRecordsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecentCallDetailRecordsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRecentCallDetailRecordsResponseBodyData() {}

  explicit ListRecentCallDetailRecordsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListRecentCallDetailRecordsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecentCallDetailRecordsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListRecentCallDetailRecordsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRecentCallDetailRecordsResponseBodyData() = default;
};
class ListRecentCallDetailRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListRecentCallDetailRecordsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListRecentCallDetailRecordsResponseBody() {}

  explicit ListRecentCallDetailRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRecentCallDetailRecordsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRecentCallDetailRecordsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRecentCallDetailRecordsResponseBody() = default;
};
class ListRecentCallDetailRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRecentCallDetailRecordsResponseBody> body{};

  ListRecentCallDetailRecordsResponse() {}

  explicit ListRecentCallDetailRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecentCallDetailRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecentCallDetailRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecentCallDetailRecordsResponse() = default;
};
class ListRolesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListRolesRequest() {}

  explicit ListRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListRolesRequest() = default;
};
class ListRolesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> roleId{};

  ListRolesResponseBodyData() {}

  explicit ListRolesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~ListRolesResponseBodyData() = default;
};
class ListRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListRolesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListRolesResponseBody() {}

  explicit ListRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListRolesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRolesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListRolesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRolesResponseBody() = default;
};
class ListRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRolesResponseBody> body{};

  ListRolesResponse() {}

  explicit ListRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRolesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRolesResponse() = default;
};
class ListSkillGroupStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupIds{};

  ListSkillGroupStatesRequest() {}

  explicit ListSkillGroupStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
  }


  virtual ~ListSkillGroupStatesRequest() = default;
};
class ListSkillGroupStatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> averageWaitingTime{};
  shared_ptr<long> breakingAgents{};
  shared_ptr<long> inboundTalkingAgents{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> longestCall{};
  shared_ptr<long> outboundScenarioReadyAgents{};
  shared_ptr<long> outboundTalkingAgents{};
  shared_ptr<long> readyAgents{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> talkingAgents{};
  shared_ptr<long> waitingCalls{};
  shared_ptr<long> waitingCallsLevel10{};
  shared_ptr<long> waitingCallsLevel20{};
  shared_ptr<long> waitingCallsLevel30{};
  shared_ptr<long> workingAgents{};

  ListSkillGroupStatesResponseBodyDataList() {}

  explicit ListSkillGroupStatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageWaitingTime) {
      res["AverageWaitingTime"] = boost::any(*averageWaitingTime);
    }
    if (breakingAgents) {
      res["BreakingAgents"] = boost::any(*breakingAgents);
    }
    if (inboundTalkingAgents) {
      res["InboundTalkingAgents"] = boost::any(*inboundTalkingAgents);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (longestCall) {
      res["LongestCall"] = boost::any(*longestCall);
    }
    if (outboundScenarioReadyAgents) {
      res["OutboundScenarioReadyAgents"] = boost::any(*outboundScenarioReadyAgents);
    }
    if (outboundTalkingAgents) {
      res["OutboundTalkingAgents"] = boost::any(*outboundTalkingAgents);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (talkingAgents) {
      res["TalkingAgents"] = boost::any(*talkingAgents);
    }
    if (waitingCalls) {
      res["WaitingCalls"] = boost::any(*waitingCalls);
    }
    if (waitingCallsLevel10) {
      res["WaitingCallsLevel10"] = boost::any(*waitingCallsLevel10);
    }
    if (waitingCallsLevel20) {
      res["WaitingCallsLevel20"] = boost::any(*waitingCallsLevel20);
    }
    if (waitingCallsLevel30) {
      res["WaitingCallsLevel30"] = boost::any(*waitingCallsLevel30);
    }
    if (workingAgents) {
      res["WorkingAgents"] = boost::any(*workingAgents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageWaitingTime") != m.end() && !m["AverageWaitingTime"].empty()) {
      averageWaitingTime = make_shared<long>(boost::any_cast<long>(m["AverageWaitingTime"]));
    }
    if (m.find("BreakingAgents") != m.end() && !m["BreakingAgents"].empty()) {
      breakingAgents = make_shared<long>(boost::any_cast<long>(m["BreakingAgents"]));
    }
    if (m.find("InboundTalkingAgents") != m.end() && !m["InboundTalkingAgents"].empty()) {
      inboundTalkingAgents = make_shared<long>(boost::any_cast<long>(m["InboundTalkingAgents"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("LongestCall") != m.end() && !m["LongestCall"].empty()) {
      longestCall = make_shared<long>(boost::any_cast<long>(m["LongestCall"]));
    }
    if (m.find("OutboundScenarioReadyAgents") != m.end() && !m["OutboundScenarioReadyAgents"].empty()) {
      outboundScenarioReadyAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioReadyAgents"]));
    }
    if (m.find("OutboundTalkingAgents") != m.end() && !m["OutboundTalkingAgents"].empty()) {
      outboundTalkingAgents = make_shared<long>(boost::any_cast<long>(m["OutboundTalkingAgents"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("TalkingAgents") != m.end() && !m["TalkingAgents"].empty()) {
      talkingAgents = make_shared<long>(boost::any_cast<long>(m["TalkingAgents"]));
    }
    if (m.find("WaitingCalls") != m.end() && !m["WaitingCalls"].empty()) {
      waitingCalls = make_shared<long>(boost::any_cast<long>(m["WaitingCalls"]));
    }
    if (m.find("WaitingCallsLevel10") != m.end() && !m["WaitingCallsLevel10"].empty()) {
      waitingCallsLevel10 = make_shared<long>(boost::any_cast<long>(m["WaitingCallsLevel10"]));
    }
    if (m.find("WaitingCallsLevel20") != m.end() && !m["WaitingCallsLevel20"].empty()) {
      waitingCallsLevel20 = make_shared<long>(boost::any_cast<long>(m["WaitingCallsLevel20"]));
    }
    if (m.find("WaitingCallsLevel30") != m.end() && !m["WaitingCallsLevel30"].empty()) {
      waitingCallsLevel30 = make_shared<long>(boost::any_cast<long>(m["WaitingCallsLevel30"]));
    }
    if (m.find("WorkingAgents") != m.end() && !m["WorkingAgents"].empty()) {
      workingAgents = make_shared<long>(boost::any_cast<long>(m["WorkingAgents"]));
    }
  }


  virtual ~ListSkillGroupStatesResponseBodyDataList() = default;
};
class ListSkillGroupStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupStatesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillGroupStatesResponseBodyData() {}

  explicit ListSkillGroupStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListSkillGroupStatesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupStatesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListSkillGroupStatesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillGroupStatesResponseBodyData() = default;
};
class ListSkillGroupStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListSkillGroupStatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListSkillGroupStatesResponseBody() {}

  explicit ListSkillGroupStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListSkillGroupStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListSkillGroupStatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSkillGroupStatesResponseBody() = default;
};
class ListSkillGroupStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSkillGroupStatesResponseBody> body{};

  ListSkillGroupStatesResponse() {}

  explicit ListSkillGroupStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupStatesResponse() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroups{};

  ListSkillGroupSummaryReportsSinceMidnightRequest() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroups) {
      res["SkillGroups"] = boost::any(*skillGroups);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      skillGroups = make_shared<string>(boost::any_cast<string>(m["SkillGroups"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightRequest() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound : public Darabonba::Model {
public:
  shared_ptr<long> abandonedInQueueOfQueueCount{};
  shared_ptr<long> answeredByAgentOfQueueCount{};
  shared_ptr<long> answeredByAgentOfQueueMaxWaitTimeDuration{};
  shared_ptr<long> answeredByAgentOfQueueWaitTimeDuration{};
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsOffered{};
  shared_ptr<string> callsOverflow{};
  shared_ptr<string> callsQueuingCanceled{};
  shared_ptr<string> callsQueuingFailure{};
  shared_ptr<string> callsQueuingRerouted{};
  shared_ptr<long> callsQueuingTimeout{};
  shared_ptr<long> callsServiceLevel10{};
  shared_ptr<long> callsServiceLevel20{};
  shared_ptr<long> callsServiceLevel30{};
  shared_ptr<long> callsTimeout{};
  shared_ptr<long> giveUpByAgentOfQueueCount{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> inComingQueueOfQueueCount{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<string> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> overFlowInQueueOfQueueCount{};
  shared_ptr<long> queueMaxWaitTimeDuration{};
  shared_ptr<long> queueWaitTimeDuration{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonedInQueueOfQueueCount) {
      res["AbandonedInQueueOfQueueCount"] = boost::any(*abandonedInQueueOfQueueCount);
    }
    if (answeredByAgentOfQueueCount) {
      res["AnsweredByAgentOfQueueCount"] = boost::any(*answeredByAgentOfQueueCount);
    }
    if (answeredByAgentOfQueueMaxWaitTimeDuration) {
      res["AnsweredByAgentOfQueueMaxWaitTimeDuration"] = boost::any(*answeredByAgentOfQueueMaxWaitTimeDuration);
    }
    if (answeredByAgentOfQueueWaitTimeDuration) {
      res["AnsweredByAgentOfQueueWaitTimeDuration"] = boost::any(*answeredByAgentOfQueueWaitTimeDuration);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsOverflow) {
      res["CallsOverflow"] = boost::any(*callsOverflow);
    }
    if (callsQueuingCanceled) {
      res["CallsQueuingCanceled"] = boost::any(*callsQueuingCanceled);
    }
    if (callsQueuingFailure) {
      res["CallsQueuingFailure"] = boost::any(*callsQueuingFailure);
    }
    if (callsQueuingRerouted) {
      res["CallsQueuingRerouted"] = boost::any(*callsQueuingRerouted);
    }
    if (callsQueuingTimeout) {
      res["CallsQueuingTimeout"] = boost::any(*callsQueuingTimeout);
    }
    if (callsServiceLevel10) {
      res["CallsServiceLevel10"] = boost::any(*callsServiceLevel10);
    }
    if (callsServiceLevel20) {
      res["CallsServiceLevel20"] = boost::any(*callsServiceLevel20);
    }
    if (callsServiceLevel30) {
      res["CallsServiceLevel30"] = boost::any(*callsServiceLevel30);
    }
    if (callsTimeout) {
      res["CallsTimeout"] = boost::any(*callsTimeout);
    }
    if (giveUpByAgentOfQueueCount) {
      res["GiveUpByAgentOfQueueCount"] = boost::any(*giveUpByAgentOfQueueCount);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (inComingQueueOfQueueCount) {
      res["InComingQueueOfQueueCount"] = boost::any(*inComingQueueOfQueueCount);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (overFlowInQueueOfQueueCount) {
      res["OverFlowInQueueOfQueueCount"] = boost::any(*overFlowInQueueOfQueueCount);
    }
    if (queueMaxWaitTimeDuration) {
      res["QueueMaxWaitTimeDuration"] = boost::any(*queueMaxWaitTimeDuration);
    }
    if (queueWaitTimeDuration) {
      res["QueueWaitTimeDuration"] = boost::any(*queueWaitTimeDuration);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonedInQueueOfQueueCount") != m.end() && !m["AbandonedInQueueOfQueueCount"].empty()) {
      abandonedInQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["AbandonedInQueueOfQueueCount"]));
    }
    if (m.find("AnsweredByAgentOfQueueCount") != m.end() && !m["AnsweredByAgentOfQueueCount"].empty()) {
      answeredByAgentOfQueueCount = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueCount"]));
    }
    if (m.find("AnsweredByAgentOfQueueMaxWaitTimeDuration") != m.end() && !m["AnsweredByAgentOfQueueMaxWaitTimeDuration"].empty()) {
      answeredByAgentOfQueueMaxWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueMaxWaitTimeDuration"]));
    }
    if (m.find("AnsweredByAgentOfQueueWaitTimeDuration") != m.end() && !m["AnsweredByAgentOfQueueWaitTimeDuration"].empty()) {
      answeredByAgentOfQueueWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueWaitTimeDuration"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsOverflow") != m.end() && !m["CallsOverflow"].empty()) {
      callsOverflow = make_shared<string>(boost::any_cast<string>(m["CallsOverflow"]));
    }
    if (m.find("CallsQueuingCanceled") != m.end() && !m["CallsQueuingCanceled"].empty()) {
      callsQueuingCanceled = make_shared<string>(boost::any_cast<string>(m["CallsQueuingCanceled"]));
    }
    if (m.find("CallsQueuingFailure") != m.end() && !m["CallsQueuingFailure"].empty()) {
      callsQueuingFailure = make_shared<string>(boost::any_cast<string>(m["CallsQueuingFailure"]));
    }
    if (m.find("CallsQueuingRerouted") != m.end() && !m["CallsQueuingRerouted"].empty()) {
      callsQueuingRerouted = make_shared<string>(boost::any_cast<string>(m["CallsQueuingRerouted"]));
    }
    if (m.find("CallsQueuingTimeout") != m.end() && !m["CallsQueuingTimeout"].empty()) {
      callsQueuingTimeout = make_shared<long>(boost::any_cast<long>(m["CallsQueuingTimeout"]));
    }
    if (m.find("CallsServiceLevel10") != m.end() && !m["CallsServiceLevel10"].empty()) {
      callsServiceLevel10 = make_shared<long>(boost::any_cast<long>(m["CallsServiceLevel10"]));
    }
    if (m.find("CallsServiceLevel20") != m.end() && !m["CallsServiceLevel20"].empty()) {
      callsServiceLevel20 = make_shared<long>(boost::any_cast<long>(m["CallsServiceLevel20"]));
    }
    if (m.find("CallsServiceLevel30") != m.end() && !m["CallsServiceLevel30"].empty()) {
      callsServiceLevel30 = make_shared<long>(boost::any_cast<long>(m["CallsServiceLevel30"]));
    }
    if (m.find("CallsTimeout") != m.end() && !m["CallsTimeout"].empty()) {
      callsTimeout = make_shared<long>(boost::any_cast<long>(m["CallsTimeout"]));
    }
    if (m.find("GiveUpByAgentOfQueueCount") != m.end() && !m["GiveUpByAgentOfQueueCount"].empty()) {
      giveUpByAgentOfQueueCount = make_shared<long>(boost::any_cast<long>(m["GiveUpByAgentOfQueueCount"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("InComingQueueOfQueueCount") != m.end() && !m["InComingQueueOfQueueCount"].empty()) {
      inComingQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["InComingQueueOfQueueCount"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<string>(boost::any_cast<string>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OverFlowInQueueOfQueueCount") != m.end() && !m["OverFlowInQueueOfQueueCount"].empty()) {
      overFlowInQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["OverFlowInQueueOfQueueCount"]));
    }
    if (m.find("QueueMaxWaitTimeDuration") != m.end() && !m["QueueMaxWaitTimeDuration"].empty()) {
      queueMaxWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["QueueMaxWaitTimeDuration"]));
    }
    if (m.find("QueueWaitTimeDuration") != m.end() && !m["QueueWaitTimeDuration"].empty()) {
      queueWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["QueueWaitTimeDuration"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<long> averageDialingTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsAgentHandled{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsQueuingCancelled{};
  shared_ptr<long> callsQueuingFailed{};
  shared_ptr<long> callsQueuingFailure{};
  shared_ptr<long> callsQueuingOverflow{};
  shared_ptr<long> callsQueuingRerouted{};
  shared_ptr<long> callsQueuingTimeout{};
  shared_ptr<string> callsServiceLevel30{};
  shared_ptr<long> callsServiceLevel30V2{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalWorkTime{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsAgentHandled) {
      res["CallsAgentHandled"] = boost::any(*callsAgentHandled);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsQueuingCancelled) {
      res["CallsQueuingCancelled"] = boost::any(*callsQueuingCancelled);
    }
    if (callsQueuingFailed) {
      res["CallsQueuingFailed"] = boost::any(*callsQueuingFailed);
    }
    if (callsQueuingFailure) {
      res["CallsQueuingFailure"] = boost::any(*callsQueuingFailure);
    }
    if (callsQueuingOverflow) {
      res["CallsQueuingOverflow"] = boost::any(*callsQueuingOverflow);
    }
    if (callsQueuingRerouted) {
      res["CallsQueuingRerouted"] = boost::any(*callsQueuingRerouted);
    }
    if (callsQueuingTimeout) {
      res["CallsQueuingTimeout"] = boost::any(*callsQueuingTimeout);
    }
    if (callsServiceLevel30) {
      res["CallsServiceLevel30"] = boost::any(*callsServiceLevel30);
    }
    if (callsServiceLevel30V2) {
      res["CallsServiceLevel30V2"] = boost::any(*callsServiceLevel30V2);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsAgentHandled") != m.end() && !m["CallsAgentHandled"].empty()) {
      callsAgentHandled = make_shared<long>(boost::any_cast<long>(m["CallsAgentHandled"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsQueuingCancelled") != m.end() && !m["CallsQueuingCancelled"].empty()) {
      callsQueuingCancelled = make_shared<long>(boost::any_cast<long>(m["CallsQueuingCancelled"]));
    }
    if (m.find("CallsQueuingFailed") != m.end() && !m["CallsQueuingFailed"].empty()) {
      callsQueuingFailed = make_shared<long>(boost::any_cast<long>(m["CallsQueuingFailed"]));
    }
    if (m.find("CallsQueuingFailure") != m.end() && !m["CallsQueuingFailure"].empty()) {
      callsQueuingFailure = make_shared<long>(boost::any_cast<long>(m["CallsQueuingFailure"]));
    }
    if (m.find("CallsQueuingOverflow") != m.end() && !m["CallsQueuingOverflow"].empty()) {
      callsQueuingOverflow = make_shared<long>(boost::any_cast<long>(m["CallsQueuingOverflow"]));
    }
    if (m.find("CallsQueuingRerouted") != m.end() && !m["CallsQueuingRerouted"].empty()) {
      callsQueuingRerouted = make_shared<long>(boost::any_cast<long>(m["CallsQueuingRerouted"]));
    }
    if (m.find("CallsQueuingTimeout") != m.end() && !m["CallsQueuingTimeout"].empty()) {
      callsQueuingTimeout = make_shared<long>(boost::any_cast<long>(m["CallsQueuingTimeout"]));
    }
    if (m.find("CallsServiceLevel30") != m.end() && !m["CallsServiceLevel30"].empty()) {
      callsServiceLevel30 = make_shared<string>(boost::any_cast<string>(m["CallsServiceLevel30"]));
    }
    if (m.find("CallsServiceLevel30V2") != m.end() && !m["CallsServiceLevel30V2"].empty()) {
      callsServiceLevel30V2 = make_shared<long>(boost::any_cast<long>(m["CallsServiceLevel30V2"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall : public Darabonba::Model {
public:
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound> inbound{};
  shared_ptr<string> instanceId{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound> outbound{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall> overall{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> timestamp{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall>(model1);
      }
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport> pagedSkillGroupSummaryReport{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBody() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pagedSkillGroupSummaryReport) {
      res["PagedSkillGroupSummaryReport"] = pagedSkillGroupSummaryReport ? boost::any(pagedSkillGroupSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PagedSkillGroupSummaryReport") != m.end() && !m["PagedSkillGroupSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagedSkillGroupSummaryReport"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagedSkillGroupSummaryReport"]));
        pagedSkillGroupSummaryReport = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBody() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBody> body{};

  ListSkillGroupSummaryReportsSinceMidnightResponse() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponse() = default;
};
class ListSkillGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListSkillGroupsRequest() {}

  explicit ListSkillGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListSkillGroupsRequest() = default;
};
class ListSkillGroupsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> phoneNumberCount{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> userCount{};

  ListSkillGroupsResponseBodyDataList() {}

  explicit ListSkillGroupsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (phoneNumberCount) {
      res["PhoneNumberCount"] = boost::any(*phoneNumberCount);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("PhoneNumberCount") != m.end() && !m["PhoneNumberCount"].empty()) {
      phoneNumberCount = make_shared<long>(boost::any_cast<long>(m["PhoneNumberCount"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~ListSkillGroupsResponseBodyDataList() = default;
};
class ListSkillGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillGroupsResponseBodyData() {}

  explicit ListSkillGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListSkillGroupsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListSkillGroupsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillGroupsResponseBodyData() = default;
};
class ListSkillGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListSkillGroupsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListSkillGroupsResponseBody() {}

  explicit ListSkillGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListSkillGroupsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListSkillGroupsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSkillGroupsResponseBody() = default;
};
class ListSkillGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSkillGroupsResponseBody> body{};

  ListSkillGroupsResponse() {}

  explicit ListSkillGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupsResponse() = default;
};
class ListSkillLevelsOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isMember{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> userId{};

  ListSkillLevelsOfUserRequest() {}

  explicit ListSkillLevelsOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isMember) {
      res["IsMember"] = boost::any(*isMember);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsMember") != m.end() && !m["IsMember"].empty()) {
      isMember = make_shared<bool>(boost::any_cast<bool>(m["IsMember"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListSkillLevelsOfUserRequest() = default;
};
class ListSkillLevelsOfUserResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> mediaType{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillLevel{};

  ListSkillLevelsOfUserResponseBodyDataList() {}

  explicit ListSkillLevelsOfUserResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      skillLevel = make_shared<string>(boost::any_cast<string>(m["SkillLevel"]));
    }
  }


  virtual ~ListSkillLevelsOfUserResponseBodyDataList() = default;
};
class ListSkillLevelsOfUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillLevelsOfUserResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillLevelsOfUserResponseBodyData() {}

  explicit ListSkillLevelsOfUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListSkillLevelsOfUserResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillLevelsOfUserResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListSkillLevelsOfUserResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillLevelsOfUserResponseBodyData() = default;
};
class ListSkillLevelsOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListSkillLevelsOfUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListSkillLevelsOfUserResponseBody() {}

  explicit ListSkillLevelsOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListSkillLevelsOfUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListSkillLevelsOfUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSkillLevelsOfUserResponseBody() = default;
};
class ListSkillLevelsOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSkillLevelsOfUserResponseBody> body{};

  ListSkillLevelsOfUserResponse() {}

  explicit ListSkillLevelsOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillLevelsOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillLevelsOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillLevelsOfUserResponse() = default;
};
class ListTicketTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ticketId{};

  ListTicketTasksRequest() {}

  explicit ListTicketTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~ListTicketTasksRequest() = default;
};
class ListTicketTasksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> assignee{};
  shared_ptr<string> assigneeName{};
  shared_ptr<string> comment{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> fileKeys{};
  shared_ptr<vector<string>> fileUrls{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> taskDefinitionNodeId{};
  shared_ptr<string> taskDefinitionNodeType{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> ticketId{};

  ListTicketTasksResponseBodyData() {}

  explicit ListTicketTasksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (assignee) {
      res["Assignee"] = boost::any(*assignee);
    }
    if (assigneeName) {
      res["AssigneeName"] = boost::any(*assigneeName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileKeys) {
      res["FileKeys"] = boost::any(*fileKeys);
    }
    if (fileUrls) {
      res["FileUrls"] = boost::any(*fileUrls);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskDefinitionNodeId) {
      res["TaskDefinitionNodeId"] = boost::any(*taskDefinitionNodeId);
    }
    if (taskDefinitionNodeType) {
      res["TaskDefinitionNodeType"] = boost::any(*taskDefinitionNodeType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Assignee") != m.end() && !m["Assignee"].empty()) {
      assignee = make_shared<string>(boost::any_cast<string>(m["Assignee"]));
    }
    if (m.find("AssigneeName") != m.end() && !m["AssigneeName"].empty()) {
      assigneeName = make_shared<string>(boost::any_cast<string>(m["AssigneeName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FileKeys") != m.end() && !m["FileKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FileUrls") != m.end() && !m["FileUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TaskDefinitionNodeId") != m.end() && !m["TaskDefinitionNodeId"].empty()) {
      taskDefinitionNodeId = make_shared<string>(boost::any_cast<string>(m["TaskDefinitionNodeId"]));
    }
    if (m.find("TaskDefinitionNodeType") != m.end() && !m["TaskDefinitionNodeType"].empty()) {
      taskDefinitionNodeType = make_shared<string>(boost::any_cast<string>(m["TaskDefinitionNodeType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~ListTicketTasksResponseBodyData() = default;
};
class ListTicketTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListTicketTasksResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListTicketTasksResponseBody() {}

  explicit ListTicketTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListTicketTasksResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTicketTasksResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTicketTasksResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTicketTasksResponseBody() = default;
};
class ListTicketTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTicketTasksResponseBody> body{};

  ListTicketTasksResponse() {}

  explicit ListTicketTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTicketTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTicketTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListTicketTasksResponse() = default;
};
class ListTicketTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> state{};

  ListTicketTemplatesRequest() {}

  explicit ListTicketTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListTicketTemplatesRequest() = default;
};
class ListTicketTemplatesResponseBodyDataListTicketFields : public Darabonba::Model {
public:
  shared_ptr<bool> array{};
  shared_ptr<string> attribute{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> dataType{};
  shared_ptr<string> description{};
  shared_ptr<bool> disabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> displayOrder{};
  shared_ptr<string> editorType{};
  shared_ptr<long> maxLength{};
  shared_ptr<double> maximum{};
  shared_ptr<long> minLength{};
  shared_ptr<double> minimum{};
  shared_ptr<string> name{};
  shared_ptr<string> pattern{};
  shared_ptr<string> patternErrorMessage{};
  shared_ptr<bool> readOnly{};
  shared_ptr<bool> required{};
  shared_ptr<bool> system{};
  shared_ptr<long> updatedTime{};

  ListTicketTemplatesResponseBodyDataListTicketFields() {}

  explicit ListTicketTemplatesResponseBodyDataListTicketFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (array) {
      res["Array"] = boost::any(*array);
    }
    if (attribute) {
      res["Attribute"] = boost::any(*attribute);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayOrder) {
      res["DisplayOrder"] = boost::any(*displayOrder);
    }
    if (editorType) {
      res["EditorType"] = boost::any(*editorType);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minimum) {
      res["Minimum"] = boost::any(*minimum);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (patternErrorMessage) {
      res["PatternErrorMessage"] = boost::any(*patternErrorMessage);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Array") != m.end() && !m["Array"].empty()) {
      array = make_shared<bool>(boost::any_cast<bool>(m["Array"]));
    }
    if (m.find("Attribute") != m.end() && !m["Attribute"].empty()) {
      attribute = make_shared<string>(boost::any_cast<string>(m["Attribute"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayOrder") != m.end() && !m["DisplayOrder"].empty()) {
      displayOrder = make_shared<long>(boost::any_cast<long>(m["DisplayOrder"]));
    }
    if (m.find("EditorType") != m.end() && !m["EditorType"].empty()) {
      editorType = make_shared<string>(boost::any_cast<string>(m["EditorType"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<double>(boost::any_cast<double>(m["Maximum"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("Minimum") != m.end() && !m["Minimum"].empty()) {
      minimum = make_shared<double>(boost::any_cast<double>(m["Minimum"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("PatternErrorMessage") != m.end() && !m["PatternErrorMessage"].empty()) {
      patternErrorMessage = make_shared<string>(boost::any_cast<string>(m["PatternErrorMessage"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
  }


  virtual ~ListTicketTemplatesResponseBodyDataListTicketFields() = default;
};
class ListTicketTemplatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> appliedVersion{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> editor{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> latestVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> processDefinition{};
  shared_ptr<string> state{};
  shared_ptr<string> templateId{};
  shared_ptr<vector<ListTicketTemplatesResponseBodyDataListTicketFields>> ticketFields{};
  shared_ptr<long> updatedTime{};

  ListTicketTemplatesResponseBodyDataList() {}

  explicit ListTicketTemplatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedVersion) {
      res["AppliedVersion"] = boost::any(*appliedVersion);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (editor) {
      res["Editor"] = boost::any(*editor);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (latestVersion) {
      res["LatestVersion"] = boost::any(*latestVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (processDefinition) {
      res["ProcessDefinition"] = boost::any(*processDefinition);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (ticketFields) {
      vector<boost::any> temp1;
      for(auto item1:*ticketFields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TicketFields"] = boost::any(temp1);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedVersion") != m.end() && !m["AppliedVersion"].empty()) {
      appliedVersion = make_shared<string>(boost::any_cast<string>(m["AppliedVersion"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Editor") != m.end() && !m["Editor"].empty()) {
      editor = make_shared<string>(boost::any_cast<string>(m["Editor"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LatestVersion") != m.end() && !m["LatestVersion"].empty()) {
      latestVersion = make_shared<string>(boost::any_cast<string>(m["LatestVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProcessDefinition") != m.end() && !m["ProcessDefinition"].empty()) {
      processDefinition = make_shared<string>(boost::any_cast<string>(m["ProcessDefinition"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TicketFields") != m.end() && !m["TicketFields"].empty()) {
      if (typeid(vector<boost::any>) == m["TicketFields"].type()) {
        vector<ListTicketTemplatesResponseBodyDataListTicketFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TicketFields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTicketTemplatesResponseBodyDataListTicketFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ticketFields = make_shared<vector<ListTicketTemplatesResponseBodyDataListTicketFields>>(expect1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
  }


  virtual ~ListTicketTemplatesResponseBodyDataList() = default;
};
class ListTicketTemplatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListTicketTemplatesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListTicketTemplatesResponseBodyData() {}

  explicit ListTicketTemplatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListTicketTemplatesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTicketTemplatesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListTicketTemplatesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTicketTemplatesResponseBodyData() = default;
};
class ListTicketTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListTicketTemplatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListTicketTemplatesResponseBody() {}

  explicit ListTicketTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTicketTemplatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTicketTemplatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTicketTemplatesResponseBody() = default;
};
class ListTicketTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTicketTemplatesResponseBody> body{};

  ListTicketTemplatesResponse() {}

  explicit ListTicketTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTicketTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTicketTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTicketTemplatesResponse() = default;
};
class ListTicketsRequest : public Darabonba::Model {
public:
  shared_ptr<string> assignee{};
  shared_ptr<string> assigneeType{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> creator{};
  shared_ptr<string> customerId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobIdList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> participant{};
  shared_ptr<long> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> ticketId{};
  shared_ptr<string> title{};

  ListTicketsRequest() {}

  explicit ListTicketsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignee) {
      res["Assignee"] = boost::any(*assignee);
    }
    if (assigneeType) {
      res["AssigneeType"] = boost::any(*assigneeType);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (customerId) {
      res["CustomerId"] = boost::any(*customerId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobIdList) {
      res["JobIdList"] = boost::any(*jobIdList);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (participant) {
      res["Participant"] = boost::any(*participant);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assignee") != m.end() && !m["Assignee"].empty()) {
      assignee = make_shared<string>(boost::any_cast<string>(m["Assignee"]));
    }
    if (m.find("AssigneeType") != m.end() && !m["AssigneeType"].empty()) {
      assigneeType = make_shared<string>(boost::any_cast<string>(m["AssigneeType"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("CustomerId") != m.end() && !m["CustomerId"].empty()) {
      customerId = make_shared<string>(boost::any_cast<string>(m["CustomerId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobIdList") != m.end() && !m["JobIdList"].empty()) {
      jobIdList = make_shared<string>(boost::any_cast<string>(m["JobIdList"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Participant") != m.end() && !m["Participant"].empty()) {
      participant = make_shared<string>(boost::any_cast<string>(m["Participant"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~ListTicketsRequest() = default;
};
class ListTicketsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> assignee{};
  shared_ptr<string> assigneeName{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> closeCode{};
  shared_ptr<string> comment{};
  shared_ptr<string> context{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> currentTaskId{};
  shared_ptr<string> currentTaskName{};
  shared_ptr<long> currentTaskStartTime{};
  shared_ptr<string> customerId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> source{};
  shared_ptr<long> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateVersion{};
  shared_ptr<string> ticketId{};
  shared_ptr<string> title{};
  shared_ptr<string> updatedTime{};

  ListTicketsResponseBodyDataList() {}

  explicit ListTicketsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignee) {
      res["Assignee"] = boost::any(*assignee);
    }
    if (assigneeName) {
      res["AssigneeName"] = boost::any(*assigneeName);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (closeCode) {
      res["CloseCode"] = boost::any(*closeCode);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (context) {
      res["Context"] = boost::any(*context);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (currentTaskId) {
      res["CurrentTaskId"] = boost::any(*currentTaskId);
    }
    if (currentTaskName) {
      res["CurrentTaskName"] = boost::any(*currentTaskName);
    }
    if (currentTaskStartTime) {
      res["CurrentTaskStartTime"] = boost::any(*currentTaskStartTime);
    }
    if (customerId) {
      res["CustomerId"] = boost::any(*customerId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateVersion) {
      res["TemplateVersion"] = boost::any(*templateVersion);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assignee") != m.end() && !m["Assignee"].empty()) {
      assignee = make_shared<string>(boost::any_cast<string>(m["Assignee"]));
    }
    if (m.find("AssigneeName") != m.end() && !m["AssigneeName"].empty()) {
      assigneeName = make_shared<string>(boost::any_cast<string>(m["AssigneeName"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("CloseCode") != m.end() && !m["CloseCode"].empty()) {
      closeCode = make_shared<string>(boost::any_cast<string>(m["CloseCode"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Context") != m.end() && !m["Context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["Context"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("CurrentTaskId") != m.end() && !m["CurrentTaskId"].empty()) {
      currentTaskId = make_shared<string>(boost::any_cast<string>(m["CurrentTaskId"]));
    }
    if (m.find("CurrentTaskName") != m.end() && !m["CurrentTaskName"].empty()) {
      currentTaskName = make_shared<string>(boost::any_cast<string>(m["CurrentTaskName"]));
    }
    if (m.find("CurrentTaskStartTime") != m.end() && !m["CurrentTaskStartTime"].empty()) {
      currentTaskStartTime = make_shared<long>(boost::any_cast<long>(m["CurrentTaskStartTime"]));
    }
    if (m.find("CustomerId") != m.end() && !m["CustomerId"].empty()) {
      customerId = make_shared<string>(boost::any_cast<string>(m["CustomerId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateVersion") != m.end() && !m["TemplateVersion"].empty()) {
      templateVersion = make_shared<string>(boost::any_cast<string>(m["TemplateVersion"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
  }


  virtual ~ListTicketsResponseBodyDataList() = default;
};
class ListTicketsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListTicketsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListTicketsResponseBodyData() {}

  explicit ListTicketsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListTicketsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTicketsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListTicketsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTicketsResponseBodyData() = default;
};
class ListTicketsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListTicketsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListTicketsResponseBody() {}

  explicit ListTicketsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTicketsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTicketsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTicketsResponseBody() = default;
};
class ListTicketsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTicketsResponseBody> body{};

  ListTicketsResponse() {}

  explicit ListTicketsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTicketsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTicketsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTicketsResponse() = default;
};
class ListUnassignedNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListUnassignedNumbersRequest() {}

  explicit ListUnassignedNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListUnassignedNumbersRequest() = default;
};
class ListUnassignedNumbersResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  ListUnassignedNumbersResponseBodyDataList() {}

  explicit ListUnassignedNumbersResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~ListUnassignedNumbersResponseBodyDataList() = default;
};
class ListUnassignedNumbersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListUnassignedNumbersResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUnassignedNumbersResponseBodyData() {}

  explicit ListUnassignedNumbersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListUnassignedNumbersResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUnassignedNumbersResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListUnassignedNumbersResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUnassignedNumbersResponseBodyData() = default;
};
class ListUnassignedNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListUnassignedNumbersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListUnassignedNumbersResponseBody() {}

  explicit ListUnassignedNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListUnassignedNumbersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListUnassignedNumbersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUnassignedNumbersResponseBody() = default;
};
class ListUnassignedNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUnassignedNumbersResponseBody> body{};

  ListUnassignedNumbersResponse() {}

  explicit ListUnassignedNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUnassignedNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUnassignedNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUnassignedNumbersResponse() = default;
};
class ListUserLevelsOfSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isMember{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> skillGroupId{};

  ListUserLevelsOfSkillGroupRequest() {}

  explicit ListUserLevelsOfSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isMember) {
      res["IsMember"] = boost::any(*isMember);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsMember") != m.end() && !m["IsMember"].empty()) {
      isMember = make_shared<bool>(boost::any_cast<bool>(m["IsMember"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListUserLevelsOfSkillGroupRequest() = default;
};
class ListUserLevelsOfSkillGroupResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> loginName{};
  shared_ptr<string> ramId{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> skillLevel{};
  shared_ptr<string> userId{};

  ListUserLevelsOfSkillGroupResponseBodyDataList() {}

  explicit ListUserLevelsOfSkillGroupResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      skillLevel = make_shared<long>(boost::any_cast<long>(m["SkillLevel"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListUserLevelsOfSkillGroupResponseBodyDataList() = default;
};
class ListUserLevelsOfSkillGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListUserLevelsOfSkillGroupResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUserLevelsOfSkillGroupResponseBodyData() {}

  explicit ListUserLevelsOfSkillGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListUserLevelsOfSkillGroupResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserLevelsOfSkillGroupResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListUserLevelsOfSkillGroupResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUserLevelsOfSkillGroupResponseBodyData() = default;
};
class ListUserLevelsOfSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListUserLevelsOfSkillGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListUserLevelsOfSkillGroupResponseBody() {}

  explicit ListUserLevelsOfSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListUserLevelsOfSkillGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListUserLevelsOfSkillGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUserLevelsOfSkillGroupResponseBody() = default;
};
class ListUserLevelsOfSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserLevelsOfSkillGroupResponseBody> body{};

  ListUserLevelsOfSkillGroupResponse() {}

  explicit ListUserLevelsOfSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserLevelsOfSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserLevelsOfSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserLevelsOfSkillGroupResponse() = default;
};
class ListUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> skillGroupId{};

  ListUsersRequest() {}

  explicit ListUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListUsersRequest() = default;
};
class ListUsersResponseBodyDataListPersonalOutboundNumberList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};
  shared_ptr<string> usage{};

  ListUsersResponseBodyDataListPersonalOutboundNumberList() {}

  explicit ListUsersResponseBodyDataListPersonalOutboundNumberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ListUsersResponseBodyDataListPersonalOutboundNumberList() = default;
};
class ListUsersResponseBodyDataListSkillLevelList : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> skillLevel{};

  ListUsersResponseBodyDataListSkillLevelList() {}

  explicit ListUsersResponseBodyDataListSkillLevelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      skillLevel = make_shared<long>(boost::any_cast<long>(m["SkillLevel"]));
    }
  }


  virtual ~ListUsersResponseBodyDataListSkillLevelList() = default;
};
class ListUsersResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> deviceExt{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> displayId{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<vector<ListUsersResponseBodyDataListPersonalOutboundNumberList>> personalOutboundNumberList{};
  shared_ptr<bool> primary{};
  shared_ptr<bool> primaryAccount{};
  shared_ptr<long> ramId{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<vector<ListUsersResponseBodyDataListSkillLevelList>> skillLevelList{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  ListUsersResponseBodyDataList() {}

  explicit ListUsersResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceExt) {
      res["DeviceExt"] = boost::any(*deviceExt);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (personalOutboundNumberList) {
      vector<boost::any> temp1;
      for(auto item1:*personalOutboundNumberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PersonalOutboundNumberList"] = boost::any(temp1);
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    if (primaryAccount) {
      res["PrimaryAccount"] = boost::any(*primaryAccount);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (skillLevelList) {
      vector<boost::any> temp1;
      for(auto item1:*skillLevelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillLevelList"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceExt") != m.end() && !m["DeviceExt"].empty()) {
      deviceExt = make_shared<string>(boost::any_cast<string>(m["DeviceExt"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("PersonalOutboundNumberList") != m.end() && !m["PersonalOutboundNumberList"].empty()) {
      if (typeid(vector<boost::any>) == m["PersonalOutboundNumberList"].type()) {
        vector<ListUsersResponseBodyDataListPersonalOutboundNumberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PersonalOutboundNumberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyDataListPersonalOutboundNumberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        personalOutboundNumberList = make_shared<vector<ListUsersResponseBodyDataListPersonalOutboundNumberList>>(expect1);
      }
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
    if (m.find("PrimaryAccount") != m.end() && !m["PrimaryAccount"].empty()) {
      primaryAccount = make_shared<bool>(boost::any_cast<bool>(m["PrimaryAccount"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<long>(boost::any_cast<long>(m["RamId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SkillLevelList") != m.end() && !m["SkillLevelList"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillLevelList"].type()) {
        vector<ListUsersResponseBodyDataListSkillLevelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillLevelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyDataListSkillLevelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillLevelList = make_shared<vector<ListUsersResponseBodyDataListSkillLevelList>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ListUsersResponseBodyDataList() = default;
};
class ListUsersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUsersResponseBodyData() {}

  explicit ListUsersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListUsersResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListUsersResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUsersResponseBodyData() = default;
};
class ListUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListUsersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListUsersResponseBody() {}

  explicit ListUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListUsersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListUsersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUsersResponseBody() = default;
};
class ListUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUsersResponseBody> body{};

  ListUsersResponse() {}

  explicit ListUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersResponse() = default;
};
class ListVoicemailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> caller{};
  shared_ptr<string> contactId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListVoicemailsRequest() {}

  explicit ListVoicemailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListVoicemailsRequest() = default;
};
class ListVoicemailsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<long> cdrStartTime{};
  shared_ptr<string> contactId{};
  shared_ptr<long> duration{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<string> startTime{};

  ListVoicemailsResponseBodyDataList() {}

  explicit ListVoicemailsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (cdrStartTime) {
      res["CdrStartTime"] = boost::any(*cdrStartTime);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("CdrStartTime") != m.end() && !m["CdrStartTime"].empty()) {
      cdrStartTime = make_shared<long>(boost::any_cast<long>(m["CdrStartTime"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListVoicemailsResponseBodyDataList() = default;
};
class ListVoicemailsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListVoicemailsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListVoicemailsResponseBodyData() {}

  explicit ListVoicemailsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListVoicemailsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVoicemailsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListVoicemailsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListVoicemailsResponseBodyData() = default;
};
class ListVoicemailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListVoicemailsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListVoicemailsResponseBody() {}

  explicit ListVoicemailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListVoicemailsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListVoicemailsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListVoicemailsResponseBody() = default;
};
class ListVoicemailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVoicemailsResponseBody> body{};

  ListVoicemailsResponse() {}

  explicit ListVoicemailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVoicemailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVoicemailsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVoicemailsResponse() = default;
};
class ListWaitingChatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIdList{};

  ListWaitingChatsRequest() {}

  explicit ListWaitingChatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
  }


  virtual ~ListWaitingChatsRequest() = default;
};
class ListWaitingChatsResponseBodyDataMessages : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> senderId{};
  shared_ptr<string> senderType{};

  ListWaitingChatsResponseBodyDataMessages() {}

  explicit ListWaitingChatsResponseBodyDataMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (senderId) {
      res["SenderId"] = boost::any(*senderId);
    }
    if (senderType) {
      res["SenderType"] = boost::any(*senderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SenderId") != m.end() && !m["SenderId"].empty()) {
      senderId = make_shared<string>(boost::any_cast<string>(m["SenderId"]));
    }
    if (m.find("SenderType") != m.end() && !m["SenderType"].empty()) {
      senderType = make_shared<string>(boost::any_cast<string>(m["SenderType"]));
    }
  }


  virtual ~ListWaitingChatsResponseBodyDataMessages() = default;
};
class ListWaitingChatsResponseBodyDataUserList : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userType{};

  ListWaitingChatsResponseBodyDataUserList() {}

  explicit ListWaitingChatsResponseBodyDataUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~ListWaitingChatsResponseBodyDataUserList() = default;
};
class ListWaitingChatsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessChannelId{};
  shared_ptr<string> accessChannelType{};
  shared_ptr<bool> beingAssigned{};
  shared_ptr<string> chatConversationId{};
  shared_ptr<long> enqueueTime{};
  shared_ptr<string> jobId{};
  shared_ptr<vector<ListWaitingChatsResponseBodyDataMessages>> messages{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<vector<ListWaitingChatsResponseBodyDataUserList>> userList{};

  ListWaitingChatsResponseBodyData() {}

  explicit ListWaitingChatsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelId) {
      res["AccessChannelId"] = boost::any(*accessChannelId);
    }
    if (accessChannelType) {
      res["AccessChannelType"] = boost::any(*accessChannelType);
    }
    if (beingAssigned) {
      res["BeingAssigned"] = boost::any(*beingAssigned);
    }
    if (chatConversationId) {
      res["ChatConversationId"] = boost::any(*chatConversationId);
    }
    if (enqueueTime) {
      res["EnqueueTime"] = boost::any(*enqueueTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Messages"] = boost::any(temp1);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelId") != m.end() && !m["AccessChannelId"].empty()) {
      accessChannelId = make_shared<string>(boost::any_cast<string>(m["AccessChannelId"]));
    }
    if (m.find("AccessChannelType") != m.end() && !m["AccessChannelType"].empty()) {
      accessChannelType = make_shared<string>(boost::any_cast<string>(m["AccessChannelType"]));
    }
    if (m.find("BeingAssigned") != m.end() && !m["BeingAssigned"].empty()) {
      beingAssigned = make_shared<bool>(boost::any_cast<bool>(m["BeingAssigned"]));
    }
    if (m.find("ChatConversationId") != m.end() && !m["ChatConversationId"].empty()) {
      chatConversationId = make_shared<string>(boost::any_cast<string>(m["ChatConversationId"]));
    }
    if (m.find("EnqueueTime") != m.end() && !m["EnqueueTime"].empty()) {
      enqueueTime = make_shared<long>(boost::any_cast<long>(m["EnqueueTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Messages") != m.end() && !m["Messages"].empty()) {
      if (typeid(vector<boost::any>) == m["Messages"].type()) {
        vector<ListWaitingChatsResponseBodyDataMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWaitingChatsResponseBodyDataMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<ListWaitingChatsResponseBodyDataMessages>>(expect1);
      }
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<ListWaitingChatsResponseBodyDataUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWaitingChatsResponseBodyDataUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<ListWaitingChatsResponseBodyDataUserList>>(expect1);
      }
    }
  }


  virtual ~ListWaitingChatsResponseBodyData() = default;
};
class ListWaitingChatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListWaitingChatsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListWaitingChatsResponseBody() {}

  explicit ListWaitingChatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListWaitingChatsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWaitingChatsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListWaitingChatsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListWaitingChatsResponseBody() = default;
};
class ListWaitingChatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWaitingChatsResponseBody> body{};

  ListWaitingChatsResponse() {}

  explicit ListWaitingChatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWaitingChatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWaitingChatsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWaitingChatsResponse() = default;
};
class MakeCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> flashSmsVariables{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> maskedCallee{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  MakeCallRequest() {}

  explicit MakeCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (flashSmsVariables) {
      res["FlashSmsVariables"] = boost::any(*flashSmsVariables);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maskedCallee) {
      res["MaskedCallee"] = boost::any(*maskedCallee);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("FlashSmsVariables") != m.end() && !m["FlashSmsVariables"].empty()) {
      flashSmsVariables = make_shared<string>(boost::any_cast<string>(m["FlashSmsVariables"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaskedCallee") != m.end() && !m["MaskedCallee"].empty()) {
      maskedCallee = make_shared<string>(boost::any_cast<string>(m["MaskedCallee"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MakeCallRequest() = default;
};
class MakeCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  MakeCallResponseBodyDataCallContextChannelContexts() {}

  explicit MakeCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MakeCallResponseBodyDataCallContextChannelContexts() = default;
};
class MakeCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<MakeCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  MakeCallResponseBodyDataCallContext() {}

  explicit MakeCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<MakeCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MakeCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<MakeCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~MakeCallResponseBodyDataCallContext() = default;
};
class MakeCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  MakeCallResponseBodyDataUserContext() {}

  explicit MakeCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~MakeCallResponseBodyDataUserContext() = default;
};
class MakeCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<MakeCallResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<MakeCallResponseBodyDataUserContext> userContext{};

  MakeCallResponseBodyData() {}

  explicit MakeCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        MakeCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<MakeCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        MakeCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<MakeCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~MakeCallResponseBodyData() = default;
};
class MakeCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<MakeCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  MakeCallResponseBody() {}

  explicit MakeCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        MakeCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<MakeCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MakeCallResponseBody() = default;
};
class MakeCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MakeCallResponseBody> body{};

  MakeCallResponse() {}

  explicit MakeCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MakeCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MakeCallResponseBody>(model1);
      }
    }
  }


  virtual ~MakeCallResponse() = default;
};
class ModifyAudioFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFileName{};
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> ossFileKey{};
  shared_ptr<string> usage{};

  ModifyAudioFileRequest() {}

  explicit ModifyAudioFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFileName) {
      res["AudioFileName"] = boost::any(*audioFileName);
    }
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossFileKey) {
      res["OssFileKey"] = boost::any(*ossFileKey);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFileName") != m.end() && !m["AudioFileName"].empty()) {
      audioFileName = make_shared<string>(boost::any_cast<string>(m["AudioFileName"]));
    }
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssFileKey") != m.end() && !m["OssFileKey"].empty()) {
      ossFileKey = make_shared<string>(boost::any_cast<string>(m["OssFileKey"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ModifyAudioFileRequest() = default;
};
class ModifyAudioFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyAudioFileResponseBody() {}

  explicit ModifyAudioFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAudioFileResponseBody() = default;
};
class ModifyAudioFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAudioFileResponseBody> body{};

  ModifyAudioFileResponse() {}

  explicit ModifyAudioFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAudioFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAudioFileResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAudioFileResponse() = default;
};
class ModifyCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> callTagNameList{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};

  ModifyCustomCallTaggingRequest() {}

  explicit ModifyCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callTagNameList) {
      res["CallTagNameList"] = boost::any(*callTagNameList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallTagNameList") != m.end() && !m["CallTagNameList"].empty()) {
      callTagNameList = make_shared<string>(boost::any_cast<string>(m["CallTagNameList"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~ModifyCustomCallTaggingRequest() = default;
};
class ModifyCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyCustomCallTaggingResponseBody() {}

  explicit ModifyCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCustomCallTaggingResponseBody() = default;
};
class ModifyCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCustomCallTaggingResponseBody> body{};

  ModifyCustomCallTaggingResponse() {}

  explicit ModifyCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCustomCallTaggingResponse() = default;
};
class ModifyInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};

  ModifyInstanceRequest() {}

  explicit ModifyInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyInstanceRequest() = default;
};
class ModifyInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyInstanceResponseBody() {}

  explicit ModifyInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceResponseBody() = default;
};
class ModifyInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceResponseBody> body{};

  ModifyInstanceResponse() {}

  explicit ModifyInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceResponse() = default;
};
class ModifyPhoneNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> usage{};

  ModifyPhoneNumberRequest() {}

  explicit ModifyPhoneNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ModifyPhoneNumberRequest() = default;
};
class ModifyPhoneNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyPhoneNumberResponseBody() {}

  explicit ModifyPhoneNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPhoneNumberResponseBody() = default;
};
class ModifyPhoneNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPhoneNumberResponseBody> body{};

  ModifyPhoneNumberResponse() {}

  explicit ModifyPhoneNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPhoneNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPhoneNumberResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPhoneNumberResponse() = default;
};
class ModifySkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};

  ModifySkillGroupRequest() {}

  explicit ModifySkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ModifySkillGroupRequest() = default;
};
class ModifySkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifySkillGroupResponseBody() {}

  explicit ModifySkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySkillGroupResponseBody() = default;
};
class ModifySkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySkillGroupResponseBody> body{};

  ModifySkillGroupResponse() {}

  explicit ModifySkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySkillGroupResponse() = default;
};
class ModifySkillLevelsOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillLevelList{};
  shared_ptr<string> userId{};

  ModifySkillLevelsOfUserRequest() {}

  explicit ModifySkillLevelsOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillLevelList) {
      res["SkillLevelList"] = boost::any(*skillLevelList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillLevelList") != m.end() && !m["SkillLevelList"].empty()) {
      skillLevelList = make_shared<string>(boost::any_cast<string>(m["SkillLevelList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ModifySkillLevelsOfUserRequest() = default;
};
class ModifySkillLevelsOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifySkillLevelsOfUserResponseBody() {}

  explicit ModifySkillLevelsOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySkillLevelsOfUserResponseBody() = default;
};
class ModifySkillLevelsOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySkillLevelsOfUserResponseBody> body{};

  ModifySkillLevelsOfUserResponse() {}

  explicit ModifySkillLevelsOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySkillLevelsOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySkillLevelsOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySkillLevelsOfUserResponse() = default;
};
class ModifyUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> displayId{};
  shared_ptr<string> displayName{};
  shared_ptr<bool> force{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mobile{};
  shared_ptr<string> nickname{};
  shared_ptr<string> roleId{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  ModifyUserRequest() {}

  explicit ModifyUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ModifyUserRequest() = default;
};
class ModifyUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ModifyUserResponseBody() {}

  explicit ModifyUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUserResponseBody() = default;
};
class ModifyUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyUserResponseBody> body{};

  ModifyUserResponse() {}

  explicit ModifyUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserResponse() = default;
};
class ModifyUserLevelsOfSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> userLevelList{};

  ModifyUserLevelsOfSkillGroupRequest() {}

  explicit ModifyUserLevelsOfSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userLevelList) {
      res["UserLevelList"] = boost::any(*userLevelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserLevelList") != m.end() && !m["UserLevelList"].empty()) {
      userLevelList = make_shared<string>(boost::any_cast<string>(m["UserLevelList"]));
    }
  }


  virtual ~ModifyUserLevelsOfSkillGroupRequest() = default;
};
class ModifyUserLevelsOfSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyUserLevelsOfSkillGroupResponseBody() {}

  explicit ModifyUserLevelsOfSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUserLevelsOfSkillGroupResponseBody() = default;
};
class ModifyUserLevelsOfSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyUserLevelsOfSkillGroupResponseBody> body{};

  ModifyUserLevelsOfSkillGroupResponse() {}

  explicit ModifyUserLevelsOfSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserLevelsOfSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserLevelsOfSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserLevelsOfSkillGroupResponse() = default;
};
class MonitorCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> monitoredUserId{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  MonitorCallRequest() {}

  explicit MonitorCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitoredUserId) {
      res["MonitoredUserId"] = boost::any(*monitoredUserId);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitoredUserId") != m.end() && !m["MonitoredUserId"].empty()) {
      monitoredUserId = make_shared<string>(boost::any_cast<string>(m["MonitoredUserId"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MonitorCallRequest() = default;
};
class MonitorCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  MonitorCallResponseBodyDataCallContextChannelContexts() {}

  explicit MonitorCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MonitorCallResponseBodyDataCallContextChannelContexts() = default;
};
class MonitorCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<MonitorCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  MonitorCallResponseBodyDataCallContext() {}

  explicit MonitorCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<MonitorCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MonitorCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<MonitorCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~MonitorCallResponseBodyDataCallContext() = default;
};
class MonitorCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  MonitorCallResponseBodyDataUserContext() {}

  explicit MonitorCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~MonitorCallResponseBodyDataUserContext() = default;
};
class MonitorCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<MonitorCallResponseBodyDataCallContext> callContext{};
  shared_ptr<MonitorCallResponseBodyDataUserContext> userContext{};

  MonitorCallResponseBodyData() {}

  explicit MonitorCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        MonitorCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<MonitorCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        MonitorCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<MonitorCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~MonitorCallResponseBodyData() = default;
};
class MonitorCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<MonitorCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  MonitorCallResponseBody() {}

  explicit MonitorCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        MonitorCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<MonitorCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MonitorCallResponseBody() = default;
};
class MonitorCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MonitorCallResponseBody> body{};

  MonitorCallResponse() {}

  explicit MonitorCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MonitorCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MonitorCallResponseBody>(model1);
      }
    }
  }


  virtual ~MonitorCallResponse() = default;
};
class MuteCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  MuteCallRequest() {}

  explicit MuteCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MuteCallRequest() = default;
};
class MuteCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  MuteCallResponseBodyDataCallContextChannelContexts() {}

  explicit MuteCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MuteCallResponseBodyDataCallContextChannelContexts() = default;
};
class MuteCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<MuteCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  MuteCallResponseBodyDataCallContext() {}

  explicit MuteCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<MuteCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MuteCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<MuteCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~MuteCallResponseBodyDataCallContext() = default;
};
class MuteCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  MuteCallResponseBodyDataUserContext() {}

  explicit MuteCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~MuteCallResponseBodyDataUserContext() = default;
};
class MuteCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<MuteCallResponseBodyDataCallContext> callContext{};
  shared_ptr<MuteCallResponseBodyDataUserContext> userContext{};

  MuteCallResponseBodyData() {}

  explicit MuteCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        MuteCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<MuteCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        MuteCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<MuteCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~MuteCallResponseBodyData() = default;
};
class MuteCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<MuteCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  MuteCallResponseBody() {}

  explicit MuteCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        MuteCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<MuteCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MuteCallResponseBody() = default;
};
class MuteCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MuteCallResponseBody> body{};

  MuteCallResponse() {}

  explicit MuteCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MuteCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MuteCallResponseBody>(model1);
      }
    }
  }


  virtual ~MuteCallResponse() = default;
};
class PauseCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  PauseCampaignRequest() {}

  explicit PauseCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~PauseCampaignRequest() = default;
};
class PauseCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  PauseCampaignResponseBody() {}

  explicit PauseCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PauseCampaignResponseBody() = default;
};
class PauseCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PauseCampaignResponseBody> body{};

  PauseCampaignResponse() {}

  explicit PauseCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PauseCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PauseCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~PauseCampaignResponse() = default;
};
class PickOutboundNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> calledNumber{};
  shared_ptr<long> count{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIdList{};

  PickOutboundNumbersRequest() {}

  explicit PickOutboundNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
  }


  virtual ~PickOutboundNumbersRequest() = default;
};
class PickOutboundNumbersResponseBodyDataCallee : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  PickOutboundNumbersResponseBodyDataCallee() {}

  explicit PickOutboundNumbersResponseBodyDataCallee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~PickOutboundNumbersResponseBodyDataCallee() = default;
};
class PickOutboundNumbersResponseBodyDataCaller : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  PickOutboundNumbersResponseBodyDataCaller() {}

  explicit PickOutboundNumbersResponseBodyDataCaller(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~PickOutboundNumbersResponseBodyDataCaller() = default;
};
class PickOutboundNumbersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<PickOutboundNumbersResponseBodyDataCallee> callee{};
  shared_ptr<PickOutboundNumbersResponseBodyDataCaller> caller{};

  PickOutboundNumbersResponseBodyData() {}

  explicit PickOutboundNumbersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = callee ? boost::any(callee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (caller) {
      res["Caller"] = caller ? boost::any(caller->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      if (typeid(map<string, boost::any>) == m["Callee"].type()) {
        PickOutboundNumbersResponseBodyDataCallee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Callee"]));
        callee = make_shared<PickOutboundNumbersResponseBodyDataCallee>(model1);
      }
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      if (typeid(map<string, boost::any>) == m["Caller"].type()) {
        PickOutboundNumbersResponseBodyDataCaller model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Caller"]));
        caller = make_shared<PickOutboundNumbersResponseBodyDataCaller>(model1);
      }
    }
  }


  virtual ~PickOutboundNumbersResponseBodyData() = default;
};
class PickOutboundNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<PickOutboundNumbersResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  PickOutboundNumbersResponseBody() {}

  explicit PickOutboundNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<PickOutboundNumbersResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PickOutboundNumbersResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<PickOutboundNumbersResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PickOutboundNumbersResponseBody() = default;
};
class PickOutboundNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PickOutboundNumbersResponseBody> body{};

  PickOutboundNumbersResponse() {}

  explicit PickOutboundNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PickOutboundNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PickOutboundNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~PickOutboundNumbersResponse() = default;
};
class PollUserStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  PollUserStatusRequest() {}

  explicit PollUserStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~PollUserStatusRequest() = default;
};
class PollUserStatusResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> channelVariables{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  PollUserStatusResponseBodyDataCallContextChannelContexts() {}

  explicit PollUserStatusResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (channelVariables) {
      res["ChannelVariables"] = boost::any(*channelVariables);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("ChannelVariables") != m.end() && !m["ChannelVariables"].empty()) {
      channelVariables = make_shared<string>(boost::any_cast<string>(m["ChannelVariables"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~PollUserStatusResponseBodyDataCallContextChannelContexts() = default;
};
class PollUserStatusResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> callVariables{};
  shared_ptr<vector<PollUserStatusResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  PollUserStatusResponseBodyDataCallContext() {}

  explicit PollUserStatusResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (callVariables) {
      res["CallVariables"] = boost::any(*callVariables);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("CallVariables") != m.end() && !m["CallVariables"].empty()) {
      callVariables = make_shared<string>(boost::any_cast<string>(m["CallVariables"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<PollUserStatusResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PollUserStatusResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<PollUserStatusResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~PollUserStatusResponseBodyDataCallContext() = default;
};
class PollUserStatusResponseBodyDataChatContextsMembers : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};
  shared_ptr<string> userType{};

  PollUserStatusResponseBodyDataChatContextsMembers() {}

  explicit PollUserStatusResponseBodyDataChatContextsMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~PollUserStatusResponseBodyDataChatContextsMembers() = default;
};
class PollUserStatusResponseBodyDataChatContexts : public Darabonba::Model {
public:
  shared_ptr<string> callVariables{};
  shared_ptr<string> chatType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<vector<PollUserStatusResponseBodyDataChatContextsMembers>> members{};

  PollUserStatusResponseBodyDataChatContexts() {}

  explicit PollUserStatusResponseBodyDataChatContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callVariables) {
      res["CallVariables"] = boost::any(*callVariables);
    }
    if (chatType) {
      res["ChatType"] = boost::any(*chatType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallVariables") != m.end() && !m["CallVariables"].empty()) {
      callVariables = make_shared<string>(boost::any_cast<string>(m["CallVariables"]));
    }
    if (m.find("ChatType") != m.end() && !m["ChatType"].empty()) {
      chatType = make_shared<string>(boost::any_cast<string>(m["ChatType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<PollUserStatusResponseBodyDataChatContextsMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PollUserStatusResponseBodyDataChatContextsMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<PollUserStatusResponseBodyDataChatContextsMembers>>(expect1);
      }
    }
  }


  virtual ~PollUserStatusResponseBodyDataChatContexts() = default;
};
class PollUserStatusResponseBodyDataUserContextParallelJobList : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> status{};
  shared_ptr<long> timestamp{};

  PollUserStatusResponseBodyDataUserContextParallelJobList() {}

  explicit PollUserStatusResponseBodyDataUserContextParallelJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~PollUserStatusResponseBodyDataUserContextParallelJobList() = default;
};
class PollUserStatusResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<PollUserStatusResponseBodyDataUserContextParallelJobList>> parallelJobList{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  PollUserStatusResponseBodyDataUserContext() {}

  explicit PollUserStatusResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (parallelJobList) {
      vector<boost::any> temp1;
      for(auto item1:*parallelJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParallelJobList"] = boost::any(temp1);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("ParallelJobList") != m.end() && !m["ParallelJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParallelJobList"].type()) {
        vector<PollUserStatusResponseBodyDataUserContextParallelJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParallelJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PollUserStatusResponseBodyDataUserContextParallelJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parallelJobList = make_shared<vector<PollUserStatusResponseBodyDataUserContextParallelJobList>>(expect1);
      }
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~PollUserStatusResponseBodyDataUserContext() = default;
};
class PollUserStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<PollUserStatusResponseBodyDataCallContext> callContext{};
  shared_ptr<vector<PollUserStatusResponseBodyDataChatContexts>> chatContexts{};
  shared_ptr<long> contextId{};
  shared_ptr<PollUserStatusResponseBodyDataUserContext> userContext{};

  PollUserStatusResponseBodyData() {}

  explicit PollUserStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (chatContexts) {
      vector<boost::any> temp1;
      for(auto item1:*chatContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChatContexts"] = boost::any(temp1);
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        PollUserStatusResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<PollUserStatusResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ChatContexts") != m.end() && !m["ChatContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChatContexts"].type()) {
        vector<PollUserStatusResponseBodyDataChatContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChatContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PollUserStatusResponseBodyDataChatContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        chatContexts = make_shared<vector<PollUserStatusResponseBodyDataChatContexts>>(expect1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        PollUserStatusResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<PollUserStatusResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~PollUserStatusResponseBodyData() = default;
};
class PollUserStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<PollUserStatusResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  PollUserStatusResponseBody() {}

  explicit PollUserStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PollUserStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PollUserStatusResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PollUserStatusResponseBody() = default;
};
class PollUserStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PollUserStatusResponseBody> body{};

  PollUserStatusResponse() {}

  explicit PollUserStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PollUserStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PollUserStatusResponseBody>(model1);
      }
    }
  }


  virtual ~PollUserStatusResponse() = default;
};
class ProcessAliMeCallbackOfStagingRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> token{};

  ProcessAliMeCallbackOfStagingRequest() {}

  explicit ProcessAliMeCallbackOfStagingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~ProcessAliMeCallbackOfStagingRequest() = default;
};
class ProcessAliMeCallbackOfStagingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> result{};

  ProcessAliMeCallbackOfStagingResponseBodyData() {}

  explicit ProcessAliMeCallbackOfStagingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ProcessAliMeCallbackOfStagingResponseBodyData() = default;
};
class ProcessAliMeCallbackOfStagingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ProcessAliMeCallbackOfStagingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ProcessAliMeCallbackOfStagingResponseBody() {}

  explicit ProcessAliMeCallbackOfStagingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ProcessAliMeCallbackOfStagingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ProcessAliMeCallbackOfStagingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ProcessAliMeCallbackOfStagingResponseBody() = default;
};
class ProcessAliMeCallbackOfStagingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ProcessAliMeCallbackOfStagingResponseBody> body{};

  ProcessAliMeCallbackOfStagingResponse() {}

  explicit ProcessAliMeCallbackOfStagingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProcessAliMeCallbackOfStagingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProcessAliMeCallbackOfStagingResponseBody>(model1);
      }
    }
  }


  virtual ~ProcessAliMeCallbackOfStagingResponse() = default;
};
class PublishContactFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> draftId{};
  shared_ptr<string> instanceId{};

  PublishContactFlowRequest() {}

  explicit PublishContactFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (draftId) {
      res["DraftId"] = boost::any(*draftId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("DraftId") != m.end() && !m["DraftId"].empty()) {
      draftId = make_shared<string>(boost::any_cast<string>(m["DraftId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~PublishContactFlowRequest() = default;
};
class PublishContactFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  PublishContactFlowResponseBody() {}

  explicit PublishContactFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishContactFlowResponseBody() = default;
};
class PublishContactFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishContactFlowResponseBody> body{};

  PublishContactFlowResponse() {}

  explicit PublishContactFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishContactFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishContactFlowResponseBody>(model1);
      }
    }
  }


  virtual ~PublishContactFlowResponse() = default;
};
class ReadyForServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<string> userId{};

  ReadyForServiceRequest() {}

  explicit ReadyForServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ReadyForServiceRequest() = default;
};
class ReadyForServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  ReadyForServiceResponseBodyData() {}

  explicit ReadyForServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ReadyForServiceResponseBodyData() = default;
};
class ReadyForServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ReadyForServiceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ReadyForServiceResponseBody() {}

  explicit ReadyForServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ReadyForServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ReadyForServiceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReadyForServiceResponseBody() = default;
};
class ReadyForServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReadyForServiceResponseBody> body{};

  ReadyForServiceResponse() {}

  explicit ReadyForServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReadyForServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReadyForServiceResponseBody>(model1);
      }
    }
  }


  virtual ~ReadyForServiceResponse() = default;
};
class RedialCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  RedialCallRequest() {}

  explicit RedialCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RedialCallRequest() = default;
};
class RedialCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  RedialCallResponseBodyDataCallContextChannelContexts() {}

  explicit RedialCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RedialCallResponseBodyDataCallContextChannelContexts() = default;
};
class RedialCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<RedialCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  RedialCallResponseBodyDataCallContext() {}

  explicit RedialCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<RedialCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RedialCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<RedialCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~RedialCallResponseBodyDataCallContext() = default;
};
class RedialCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  RedialCallResponseBodyDataUserContext() {}

  explicit RedialCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~RedialCallResponseBodyDataUserContext() = default;
};
class RedialCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<RedialCallResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<RedialCallResponseBodyDataUserContext> userContext{};

  RedialCallResponseBodyData() {}

  explicit RedialCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        RedialCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<RedialCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        RedialCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<RedialCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~RedialCallResponseBodyData() = default;
};
class RedialCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RedialCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RedialCallResponseBody() {}

  explicit RedialCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RedialCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RedialCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RedialCallResponseBody() = default;
};
class RedialCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RedialCallResponseBody> body{};

  RedialCallResponse() {}

  explicit RedialCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RedialCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RedialCallResponseBody>(model1);
      }
    }
  }


  virtual ~RedialCallResponse() = default;
};
class RegisterDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> password{};
  shared_ptr<string> userId{};

  RegisterDeviceRequest() {}

  explicit RegisterDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RegisterDeviceRequest() = default;
};
class RegisterDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RegisterDeviceResponseBody() {}

  explicit RegisterDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterDeviceResponseBody() = default;
};
class RegisterDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterDeviceResponseBody> body{};

  RegisterDeviceResponse() {}

  explicit RegisterDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterDeviceResponse() = default;
};
class RegisterDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> password{};
  shared_ptr<string> userIdListJson{};

  RegisterDevicesRequest() {}

  explicit RegisterDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userIdListJson) {
      res["UserIdListJson"] = boost::any(*userIdListJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserIdListJson") != m.end() && !m["UserIdListJson"].empty()) {
      userIdListJson = make_shared<string>(boost::any_cast<string>(m["UserIdListJson"]));
    }
  }


  virtual ~RegisterDevicesRequest() = default;
};
class RegisterDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RegisterDevicesResponseBody() {}

  explicit RegisterDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterDevicesResponseBody() = default;
};
class RegisterDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterDevicesResponseBody> body{};

  RegisterDevicesResponse() {}

  explicit RegisterDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterDevicesResponse() = default;
};
class RejectChatRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  RejectChatRequest() {}

  explicit RejectChatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~RejectChatRequest() = default;
};
class RejectChatResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RejectChatResponseBody() {}

  explicit RejectChatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RejectChatResponseBody() = default;
};
class RejectChatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RejectChatResponseBody> body{};

  RejectChatResponse() {}

  explicit RejectChatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RejectChatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RejectChatResponseBody>(model1);
      }
    }
  }


  virtual ~RejectChatResponse() = default;
};
class RejectTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ticketId{};

  RejectTicketRequest() {}

  explicit RejectTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~RejectTicketRequest() = default;
};
class RejectTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RejectTicketResponseBody() {}

  explicit RejectTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RejectTicketResponseBody() = default;
};
class RejectTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RejectTicketResponseBody> body{};

  RejectTicketResponse() {}

  explicit RejectTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RejectTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RejectTicketResponseBody>(model1);
      }
    }
  }


  virtual ~RejectTicketResponse() = default;
};
class ReleaseCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  ReleaseCallRequest() {}

  explicit ReleaseCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ReleaseCallRequest() = default;
};
class ReleaseCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> channelVariables{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  ReleaseCallResponseBodyDataCallContextChannelContexts() {}

  explicit ReleaseCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (channelVariables) {
      res["ChannelVariables"] = boost::any(*channelVariables);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("ChannelVariables") != m.end() && !m["ChannelVariables"].empty()) {
      channelVariables = make_shared<string>(boost::any_cast<string>(m["ChannelVariables"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ReleaseCallResponseBodyDataCallContextChannelContexts() = default;
};
class ReleaseCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<vector<ReleaseCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  ReleaseCallResponseBodyDataCallContext() {}

  explicit ReleaseCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<ReleaseCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ReleaseCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<ReleaseCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReleaseCallResponseBodyDataCallContext() = default;
};
class ReleaseCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  ReleaseCallResponseBodyDataUserContext() {}

  explicit ReleaseCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ReleaseCallResponseBodyDataUserContext() = default;
};
class ReleaseCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ReleaseCallResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<ReleaseCallResponseBodyDataUserContext> userContext{};

  ReleaseCallResponseBodyData() {}

  explicit ReleaseCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        ReleaseCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<ReleaseCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        ReleaseCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<ReleaseCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~ReleaseCallResponseBodyData() = default;
};
class ReleaseCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ReleaseCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ReleaseCallResponseBody() {}

  explicit ReleaseCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ReleaseCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ReleaseCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseCallResponseBody() = default;
};
class ReleaseCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseCallResponseBody> body{};

  ReleaseCallResponse() {}

  explicit ReleaseCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseCallResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseCallResponse() = default;
};
class ReleaseChatRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> token{};
  shared_ptr<string> userId{};
  shared_ptr<string> userType{};

  ReleaseChatRequest() {}

  explicit ReleaseChatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~ReleaseChatRequest() = default;
};
class ReleaseChatResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ReleaseChatResponseBody() {}

  explicit ReleaseChatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseChatResponseBody() = default;
};
class ReleaseChatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseChatResponseBody> body{};

  ReleaseChatResponse() {}

  explicit ReleaseChatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseChatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseChatResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseChatResponse() = default;
};
class RemoveBlacklistCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> number{};

  RemoveBlacklistCallTaggingRequest() {}

  explicit RemoveBlacklistCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~RemoveBlacklistCallTaggingRequest() = default;
};
class RemoveBlacklistCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveBlacklistCallTaggingResponseBody() {}

  explicit RemoveBlacklistCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveBlacklistCallTaggingResponseBody() = default;
};
class RemoveBlacklistCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveBlacklistCallTaggingResponseBody> body{};

  RemoveBlacklistCallTaggingResponse() {}

  explicit RemoveBlacklistCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveBlacklistCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveBlacklistCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveBlacklistCallTaggingResponse() = default;
};
class RemoveDoNotCallNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};

  RemoveDoNotCallNumbersRequest() {}

  explicit RemoveDoNotCallNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
  }


  virtual ~RemoveDoNotCallNumbersRequest() = default;
};
class RemoveDoNotCallNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RemoveDoNotCallNumbersResponseBody() {}

  explicit RemoveDoNotCallNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveDoNotCallNumbersResponseBody() = default;
};
class RemoveDoNotCallNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveDoNotCallNumbersResponseBody> body{};

  RemoveDoNotCallNumbersResponse() {}

  explicit RemoveDoNotCallNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveDoNotCallNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveDoNotCallNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveDoNotCallNumbersResponse() = default;
};
class RemovePersonalNumbersFromUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> userId{};

  RemovePersonalNumbersFromUserRequest() {}

  explicit RemovePersonalNumbersFromUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RemovePersonalNumbersFromUserRequest() = default;
};
class RemovePersonalNumbersFromUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemovePersonalNumbersFromUserResponseBody() {}

  explicit RemovePersonalNumbersFromUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePersonalNumbersFromUserResponseBody() = default;
};
class RemovePersonalNumbersFromUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePersonalNumbersFromUserResponseBody> body{};

  RemovePersonalNumbersFromUserResponse() {}

  explicit RemovePersonalNumbersFromUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePersonalNumbersFromUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePersonalNumbersFromUserResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePersonalNumbersFromUserResponse() = default;
};
class RemovePhoneNumberFromSkillGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> skillGroupIdList{};

  RemovePhoneNumberFromSkillGroupsRequest() {}

  explicit RemovePhoneNumberFromSkillGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
  }


  virtual ~RemovePhoneNumberFromSkillGroupsRequest() = default;
};
class RemovePhoneNumberFromSkillGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemovePhoneNumberFromSkillGroupsResponseBody() {}

  explicit RemovePhoneNumberFromSkillGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePhoneNumberFromSkillGroupsResponseBody() = default;
};
class RemovePhoneNumberFromSkillGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePhoneNumberFromSkillGroupsResponseBody> body{};

  RemovePhoneNumberFromSkillGroupsResponse() {}

  explicit RemovePhoneNumberFromSkillGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePhoneNumberFromSkillGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePhoneNumberFromSkillGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePhoneNumberFromSkillGroupsResponse() = default;
};
class RemovePhoneNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<bool> force{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};

  RemovePhoneNumbersRequest() {}

  explicit RemovePhoneNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
  }


  virtual ~RemovePhoneNumbersRequest() = default;
};
class RemovePhoneNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RemovePhoneNumbersResponseBody() {}

  explicit RemovePhoneNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePhoneNumbersResponseBody() = default;
};
class RemovePhoneNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePhoneNumbersResponseBody> body{};

  RemovePhoneNumbersResponse() {}

  explicit RemovePhoneNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePhoneNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePhoneNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePhoneNumbersResponse() = default;
};
class RemovePhoneNumbersFromSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> skillGroupId{};

  RemovePhoneNumbersFromSkillGroupRequest() {}

  explicit RemovePhoneNumbersFromSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~RemovePhoneNumbersFromSkillGroupRequest() = default;
};
class RemovePhoneNumbersFromSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemovePhoneNumbersFromSkillGroupResponseBody() {}

  explicit RemovePhoneNumbersFromSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePhoneNumbersFromSkillGroupResponseBody() = default;
};
class RemovePhoneNumbersFromSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePhoneNumbersFromSkillGroupResponseBody> body{};

  RemovePhoneNumbersFromSkillGroupResponse() {}

  explicit RemovePhoneNumbersFromSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePhoneNumbersFromSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePhoneNumbersFromSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePhoneNumbersFromSkillGroupResponse() = default;
};
class RemoveSkillGroupsFromUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIdList{};
  shared_ptr<string> userId{};

  RemoveSkillGroupsFromUserRequest() {}

  explicit RemoveSkillGroupsFromUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RemoveSkillGroupsFromUserRequest() = default;
};
class RemoveSkillGroupsFromUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveSkillGroupsFromUserResponseBody() {}

  explicit RemoveSkillGroupsFromUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveSkillGroupsFromUserResponseBody() = default;
};
class RemoveSkillGroupsFromUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveSkillGroupsFromUserResponseBody> body{};

  RemoveSkillGroupsFromUserResponse() {}

  explicit RemoveSkillGroupsFromUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveSkillGroupsFromUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveSkillGroupsFromUserResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveSkillGroupsFromUserResponse() = default;
};
class RemoveUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<bool> force{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> notificationEmail{};
  shared_ptr<string> userIdList{};

  RemoveUsersRequest() {}

  explicit RemoveUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (notificationEmail) {
      res["NotificationEmail"] = boost::any(*notificationEmail);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NotificationEmail") != m.end() && !m["NotificationEmail"].empty()) {
      notificationEmail = make_shared<string>(boost::any_cast<string>(m["NotificationEmail"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      userIdList = make_shared<string>(boost::any_cast<string>(m["UserIdList"]));
    }
  }


  virtual ~RemoveUsersRequest() = default;
};
class RemoveUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RemoveUsersResponseBody() {}

  explicit RemoveUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveUsersResponseBody() = default;
};
class RemoveUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveUsersResponseBody> body{};

  RemoveUsersResponse() {}

  explicit RemoveUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUsersResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUsersResponse() = default;
};
class RemoveUsersFromSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> userIdList{};

  RemoveUsersFromSkillGroupRequest() {}

  explicit RemoveUsersFromSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      userIdList = make_shared<string>(boost::any_cast<string>(m["UserIdList"]));
    }
  }


  virtual ~RemoveUsersFromSkillGroupRequest() = default;
};
class RemoveUsersFromSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveUsersFromSkillGroupResponseBody() {}

  explicit RemoveUsersFromSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveUsersFromSkillGroupResponseBody() = default;
};
class RemoveUsersFromSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveUsersFromSkillGroupResponseBody> body{};

  RemoveUsersFromSkillGroupResponse() {}

  explicit RemoveUsersFromSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUsersFromSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUsersFromSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUsersFromSkillGroupResponse() = default;
};
class ResetAgentStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  ResetAgentStateRequest() {}

  explicit ResetAgentStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ResetAgentStateRequest() = default;
};
class ResetAgentStateResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  ResetAgentStateResponseBodyData() {}

  explicit ResetAgentStateResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ResetAgentStateResponseBodyData() = default;
};
class ResetAgentStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ResetAgentStateResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ResetAgentStateResponseBody() {}

  explicit ResetAgentStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ResetAgentStateResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ResetAgentStateResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetAgentStateResponseBody() = default;
};
class ResetAgentStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetAgentStateResponseBody> body{};

  ResetAgentStateResponse() {}

  explicit ResetAgentStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAgentStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAgentStateResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAgentStateResponse() = default;
};
class ResetUserPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> password{};
  shared_ptr<string> userId{};

  ResetUserPasswordRequest() {}

  explicit ResetUserPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ResetUserPasswordRequest() = default;
};
class ResetUserPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ResetUserPasswordResponseBody() {}

  explicit ResetUserPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetUserPasswordResponseBody() = default;
};
class ResetUserPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetUserPasswordResponseBody> body{};

  ResetUserPasswordResponse() {}

  explicit ResetUserPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetUserPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetUserPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ResetUserPasswordResponse() = default;
};
class RestoreArchivedRecordingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactIds{};
  shared_ptr<string> instanceId{};

  RestoreArchivedRecordingsRequest() {}

  explicit RestoreArchivedRecordingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~RestoreArchivedRecordingsRequest() = default;
};
class RestoreArchivedRecordingsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> exists{};
  shared_ptr<string> status{};
  shared_ptr<string> storageType{};

  RestoreArchivedRecordingsResponseBodyData() {}

  explicit RestoreArchivedRecordingsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (exists) {
      res["Exists"] = boost::any(*exists);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Exists") != m.end() && !m["Exists"].empty()) {
      exists = make_shared<string>(boost::any_cast<string>(m["Exists"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~RestoreArchivedRecordingsResponseBodyData() = default;
};
class RestoreArchivedRecordingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<RestoreArchivedRecordingsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RestoreArchivedRecordingsResponseBody() {}

  explicit RestoreArchivedRecordingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<RestoreArchivedRecordingsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RestoreArchivedRecordingsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<RestoreArchivedRecordingsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestoreArchivedRecordingsResponseBody() = default;
};
class RestoreArchivedRecordingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestoreArchivedRecordingsResponseBody> body{};

  RestoreArchivedRecordingsResponse() {}

  explicit RestoreArchivedRecordingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestoreArchivedRecordingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestoreArchivedRecordingsResponseBody>(model1);
      }
    }
  }


  virtual ~RestoreArchivedRecordingsResponse() = default;
};
class ResubmitTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ticketId{};

  ResubmitTicketRequest() {}

  explicit ResubmitTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~ResubmitTicketRequest() = default;
};
class ResubmitTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ResubmitTicketResponseBody() {}

  explicit ResubmitTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResubmitTicketResponseBody() = default;
};
class ResubmitTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResubmitTicketResponseBody> body{};

  ResubmitTicketResponse() {}

  explicit ResubmitTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResubmitTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResubmitTicketResponseBody>(model1);
      }
    }
  }


  virtual ~ResubmitTicketResponse() = default;
};
class ResumeCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  ResumeCampaignRequest() {}

  explicit ResumeCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ResumeCampaignRequest() = default;
};
class ResumeCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ResumeCampaignResponseBody() {}

  explicit ResumeCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeCampaignResponseBody() = default;
};
class ResumeCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeCampaignResponseBody> body{};

  ResumeCampaignResponse() {}

  explicit ResumeCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeCampaignResponse() = default;
};
class RetrieveCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  RetrieveCallRequest() {}

  explicit RetrieveCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RetrieveCallRequest() = default;
};
class RetrieveCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  RetrieveCallResponseBodyDataCallContextChannelContexts() {}

  explicit RetrieveCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RetrieveCallResponseBodyDataCallContextChannelContexts() = default;
};
class RetrieveCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<RetrieveCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  RetrieveCallResponseBodyDataCallContext() {}

  explicit RetrieveCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<RetrieveCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RetrieveCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<RetrieveCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~RetrieveCallResponseBodyDataCallContext() = default;
};
class RetrieveCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  RetrieveCallResponseBodyDataUserContext() {}

  explicit RetrieveCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~RetrieveCallResponseBodyDataUserContext() = default;
};
class RetrieveCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<RetrieveCallResponseBodyDataCallContext> callContext{};
  shared_ptr<RetrieveCallResponseBodyDataUserContext> userContext{};

  RetrieveCallResponseBodyData() {}

  explicit RetrieveCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        RetrieveCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<RetrieveCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        RetrieveCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<RetrieveCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~RetrieveCallResponseBodyData() = default;
};
class RetrieveCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RetrieveCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RetrieveCallResponseBody() {}

  explicit RetrieveCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RetrieveCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RetrieveCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RetrieveCallResponseBody() = default;
};
class RetrieveCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetrieveCallResponseBody> body{};

  RetrieveCallResponse() {}

  explicit RetrieveCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetrieveCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetrieveCallResponseBody>(model1);
      }
    }
  }


  virtual ~RetrieveCallResponse() = default;
};
class SaveDocumentRequest : public Darabonba::Model {
public:
  shared_ptr<string> documentId{};
  shared_ptr<string> documentJson{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  SaveDocumentRequest() {}

  explicit SaveDocumentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (documentId) {
      res["DocumentId"] = boost::any(*documentId);
    }
    if (documentJson) {
      res["DocumentJson"] = boost::any(*documentJson);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocumentId") != m.end() && !m["DocumentId"].empty()) {
      documentId = make_shared<string>(boost::any_cast<string>(m["DocumentId"]));
    }
    if (m.find("DocumentJson") != m.end() && !m["DocumentJson"].empty()) {
      documentJson = make_shared<string>(boost::any_cast<string>(m["DocumentJson"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~SaveDocumentRequest() = default;
};
class SaveDocumentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  SaveDocumentResponseBody() {}

  explicit SaveDocumentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SaveDocumentResponseBody() = default;
};
class SaveDocumentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveDocumentResponseBody> body{};

  SaveDocumentResponse() {}

  explicit SaveDocumentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveDocumentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveDocumentResponseBody>(model1);
      }
    }
  }


  virtual ~SaveDocumentResponse() = default;
};
class SaveRTCStatsV2Request : public Darabonba::Model {
public:
  shared_ptr<string> callId{};
  shared_ptr<string> generalInfo{};
  shared_ptr<string> googAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> receiverReport{};
  shared_ptr<string> senderReport{};

  SaveRTCStatsV2Request() {}

  explicit SaveRTCStatsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (generalInfo) {
      res["GeneralInfo"] = boost::any(*generalInfo);
    }
    if (googAddress) {
      res["GoogAddress"] = boost::any(*googAddress);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (receiverReport) {
      res["ReceiverReport"] = boost::any(*receiverReport);
    }
    if (senderReport) {
      res["SenderReport"] = boost::any(*senderReport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("GeneralInfo") != m.end() && !m["GeneralInfo"].empty()) {
      generalInfo = make_shared<string>(boost::any_cast<string>(m["GeneralInfo"]));
    }
    if (m.find("GoogAddress") != m.end() && !m["GoogAddress"].empty()) {
      googAddress = make_shared<string>(boost::any_cast<string>(m["GoogAddress"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ReceiverReport") != m.end() && !m["ReceiverReport"].empty()) {
      receiverReport = make_shared<string>(boost::any_cast<string>(m["ReceiverReport"]));
    }
    if (m.find("SenderReport") != m.end() && !m["SenderReport"].empty()) {
      senderReport = make_shared<string>(boost::any_cast<string>(m["SenderReport"]));
    }
  }


  virtual ~SaveRTCStatsV2Request() = default;
};
class SaveRTCStatsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rowCount{};
  shared_ptr<bool> success{};
  shared_ptr<long> timeStamp{};

  SaveRTCStatsV2ResponseBody() {}

  explicit SaveRTCStatsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~SaveRTCStatsV2ResponseBody() = default;
};
class SaveRTCStatsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveRTCStatsV2ResponseBody> body{};

  SaveRTCStatsV2Response() {}

  explicit SaveRTCStatsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveRTCStatsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveRTCStatsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~SaveRTCStatsV2Response() = default;
};
class SaveTerminalLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> callId{};
  shared_ptr<string> content{};
  shared_ptr<long> dataType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> methodName{};
  shared_ptr<string> status{};
  shared_ptr<string> uniqueRequestId{};

  SaveTerminalLogRequest() {}

  explicit SaveTerminalLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uniqueRequestId) {
      res["UniqueRequestId"] = boost::any(*uniqueRequestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<long>(boost::any_cast<long>(m["DataType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UniqueRequestId") != m.end() && !m["UniqueRequestId"].empty()) {
      uniqueRequestId = make_shared<string>(boost::any_cast<string>(m["UniqueRequestId"]));
    }
  }


  virtual ~SaveTerminalLogRequest() = default;
};
class SaveTerminalLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> timeStamp{};

  SaveTerminalLogResponseBody() {}

  explicit SaveTerminalLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~SaveTerminalLogResponseBody() = default;
};
class SaveTerminalLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveTerminalLogResponseBody> body{};

  SaveTerminalLogResponse() {}

  explicit SaveTerminalLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveTerminalLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveTerminalLogResponseBody>(model1);
      }
    }
  }


  virtual ~SaveTerminalLogResponse() = default;
};
class SaveWebRTCStatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> callId{};
  shared_ptr<string> generalInfo{};
  shared_ptr<string> googAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> receiverReport{};
  shared_ptr<string> senderReport{};

  SaveWebRTCStatsRequest() {}

  explicit SaveWebRTCStatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (generalInfo) {
      res["GeneralInfo"] = boost::any(*generalInfo);
    }
    if (googAddress) {
      res["GoogAddress"] = boost::any(*googAddress);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (receiverReport) {
      res["ReceiverReport"] = boost::any(*receiverReport);
    }
    if (senderReport) {
      res["SenderReport"] = boost::any(*senderReport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("GeneralInfo") != m.end() && !m["GeneralInfo"].empty()) {
      generalInfo = make_shared<string>(boost::any_cast<string>(m["GeneralInfo"]));
    }
    if (m.find("GoogAddress") != m.end() && !m["GoogAddress"].empty()) {
      googAddress = make_shared<string>(boost::any_cast<string>(m["GoogAddress"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ReceiverReport") != m.end() && !m["ReceiverReport"].empty()) {
      receiverReport = make_shared<string>(boost::any_cast<string>(m["ReceiverReport"]));
    }
    if (m.find("SenderReport") != m.end() && !m["SenderReport"].empty()) {
      senderReport = make_shared<string>(boost::any_cast<string>(m["SenderReport"]));
    }
  }


  virtual ~SaveWebRTCStatsRequest() = default;
};
class SaveWebRTCStatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rowCount{};
  shared_ptr<bool> success{};
  shared_ptr<long> timeStamp{};

  SaveWebRTCStatsResponseBody() {}

  explicit SaveWebRTCStatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~SaveWebRTCStatsResponseBody() = default;
};
class SaveWebRTCStatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveWebRTCStatsResponseBody> body{};

  SaveWebRTCStatsResponse() {}

  explicit SaveWebRTCStatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveWebRTCStatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveWebRTCStatsResponseBody>(model1);
      }
    }
  }


  virtual ~SaveWebRTCStatsResponse() = default;
};
class SaveWebRtcInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> callId{};
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  SaveWebRtcInfoRequest() {}

  explicit SaveWebRtcInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SaveWebRtcInfoRequest() = default;
};
class SaveWebRtcInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rowCount{};
  shared_ptr<bool> success{};
  shared_ptr<long> timeStamp{};

  SaveWebRtcInfoResponseBody() {}

  explicit SaveWebRtcInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~SaveWebRtcInfoResponseBody() = default;
};
class SaveWebRtcInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveWebRtcInfoResponseBody> body{};

  SaveWebRtcInfoResponse() {}

  explicit SaveWebRtcInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveWebRtcInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveWebRtcInfoResponseBody>(model1);
      }
    }
  }


  virtual ~SaveWebRtcInfoResponse() = default;
};
class SendDtmfSignalingRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> dtmf{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  SendDtmfSignalingRequest() {}

  explicit SendDtmfSignalingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (dtmf) {
      res["Dtmf"] = boost::any(*dtmf);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Dtmf") != m.end() && !m["Dtmf"].empty()) {
      dtmf = make_shared<string>(boost::any_cast<string>(m["Dtmf"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SendDtmfSignalingRequest() = default;
};
class SendDtmfSignalingResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  SendDtmfSignalingResponseBodyDataCallContextChannelContexts() {}

  explicit SendDtmfSignalingResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SendDtmfSignalingResponseBodyDataCallContextChannelContexts() = default;
};
class SendDtmfSignalingResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<SendDtmfSignalingResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  SendDtmfSignalingResponseBodyDataCallContext() {}

  explicit SendDtmfSignalingResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<SendDtmfSignalingResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SendDtmfSignalingResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<SendDtmfSignalingResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SendDtmfSignalingResponseBodyDataCallContext() = default;
};
class SendDtmfSignalingResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  SendDtmfSignalingResponseBodyDataUserContext() {}

  explicit SendDtmfSignalingResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~SendDtmfSignalingResponseBodyDataUserContext() = default;
};
class SendDtmfSignalingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<SendDtmfSignalingResponseBodyDataCallContext> callContext{};
  shared_ptr<SendDtmfSignalingResponseBodyDataUserContext> userContext{};

  SendDtmfSignalingResponseBodyData() {}

  explicit SendDtmfSignalingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        SendDtmfSignalingResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<SendDtmfSignalingResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        SendDtmfSignalingResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<SendDtmfSignalingResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~SendDtmfSignalingResponseBodyData() = default;
};
class SendDtmfSignalingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SendDtmfSignalingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  SendDtmfSignalingResponseBody() {}

  explicit SendDtmfSignalingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SendDtmfSignalingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SendDtmfSignalingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendDtmfSignalingResponseBody() = default;
};
class SendDtmfSignalingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendDtmfSignalingResponseBody> body{};

  SendDtmfSignalingResponse() {}

  explicit SendDtmfSignalingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendDtmfSignalingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendDtmfSignalingResponseBody>(model1);
      }
    }
  }


  virtual ~SendDtmfSignalingResponse() = default;
};
class SignInGroupRequest : public Darabonba::Model {
public:
  shared_ptr<bool> additivity{};
  shared_ptr<string> chatDeviceId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> signedSkillGroupIdList{};
  shared_ptr<string> userId{};

  SignInGroupRequest() {}

  explicit SignInGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additivity) {
      res["Additivity"] = boost::any(*additivity);
    }
    if (chatDeviceId) {
      res["ChatDeviceId"] = boost::any(*chatDeviceId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Additivity") != m.end() && !m["Additivity"].empty()) {
      additivity = make_shared<bool>(boost::any_cast<bool>(m["Additivity"]));
    }
    if (m.find("ChatDeviceId") != m.end() && !m["ChatDeviceId"].empty()) {
      chatDeviceId = make_shared<string>(boost::any_cast<string>(m["ChatDeviceId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      signedSkillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SignedSkillGroupIdList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SignInGroupRequest() = default;
};
class SignInGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> chatDeviceId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  SignInGroupResponseBodyData() {}

  explicit SignInGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (chatDeviceId) {
      res["ChatDeviceId"] = boost::any(*chatDeviceId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("ChatDeviceId") != m.end() && !m["ChatDeviceId"].empty()) {
      chatDeviceId = make_shared<string>(boost::any_cast<string>(m["ChatDeviceId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~SignInGroupResponseBodyData() = default;
};
class SignInGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SignInGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  SignInGroupResponseBody() {}

  explicit SignInGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SignInGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SignInGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SignInGroupResponseBody() = default;
};
class SignInGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SignInGroupResponseBody> body{};

  SignInGroupResponse() {}

  explicit SignInGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SignInGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SignInGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SignInGroupResponse() = default;
};
class SignOutGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  SignOutGroupRequest() {}

  explicit SignOutGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SignOutGroupRequest() = default;
};
class SignOutGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  SignOutGroupResponseBodyData() {}

  explicit SignOutGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~SignOutGroupResponseBodyData() = default;
};
class SignOutGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SignOutGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  SignOutGroupResponseBody() {}

  explicit SignOutGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SignOutGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SignOutGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SignOutGroupResponseBody() = default;
};
class SignOutGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SignOutGroupResponseBody> body{};

  SignOutGroupResponse() {}

  explicit SignOutGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SignOutGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SignOutGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SignOutGroupResponse() = default;
};
class StartBack2BackCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> additionalBroker{};
  shared_ptr<string> broker{};
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};

  StartBack2BackCallRequest() {}

  explicit StartBack2BackCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalBroker) {
      res["AdditionalBroker"] = boost::any(*additionalBroker);
    }
    if (broker) {
      res["Broker"] = boost::any(*broker);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalBroker") != m.end() && !m["AdditionalBroker"].empty()) {
      additionalBroker = make_shared<string>(boost::any_cast<string>(m["AdditionalBroker"]));
    }
    if (m.find("Broker") != m.end() && !m["Broker"].empty()) {
      broker = make_shared<string>(boost::any_cast<string>(m["Broker"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~StartBack2BackCallRequest() = default;
};
class StartBack2BackCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  StartBack2BackCallResponseBodyDataCallContextChannelContexts() {}

  explicit StartBack2BackCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartBack2BackCallResponseBodyDataCallContextChannelContexts() = default;
};
class StartBack2BackCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<StartBack2BackCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  StartBack2BackCallResponseBodyDataCallContext() {}

  explicit StartBack2BackCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<StartBack2BackCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartBack2BackCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<StartBack2BackCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~StartBack2BackCallResponseBodyDataCallContext() = default;
};
class StartBack2BackCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  StartBack2BackCallResponseBodyDataUserContext() {}

  explicit StartBack2BackCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~StartBack2BackCallResponseBodyDataUserContext() = default;
};
class StartBack2BackCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<StartBack2BackCallResponseBodyDataCallContext> callContext{};
  shared_ptr<StartBack2BackCallResponseBodyDataUserContext> userContext{};

  StartBack2BackCallResponseBodyData() {}

  explicit StartBack2BackCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        StartBack2BackCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<StartBack2BackCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        StartBack2BackCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<StartBack2BackCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~StartBack2BackCallResponseBodyData() = default;
};
class StartBack2BackCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<StartBack2BackCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  StartBack2BackCallResponseBody() {}

  explicit StartBack2BackCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartBack2BackCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartBack2BackCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartBack2BackCallResponseBody() = default;
};
class StartBack2BackCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartBack2BackCallResponseBody> body{};

  StartBack2BackCallResponse() {}

  explicit StartBack2BackCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartBack2BackCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartBack2BackCallResponseBody>(model1);
      }
    }
  }


  virtual ~StartBack2BackCallResponse() = default;
};
class StartChatRequestUserList : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> nickname{};
  shared_ptr<string> userId{};
  shared_ptr<string> userType{};

  StartChatRequestUserList() {}

  explicit StartChatRequestUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~StartChatRequestUserList() = default;
};
class StartChatRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessChannelId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> token{};
  shared_ptr<vector<StartChatRequestUserList>> userList{};

  StartChatRequest() {}

  explicit StartChatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelId) {
      res["AccessChannelId"] = boost::any(*accessChannelId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelId") != m.end() && !m["AccessChannelId"].empty()) {
      accessChannelId = make_shared<string>(boost::any_cast<string>(m["AccessChannelId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<StartChatRequestUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartChatRequestUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<StartChatRequestUserList>>(expect1);
      }
    }
  }


  virtual ~StartChatRequest() = default;
};
class StartChatShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessChannelId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> token{};
  shared_ptr<string> userListShrink{};

  StartChatShrinkRequest() {}

  explicit StartChatShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessChannelId) {
      res["AccessChannelId"] = boost::any(*accessChannelId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (userListShrink) {
      res["UserList"] = boost::any(*userListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessChannelId") != m.end() && !m["AccessChannelId"].empty()) {
      accessChannelId = make_shared<string>(boost::any_cast<string>(m["AccessChannelId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      userListShrink = make_shared<string>(boost::any_cast<string>(m["UserList"]));
    }
  }


  virtual ~StartChatShrinkRequest() = default;
};
class StartChatResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> chatConversationId{};
  shared_ptr<string> jobId{};

  StartChatResponseBodyData() {}

  explicit StartChatResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chatConversationId) {
      res["ChatConversationId"] = boost::any(*chatConversationId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChatConversationId") != m.end() && !m["ChatConversationId"].empty()) {
      chatConversationId = make_shared<string>(boost::any_cast<string>(m["ChatConversationId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~StartChatResponseBodyData() = default;
};
class StartChatResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<StartChatResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  StartChatResponseBody() {}

  explicit StartChatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartChatResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartChatResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartChatResponseBody() = default;
};
class StartChatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartChatResponseBody> body{};

  StartChatResponse() {}

  explicit StartChatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartChatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartChatResponseBody>(model1);
      }
    }
  }


  virtual ~StartChatResponse() = default;
};
class StartConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> participantListJson{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  StartConferenceRequest() {}

  explicit StartConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (participantListJson) {
      res["ParticipantListJson"] = boost::any(*participantListJson);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ParticipantListJson") != m.end() && !m["ParticipantListJson"].empty()) {
      participantListJson = make_shared<string>(boost::any_cast<string>(m["ParticipantListJson"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartConferenceRequest() = default;
};
class StartConferenceResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  StartConferenceResponseBodyDataCallContextChannelContexts() {}

  explicit StartConferenceResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartConferenceResponseBodyDataCallContextChannelContexts() = default;
};
class StartConferenceResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<StartConferenceResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  StartConferenceResponseBodyDataCallContext() {}

  explicit StartConferenceResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<StartConferenceResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartConferenceResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<StartConferenceResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~StartConferenceResponseBodyDataCallContext() = default;
};
class StartConferenceResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  StartConferenceResponseBodyDataUserContext() {}

  explicit StartConferenceResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~StartConferenceResponseBodyDataUserContext() = default;
};
class StartConferenceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<StartConferenceResponseBodyDataCallContext> callContext{};
  shared_ptr<StartConferenceResponseBodyDataUserContext> userContext{};

  StartConferenceResponseBodyData() {}

  explicit StartConferenceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        StartConferenceResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<StartConferenceResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        StartConferenceResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<StartConferenceResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~StartConferenceResponseBodyData() = default;
};
class StartConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<StartConferenceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  StartConferenceResponseBody() {}

  explicit StartConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartConferenceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartConferenceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartConferenceResponseBody() = default;
};
class StartConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartConferenceResponseBody> body{};

  StartConferenceResponse() {}

  explicit StartConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~StartConferenceResponse() = default;
};
class StartEditContactFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};

  StartEditContactFlowRequest() {}

  explicit StartEditContactFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~StartEditContactFlowRequest() = default;
};
class StartEditContactFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  StartEditContactFlowResponseBody() {}

  explicit StartEditContactFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartEditContactFlowResponseBody() = default;
};
class StartEditContactFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartEditContactFlowResponseBody> body{};

  StartEditContactFlowResponse() {}

  explicit StartEditContactFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartEditContactFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartEditContactFlowResponseBody>(model1);
      }
    }
  }


  virtual ~StartEditContactFlowResponse() = default;
};
class StartPredictiveCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> contactFlowVariables{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> maskedCallee{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};

  StartPredictiveCallRequest() {}

  explicit StartPredictiveCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (contactFlowVariables) {
      res["ContactFlowVariables"] = boost::any(*contactFlowVariables);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maskedCallee) {
      res["MaskedCallee"] = boost::any(*maskedCallee);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("ContactFlowVariables") != m.end() && !m["ContactFlowVariables"].empty()) {
      contactFlowVariables = make_shared<string>(boost::any_cast<string>(m["ContactFlowVariables"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaskedCallee") != m.end() && !m["MaskedCallee"].empty()) {
      maskedCallee = make_shared<string>(boost::any_cast<string>(m["MaskedCallee"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~StartPredictiveCallRequest() = default;
};
class StartPredictiveCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  StartPredictiveCallResponseBodyDataCallContextChannelContexts() {}

  explicit StartPredictiveCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartPredictiveCallResponseBodyDataCallContextChannelContexts() = default;
};
class StartPredictiveCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<StartPredictiveCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  StartPredictiveCallResponseBodyDataCallContext() {}

  explicit StartPredictiveCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<StartPredictiveCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartPredictiveCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<StartPredictiveCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~StartPredictiveCallResponseBodyDataCallContext() = default;
};
class StartPredictiveCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  StartPredictiveCallResponseBodyDataUserContext() {}

  explicit StartPredictiveCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~StartPredictiveCallResponseBodyDataUserContext() = default;
};
class StartPredictiveCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<StartPredictiveCallResponseBodyDataCallContext> callContext{};
  shared_ptr<StartPredictiveCallResponseBodyDataUserContext> userContext{};

  StartPredictiveCallResponseBodyData() {}

  explicit StartPredictiveCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        StartPredictiveCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<StartPredictiveCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        StartPredictiveCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<StartPredictiveCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~StartPredictiveCallResponseBodyData() = default;
};
class StartPredictiveCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<StartPredictiveCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  StartPredictiveCallResponseBody() {}

  explicit StartPredictiveCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartPredictiveCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartPredictiveCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartPredictiveCallResponseBody() = default;
};
class StartPredictiveCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartPredictiveCallResponseBody> body{};

  StartPredictiveCallResponse() {}

  explicit StartPredictiveCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartPredictiveCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartPredictiveCallResponseBody>(model1);
      }
    }
  }


  virtual ~StartPredictiveCallResponse() = default;
};
class StartPrivacyCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> instanceId{};

  StartPrivacyCallRequest() {}

  explicit StartPrivacyCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~StartPrivacyCallRequest() = default;
};
class StartPrivacyCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  StartPrivacyCallResponseBody() {}

  explicit StartPrivacyCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartPrivacyCallResponseBody() = default;
};
class StartPrivacyCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartPrivacyCallResponseBody> body{};

  StartPrivacyCallResponse() {}

  explicit StartPrivacyCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartPrivacyCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartPrivacyCallResponseBody>(model1);
      }
    }
  }


  virtual ~StartPrivacyCallResponse() = default;
};
class SubmitCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  SubmitCampaignRequest() {}

  explicit SubmitCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~SubmitCampaignRequest() = default;
};
class SubmitCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  SubmitCampaignResponseBody() {}

  explicit SubmitCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitCampaignResponseBody() = default;
};
class SubmitCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitCampaignResponseBody> body{};

  SubmitCampaignResponse() {}

  explicit SubmitCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitCampaignResponse() = default;
};
class SwitchToConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  SwitchToConferenceRequest() {}

  explicit SwitchToConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SwitchToConferenceRequest() = default;
};
class SwitchToConferenceResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  SwitchToConferenceResponseBodyDataCallContextChannelContexts() {}

  explicit SwitchToConferenceResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SwitchToConferenceResponseBodyDataCallContextChannelContexts() = default;
};
class SwitchToConferenceResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<SwitchToConferenceResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  SwitchToConferenceResponseBodyDataCallContext() {}

  explicit SwitchToConferenceResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<SwitchToConferenceResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SwitchToConferenceResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<SwitchToConferenceResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SwitchToConferenceResponseBodyDataCallContext() = default;
};
class SwitchToConferenceResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  SwitchToConferenceResponseBodyDataUserContext() {}

  explicit SwitchToConferenceResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~SwitchToConferenceResponseBodyDataUserContext() = default;
};
class SwitchToConferenceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<SwitchToConferenceResponseBodyDataCallContext> callContext{};
  shared_ptr<SwitchToConferenceResponseBodyDataUserContext> userContext{};

  SwitchToConferenceResponseBodyData() {}

  explicit SwitchToConferenceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        SwitchToConferenceResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<SwitchToConferenceResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        SwitchToConferenceResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<SwitchToConferenceResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~SwitchToConferenceResponseBodyData() = default;
};
class SwitchToConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SwitchToConferenceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  SwitchToConferenceResponseBody() {}

  explicit SwitchToConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SwitchToConferenceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SwitchToConferenceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchToConferenceResponseBody() = default;
};
class SwitchToConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchToConferenceResponseBody> body{};

  SwitchToConferenceResponse() {}

  explicit SwitchToConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchToConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchToConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchToConferenceResponse() = default;
};
class TakeBreakRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  TakeBreakRequest() {}

  explicit TakeBreakRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~TakeBreakRequest() = default;
};
class TakeBreakResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  TakeBreakResponseBodyData() {}

  explicit TakeBreakResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~TakeBreakResponseBodyData() = default;
};
class TakeBreakResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<TakeBreakResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  TakeBreakResponseBody() {}

  explicit TakeBreakResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        TakeBreakResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<TakeBreakResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TakeBreakResponseBody() = default;
};
class TakeBreakResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TakeBreakResponseBody> body{};

  TakeBreakResponse() {}

  explicit TakeBreakResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TakeBreakResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TakeBreakResponseBody>(model1);
      }
    }
  }


  virtual ~TakeBreakResponse() = default;
};
class TerminateTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ticketId{};

  TerminateTicketRequest() {}

  explicit TerminateTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~TerminateTicketRequest() = default;
};
class TerminateTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  TerminateTicketResponseBody() {}

  explicit TerminateTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TerminateTicketResponseBody() = default;
};
class TerminateTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TerminateTicketResponseBody> body{};

  TerminateTicketResponse() {}

  explicit TerminateTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TerminateTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TerminateTicketResponseBody>(model1);
      }
    }
  }


  virtual ~TerminateTicketResponse() = default;
};
class TransferTicketTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> assignee{};
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> ticketId{};

  TransferTicketTaskRequest() {}

  explicit TransferTicketTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignee) {
      res["Assignee"] = boost::any(*assignee);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assignee") != m.end() && !m["Assignee"].empty()) {
      assignee = make_shared<string>(boost::any_cast<string>(m["Assignee"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~TransferTicketTaskRequest() = default;
};
class TransferTicketTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  TransferTicketTaskResponseBody() {}

  explicit TransferTicketTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TransferTicketTaskResponseBody() = default;
};
class TransferTicketTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TransferTicketTaskResponseBody> body{};

  TransferTicketTaskResponse() {}

  explicit TransferTicketTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransferTicketTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransferTicketTaskResponseBody>(model1);
      }
    }
  }


  virtual ~TransferTicketTaskResponse() = default;
};
class UnmuteCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  UnmuteCallRequest() {}

  explicit UnmuteCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UnmuteCallRequest() = default;
};
class UnmuteCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  UnmuteCallResponseBodyDataCallContextChannelContexts() {}

  explicit UnmuteCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UnmuteCallResponseBodyDataCallContextChannelContexts() = default;
};
class UnmuteCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<UnmuteCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  UnmuteCallResponseBodyDataCallContext() {}

  explicit UnmuteCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<UnmuteCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnmuteCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<UnmuteCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~UnmuteCallResponseBodyDataCallContext() = default;
};
class UnmuteCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  UnmuteCallResponseBodyDataUserContext() {}

  explicit UnmuteCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~UnmuteCallResponseBodyDataUserContext() = default;
};
class UnmuteCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<UnmuteCallResponseBodyDataCallContext> callContext{};
  shared_ptr<UnmuteCallResponseBodyDataUserContext> userContext{};

  UnmuteCallResponseBodyData() {}

  explicit UnmuteCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        UnmuteCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<UnmuteCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        UnmuteCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<UnmuteCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~UnmuteCallResponseBodyData() = default;
};
class UnmuteCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UnmuteCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  UnmuteCallResponseBody() {}

  explicit UnmuteCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UnmuteCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UnmuteCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnmuteCallResponseBody() = default;
};
class UnmuteCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnmuteCallResponseBody> body{};

  UnmuteCallResponse() {}

  explicit UnmuteCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnmuteCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnmuteCallResponseBody>(model1);
      }
    }
  }


  virtual ~UnmuteCallResponse() = default;
};
class UnregisterDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  UnregisterDeviceRequest() {}

  explicit UnregisterDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UnregisterDeviceRequest() = default;
};
class UnregisterDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UnregisterDeviceResponseBody() {}

  explicit UnregisterDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnregisterDeviceResponseBody() = default;
};
class UnregisterDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnregisterDeviceResponseBody> body{};

  UnregisterDeviceResponse() {}

  explicit UnregisterDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnregisterDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnregisterDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~UnregisterDeviceResponse() = default;
};
class UpdateCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> callableTime{};
  shared_ptr<string> campaignId{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> startTime{};
  shared_ptr<string> strategyParameters{};

  UpdateCampaignRequest() {}

  explicit UpdateCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callableTime) {
      res["CallableTime"] = boost::any(*callableTime);
    }
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyParameters) {
      res["StrategyParameters"] = boost::any(*strategyParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallableTime") != m.end() && !m["CallableTime"].empty()) {
      callableTime = make_shared<string>(boost::any_cast<string>(m["CallableTime"]));
    }
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StrategyParameters") != m.end() && !m["StrategyParameters"].empty()) {
      strategyParameters = make_shared<string>(boost::any_cast<string>(m["StrategyParameters"]));
    }
  }


  virtual ~UpdateCampaignRequest() = default;
};
class UpdateCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateCampaignResponseBody() {}

  explicit UpdateCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCampaignResponseBody() = default;
};
class UpdateCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCampaignResponseBody> body{};

  UpdateCampaignResponse() {}

  explicit UpdateCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCampaignResponse() = default;
};
class UpdateConfigItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> configItems{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};

  UpdateConfigItemsRequest() {}

  explicit UpdateConfigItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItems) {
      res["ConfigItems"] = boost::any(*configItems);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItems") != m.end() && !m["ConfigItems"].empty()) {
      configItems = make_shared<string>(boost::any_cast<string>(m["ConfigItems"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~UpdateConfigItemsRequest() = default;
};
class UpdateConfigItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  UpdateConfigItemsResponseBody() {}

  explicit UpdateConfigItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConfigItemsResponseBody() = default;
};
class UpdateConfigItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConfigItemsResponseBody> body{};

  UpdateConfigItemsResponse() {}

  explicit UpdateConfigItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConfigItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConfigItemsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConfigItemsResponse() = default;
};
class UpdateSchemaPropertyRequestProperty : public Darabonba::Model {
public:
  shared_ptr<bool> array{};
  shared_ptr<string> attributes{};
  shared_ptr<string> dataType{};
  shared_ptr<string> description{};
  shared_ptr<bool> disabled{};
  shared_ptr<string> displayName{};
  shared_ptr<long> displayOrder{};
  shared_ptr<string> editorType{};
  shared_ptr<long> maxLength{};
  shared_ptr<double> maximum{};
  shared_ptr<long> minLength{};
  shared_ptr<double> minimum{};
  shared_ptr<string> name{};
  shared_ptr<string> pattern{};
  shared_ptr<string> patternErrorMessage{};
  shared_ptr<bool> readOnly{};
  shared_ptr<bool> required{};

  UpdateSchemaPropertyRequestProperty() {}

  explicit UpdateSchemaPropertyRequestProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (array) {
      res["Array"] = boost::any(*array);
    }
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayOrder) {
      res["DisplayOrder"] = boost::any(*displayOrder);
    }
    if (editorType) {
      res["EditorType"] = boost::any(*editorType);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minimum) {
      res["Minimum"] = boost::any(*minimum);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (patternErrorMessage) {
      res["PatternErrorMessage"] = boost::any(*patternErrorMessage);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Array") != m.end() && !m["Array"].empty()) {
      array = make_shared<bool>(boost::any_cast<bool>(m["Array"]));
    }
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      attributes = make_shared<string>(boost::any_cast<string>(m["Attributes"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayOrder") != m.end() && !m["DisplayOrder"].empty()) {
      displayOrder = make_shared<long>(boost::any_cast<long>(m["DisplayOrder"]));
    }
    if (m.find("EditorType") != m.end() && !m["EditorType"].empty()) {
      editorType = make_shared<string>(boost::any_cast<string>(m["EditorType"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<double>(boost::any_cast<double>(m["Maximum"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("Minimum") != m.end() && !m["Minimum"].empty()) {
      minimum = make_shared<double>(boost::any_cast<double>(m["Minimum"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("PatternErrorMessage") != m.end() && !m["PatternErrorMessage"].empty()) {
      patternErrorMessage = make_shared<string>(boost::any_cast<string>(m["PatternErrorMessage"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~UpdateSchemaPropertyRequestProperty() = default;
};
class UpdateSchemaPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<UpdateSchemaPropertyRequestProperty> property{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  UpdateSchemaPropertyRequest() {}

  explicit UpdateSchemaPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (property) {
      res["Property"] = property ? boost::any(property->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      if (typeid(map<string, boost::any>) == m["Property"].type()) {
        UpdateSchemaPropertyRequestProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Property"]));
        property = make_shared<UpdateSchemaPropertyRequestProperty>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~UpdateSchemaPropertyRequest() = default;
};
class UpdateSchemaPropertyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> propertyShrink{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schemaId{};

  UpdateSchemaPropertyShrinkRequest() {}

  explicit UpdateSchemaPropertyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (propertyShrink) {
      res["Property"] = boost::any(*propertyShrink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      propertyShrink = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<string>(boost::any_cast<string>(m["SchemaId"]));
    }
  }


  virtual ~UpdateSchemaPropertyShrinkRequest() = default;
};
class UpdateSchemaPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  UpdateSchemaPropertyResponseBody() {}

  explicit UpdateSchemaPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSchemaPropertyResponseBody() = default;
};
class UpdateSchemaPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSchemaPropertyResponseBody> body{};

  UpdateSchemaPropertyResponse() {}

  explicit UpdateSchemaPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSchemaPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSchemaPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSchemaPropertyResponse() = default;
};
class UpdateTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> context{};
  shared_ptr<string> customerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ticketId{};
  shared_ptr<string> title{};

  UpdateTicketRequest() {}

  explicit UpdateTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (context) {
      res["Context"] = boost::any(*context);
    }
    if (customerId) {
      res["CustomerId"] = boost::any(*customerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Context") != m.end() && !m["Context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["Context"]));
    }
    if (m.find("CustomerId") != m.end() && !m["CustomerId"].empty()) {
      customerId = make_shared<string>(boost::any_cast<string>(m["CustomerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateTicketRequest() = default;
};
class UpdateTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  UpdateTicketResponseBody() {}

  explicit UpdateTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateTicketResponseBody() = default;
};
class UpdateTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTicketResponseBody> body{};

  UpdateTicketResponse() {}

  explicit UpdateTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTicketResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTicketResponse() = default;
};
class WithdrawTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ticketId{};

  WithdrawTicketRequest() {}

  explicit WithdrawTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ticketId) {
      res["TicketId"] = boost::any(*ticketId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TicketId") != m.end() && !m["TicketId"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["TicketId"]));
    }
  }


  virtual ~WithdrawTicketRequest() = default;
};
class WithdrawTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  WithdrawTicketResponseBody() {}

  explicit WithdrawTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~WithdrawTicketResponseBody() = default;
};
class WithdrawTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WithdrawTicketResponseBody> body{};

  WithdrawTicketResponse() {}

  explicit WithdrawTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WithdrawTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WithdrawTicketResponseBody>(model1);
      }
    }
  }


  virtual ~WithdrawTicketResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbortCampaignResponse abortCampaignWithOptions(shared_ptr<AbortCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbortCampaignResponse abortCampaign(shared_ptr<AbortCampaignRequest> request);
  AcceptChatResponse acceptChatWithOptions(shared_ptr<AcceptChatRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AcceptChatResponse acceptChat(shared_ptr<AcceptChatRequest> request);
  AddBlacklistCallTaggingResponse addBlacklistCallTaggingWithOptions(shared_ptr<AddBlacklistCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddBlacklistCallTaggingResponse addBlacklistCallTagging(shared_ptr<AddBlacklistCallTaggingRequest> request);
  AddCasesResponse addCasesWithOptions(shared_ptr<AddCasesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasesResponse addCases(shared_ptr<AddCasesRequest> request);
  AddNumbersToSkillGroupResponse addNumbersToSkillGroupWithOptions(shared_ptr<AddNumbersToSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddNumbersToSkillGroupResponse addNumbersToSkillGroup(shared_ptr<AddNumbersToSkillGroupRequest> request);
  AddPersonalNumbersToUserResponse addPersonalNumbersToUserWithOptions(shared_ptr<AddPersonalNumbersToUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPersonalNumbersToUserResponse addPersonalNumbersToUser(shared_ptr<AddPersonalNumbersToUserRequest> request);
  AddPhoneNumberToSkillGroupsResponse addPhoneNumberToSkillGroupsWithOptions(shared_ptr<AddPhoneNumberToSkillGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPhoneNumberToSkillGroupsResponse addPhoneNumberToSkillGroups(shared_ptr<AddPhoneNumberToSkillGroupsRequest> request);
  AddPhoneNumbersResponse addPhoneNumbersWithOptions(shared_ptr<AddPhoneNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPhoneNumbersResponse addPhoneNumbers(shared_ptr<AddPhoneNumbersRequest> request);
  AddSchemaPropertyResponse addSchemaPropertyWithOptions(shared_ptr<AddSchemaPropertyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSchemaPropertyResponse addSchemaProperty(shared_ptr<AddSchemaPropertyRequest> request);
  AddSkillGroupsToUserResponse addSkillGroupsToUserWithOptions(shared_ptr<AddSkillGroupsToUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSkillGroupsToUserResponse addSkillGroupsToUser(shared_ptr<AddSkillGroupsToUserRequest> request);
  AddTicketTaskResponse addTicketTaskWithOptions(shared_ptr<AddTicketTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTicketTaskResponse addTicketTask(shared_ptr<AddTicketTaskRequest> request);
  AddUsersToSkillGroupResponse addUsersToSkillGroupWithOptions(shared_ptr<AddUsersToSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddUsersToSkillGroupResponse addUsersToSkillGroup(shared_ptr<AddUsersToSkillGroupRequest> request);
  AnalyzeConversationResponse analyzeConversationWithOptions(shared_ptr<AnalyzeConversationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AnalyzeConversationResponse analyzeConversation(shared_ptr<AnalyzeConversationRequest> request);
  AnswerCallResponse answerCallWithOptions(shared_ptr<AnswerCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AnswerCallResponse answerCall(shared_ptr<AnswerCallRequest> request);
  AppendCasesResponse appendCasesWithOptions(shared_ptr<AppendCasesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AppendCasesResponse appendCases(shared_ptr<AppendCasesRequest> request);
  AssignUsersResponse assignUsersWithOptions(shared_ptr<AssignUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssignUsersResponse assignUsers(shared_ptr<AssignUsersRequest> request);
  BargeInCallResponse bargeInCallWithOptions(shared_ptr<BargeInCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BargeInCallResponse bargeInCall(shared_ptr<BargeInCallRequest> request);
  BlindTransferResponse blindTransferWithOptions(shared_ptr<BlindTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BlindTransferResponse blindTransfer(shared_ptr<BlindTransferRequest> request);
  BridgeRtcCallResponse bridgeRtcCallWithOptions(shared_ptr<BridgeRtcCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BridgeRtcCallResponse bridgeRtcCall(shared_ptr<BridgeRtcCallRequest> request);
  CancelAttendedTransferResponse cancelAttendedTransferWithOptions(shared_ptr<CancelAttendedTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelAttendedTransferResponse cancelAttendedTransfer(shared_ptr<CancelAttendedTransferRequest> request);
  ChangeVisibilityResponse changeVisibilityWithOptions(shared_ptr<ChangeVisibilityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeVisibilityResponse changeVisibility(shared_ptr<ChangeVisibilityRequest> request);
  ChangeWorkModeResponse changeWorkModeWithOptions(shared_ptr<ChangeWorkModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeWorkModeResponse changeWorkMode(shared_ptr<ChangeWorkModeRequest> request);
  ClaimChatResponse claimChatWithOptions(shared_ptr<ClaimChatRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClaimChatResponse claimChat(shared_ptr<ClaimChatRequest> request);
  CoachCallResponse coachCallWithOptions(shared_ptr<CoachCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CoachCallResponse coachCall(shared_ptr<CoachCallRequest> request);
  CommitContactFlowResponse commitContactFlowWithOptions(shared_ptr<CommitContactFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommitContactFlowResponse commitContactFlow(shared_ptr<CommitContactFlowRequest> request);
  CompleteAttendedTransferResponse completeAttendedTransferWithOptions(shared_ptr<CompleteAttendedTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CompleteAttendedTransferResponse completeAttendedTransfer(shared_ptr<CompleteAttendedTransferRequest> request);
  CreateAudioFileResponse createAudioFileWithOptions(shared_ptr<CreateAudioFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAudioFileResponse createAudioFile(shared_ptr<CreateAudioFileRequest> request);
  CreateCallTagsResponse createCallTagsWithOptions(shared_ptr<CreateCallTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCallTagsResponse createCallTags(shared_ptr<CreateCallTagsRequest> request);
  CreateCampaignResponse createCampaignWithOptions(shared_ptr<CreateCampaignRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCampaignResponse createCampaign(shared_ptr<CreateCampaignRequest> request);
  CreateContactFlowResponse createContactFlowWithOptions(shared_ptr<CreateContactFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateContactFlowResponse createContactFlow(shared_ptr<CreateContactFlowRequest> request);
  CreateCustomCallTaggingResponse createCustomCallTaggingWithOptions(shared_ptr<CreateCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomCallTaggingResponse createCustomCallTagging(shared_ptr<CreateCustomCallTaggingRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateSchemaResponse createSchemaWithOptions(shared_ptr<CreateSchemaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSchemaResponse createSchema(shared_ptr<CreateSchemaRequest> request);
  CreateSkillGroupResponse createSkillGroupWithOptions(shared_ptr<CreateSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSkillGroupResponse createSkillGroup(shared_ptr<CreateSkillGroupRequest> request);
  CreateTicketResponse createTicketWithOptions(shared_ptr<CreateTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTicketResponse createTicket(shared_ptr<CreateTicketRequest> request);
  CreateUserResponse createUserWithOptions(shared_ptr<CreateUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserResponse createUser(shared_ptr<CreateUserRequest> request);
  DeleteAudioFileResponse deleteAudioFileWithOptions(shared_ptr<DeleteAudioFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAudioFileResponse deleteAudioFile(shared_ptr<DeleteAudioFileRequest> request);
  DeleteCallTagResponse deleteCallTagWithOptions(shared_ptr<DeleteCallTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCallTagResponse deleteCallTag(shared_ptr<DeleteCallTagRequest> request);
  DeleteContactFlowResponse deleteContactFlowWithOptions(shared_ptr<DeleteContactFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactFlowResponse deleteContactFlow(shared_ptr<DeleteContactFlowRequest> request);
  DeleteCustomCallTaggingResponse deleteCustomCallTaggingWithOptions(shared_ptr<DeleteCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomCallTaggingResponse deleteCustomCallTagging(shared_ptr<DeleteCustomCallTaggingRequest> request);
  DeleteDocumentResponse deleteDocumentWithOptions(shared_ptr<DeleteDocumentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDocumentResponse deleteDocument(shared_ptr<DeleteDocumentRequest> request);
  DeleteDocumentsResponse deleteDocumentsWithOptions(shared_ptr<DeleteDocumentsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDocumentsResponse deleteDocuments(shared_ptr<DeleteDocumentsRequest> request);
  DeleteSchemaResponse deleteSchemaWithOptions(shared_ptr<DeleteSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSchemaResponse deleteSchema(shared_ptr<DeleteSchemaRequest> request);
  DeleteSchemaPropertyResponse deleteSchemaPropertyWithOptions(shared_ptr<DeleteSchemaPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSchemaPropertyResponse deleteSchemaProperty(shared_ptr<DeleteSchemaPropertyRequest> request);
  DeleteSkillGroupResponse deleteSkillGroupWithOptions(shared_ptr<DeleteSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSkillGroupResponse deleteSkillGroup(shared_ptr<DeleteSkillGroupRequest> request);
  DeleteTicketResponse deleteTicketWithOptions(shared_ptr<DeleteTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTicketResponse deleteTicket(shared_ptr<DeleteTicketRequest> request);
  DeleteTicketTemplateResponse deleteTicketTemplateWithOptions(shared_ptr<DeleteTicketTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTicketTemplateResponse deleteTicketTemplate(shared_ptr<DeleteTicketTemplateRequest> request);
  DisableSchemaPropertyResponse disableSchemaPropertyWithOptions(shared_ptr<DisableSchemaPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableSchemaPropertyResponse disableSchemaProperty(shared_ptr<DisableSchemaPropertyRequest> request);
  DisableTicketTemplateResponse disableTicketTemplateWithOptions(shared_ptr<DisableTicketTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableTicketTemplateResponse disableTicketTemplate(shared_ptr<DisableTicketTemplateRequest> request);
  DiscardEditingContactFlowResponse discardEditingContactFlowWithOptions(shared_ptr<DiscardEditingContactFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DiscardEditingContactFlowResponse discardEditingContactFlow(shared_ptr<DiscardEditingContactFlowRequest> request);
  EnableSchemaPropertyResponse enableSchemaPropertyWithOptions(shared_ptr<EnableSchemaPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableSchemaPropertyResponse enableSchemaProperty(shared_ptr<EnableSchemaPropertyRequest> request);
  EnableTicketTemplateResponse enableTicketTemplateWithOptions(shared_ptr<EnableTicketTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableTicketTemplateResponse enableTicketTemplate(shared_ptr<EnableTicketTemplateRequest> request);
  EndConferenceResponse endConferenceWithOptions(shared_ptr<EndConferenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EndConferenceResponse endConference(shared_ptr<EndConferenceRequest> request);
  ExportCustomCallTaggingResponse exportCustomCallTaggingWithOptions(shared_ptr<ExportCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportCustomCallTaggingResponse exportCustomCallTagging(shared_ptr<ExportCustomCallTaggingRequest> request);
  ExportDoNotCallNumbersResponse exportDoNotCallNumbersWithOptions(shared_ptr<ExportDoNotCallNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportDoNotCallNumbersResponse exportDoNotCallNumbers(shared_ptr<ExportDoNotCallNumbersRequest> request);
  FinishTicketTaskResponse finishTicketTaskWithOptions(shared_ptr<FinishTicketTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FinishTicketTaskResponse finishTicketTask(shared_ptr<FinishTicketTaskRequest> request);
  GetAccessChannelOfStagingResponse getAccessChannelOfStagingWithOptions(shared_ptr<GetAccessChannelOfStagingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAccessChannelOfStagingResponse getAccessChannelOfStaging(shared_ptr<GetAccessChannelOfStagingRequest> request);
  GetAudioFileResponse getAudioFileWithOptions(shared_ptr<GetAudioFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAudioFileResponse getAudioFile(shared_ptr<GetAudioFileRequest> request);
  GetAudioFileDownloadUrlResponse getAudioFileDownloadUrlWithOptions(shared_ptr<GetAudioFileDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAudioFileDownloadUrlResponse getAudioFileDownloadUrl(shared_ptr<GetAudioFileDownloadUrlRequest> request);
  GetAudioFileUploadParametersResponse getAudioFileUploadParametersWithOptions(shared_ptr<GetAudioFileUploadParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAudioFileUploadParametersResponse getAudioFileUploadParameters(shared_ptr<GetAudioFileUploadParametersRequest> request);
  GetCallDetailRecordResponse getCallDetailRecordWithOptions(shared_ptr<GetCallDetailRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCallDetailRecordResponse getCallDetailRecord(shared_ptr<GetCallDetailRecordRequest> request);
  GetCampaignResponse getCampaignWithOptions(shared_ptr<GetCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCampaignResponse getCampaign(shared_ptr<GetCampaignRequest> request);
  GetCaseFileUploadUrlResponse getCaseFileUploadUrlWithOptions(shared_ptr<GetCaseFileUploadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCaseFileUploadUrlResponse getCaseFileUploadUrl(shared_ptr<GetCaseFileUploadUrlRequest> request);
  GetChatMediaUrlResponse getChatMediaUrlWithOptions(shared_ptr<GetChatMediaUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetChatMediaUrlResponse getChatMediaUrl(shared_ptr<GetChatMediaUrlRequest> request);
  GetContactFlowResponse getContactFlowWithOptions(shared_ptr<GetContactFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetContactFlowResponse getContactFlow(shared_ptr<GetContactFlowRequest> request);
  GetConversationDetailResponse getConversationDetailWithOptions(shared_ptr<GetConversationDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConversationDetailResponse getConversationDetail(shared_ptr<GetConversationDetailRequest> request);
  GetDataChannelCredentialsResponse getDataChannelCredentialsWithOptions(shared_ptr<GetDataChannelCredentialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataChannelCredentialsResponse getDataChannelCredentials(shared_ptr<GetDataChannelCredentialsRequest> request);
  GetDoNotCallFileUploadParametersResponse getDoNotCallFileUploadParametersWithOptions(shared_ptr<GetDoNotCallFileUploadParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoNotCallFileUploadParametersResponse getDoNotCallFileUploadParameters(shared_ptr<GetDoNotCallFileUploadParametersRequest> request);
  GetDocumentUploadParametersResponse getDocumentUploadParametersWithOptions(shared_ptr<GetDocumentUploadParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDocumentUploadParametersResponse getDocumentUploadParameters(shared_ptr<GetDocumentUploadParametersRequest> request);
  GetEarlyMediaRecordingResponse getEarlyMediaRecordingWithOptions(shared_ptr<GetEarlyMediaRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEarlyMediaRecordingResponse getEarlyMediaRecording(shared_ptr<GetEarlyMediaRecordingRequest> request);
  GetHistoricalCallerReportResponse getHistoricalCallerReportWithOptions(shared_ptr<GetHistoricalCallerReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHistoricalCallerReportResponse getHistoricalCallerReport(shared_ptr<GetHistoricalCallerReportRequest> request);
  GetHistoricalCampaignReportResponse getHistoricalCampaignReportWithOptions(shared_ptr<GetHistoricalCampaignReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHistoricalCampaignReportResponse getHistoricalCampaignReport(shared_ptr<GetHistoricalCampaignReportRequest> request);
  GetHistoricalInstanceReportResponse getHistoricalInstanceReportWithOptions(shared_ptr<GetHistoricalInstanceReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHistoricalInstanceReportResponse getHistoricalInstanceReport(shared_ptr<GetHistoricalInstanceReportRequest> request);
  GetInstanceResponse getInstanceWithOptions(shared_ptr<GetInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceResponse getInstance(shared_ptr<GetInstanceRequest> request);
  GetInstanceTrendingReportResponse getInstanceTrendingReportWithOptions(shared_ptr<GetInstanceTrendingReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceTrendingReportResponse getInstanceTrendingReport(shared_ptr<GetInstanceTrendingReportRequest> request);
  GetLoginDetailsResponse getLoginDetailsWithOptions(shared_ptr<GetLoginDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLoginDetailsResponse getLoginDetails(shared_ptr<GetLoginDetailsRequest> request);
  GetMonoRecordingResponse getMonoRecordingWithOptions(shared_ptr<GetMonoRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMonoRecordingResponse getMonoRecording(shared_ptr<GetMonoRecordingRequest> request);
  GetMultiChannelRecordingResponse getMultiChannelRecordingWithOptions(shared_ptr<GetMultiChannelRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultiChannelRecordingResponse getMultiChannelRecording(shared_ptr<GetMultiChannelRecordingRequest> request);
  GetNumberLocationResponse getNumberLocationWithOptions(shared_ptr<GetNumberLocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNumberLocationResponse getNumberLocation(shared_ptr<GetNumberLocationRequest> request);
  GetRealtimeCampaignStatsResponse getRealtimeCampaignStatsWithOptions(shared_ptr<GetRealtimeCampaignStatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRealtimeCampaignStatsResponse getRealtimeCampaignStats(shared_ptr<GetRealtimeCampaignStatsRequest> request);
  GetRealtimeInstanceStatesResponse getRealtimeInstanceStatesWithOptions(shared_ptr<GetRealtimeInstanceStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRealtimeInstanceStatesResponse getRealtimeInstanceStates(shared_ptr<GetRealtimeInstanceStatesRequest> request);
  GetSchemaResponse getSchemaWithOptions(shared_ptr<GetSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSchemaResponse getSchema(shared_ptr<GetSchemaRequest> request);
  GetSkillGroupResponse getSkillGroupWithOptions(shared_ptr<GetSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSkillGroupResponse getSkillGroup(shared_ptr<GetSkillGroupRequest> request);
  GetTicketResponse getTicketWithOptions(shared_ptr<GetTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTicketResponse getTicket(shared_ptr<GetTicketRequest> request);
  GetTicketSummaryReportResponse getTicketSummaryReportWithOptions(shared_ptr<GetTicketSummaryReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTicketSummaryReportResponse getTicketSummaryReport(shared_ptr<GetTicketSummaryReportRequest> request);
  GetTicketTemplateResponse getTicketTemplateWithOptions(shared_ptr<GetTicketTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTicketTemplateResponse getTicketTemplate(shared_ptr<GetTicketTemplateRequest> request);
  GetTurnCredentialsResponse getTurnCredentialsWithOptions(shared_ptr<GetTurnCredentialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTurnCredentialsResponse getTurnCredentials(shared_ptr<GetTurnCredentialsRequest> request);
  GetTurnServerListResponse getTurnServerListWithOptions(shared_ptr<GetTurnServerListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTurnServerListResponse getTurnServerList(shared_ptr<GetTurnServerListRequest> request);
  GetUploadAudioDataParamsResponse getUploadAudioDataParamsWithOptions(shared_ptr<GetUploadAudioDataParamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUploadAudioDataParamsResponse getUploadAudioDataParams(shared_ptr<GetUploadAudioDataParamsRequest> request);
  GetUserResponse getUserWithOptions(shared_ptr<GetUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserResponse getUser(shared_ptr<GetUserRequest> request);
  GetVideoResponse getVideoWithOptions(shared_ptr<GetVideoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVideoResponse getVideo(shared_ptr<GetVideoRequest> request);
  GetVisitorLoginDetailsResponse getVisitorLoginDetailsWithOptions(shared_ptr<GetVisitorLoginDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVisitorLoginDetailsResponse getVisitorLoginDetails(shared_ptr<GetVisitorLoginDetailsRequest> request);
  GetVoicemailRecordingResponse getVoicemailRecordingWithOptions(shared_ptr<GetVoicemailRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVoicemailRecordingResponse getVoicemailRecording(shared_ptr<GetVoicemailRecordingRequest> request);
  HoldCallResponse holdCallWithOptions(shared_ptr<HoldCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HoldCallResponse holdCall(shared_ptr<HoldCallRequest> request);
  ImportAdminsResponse importAdminsWithOptions(shared_ptr<ImportAdminsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportAdminsResponse importAdmins(shared_ptr<ImportAdminsRequest> request);
  ImportCorpNumbersResponse importCorpNumbersWithOptions(shared_ptr<ImportCorpNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportCorpNumbersResponse importCorpNumbers(shared_ptr<ImportCorpNumbersRequest> request);
  ImportCustomCallTaggingResponse importCustomCallTaggingWithOptions(shared_ptr<ImportCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportCustomCallTaggingResponse importCustomCallTagging(shared_ptr<ImportCustomCallTaggingRequest> request);
  ImportDoNotCallNumbersResponse importDoNotCallNumbersWithOptions(shared_ptr<ImportDoNotCallNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportDoNotCallNumbersResponse importDoNotCallNumbers(shared_ptr<ImportDoNotCallNumbersRequest> request);
  ImportDocumentsResponse importDocumentsWithOptions(shared_ptr<ImportDocumentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportDocumentsResponse importDocuments(shared_ptr<ImportDocumentsRequest> request);
  InitiateAttendedTransferResponse initiateAttendedTransferWithOptions(shared_ptr<InitiateAttendedTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitiateAttendedTransferResponse initiateAttendedTransfer(shared_ptr<InitiateAttendedTransferRequest> request);
  InterceptCallResponse interceptCallWithOptions(shared_ptr<InterceptCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InterceptCallResponse interceptCall(shared_ptr<InterceptCallRequest> request);
  LaunchAuthenticationResponse launchAuthenticationWithOptions(shared_ptr<LaunchAuthenticationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LaunchAuthenticationResponse launchAuthentication(shared_ptr<LaunchAuthenticationRequest> request);
  LaunchSurveyResponse launchSurveyWithOptions(shared_ptr<LaunchSurveyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LaunchSurveyResponse launchSurvey(shared_ptr<LaunchSurveyRequest> request);
  ListAgentStateLogsResponse listAgentStateLogsWithOptions(shared_ptr<ListAgentStateLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentStateLogsResponse listAgentStateLogs(shared_ptr<ListAgentStateLogsRequest> request);
  ListAgentStatesResponse listAgentStatesWithOptions(shared_ptr<ListAgentStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentStatesResponse listAgentStates(shared_ptr<ListAgentStatesRequest> request);
  ListAgentSummaryReportsSinceMidnightResponse listAgentSummaryReportsSinceMidnightWithOptions(shared_ptr<ListAgentSummaryReportsSinceMidnightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentSummaryReportsSinceMidnightResponse listAgentSummaryReportsSinceMidnight(shared_ptr<ListAgentSummaryReportsSinceMidnightRequest> request);
  ListAttemptsResponse listAttemptsWithOptions(shared_ptr<ListAttemptsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAttemptsResponse listAttempts(shared_ptr<ListAttemptsRequest> request);
  ListAudioFilesResponse listAudioFilesWithOptions(shared_ptr<ListAudioFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAudioFilesResponse listAudioFiles(shared_ptr<ListAudioFilesRequest> request);
  ListBlacklistCallTaggingsResponse listBlacklistCallTaggingsWithOptions(shared_ptr<ListBlacklistCallTaggingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBlacklistCallTaggingsResponse listBlacklistCallTaggings(shared_ptr<ListBlacklistCallTaggingsRequest> request);
  ListBriefSkillGroupsResponse listBriefSkillGroupsWithOptions(shared_ptr<ListBriefSkillGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBriefSkillGroupsResponse listBriefSkillGroups(shared_ptr<ListBriefSkillGroupsRequest> request);
  ListCallDetailRecordsResponse listCallDetailRecordsWithOptions(shared_ptr<ListCallDetailRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCallDetailRecordsResponse listCallDetailRecords(shared_ptr<ListCallDetailRecordsRequest> request);
  ListCallDetailRecordsV2Response listCallDetailRecordsV2WithOptions(shared_ptr<ListCallDetailRecordsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCallDetailRecordsV2Response listCallDetailRecordsV2(shared_ptr<ListCallDetailRecordsV2Request> request);
  ListCallSummariesResponse listCallSummariesWithOptions(shared_ptr<ListCallSummariesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCallSummariesResponse listCallSummaries(shared_ptr<ListCallSummariesRequest> request);
  ListCallTagsResponse listCallTagsWithOptions(shared_ptr<ListCallTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCallTagsResponse listCallTags(shared_ptr<ListCallTagsRequest> request);
  ListCampaignTrendingReportResponse listCampaignTrendingReportWithOptions(shared_ptr<ListCampaignTrendingReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCampaignTrendingReportResponse listCampaignTrendingReport(shared_ptr<ListCampaignTrendingReportRequest> request);
  ListCampaignsResponse listCampaignsWithOptions(shared_ptr<ListCampaignsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCampaignsResponse listCampaigns(shared_ptr<ListCampaignsRequest> request);
  ListCasesResponse listCasesWithOptions(shared_ptr<ListCasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCasesResponse listCases(shared_ptr<ListCasesRequest> request);
  ListCategoriesResponse listCategoriesWithOptions(shared_ptr<ListCategoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCategoriesResponse listCategories(shared_ptr<ListCategoriesRequest> request);
  ListCommonTicketFieldsResponse listCommonTicketFieldsWithOptions(shared_ptr<ListCommonTicketFieldsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCommonTicketFieldsResponse listCommonTicketFields(shared_ptr<ListCommonTicketFieldsRequest> request);
  ListConfigItemsResponse listConfigItemsWithOptions(shared_ptr<ListConfigItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigItemsResponse listConfigItems(shared_ptr<ListConfigItemsRequest> request);
  ListContactFlowsResponse listContactFlowsWithOptions(shared_ptr<ListContactFlowsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListContactFlowsResponse listContactFlows(shared_ptr<ListContactFlowsRequest> request);
  ListCustomCallTaggingResponse listCustomCallTaggingWithOptions(shared_ptr<ListCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomCallTaggingResponse listCustomCallTagging(shared_ptr<ListCustomCallTaggingRequest> request);
  ListDevicesResponse listDevicesWithOptions(shared_ptr<ListDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDevicesResponse listDevices(shared_ptr<ListDevicesRequest> request);
  ListDoNotCallNumbersResponse listDoNotCallNumbersWithOptions(shared_ptr<ListDoNotCallNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoNotCallNumbersResponse listDoNotCallNumbers(shared_ptr<ListDoNotCallNumbersRequest> request);
  ListDocumentsResponse listDocumentsWithOptions(shared_ptr<ListDocumentsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDocumentsResponse listDocuments(shared_ptr<ListDocumentsRequest> request);
  ListFlashSmsApplicationsResponse listFlashSmsApplicationsWithOptions(shared_ptr<ListFlashSmsApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlashSmsApplicationsResponse listFlashSmsApplications(shared_ptr<ListFlashSmsApplicationsRequest> request);
  ListFlashSmsTemplatesResponse listFlashSmsTemplatesWithOptions(shared_ptr<ListFlashSmsTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlashSmsTemplatesResponse listFlashSmsTemplates(shared_ptr<ListFlashSmsTemplatesRequest> request);
  ListGroupChatMessagesResponse listGroupChatMessagesWithOptions(shared_ptr<ListGroupChatMessagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGroupChatMessagesResponse listGroupChatMessages(shared_ptr<ListGroupChatMessagesRequest> request);
  ListHistoricalAgentReportResponse listHistoricalAgentReportWithOptions(shared_ptr<ListHistoricalAgentReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHistoricalAgentReportResponse listHistoricalAgentReport(shared_ptr<ListHistoricalAgentReportRequest> request);
  ListHistoricalAgentSkillGroupReportResponse listHistoricalAgentSkillGroupReportWithOptions(shared_ptr<ListHistoricalAgentSkillGroupReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHistoricalAgentSkillGroupReportResponse listHistoricalAgentSkillGroupReport(shared_ptr<ListHistoricalAgentSkillGroupReportRequest> request);
  ListHistoricalSkillGroupReportResponse listHistoricalSkillGroupReportWithOptions(shared_ptr<ListHistoricalSkillGroupReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHistoricalSkillGroupReportResponse listHistoricalSkillGroupReport(shared_ptr<ListHistoricalSkillGroupReportRequest> request);
  ListInstancesResponse listInstancesWithOptions(shared_ptr<ListInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesResponse listInstances(shared_ptr<ListInstancesRequest> request);
  ListInstancesOfUserResponse listInstancesOfUserWithOptions(shared_ptr<ListInstancesOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesOfUserResponse listInstancesOfUser(shared_ptr<ListInstancesOfUserRequest> request);
  ListIntervalAgentReportResponse listIntervalAgentReportWithOptions(shared_ptr<ListIntervalAgentReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntervalAgentReportResponse listIntervalAgentReport(shared_ptr<ListIntervalAgentReportRequest> request);
  ListIntervalAgentSkillGroupReportResponse listIntervalAgentSkillGroupReportWithOptions(shared_ptr<ListIntervalAgentSkillGroupReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntervalAgentSkillGroupReportResponse listIntervalAgentSkillGroupReport(shared_ptr<ListIntervalAgentSkillGroupReportRequest> request);
  ListIntervalInstanceReportResponse listIntervalInstanceReportWithOptions(shared_ptr<ListIntervalInstanceReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntervalInstanceReportResponse listIntervalInstanceReport(shared_ptr<ListIntervalInstanceReportRequest> request);
  ListIntervalSkillGroupReportResponse listIntervalSkillGroupReportWithOptions(shared_ptr<ListIntervalSkillGroupReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntervalSkillGroupReportResponse listIntervalSkillGroupReport(shared_ptr<ListIntervalSkillGroupReportRequest> request);
  ListIvrTrackingDetailsResponse listIvrTrackingDetailsWithOptions(shared_ptr<ListIvrTrackingDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIvrTrackingDetailsResponse listIvrTrackingDetails(shared_ptr<ListIvrTrackingDetailsRequest> request);
  ListLegacyAgentEventLogsResponse listLegacyAgentEventLogsWithOptions(shared_ptr<ListLegacyAgentEventLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLegacyAgentEventLogsResponse listLegacyAgentEventLogs(shared_ptr<ListLegacyAgentEventLogsRequest> request);
  ListLegacyAgentStatusLogsResponse listLegacyAgentStatusLogsWithOptions(shared_ptr<ListLegacyAgentStatusLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLegacyAgentStatusLogsResponse listLegacyAgentStatusLogs(shared_ptr<ListLegacyAgentStatusLogsRequest> request);
  ListLegacyAppraiseLogsResponse listLegacyAppraiseLogsWithOptions(shared_ptr<ListLegacyAppraiseLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLegacyAppraiseLogsResponse listLegacyAppraiseLogs(shared_ptr<ListLegacyAppraiseLogsRequest> request);
  ListLegacyQueueEventLogsResponse listLegacyQueueEventLogsWithOptions(shared_ptr<ListLegacyQueueEventLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLegacyQueueEventLogsResponse listLegacyQueueEventLogs(shared_ptr<ListLegacyQueueEventLogsRequest> request);
  ListMonoRecordingsResponse listMonoRecordingsWithOptions(shared_ptr<ListMonoRecordingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMonoRecordingsResponse listMonoRecordings(shared_ptr<ListMonoRecordingsRequest> request);
  ListMultiChannelRecordingsResponse listMultiChannelRecordingsWithOptions(shared_ptr<ListMultiChannelRecordingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMultiChannelRecordingsResponse listMultiChannelRecordings(shared_ptr<ListMultiChannelRecordingsRequest> request);
  ListOutboundNumbersOfUserResponse listOutboundNumbersOfUserWithOptions(shared_ptr<ListOutboundNumbersOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOutboundNumbersOfUserResponse listOutboundNumbersOfUser(shared_ptr<ListOutboundNumbersOfUserRequest> request);
  ListPersonalNumbersOfUserResponse listPersonalNumbersOfUserWithOptions(shared_ptr<ListPersonalNumbersOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPersonalNumbersOfUserResponse listPersonalNumbersOfUser(shared_ptr<ListPersonalNumbersOfUserRequest> request);
  ListPhoneNumbersResponse listPhoneNumbersWithOptions(shared_ptr<ListPhoneNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPhoneNumbersResponse listPhoneNumbers(shared_ptr<ListPhoneNumbersRequest> request);
  ListPhoneNumbersOfSkillGroupResponse listPhoneNumbersOfSkillGroupWithOptions(shared_ptr<ListPhoneNumbersOfSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPhoneNumbersOfSkillGroupResponse listPhoneNumbersOfSkillGroup(shared_ptr<ListPhoneNumbersOfSkillGroupRequest> request);
  ListPrivilegesOfUserResponse listPrivilegesOfUserWithOptions(shared_ptr<ListPrivilegesOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrivilegesOfUserResponse listPrivilegesOfUser(shared_ptr<ListPrivilegesOfUserRequest> request);
  ListRamUsersResponse listRamUsersWithOptions(shared_ptr<ListRamUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRamUsersResponse listRamUsers(shared_ptr<ListRamUsersRequest> request);
  ListRealtimeAgentStatesResponse listRealtimeAgentStatesWithOptions(shared_ptr<ListRealtimeAgentStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRealtimeAgentStatesResponse listRealtimeAgentStates(shared_ptr<ListRealtimeAgentStatesRequest> request);
  ListRealtimeSkillGroupStatesResponse listRealtimeSkillGroupStatesWithOptions(shared_ptr<ListRealtimeSkillGroupStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRealtimeSkillGroupStatesResponse listRealtimeSkillGroupStates(shared_ptr<ListRealtimeSkillGroupStatesRequest> request);
  ListRecentCallDetailRecordsResponse listRecentCallDetailRecordsWithOptions(shared_ptr<ListRecentCallDetailRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecentCallDetailRecordsResponse listRecentCallDetailRecords(shared_ptr<ListRecentCallDetailRecordsRequest> request);
  ListRolesResponse listRolesWithOptions(shared_ptr<ListRolesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRolesResponse listRoles(shared_ptr<ListRolesRequest> request);
  ListSkillGroupStatesResponse listSkillGroupStatesWithOptions(shared_ptr<ListSkillGroupStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupStatesResponse listSkillGroupStates(shared_ptr<ListSkillGroupStatesRequest> request);
  ListSkillGroupSummaryReportsSinceMidnightResponse listSkillGroupSummaryReportsSinceMidnightWithOptions(shared_ptr<ListSkillGroupSummaryReportsSinceMidnightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupSummaryReportsSinceMidnightResponse listSkillGroupSummaryReportsSinceMidnight(shared_ptr<ListSkillGroupSummaryReportsSinceMidnightRequest> request);
  ListSkillGroupsResponse listSkillGroupsWithOptions(shared_ptr<ListSkillGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupsResponse listSkillGroups(shared_ptr<ListSkillGroupsRequest> request);
  ListSkillLevelsOfUserResponse listSkillLevelsOfUserWithOptions(shared_ptr<ListSkillLevelsOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillLevelsOfUserResponse listSkillLevelsOfUser(shared_ptr<ListSkillLevelsOfUserRequest> request);
  ListTicketTasksResponse listTicketTasksWithOptions(shared_ptr<ListTicketTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTicketTasksResponse listTicketTasks(shared_ptr<ListTicketTasksRequest> request);
  ListTicketTemplatesResponse listTicketTemplatesWithOptions(shared_ptr<ListTicketTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTicketTemplatesResponse listTicketTemplates(shared_ptr<ListTicketTemplatesRequest> request);
  ListTicketsResponse listTicketsWithOptions(shared_ptr<ListTicketsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTicketsResponse listTickets(shared_ptr<ListTicketsRequest> request);
  ListUnassignedNumbersResponse listUnassignedNumbersWithOptions(shared_ptr<ListUnassignedNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUnassignedNumbersResponse listUnassignedNumbers(shared_ptr<ListUnassignedNumbersRequest> request);
  ListUserLevelsOfSkillGroupResponse listUserLevelsOfSkillGroupWithOptions(shared_ptr<ListUserLevelsOfSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserLevelsOfSkillGroupResponse listUserLevelsOfSkillGroup(shared_ptr<ListUserLevelsOfSkillGroupRequest> request);
  ListUsersResponse listUsersWithOptions(shared_ptr<ListUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersResponse listUsers(shared_ptr<ListUsersRequest> request);
  ListVoicemailsResponse listVoicemailsWithOptions(shared_ptr<ListVoicemailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVoicemailsResponse listVoicemails(shared_ptr<ListVoicemailsRequest> request);
  ListWaitingChatsResponse listWaitingChatsWithOptions(shared_ptr<ListWaitingChatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWaitingChatsResponse listWaitingChats(shared_ptr<ListWaitingChatsRequest> request);
  MakeCallResponse makeCallWithOptions(shared_ptr<MakeCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MakeCallResponse makeCall(shared_ptr<MakeCallRequest> request);
  ModifyAudioFileResponse modifyAudioFileWithOptions(shared_ptr<ModifyAudioFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAudioFileResponse modifyAudioFile(shared_ptr<ModifyAudioFileRequest> request);
  ModifyCustomCallTaggingResponse modifyCustomCallTaggingWithOptions(shared_ptr<ModifyCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCustomCallTaggingResponse modifyCustomCallTagging(shared_ptr<ModifyCustomCallTaggingRequest> request);
  ModifyInstanceResponse modifyInstanceWithOptions(shared_ptr<ModifyInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceResponse modifyInstance(shared_ptr<ModifyInstanceRequest> request);
  ModifyPhoneNumberResponse modifyPhoneNumberWithOptions(shared_ptr<ModifyPhoneNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPhoneNumberResponse modifyPhoneNumber(shared_ptr<ModifyPhoneNumberRequest> request);
  ModifySkillGroupResponse modifySkillGroupWithOptions(shared_ptr<ModifySkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySkillGroupResponse modifySkillGroup(shared_ptr<ModifySkillGroupRequest> request);
  ModifySkillLevelsOfUserResponse modifySkillLevelsOfUserWithOptions(shared_ptr<ModifySkillLevelsOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySkillLevelsOfUserResponse modifySkillLevelsOfUser(shared_ptr<ModifySkillLevelsOfUserRequest> request);
  ModifyUserResponse modifyUserWithOptions(shared_ptr<ModifyUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserResponse modifyUser(shared_ptr<ModifyUserRequest> request);
  ModifyUserLevelsOfSkillGroupResponse modifyUserLevelsOfSkillGroupWithOptions(shared_ptr<ModifyUserLevelsOfSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserLevelsOfSkillGroupResponse modifyUserLevelsOfSkillGroup(shared_ptr<ModifyUserLevelsOfSkillGroupRequest> request);
  MonitorCallResponse monitorCallWithOptions(shared_ptr<MonitorCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MonitorCallResponse monitorCall(shared_ptr<MonitorCallRequest> request);
  MuteCallResponse muteCallWithOptions(shared_ptr<MuteCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MuteCallResponse muteCall(shared_ptr<MuteCallRequest> request);
  PauseCampaignResponse pauseCampaignWithOptions(shared_ptr<PauseCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PauseCampaignResponse pauseCampaign(shared_ptr<PauseCampaignRequest> request);
  PickOutboundNumbersResponse pickOutboundNumbersWithOptions(shared_ptr<PickOutboundNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PickOutboundNumbersResponse pickOutboundNumbers(shared_ptr<PickOutboundNumbersRequest> request);
  PollUserStatusResponse pollUserStatusWithOptions(shared_ptr<PollUserStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PollUserStatusResponse pollUserStatus(shared_ptr<PollUserStatusRequest> request);
  ProcessAliMeCallbackOfStagingResponse processAliMeCallbackOfStagingWithOptions(shared_ptr<ProcessAliMeCallbackOfStagingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProcessAliMeCallbackOfStagingResponse processAliMeCallbackOfStaging(shared_ptr<ProcessAliMeCallbackOfStagingRequest> request);
  PublishContactFlowResponse publishContactFlowWithOptions(shared_ptr<PublishContactFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishContactFlowResponse publishContactFlow(shared_ptr<PublishContactFlowRequest> request);
  ReadyForServiceResponse readyForServiceWithOptions(shared_ptr<ReadyForServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReadyForServiceResponse readyForService(shared_ptr<ReadyForServiceRequest> request);
  RedialCallResponse redialCallWithOptions(shared_ptr<RedialCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RedialCallResponse redialCall(shared_ptr<RedialCallRequest> request);
  RegisterDeviceResponse registerDeviceWithOptions(shared_ptr<RegisterDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterDeviceResponse registerDevice(shared_ptr<RegisterDeviceRequest> request);
  RegisterDevicesResponse registerDevicesWithOptions(shared_ptr<RegisterDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterDevicesResponse registerDevices(shared_ptr<RegisterDevicesRequest> request);
  RejectChatResponse rejectChatWithOptions(shared_ptr<RejectChatRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RejectChatResponse rejectChat(shared_ptr<RejectChatRequest> request);
  RejectTicketResponse rejectTicketWithOptions(shared_ptr<RejectTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RejectTicketResponse rejectTicket(shared_ptr<RejectTicketRequest> request);
  ReleaseCallResponse releaseCallWithOptions(shared_ptr<ReleaseCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseCallResponse releaseCall(shared_ptr<ReleaseCallRequest> request);
  ReleaseChatResponse releaseChatWithOptions(shared_ptr<ReleaseChatRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseChatResponse releaseChat(shared_ptr<ReleaseChatRequest> request);
  RemoveBlacklistCallTaggingResponse removeBlacklistCallTaggingWithOptions(shared_ptr<RemoveBlacklistCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveBlacklistCallTaggingResponse removeBlacklistCallTagging(shared_ptr<RemoveBlacklistCallTaggingRequest> request);
  RemoveDoNotCallNumbersResponse removeDoNotCallNumbersWithOptions(shared_ptr<RemoveDoNotCallNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveDoNotCallNumbersResponse removeDoNotCallNumbers(shared_ptr<RemoveDoNotCallNumbersRequest> request);
  RemovePersonalNumbersFromUserResponse removePersonalNumbersFromUserWithOptions(shared_ptr<RemovePersonalNumbersFromUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePersonalNumbersFromUserResponse removePersonalNumbersFromUser(shared_ptr<RemovePersonalNumbersFromUserRequest> request);
  RemovePhoneNumberFromSkillGroupsResponse removePhoneNumberFromSkillGroupsWithOptions(shared_ptr<RemovePhoneNumberFromSkillGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePhoneNumberFromSkillGroupsResponse removePhoneNumberFromSkillGroups(shared_ptr<RemovePhoneNumberFromSkillGroupsRequest> request);
  RemovePhoneNumbersResponse removePhoneNumbersWithOptions(shared_ptr<RemovePhoneNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePhoneNumbersResponse removePhoneNumbers(shared_ptr<RemovePhoneNumbersRequest> request);
  RemovePhoneNumbersFromSkillGroupResponse removePhoneNumbersFromSkillGroupWithOptions(shared_ptr<RemovePhoneNumbersFromSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePhoneNumbersFromSkillGroupResponse removePhoneNumbersFromSkillGroup(shared_ptr<RemovePhoneNumbersFromSkillGroupRequest> request);
  RemoveSkillGroupsFromUserResponse removeSkillGroupsFromUserWithOptions(shared_ptr<RemoveSkillGroupsFromUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveSkillGroupsFromUserResponse removeSkillGroupsFromUser(shared_ptr<RemoveSkillGroupsFromUserRequest> request);
  RemoveUsersResponse removeUsersWithOptions(shared_ptr<RemoveUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUsersResponse removeUsers(shared_ptr<RemoveUsersRequest> request);
  RemoveUsersFromSkillGroupResponse removeUsersFromSkillGroupWithOptions(shared_ptr<RemoveUsersFromSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUsersFromSkillGroupResponse removeUsersFromSkillGroup(shared_ptr<RemoveUsersFromSkillGroupRequest> request);
  ResetAgentStateResponse resetAgentStateWithOptions(shared_ptr<ResetAgentStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAgentStateResponse resetAgentState(shared_ptr<ResetAgentStateRequest> request);
  ResetUserPasswordResponse resetUserPasswordWithOptions(shared_ptr<ResetUserPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetUserPasswordResponse resetUserPassword(shared_ptr<ResetUserPasswordRequest> request);
  RestoreArchivedRecordingsResponse restoreArchivedRecordingsWithOptions(shared_ptr<RestoreArchivedRecordingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestoreArchivedRecordingsResponse restoreArchivedRecordings(shared_ptr<RestoreArchivedRecordingsRequest> request);
  ResubmitTicketResponse resubmitTicketWithOptions(shared_ptr<ResubmitTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResubmitTicketResponse resubmitTicket(shared_ptr<ResubmitTicketRequest> request);
  ResumeCampaignResponse resumeCampaignWithOptions(shared_ptr<ResumeCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeCampaignResponse resumeCampaign(shared_ptr<ResumeCampaignRequest> request);
  RetrieveCallResponse retrieveCallWithOptions(shared_ptr<RetrieveCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetrieveCallResponse retrieveCall(shared_ptr<RetrieveCallRequest> request);
  SaveDocumentResponse saveDocumentWithOptions(shared_ptr<SaveDocumentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveDocumentResponse saveDocument(shared_ptr<SaveDocumentRequest> request);
  SaveRTCStatsV2Response saveRTCStatsV2WithOptions(shared_ptr<SaveRTCStatsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveRTCStatsV2Response saveRTCStatsV2(shared_ptr<SaveRTCStatsV2Request> request);
  SaveTerminalLogResponse saveTerminalLogWithOptions(shared_ptr<SaveTerminalLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveTerminalLogResponse saveTerminalLog(shared_ptr<SaveTerminalLogRequest> request);
  SaveWebRTCStatsResponse saveWebRTCStatsWithOptions(shared_ptr<SaveWebRTCStatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveWebRTCStatsResponse saveWebRTCStats(shared_ptr<SaveWebRTCStatsRequest> request);
  SaveWebRtcInfoResponse saveWebRtcInfoWithOptions(shared_ptr<SaveWebRtcInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveWebRtcInfoResponse saveWebRtcInfo(shared_ptr<SaveWebRtcInfoRequest> request);
  SendDtmfSignalingResponse sendDtmfSignalingWithOptions(shared_ptr<SendDtmfSignalingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendDtmfSignalingResponse sendDtmfSignaling(shared_ptr<SendDtmfSignalingRequest> request);
  SignInGroupResponse signInGroupWithOptions(shared_ptr<SignInGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SignInGroupResponse signInGroup(shared_ptr<SignInGroupRequest> request);
  SignOutGroupResponse signOutGroupWithOptions(shared_ptr<SignOutGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SignOutGroupResponse signOutGroup(shared_ptr<SignOutGroupRequest> request);
  StartBack2BackCallResponse startBack2BackCallWithOptions(shared_ptr<StartBack2BackCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartBack2BackCallResponse startBack2BackCall(shared_ptr<StartBack2BackCallRequest> request);
  StartChatResponse startChatWithOptions(shared_ptr<StartChatRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartChatResponse startChat(shared_ptr<StartChatRequest> request);
  StartConferenceResponse startConferenceWithOptions(shared_ptr<StartConferenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartConferenceResponse startConference(shared_ptr<StartConferenceRequest> request);
  StartEditContactFlowResponse startEditContactFlowWithOptions(shared_ptr<StartEditContactFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartEditContactFlowResponse startEditContactFlow(shared_ptr<StartEditContactFlowRequest> request);
  StartPredictiveCallResponse startPredictiveCallWithOptions(shared_ptr<StartPredictiveCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartPredictiveCallResponse startPredictiveCall(shared_ptr<StartPredictiveCallRequest> request);
  StartPrivacyCallResponse startPrivacyCallWithOptions(shared_ptr<StartPrivacyCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartPrivacyCallResponse startPrivacyCall(shared_ptr<StartPrivacyCallRequest> request);
  SubmitCampaignResponse submitCampaignWithOptions(shared_ptr<SubmitCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitCampaignResponse submitCampaign(shared_ptr<SubmitCampaignRequest> request);
  SwitchToConferenceResponse switchToConferenceWithOptions(shared_ptr<SwitchToConferenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchToConferenceResponse switchToConference(shared_ptr<SwitchToConferenceRequest> request);
  TakeBreakResponse takeBreakWithOptions(shared_ptr<TakeBreakRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TakeBreakResponse takeBreak(shared_ptr<TakeBreakRequest> request);
  TerminateTicketResponse terminateTicketWithOptions(shared_ptr<TerminateTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TerminateTicketResponse terminateTicket(shared_ptr<TerminateTicketRequest> request);
  TransferTicketTaskResponse transferTicketTaskWithOptions(shared_ptr<TransferTicketTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransferTicketTaskResponse transferTicketTask(shared_ptr<TransferTicketTaskRequest> request);
  UnmuteCallResponse unmuteCallWithOptions(shared_ptr<UnmuteCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnmuteCallResponse unmuteCall(shared_ptr<UnmuteCallRequest> request);
  UnregisterDeviceResponse unregisterDeviceWithOptions(shared_ptr<UnregisterDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnregisterDeviceResponse unregisterDevice(shared_ptr<UnregisterDeviceRequest> request);
  UpdateCampaignResponse updateCampaignWithOptions(shared_ptr<UpdateCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCampaignResponse updateCampaign(shared_ptr<UpdateCampaignRequest> request);
  UpdateConfigItemsResponse updateConfigItemsWithOptions(shared_ptr<UpdateConfigItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConfigItemsResponse updateConfigItems(shared_ptr<UpdateConfigItemsRequest> request);
  UpdateSchemaPropertyResponse updateSchemaPropertyWithOptions(shared_ptr<UpdateSchemaPropertyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSchemaPropertyResponse updateSchemaProperty(shared_ptr<UpdateSchemaPropertyRequest> request);
  UpdateTicketResponse updateTicketWithOptions(shared_ptr<UpdateTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTicketResponse updateTicket(shared_ptr<UpdateTicketRequest> request);
  WithdrawTicketResponse withdrawTicketWithOptions(shared_ptr<WithdrawTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WithdrawTicketResponse withdrawTicket(shared_ptr<WithdrawTicketRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_CCC20200701

#endif
