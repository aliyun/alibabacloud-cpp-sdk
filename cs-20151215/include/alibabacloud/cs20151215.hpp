// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CS20151215_H_
#define ALIBABACLOUD_CS20151215_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_CS20151215 {
class InstanceMetadataOptions : public Darabonba::Model {
public:
  shared_ptr<string> httpTokens{};

  InstanceMetadataOptions() {}

  explicit InstanceMetadataOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpTokens) {
      res["http_tokens"] = boost::any(*httpTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("http_tokens") != m.end() && !m["http_tokens"].empty()) {
      httpTokens = make_shared<string>(boost::any_cast<string>(m["http_tokens"]));
    }
  }


  virtual ~InstanceMetadataOptions() = default;
};
class Addon : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<bool> disabled{};
  shared_ptr<string> name{};
  shared_ptr<string> version{};

  Addon() {}

  explicit Addon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (disabled) {
      res["disabled"] = boost::any(*disabled);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
    if (m.find("disabled") != m.end() && !m["disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["disabled"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~Addon() = default;
};
class ContainerdConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> insecureRegistries{};
  shared_ptr<vector<string>> registryMirrors{};

  ContainerdConfig() {}

  explicit ContainerdConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (insecureRegistries) {
      res["insecureRegistries"] = boost::any(*insecureRegistries);
    }
    if (registryMirrors) {
      res["registryMirrors"] = boost::any(*registryMirrors);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("insecureRegistries") != m.end() && !m["insecureRegistries"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["insecureRegistries"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["insecureRegistries"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      insecureRegistries = make_shared<vector<string>>(toVec1);
    }
    if (m.find("registryMirrors") != m.end() && !m["registryMirrors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["registryMirrors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["registryMirrors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      registryMirrors = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ContainerdConfig() = default;
};
class DataDisk : public Darabonba::Model {
public:
  shared_ptr<bool> autoFormat{};
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<bool> burstingEnabled{};
  shared_ptr<string> category{};
  shared_ptr<string> device{};
  shared_ptr<string> diskName{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> fileSystem{};
  shared_ptr<string> kmsKeyId{};
  shared_ptr<string> mountTarget{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<long> provisionedIops{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};

  DataDisk() {}

  explicit DataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoFormat) {
      res["auto_format"] = boost::any(*autoFormat);
    }
    if (autoSnapshotPolicyId) {
      res["auto_snapshot_policy_id"] = boost::any(*autoSnapshotPolicyId);
    }
    if (burstingEnabled) {
      res["bursting_enabled"] = boost::any(*burstingEnabled);
    }
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (device) {
      res["device"] = boost::any(*device);
    }
    if (diskName) {
      res["disk_name"] = boost::any(*diskName);
    }
    if (encrypted) {
      res["encrypted"] = boost::any(*encrypted);
    }
    if (fileSystem) {
      res["file_system"] = boost::any(*fileSystem);
    }
    if (kmsKeyId) {
      res["kms_key_id"] = boost::any(*kmsKeyId);
    }
    if (mountTarget) {
      res["mount_target"] = boost::any(*mountTarget);
    }
    if (performanceLevel) {
      res["performance_level"] = boost::any(*performanceLevel);
    }
    if (provisionedIops) {
      res["provisioned_iops"] = boost::any(*provisionedIops);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["snapshot_id"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_format") != m.end() && !m["auto_format"].empty()) {
      autoFormat = make_shared<bool>(boost::any_cast<bool>(m["auto_format"]));
    }
    if (m.find("auto_snapshot_policy_id") != m.end() && !m["auto_snapshot_policy_id"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["auto_snapshot_policy_id"]));
    }
    if (m.find("bursting_enabled") != m.end() && !m["bursting_enabled"].empty()) {
      burstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["bursting_enabled"]));
    }
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("device") != m.end() && !m["device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["device"]));
    }
    if (m.find("disk_name") != m.end() && !m["disk_name"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["disk_name"]));
    }
    if (m.find("encrypted") != m.end() && !m["encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["encrypted"]));
    }
    if (m.find("file_system") != m.end() && !m["file_system"].empty()) {
      fileSystem = make_shared<string>(boost::any_cast<string>(m["file_system"]));
    }
    if (m.find("kms_key_id") != m.end() && !m["kms_key_id"].empty()) {
      kmsKeyId = make_shared<string>(boost::any_cast<string>(m["kms_key_id"]));
    }
    if (m.find("mount_target") != m.end() && !m["mount_target"].empty()) {
      mountTarget = make_shared<string>(boost::any_cast<string>(m["mount_target"]));
    }
    if (m.find("performance_level") != m.end() && !m["performance_level"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["performance_level"]));
    }
    if (m.find("provisioned_iops") != m.end() && !m["provisioned_iops"].empty()) {
      provisionedIops = make_shared<long>(boost::any_cast<long>(m["provisioned_iops"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("snapshot_id") != m.end() && !m["snapshot_id"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["snapshot_id"]));
    }
  }


  virtual ~DataDisk() = default;
};
class InstancePatterns : public Darabonba::Model {
public:
  shared_ptr<vector<string>> architectures{};
  shared_ptr<string> burstPerformanceOption{};
  shared_ptr<long> core{};
  shared_ptr<long> cores{};
  shared_ptr<vector<string>> cpuArchitectures{};
  shared_ptr<vector<string>> excludedInstanceTypes{};
  shared_ptr<vector<string>> instanceCategories{};
  shared_ptr<string> instanceFamilyLevel{};
  shared_ptr<vector<string>> instanceTypeFamilies{};
  shared_ptr<long> maxCpuCores{};
  shared_ptr<double> maxMemorySize{};
  shared_ptr<double> maxPrice{};
  shared_ptr<long> maximumGpuAmount{};
  shared_ptr<double> memory{};
  shared_ptr<long> minCpuCores{};
  shared_ptr<double> minMemorySize{};
  shared_ptr<long> minimumEniIpv6AddressQuantity{};
  shared_ptr<long> minimumEniPrivateIpAddressQuantity{};
  shared_ptr<long> minimumEniQuantity{};

  InstancePatterns() {}

  explicit InstancePatterns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architectures) {
      res["architectures"] = boost::any(*architectures);
    }
    if (burstPerformanceOption) {
      res["burst_performance_option"] = boost::any(*burstPerformanceOption);
    }
    if (core) {
      res["core"] = boost::any(*core);
    }
    if (cores) {
      res["cores"] = boost::any(*cores);
    }
    if (cpuArchitectures) {
      res["cpu_architectures"] = boost::any(*cpuArchitectures);
    }
    if (excludedInstanceTypes) {
      res["excluded_instance_types"] = boost::any(*excludedInstanceTypes);
    }
    if (instanceCategories) {
      res["instance_categories"] = boost::any(*instanceCategories);
    }
    if (instanceFamilyLevel) {
      res["instance_family_level"] = boost::any(*instanceFamilyLevel);
    }
    if (instanceTypeFamilies) {
      res["instance_type_families"] = boost::any(*instanceTypeFamilies);
    }
    if (maxCpuCores) {
      res["max_cpu_cores"] = boost::any(*maxCpuCores);
    }
    if (maxMemorySize) {
      res["max_memory_size"] = boost::any(*maxMemorySize);
    }
    if (maxPrice) {
      res["max_price"] = boost::any(*maxPrice);
    }
    if (maximumGpuAmount) {
      res["maximum_gpu_amount"] = boost::any(*maximumGpuAmount);
    }
    if (memory) {
      res["memory"] = boost::any(*memory);
    }
    if (minCpuCores) {
      res["min_cpu_cores"] = boost::any(*minCpuCores);
    }
    if (minMemorySize) {
      res["min_memory_size"] = boost::any(*minMemorySize);
    }
    if (minimumEniIpv6AddressQuantity) {
      res["minimum_eni_ipv6_address_quantity"] = boost::any(*minimumEniIpv6AddressQuantity);
    }
    if (minimumEniPrivateIpAddressQuantity) {
      res["minimum_eni_private_ip_address_quantity"] = boost::any(*minimumEniPrivateIpAddressQuantity);
    }
    if (minimumEniQuantity) {
      res["minimum_eni_quantity"] = boost::any(*minimumEniQuantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("architectures") != m.end() && !m["architectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["architectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["architectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      architectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("burst_performance_option") != m.end() && !m["burst_performance_option"].empty()) {
      burstPerformanceOption = make_shared<string>(boost::any_cast<string>(m["burst_performance_option"]));
    }
    if (m.find("core") != m.end() && !m["core"].empty()) {
      core = make_shared<long>(boost::any_cast<long>(m["core"]));
    }
    if (m.find("cores") != m.end() && !m["cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["cores"]));
    }
    if (m.find("cpu_architectures") != m.end() && !m["cpu_architectures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["cpu_architectures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["cpu_architectures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cpuArchitectures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("excluded_instance_types") != m.end() && !m["excluded_instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["excluded_instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["excluded_instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludedInstanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("instance_categories") != m.end() && !m["instance_categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("instance_family_level") != m.end() && !m["instance_family_level"].empty()) {
      instanceFamilyLevel = make_shared<string>(boost::any_cast<string>(m["instance_family_level"]));
    }
    if (m.find("instance_type_families") != m.end() && !m["instance_type_families"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_type_families"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_type_families"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypeFamilies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("max_cpu_cores") != m.end() && !m["max_cpu_cores"].empty()) {
      maxCpuCores = make_shared<long>(boost::any_cast<long>(m["max_cpu_cores"]));
    }
    if (m.find("max_memory_size") != m.end() && !m["max_memory_size"].empty()) {
      maxMemorySize = make_shared<double>(boost::any_cast<double>(m["max_memory_size"]));
    }
    if (m.find("max_price") != m.end() && !m["max_price"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["max_price"]));
    }
    if (m.find("maximum_gpu_amount") != m.end() && !m["maximum_gpu_amount"].empty()) {
      maximumGpuAmount = make_shared<long>(boost::any_cast<long>(m["maximum_gpu_amount"]));
    }
    if (m.find("memory") != m.end() && !m["memory"].empty()) {
      memory = make_shared<double>(boost::any_cast<double>(m["memory"]));
    }
    if (m.find("min_cpu_cores") != m.end() && !m["min_cpu_cores"].empty()) {
      minCpuCores = make_shared<long>(boost::any_cast<long>(m["min_cpu_cores"]));
    }
    if (m.find("min_memory_size") != m.end() && !m["min_memory_size"].empty()) {
      minMemorySize = make_shared<double>(boost::any_cast<double>(m["min_memory_size"]));
    }
    if (m.find("minimum_eni_ipv6_address_quantity") != m.end() && !m["minimum_eni_ipv6_address_quantity"].empty()) {
      minimumEniIpv6AddressQuantity = make_shared<long>(boost::any_cast<long>(m["minimum_eni_ipv6_address_quantity"]));
    }
    if (m.find("minimum_eni_private_ip_address_quantity") != m.end() && !m["minimum_eni_private_ip_address_quantity"].empty()) {
      minimumEniPrivateIpAddressQuantity = make_shared<long>(boost::any_cast<long>(m["minimum_eni_private_ip_address_quantity"]));
    }
    if (m.find("minimum_eni_quantity") != m.end() && !m["minimum_eni_quantity"].empty()) {
      minimumEniQuantity = make_shared<long>(boost::any_cast<long>(m["minimum_eni_quantity"]));
    }
  }


  virtual ~InstancePatterns() = default;
};
class KubeletConfigReservedMemory : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> limits{};
  shared_ptr<long> numaNode{};

  KubeletConfigReservedMemory() {}

  explicit KubeletConfigReservedMemory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (limits) {
      res["limits"] = boost::any(*limits);
    }
    if (numaNode) {
      res["numaNode"] = boost::any(*numaNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("limits") != m.end() && !m["limits"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["limits"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      limits = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("numaNode") != m.end() && !m["numaNode"].empty()) {
      numaNode = make_shared<long>(boost::any_cast<long>(m["numaNode"]));
    }
  }


  virtual ~KubeletConfigReservedMemory() = default;
};
class KubeletConfigTracing : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};
  shared_ptr<long> samplingRatePerMillion{};

  KubeletConfigTracing() {}

  explicit KubeletConfigTracing(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["endpoint"] = boost::any(*endpoint);
    }
    if (samplingRatePerMillion) {
      res["samplingRatePerMillion"] = boost::any(*samplingRatePerMillion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endpoint") != m.end() && !m["endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["endpoint"]));
    }
    if (m.find("samplingRatePerMillion") != m.end() && !m["samplingRatePerMillion"].empty()) {
      samplingRatePerMillion = make_shared<long>(boost::any_cast<long>(m["samplingRatePerMillion"]));
    }
  }


  virtual ~KubeletConfigTracing() = default;
};
class KubeletConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> allowedUnsafeSysctls{};
  shared_ptr<vector<string>> clusterDNS{};
  shared_ptr<long> containerLogMaxFiles{};
  shared_ptr<string> containerLogMaxSize{};
  shared_ptr<long> containerLogMaxWorkers{};
  shared_ptr<string> containerLogMonitorInterval{};
  shared_ptr<bool> cpuCFSQuota{};
  shared_ptr<string> cpuCFSQuotaPeriod{};
  shared_ptr<string> cpuManagerPolicy{};
  shared_ptr<long> eventBurst{};
  shared_ptr<long> eventRecordQPS{};
  shared_ptr<map<string, boost::any>> evictionHard{};
  shared_ptr<map<string, boost::any>> evictionSoft{};
  shared_ptr<map<string, boost::any>> evictionSoftGracePeriod{};
  shared_ptr<map<string, boost::any>> featureGates{};
  shared_ptr<long> imageGCHighThresholdPercent{};
  shared_ptr<long> imageGCLowThresholdPercent{};
  shared_ptr<long> kubeAPIBurst{};
  shared_ptr<long> kubeAPIQPS{};
  shared_ptr<map<string, boost::any>> kubeReserved{};
  shared_ptr<long> maxPods{};
  shared_ptr<string> memoryManagerPolicy{};
  shared_ptr<long> podPidsLimit{};
  shared_ptr<long> readOnlyPort{};
  shared_ptr<long> registryBurst{};
  shared_ptr<long> registryPullQPS{};
  shared_ptr<vector<KubeletConfigReservedMemory>> reservedMemory{};
  shared_ptr<bool> serializeImagePulls{};
  shared_ptr<map<string, boost::any>> systemReserved{};
  shared_ptr<string> topologyManagerPolicy{};
  shared_ptr<KubeletConfigTracing> tracing{};

  KubeletConfig() {}

  explicit KubeletConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowedUnsafeSysctls) {
      res["allowedUnsafeSysctls"] = boost::any(*allowedUnsafeSysctls);
    }
    if (clusterDNS) {
      res["clusterDNS"] = boost::any(*clusterDNS);
    }
    if (containerLogMaxFiles) {
      res["containerLogMaxFiles"] = boost::any(*containerLogMaxFiles);
    }
    if (containerLogMaxSize) {
      res["containerLogMaxSize"] = boost::any(*containerLogMaxSize);
    }
    if (containerLogMaxWorkers) {
      res["containerLogMaxWorkers"] = boost::any(*containerLogMaxWorkers);
    }
    if (containerLogMonitorInterval) {
      res["containerLogMonitorInterval"] = boost::any(*containerLogMonitorInterval);
    }
    if (cpuCFSQuota) {
      res["cpuCFSQuota"] = boost::any(*cpuCFSQuota);
    }
    if (cpuCFSQuotaPeriod) {
      res["cpuCFSQuotaPeriod"] = boost::any(*cpuCFSQuotaPeriod);
    }
    if (cpuManagerPolicy) {
      res["cpuManagerPolicy"] = boost::any(*cpuManagerPolicy);
    }
    if (eventBurst) {
      res["eventBurst"] = boost::any(*eventBurst);
    }
    if (eventRecordQPS) {
      res["eventRecordQPS"] = boost::any(*eventRecordQPS);
    }
    if (evictionHard) {
      res["evictionHard"] = boost::any(*evictionHard);
    }
    if (evictionSoft) {
      res["evictionSoft"] = boost::any(*evictionSoft);
    }
    if (evictionSoftGracePeriod) {
      res["evictionSoftGracePeriod"] = boost::any(*evictionSoftGracePeriod);
    }
    if (featureGates) {
      res["featureGates"] = boost::any(*featureGates);
    }
    if (imageGCHighThresholdPercent) {
      res["imageGCHighThresholdPercent"] = boost::any(*imageGCHighThresholdPercent);
    }
    if (imageGCLowThresholdPercent) {
      res["imageGCLowThresholdPercent"] = boost::any(*imageGCLowThresholdPercent);
    }
    if (kubeAPIBurst) {
      res["kubeAPIBurst"] = boost::any(*kubeAPIBurst);
    }
    if (kubeAPIQPS) {
      res["kubeAPIQPS"] = boost::any(*kubeAPIQPS);
    }
    if (kubeReserved) {
      res["kubeReserved"] = boost::any(*kubeReserved);
    }
    if (maxPods) {
      res["maxPods"] = boost::any(*maxPods);
    }
    if (memoryManagerPolicy) {
      res["memoryManagerPolicy"] = boost::any(*memoryManagerPolicy);
    }
    if (podPidsLimit) {
      res["podPidsLimit"] = boost::any(*podPidsLimit);
    }
    if (readOnlyPort) {
      res["readOnlyPort"] = boost::any(*readOnlyPort);
    }
    if (registryBurst) {
      res["registryBurst"] = boost::any(*registryBurst);
    }
    if (registryPullQPS) {
      res["registryPullQPS"] = boost::any(*registryPullQPS);
    }
    if (reservedMemory) {
      vector<boost::any> temp1;
      for(auto item1:*reservedMemory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reservedMemory"] = boost::any(temp1);
    }
    if (serializeImagePulls) {
      res["serializeImagePulls"] = boost::any(*serializeImagePulls);
    }
    if (systemReserved) {
      res["systemReserved"] = boost::any(*systemReserved);
    }
    if (topologyManagerPolicy) {
      res["topologyManagerPolicy"] = boost::any(*topologyManagerPolicy);
    }
    if (tracing) {
      res["tracing"] = tracing ? boost::any(tracing->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowedUnsafeSysctls") != m.end() && !m["allowedUnsafeSysctls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["allowedUnsafeSysctls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowedUnsafeSysctls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      allowedUnsafeSysctls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("clusterDNS") != m.end() && !m["clusterDNS"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["clusterDNS"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["clusterDNS"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterDNS = make_shared<vector<string>>(toVec1);
    }
    if (m.find("containerLogMaxFiles") != m.end() && !m["containerLogMaxFiles"].empty()) {
      containerLogMaxFiles = make_shared<long>(boost::any_cast<long>(m["containerLogMaxFiles"]));
    }
    if (m.find("containerLogMaxSize") != m.end() && !m["containerLogMaxSize"].empty()) {
      containerLogMaxSize = make_shared<string>(boost::any_cast<string>(m["containerLogMaxSize"]));
    }
    if (m.find("containerLogMaxWorkers") != m.end() && !m["containerLogMaxWorkers"].empty()) {
      containerLogMaxWorkers = make_shared<long>(boost::any_cast<long>(m["containerLogMaxWorkers"]));
    }
    if (m.find("containerLogMonitorInterval") != m.end() && !m["containerLogMonitorInterval"].empty()) {
      containerLogMonitorInterval = make_shared<string>(boost::any_cast<string>(m["containerLogMonitorInterval"]));
    }
    if (m.find("cpuCFSQuota") != m.end() && !m["cpuCFSQuota"].empty()) {
      cpuCFSQuota = make_shared<bool>(boost::any_cast<bool>(m["cpuCFSQuota"]));
    }
    if (m.find("cpuCFSQuotaPeriod") != m.end() && !m["cpuCFSQuotaPeriod"].empty()) {
      cpuCFSQuotaPeriod = make_shared<string>(boost::any_cast<string>(m["cpuCFSQuotaPeriod"]));
    }
    if (m.find("cpuManagerPolicy") != m.end() && !m["cpuManagerPolicy"].empty()) {
      cpuManagerPolicy = make_shared<string>(boost::any_cast<string>(m["cpuManagerPolicy"]));
    }
    if (m.find("eventBurst") != m.end() && !m["eventBurst"].empty()) {
      eventBurst = make_shared<long>(boost::any_cast<long>(m["eventBurst"]));
    }
    if (m.find("eventRecordQPS") != m.end() && !m["eventRecordQPS"].empty()) {
      eventRecordQPS = make_shared<long>(boost::any_cast<long>(m["eventRecordQPS"]));
    }
    if (m.find("evictionHard") != m.end() && !m["evictionHard"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["evictionHard"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      evictionHard = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("evictionSoft") != m.end() && !m["evictionSoft"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["evictionSoft"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      evictionSoft = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("evictionSoftGracePeriod") != m.end() && !m["evictionSoftGracePeriod"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["evictionSoftGracePeriod"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      evictionSoftGracePeriod = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("featureGates") != m.end() && !m["featureGates"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["featureGates"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      featureGates = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("imageGCHighThresholdPercent") != m.end() && !m["imageGCHighThresholdPercent"].empty()) {
      imageGCHighThresholdPercent = make_shared<long>(boost::any_cast<long>(m["imageGCHighThresholdPercent"]));
    }
    if (m.find("imageGCLowThresholdPercent") != m.end() && !m["imageGCLowThresholdPercent"].empty()) {
      imageGCLowThresholdPercent = make_shared<long>(boost::any_cast<long>(m["imageGCLowThresholdPercent"]));
    }
    if (m.find("kubeAPIBurst") != m.end() && !m["kubeAPIBurst"].empty()) {
      kubeAPIBurst = make_shared<long>(boost::any_cast<long>(m["kubeAPIBurst"]));
    }
    if (m.find("kubeAPIQPS") != m.end() && !m["kubeAPIQPS"].empty()) {
      kubeAPIQPS = make_shared<long>(boost::any_cast<long>(m["kubeAPIQPS"]));
    }
    if (m.find("kubeReserved") != m.end() && !m["kubeReserved"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["kubeReserved"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      kubeReserved = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("maxPods") != m.end() && !m["maxPods"].empty()) {
      maxPods = make_shared<long>(boost::any_cast<long>(m["maxPods"]));
    }
    if (m.find("memoryManagerPolicy") != m.end() && !m["memoryManagerPolicy"].empty()) {
      memoryManagerPolicy = make_shared<string>(boost::any_cast<string>(m["memoryManagerPolicy"]));
    }
    if (m.find("podPidsLimit") != m.end() && !m["podPidsLimit"].empty()) {
      podPidsLimit = make_shared<long>(boost::any_cast<long>(m["podPidsLimit"]));
    }
    if (m.find("readOnlyPort") != m.end() && !m["readOnlyPort"].empty()) {
      readOnlyPort = make_shared<long>(boost::any_cast<long>(m["readOnlyPort"]));
    }
    if (m.find("registryBurst") != m.end() && !m["registryBurst"].empty()) {
      registryBurst = make_shared<long>(boost::any_cast<long>(m["registryBurst"]));
    }
    if (m.find("registryPullQPS") != m.end() && !m["registryPullQPS"].empty()) {
      registryPullQPS = make_shared<long>(boost::any_cast<long>(m["registryPullQPS"]));
    }
    if (m.find("reservedMemory") != m.end() && !m["reservedMemory"].empty()) {
      if (typeid(vector<boost::any>) == m["reservedMemory"].type()) {
        vector<KubeletConfigReservedMemory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reservedMemory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            KubeletConfigReservedMemory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reservedMemory = make_shared<vector<KubeletConfigReservedMemory>>(expect1);
      }
    }
    if (m.find("serializeImagePulls") != m.end() && !m["serializeImagePulls"].empty()) {
      serializeImagePulls = make_shared<bool>(boost::any_cast<bool>(m["serializeImagePulls"]));
    }
    if (m.find("systemReserved") != m.end() && !m["systemReserved"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["systemReserved"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      systemReserved = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("topologyManagerPolicy") != m.end() && !m["topologyManagerPolicy"].empty()) {
      topologyManagerPolicy = make_shared<string>(boost::any_cast<string>(m["topologyManagerPolicy"]));
    }
    if (m.find("tracing") != m.end() && !m["tracing"].empty()) {
      if (typeid(map<string, boost::any>) == m["tracing"].type()) {
        KubeletConfigTracing model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tracing"]));
        tracing = make_shared<KubeletConfigTracing>(model1);
      }
    }
  }


  virtual ~KubeletConfig() = default;
};
class MaintenanceWindow : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<bool> enable{};
  shared_ptr<string> maintenanceTime{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> weeklyPeriod{};

  MaintenanceWindow() {}

  explicit MaintenanceWindow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (maintenanceTime) {
      res["maintenance_time"] = boost::any(*maintenanceTime);
    }
    if (recurrence) {
      res["recurrence"] = boost::any(*recurrence);
    }
    if (weeklyPeriod) {
      res["weekly_period"] = boost::any(*weeklyPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["duration"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("maintenance_time") != m.end() && !m["maintenance_time"].empty()) {
      maintenanceTime = make_shared<string>(boost::any_cast<string>(m["maintenance_time"]));
    }
    if (m.find("recurrence") != m.end() && !m["recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["recurrence"]));
    }
    if (m.find("weekly_period") != m.end() && !m["weekly_period"].empty()) {
      weeklyPeriod = make_shared<string>(boost::any_cast<string>(m["weekly_period"]));
    }
  }


  virtual ~MaintenanceWindow() = default;
};
class NodepoolAutoScaling : public Darabonba::Model {
public:
  shared_ptr<long> eipBandwidth{};
  shared_ptr<string> eipInternetChargeType{};
  shared_ptr<bool> enable{};
  shared_ptr<bool> isBondEip{};
  shared_ptr<long> maxInstances{};
  shared_ptr<long> minInstances{};
  shared_ptr<string> type{};

  NodepoolAutoScaling() {}

  explicit NodepoolAutoScaling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipBandwidth) {
      res["eip_bandwidth"] = boost::any(*eipBandwidth);
    }
    if (eipInternetChargeType) {
      res["eip_internet_charge_type"] = boost::any(*eipInternetChargeType);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (isBondEip) {
      res["is_bond_eip"] = boost::any(*isBondEip);
    }
    if (maxInstances) {
      res["max_instances"] = boost::any(*maxInstances);
    }
    if (minInstances) {
      res["min_instances"] = boost::any(*minInstances);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eip_bandwidth") != m.end() && !m["eip_bandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["eip_bandwidth"]));
    }
    if (m.find("eip_internet_charge_type") != m.end() && !m["eip_internet_charge_type"].empty()) {
      eipInternetChargeType = make_shared<string>(boost::any_cast<string>(m["eip_internet_charge_type"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("is_bond_eip") != m.end() && !m["is_bond_eip"].empty()) {
      isBondEip = make_shared<bool>(boost::any_cast<bool>(m["is_bond_eip"]));
    }
    if (m.find("max_instances") != m.end() && !m["max_instances"].empty()) {
      maxInstances = make_shared<long>(boost::any_cast<long>(m["max_instances"]));
    }
    if (m.find("min_instances") != m.end() && !m["min_instances"].empty()) {
      minInstances = make_shared<long>(boost::any_cast<long>(m["min_instances"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~NodepoolAutoScaling() = default;
};
class NodepoolInterconnectConfig : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> ccnId{};
  shared_ptr<string> ccnRegionId{};
  shared_ptr<string> cenId{};
  shared_ptr<string> improvedPeriod{};

  NodepoolInterconnectConfig() {}

  explicit NodepoolInterconnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["bandwidth"] = boost::any(*bandwidth);
    }
    if (ccnId) {
      res["ccn_id"] = boost::any(*ccnId);
    }
    if (ccnRegionId) {
      res["ccn_region_id"] = boost::any(*ccnRegionId);
    }
    if (cenId) {
      res["cen_id"] = boost::any(*cenId);
    }
    if (improvedPeriod) {
      res["improved_period"] = boost::any(*improvedPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bandwidth") != m.end() && !m["bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["bandwidth"]));
    }
    if (m.find("ccn_id") != m.end() && !m["ccn_id"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["ccn_id"]));
    }
    if (m.find("ccn_region_id") != m.end() && !m["ccn_region_id"].empty()) {
      ccnRegionId = make_shared<string>(boost::any_cast<string>(m["ccn_region_id"]));
    }
    if (m.find("cen_id") != m.end() && !m["cen_id"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["cen_id"]));
    }
    if (m.find("improved_period") != m.end() && !m["improved_period"].empty()) {
      improvedPeriod = make_shared<string>(boost::any_cast<string>(m["improved_period"]));
    }
  }


  virtual ~NodepoolInterconnectConfig() = default;
};
class Tag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  Tag() {}

  explicit Tag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~Tag() = default;
};
class Taint : public Darabonba::Model {
public:
  shared_ptr<string> effect{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  Taint() {}

  explicit Taint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      res["effect"] = boost::any(*effect);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("effect") != m.end() && !m["effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["effect"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~Taint() = default;
};
class NodepoolKubernetesConfig : public Darabonba::Model {
public:
  shared_ptr<bool> cmsEnabled{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<vector<Tag>> labels{};
  shared_ptr<string> nodeNameMode{};
  shared_ptr<string> runtime{};
  shared_ptr<string> runtimeVersion{};
  shared_ptr<vector<Taint>> taints{};
  shared_ptr<string> userData{};

  NodepoolKubernetesConfig() {}

  explicit NodepoolKubernetesConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cmsEnabled) {
      res["cms_enabled"] = boost::any(*cmsEnabled);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["labels"] = boost::any(temp1);
    }
    if (nodeNameMode) {
      res["node_name_mode"] = boost::any(*nodeNameMode);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (runtimeVersion) {
      res["runtime_version"] = boost::any(*runtimeVersion);
    }
    if (taints) {
      vector<boost::any> temp1;
      for(auto item1:*taints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["taints"] = boost::any(temp1);
    }
    if (userData) {
      res["user_data"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cms_enabled") != m.end() && !m["cms_enabled"].empty()) {
      cmsEnabled = make_shared<bool>(boost::any_cast<bool>(m["cms_enabled"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("labels") != m.end() && !m["labels"].empty()) {
      if (typeid(vector<boost::any>) == m["labels"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("node_name_mode") != m.end() && !m["node_name_mode"].empty()) {
      nodeNameMode = make_shared<string>(boost::any_cast<string>(m["node_name_mode"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("runtime_version") != m.end() && !m["runtime_version"].empty()) {
      runtimeVersion = make_shared<string>(boost::any_cast<string>(m["runtime_version"]));
    }
    if (m.find("taints") != m.end() && !m["taints"].empty()) {
      if (typeid(vector<boost::any>) == m["taints"].type()) {
        vector<Taint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["taints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Taint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taints = make_shared<vector<Taint>>(expect1);
      }
    }
    if (m.find("user_data") != m.end() && !m["user_data"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["user_data"]));
    }
  }


  virtual ~NodepoolKubernetesConfig() = default;
};
class NodepoolManagementAutoRepairPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> restartNode{};

  NodepoolManagementAutoRepairPolicy() {}

  explicit NodepoolManagementAutoRepairPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (restartNode) {
      res["restart_node"] = boost::any(*restartNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("restart_node") != m.end() && !m["restart_node"].empty()) {
      restartNode = make_shared<bool>(boost::any_cast<bool>(m["restart_node"]));
    }
  }


  virtual ~NodepoolManagementAutoRepairPolicy() = default;
};
class NodepoolManagementAutoUpgradePolicy : public Darabonba::Model {
public:
  shared_ptr<bool> autoUpgradeKubelet{};

  NodepoolManagementAutoUpgradePolicy() {}

  explicit NodepoolManagementAutoUpgradePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpgradeKubelet) {
      res["auto_upgrade_kubelet"] = boost::any(*autoUpgradeKubelet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_upgrade_kubelet") != m.end() && !m["auto_upgrade_kubelet"].empty()) {
      autoUpgradeKubelet = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade_kubelet"]));
    }
  }


  virtual ~NodepoolManagementAutoUpgradePolicy() = default;
};
class NodepoolManagementAutoVulFixPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> restartNode{};
  shared_ptr<string> vulLevel{};

  NodepoolManagementAutoVulFixPolicy() {}

  explicit NodepoolManagementAutoVulFixPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (restartNode) {
      res["restart_node"] = boost::any(*restartNode);
    }
    if (vulLevel) {
      res["vul_level"] = boost::any(*vulLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("restart_node") != m.end() && !m["restart_node"].empty()) {
      restartNode = make_shared<bool>(boost::any_cast<bool>(m["restart_node"]));
    }
    if (m.find("vul_level") != m.end() && !m["vul_level"].empty()) {
      vulLevel = make_shared<string>(boost::any_cast<string>(m["vul_level"]));
    }
  }


  virtual ~NodepoolManagementAutoVulFixPolicy() = default;
};
class NodepoolManagementUpgradeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoUpgrade{};
  shared_ptr<long> maxUnavailable{};
  shared_ptr<long> surge{};
  shared_ptr<long> surgePercentage{};

  NodepoolManagementUpgradeConfig() {}

  explicit NodepoolManagementUpgradeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpgrade) {
      res["auto_upgrade"] = boost::any(*autoUpgrade);
    }
    if (maxUnavailable) {
      res["max_unavailable"] = boost::any(*maxUnavailable);
    }
    if (surge) {
      res["surge"] = boost::any(*surge);
    }
    if (surgePercentage) {
      res["surge_percentage"] = boost::any(*surgePercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_upgrade") != m.end() && !m["auto_upgrade"].empty()) {
      autoUpgrade = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade"]));
    }
    if (m.find("max_unavailable") != m.end() && !m["max_unavailable"].empty()) {
      maxUnavailable = make_shared<long>(boost::any_cast<long>(m["max_unavailable"]));
    }
    if (m.find("surge") != m.end() && !m["surge"].empty()) {
      surge = make_shared<long>(boost::any_cast<long>(m["surge"]));
    }
    if (m.find("surge_percentage") != m.end() && !m["surge_percentage"].empty()) {
      surgePercentage = make_shared<long>(boost::any_cast<long>(m["surge_percentage"]));
    }
  }


  virtual ~NodepoolManagementUpgradeConfig() = default;
};
class NodepoolManagement : public Darabonba::Model {
public:
  shared_ptr<bool> autoRepair{};
  shared_ptr<NodepoolManagementAutoRepairPolicy> autoRepairPolicy{};
  shared_ptr<bool> autoUpgrade{};
  shared_ptr<NodepoolManagementAutoUpgradePolicy> autoUpgradePolicy{};
  shared_ptr<bool> autoVulFix{};
  shared_ptr<NodepoolManagementAutoVulFixPolicy> autoVulFixPolicy{};
  shared_ptr<bool> enable{};
  shared_ptr<NodepoolManagementUpgradeConfig> upgradeConfig{};

  NodepoolManagement() {}

  explicit NodepoolManagement(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRepair) {
      res["auto_repair"] = boost::any(*autoRepair);
    }
    if (autoRepairPolicy) {
      res["auto_repair_policy"] = autoRepairPolicy ? boost::any(autoRepairPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoUpgrade) {
      res["auto_upgrade"] = boost::any(*autoUpgrade);
    }
    if (autoUpgradePolicy) {
      res["auto_upgrade_policy"] = autoUpgradePolicy ? boost::any(autoUpgradePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoVulFix) {
      res["auto_vul_fix"] = boost::any(*autoVulFix);
    }
    if (autoVulFixPolicy) {
      res["auto_vul_fix_policy"] = autoVulFixPolicy ? boost::any(autoVulFixPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (upgradeConfig) {
      res["upgrade_config"] = upgradeConfig ? boost::any(upgradeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_repair") != m.end() && !m["auto_repair"].empty()) {
      autoRepair = make_shared<bool>(boost::any_cast<bool>(m["auto_repair"]));
    }
    if (m.find("auto_repair_policy") != m.end() && !m["auto_repair_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_repair_policy"].type()) {
        NodepoolManagementAutoRepairPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_repair_policy"]));
        autoRepairPolicy = make_shared<NodepoolManagementAutoRepairPolicy>(model1);
      }
    }
    if (m.find("auto_upgrade") != m.end() && !m["auto_upgrade"].empty()) {
      autoUpgrade = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade"]));
    }
    if (m.find("auto_upgrade_policy") != m.end() && !m["auto_upgrade_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_upgrade_policy"].type()) {
        NodepoolManagementAutoUpgradePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_upgrade_policy"]));
        autoUpgradePolicy = make_shared<NodepoolManagementAutoUpgradePolicy>(model1);
      }
    }
    if (m.find("auto_vul_fix") != m.end() && !m["auto_vul_fix"].empty()) {
      autoVulFix = make_shared<bool>(boost::any_cast<bool>(m["auto_vul_fix"]));
    }
    if (m.find("auto_vul_fix_policy") != m.end() && !m["auto_vul_fix_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_vul_fix_policy"].type()) {
        NodepoolManagementAutoVulFixPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_vul_fix_policy"]));
        autoVulFixPolicy = make_shared<NodepoolManagementAutoVulFixPolicy>(model1);
      }
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("upgrade_config") != m.end() && !m["upgrade_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_config"].type()) {
        NodepoolManagementUpgradeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_config"]));
        upgradeConfig = make_shared<NodepoolManagementUpgradeConfig>(model1);
      }
    }
  }


  virtual ~NodepoolManagement() = default;
};
class NodepoolNodeConfig : public Darabonba::Model {
public:
  shared_ptr<KubeletConfig> kubeletConfiguration{};

  NodepoolNodeConfig() {}

  explicit NodepoolNodeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kubeletConfiguration) {
      res["kubelet_configuration"] = kubeletConfiguration ? boost::any(kubeletConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("kubelet_configuration") != m.end() && !m["kubelet_configuration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kubelet_configuration"].type()) {
        KubeletConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kubelet_configuration"]));
        kubeletConfiguration = make_shared<KubeletConfig>(model1);
      }
    }
  }


  virtual ~NodepoolNodeConfig() = default;
};
class NodepoolNodepoolInfo : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> type{};

  NodepoolNodepoolInfo() {}

  explicit NodepoolNodepoolInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~NodepoolNodepoolInfo() = default;
};
class NodepoolScalingGroupPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  NodepoolScalingGroupPrivatePoolOptions() {}

  explicit NodepoolScalingGroupPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["match_criteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("match_criteria") != m.end() && !m["match_criteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["match_criteria"]));
    }
  }


  virtual ~NodepoolScalingGroupPrivatePoolOptions() = default;
};
class NodepoolScalingGroupSpotPriceLimit : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> priceLimit{};

  NodepoolScalingGroupSpotPriceLimit() {}

  explicit NodepoolScalingGroupSpotPriceLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["instance_type"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["price_limit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instance_type") != m.end() && !m["instance_type"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instance_type"]));
    }
    if (m.find("price_limit") != m.end() && !m["price_limit"].empty()) {
      priceLimit = make_shared<string>(boost::any_cast<string>(m["price_limit"]));
    }
  }


  virtual ~NodepoolScalingGroupSpotPriceLimit() = default;
};
class NodepoolScalingGroupTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  NodepoolScalingGroupTags() {}

  explicit NodepoolScalingGroupTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~NodepoolScalingGroupTags() = default;
};
class NodepoolScalingGroup : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<vector<DataDisk>> dataDisks{};
  shared_ptr<string> deploymentsetId{};
  shared_ptr<long> desiredSize{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<InstanceMetadataOptions> instanceMetadataOptions{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> keyPair{};
  shared_ptr<bool> loginAsNonRoot{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> multiAzPolicy{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> platform{};
  shared_ptr<NodepoolScalingGroupPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<vector<string>> rdsInstances{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<vector<NodepoolScalingGroupSpotPriceLimit>> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<bool> systemDiskBurstingEnabled{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskEncryptAlgorithm{};
  shared_ptr<bool> systemDiskEncrypted{};
  shared_ptr<string> systemDiskKmsKeyId{};
  shared_ptr<string> systemDiskPerformanceLevel{};
  shared_ptr<long> systemDiskProvisionedIops{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<vector<NodepoolScalingGroupTags>> tags{};
  shared_ptr<vector<string>> vswitchIds{};

  NodepoolScalingGroup() {}

  explicit NodepoolScalingGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["auto_renew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["auto_renew_period"] = boost::any(*autoRenewPeriod);
    }
    if (compensateWithOnDemand) {
      res["compensate_with_on_demand"] = boost::any(*compensateWithOnDemand);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_disks"] = boost::any(temp1);
    }
    if (deploymentsetId) {
      res["deploymentset_id"] = boost::any(*deploymentsetId);
    }
    if (desiredSize) {
      res["desired_size"] = boost::any(*desiredSize);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (imageType) {
      res["image_type"] = boost::any(*imageType);
    }
    if (instanceChargeType) {
      res["instance_charge_type"] = boost::any(*instanceChargeType);
    }
    if (instanceMetadataOptions) {
      res["instance_metadata_options"] = instanceMetadataOptions ? boost::any(instanceMetadataOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTypes) {
      res["instance_types"] = boost::any(*instanceTypes);
    }
    if (internetChargeType) {
      res["internet_charge_type"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["internet_max_bandwidth_out"] = boost::any(*internetMaxBandwidthOut);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (loginAsNonRoot) {
      res["login_as_non_root"] = boost::any(*loginAsNonRoot);
    }
    if (loginPassword) {
      res["login_password"] = boost::any(*loginPassword);
    }
    if (multiAzPolicy) {
      res["multi_az_policy"] = boost::any(*multiAzPolicy);
    }
    if (onDemandBaseCapacity) {
      res["on_demand_base_capacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["on_demand_percentage_above_base_capacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["period_unit"] = boost::any(*periodUnit);
    }
    if (platform) {
      res["platform"] = boost::any(*platform);
    }
    if (privatePoolOptions) {
      res["private_pool_options"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ramRoleName) {
      res["ram_role_name"] = boost::any(*ramRoleName);
    }
    if (rdsInstances) {
      res["rds_instances"] = boost::any(*rdsInstances);
    }
    if (scalingPolicy) {
      res["scaling_policy"] = boost::any(*scalingPolicy);
    }
    if (securityGroupId) {
      res["security_group_id"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["security_group_ids"] = boost::any(*securityGroupIds);
    }
    if (spotInstancePools) {
      res["spot_instance_pools"] = boost::any(*spotInstancePools);
    }
    if (spotInstanceRemedy) {
      res["spot_instance_remedy"] = boost::any(*spotInstanceRemedy);
    }
    if (spotPriceLimit) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["spot_price_limit"] = boost::any(temp1);
    }
    if (spotStrategy) {
      res["spot_strategy"] = boost::any(*spotStrategy);
    }
    if (systemDiskBurstingEnabled) {
      res["system_disk_bursting_enabled"] = boost::any(*systemDiskBurstingEnabled);
    }
    if (systemDiskCategories) {
      res["system_disk_categories"] = boost::any(*systemDiskCategories);
    }
    if (systemDiskCategory) {
      res["system_disk_category"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskEncryptAlgorithm) {
      res["system_disk_encrypt_algorithm"] = boost::any(*systemDiskEncryptAlgorithm);
    }
    if (systemDiskEncrypted) {
      res["system_disk_encrypted"] = boost::any(*systemDiskEncrypted);
    }
    if (systemDiskKmsKeyId) {
      res["system_disk_kms_key_id"] = boost::any(*systemDiskKmsKeyId);
    }
    if (systemDiskPerformanceLevel) {
      res["system_disk_performance_level"] = boost::any(*systemDiskPerformanceLevel);
    }
    if (systemDiskProvisionedIops) {
      res["system_disk_provisioned_iops"] = boost::any(*systemDiskProvisionedIops);
    }
    if (systemDiskSize) {
      res["system_disk_size"] = boost::any(*systemDiskSize);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_renew") != m.end() && !m["auto_renew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["auto_renew"]));
    }
    if (m.find("auto_renew_period") != m.end() && !m["auto_renew_period"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["auto_renew_period"]));
    }
    if (m.find("compensate_with_on_demand") != m.end() && !m["compensate_with_on_demand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["compensate_with_on_demand"]));
    }
    if (m.find("data_disks") != m.end() && !m["data_disks"].empty()) {
      if (typeid(vector<boost::any>) == m["data_disks"].type()) {
        vector<DataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DataDisk>>(expect1);
      }
    }
    if (m.find("deploymentset_id") != m.end() && !m["deploymentset_id"].empty()) {
      deploymentsetId = make_shared<string>(boost::any_cast<string>(m["deploymentset_id"]));
    }
    if (m.find("desired_size") != m.end() && !m["desired_size"].empty()) {
      desiredSize = make_shared<long>(boost::any_cast<long>(m["desired_size"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("image_type") != m.end() && !m["image_type"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["image_type"]));
    }
    if (m.find("instance_charge_type") != m.end() && !m["instance_charge_type"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["instance_charge_type"]));
    }
    if (m.find("instance_metadata_options") != m.end() && !m["instance_metadata_options"].empty()) {
      if (typeid(map<string, boost::any>) == m["instance_metadata_options"].type()) {
        InstanceMetadataOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["instance_metadata_options"]));
        instanceMetadataOptions = make_shared<InstanceMetadataOptions>(model1);
      }
    }
    if (m.find("instance_types") != m.end() && !m["instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("internet_charge_type") != m.end() && !m["internet_charge_type"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["internet_charge_type"]));
    }
    if (m.find("internet_max_bandwidth_out") != m.end() && !m["internet_max_bandwidth_out"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["internet_max_bandwidth_out"]));
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("login_as_non_root") != m.end() && !m["login_as_non_root"].empty()) {
      loginAsNonRoot = make_shared<bool>(boost::any_cast<bool>(m["login_as_non_root"]));
    }
    if (m.find("login_password") != m.end() && !m["login_password"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["login_password"]));
    }
    if (m.find("multi_az_policy") != m.end() && !m["multi_az_policy"].empty()) {
      multiAzPolicy = make_shared<string>(boost::any_cast<string>(m["multi_az_policy"]));
    }
    if (m.find("on_demand_base_capacity") != m.end() && !m["on_demand_base_capacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["on_demand_base_capacity"]));
    }
    if (m.find("on_demand_percentage_above_base_capacity") != m.end() && !m["on_demand_percentage_above_base_capacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["on_demand_percentage_above_base_capacity"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("period_unit") != m.end() && !m["period_unit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["period_unit"]));
    }
    if (m.find("platform") != m.end() && !m["platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["platform"]));
    }
    if (m.find("private_pool_options") != m.end() && !m["private_pool_options"].empty()) {
      if (typeid(map<string, boost::any>) == m["private_pool_options"].type()) {
        NodepoolScalingGroupPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["private_pool_options"]));
        privatePoolOptions = make_shared<NodepoolScalingGroupPrivatePoolOptions>(model1);
      }
    }
    if (m.find("ram_role_name") != m.end() && !m["ram_role_name"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["ram_role_name"]));
    }
    if (m.find("rds_instances") != m.end() && !m["rds_instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["rds_instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["rds_instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rdsInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("scaling_policy") != m.end() && !m["scaling_policy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["scaling_policy"]));
    }
    if (m.find("security_group_id") != m.end() && !m["security_group_id"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["security_group_id"]));
    }
    if (m.find("security_group_ids") != m.end() && !m["security_group_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["security_group_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["security_group_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("spot_instance_pools") != m.end() && !m["spot_instance_pools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["spot_instance_pools"]));
    }
    if (m.find("spot_instance_remedy") != m.end() && !m["spot_instance_remedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["spot_instance_remedy"]));
    }
    if (m.find("spot_price_limit") != m.end() && !m["spot_price_limit"].empty()) {
      if (typeid(vector<boost::any>) == m["spot_price_limit"].type()) {
        vector<NodepoolScalingGroupSpotPriceLimit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["spot_price_limit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            NodepoolScalingGroupSpotPriceLimit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimit = make_shared<vector<NodepoolScalingGroupSpotPriceLimit>>(expect1);
      }
    }
    if (m.find("spot_strategy") != m.end() && !m["spot_strategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["spot_strategy"]));
    }
    if (m.find("system_disk_bursting_enabled") != m.end() && !m["system_disk_bursting_enabled"].empty()) {
      systemDiskBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["system_disk_bursting_enabled"]));
    }
    if (m.find("system_disk_categories") != m.end() && !m["system_disk_categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["system_disk_categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["system_disk_categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("system_disk_category") != m.end() && !m["system_disk_category"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["system_disk_category"]));
    }
    if (m.find("system_disk_encrypt_algorithm") != m.end() && !m["system_disk_encrypt_algorithm"].empty()) {
      systemDiskEncryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["system_disk_encrypt_algorithm"]));
    }
    if (m.find("system_disk_encrypted") != m.end() && !m["system_disk_encrypted"].empty()) {
      systemDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["system_disk_encrypted"]));
    }
    if (m.find("system_disk_kms_key_id") != m.end() && !m["system_disk_kms_key_id"].empty()) {
      systemDiskKmsKeyId = make_shared<string>(boost::any_cast<string>(m["system_disk_kms_key_id"]));
    }
    if (m.find("system_disk_performance_level") != m.end() && !m["system_disk_performance_level"].empty()) {
      systemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["system_disk_performance_level"]));
    }
    if (m.find("system_disk_provisioned_iops") != m.end() && !m["system_disk_provisioned_iops"].empty()) {
      systemDiskProvisionedIops = make_shared<long>(boost::any_cast<long>(m["system_disk_provisioned_iops"]));
    }
    if (m.find("system_disk_size") != m.end() && !m["system_disk_size"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["system_disk_size"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<NodepoolScalingGroupTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            NodepoolScalingGroupTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<NodepoolScalingGroupTags>>(expect1);
      }
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~NodepoolScalingGroup() = default;
};
class NodepoolTeeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> teeEnable{};

  NodepoolTeeConfig() {}

  explicit NodepoolTeeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (teeEnable) {
      res["tee_enable"] = boost::any(*teeEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tee_enable") != m.end() && !m["tee_enable"].empty()) {
      teeEnable = make_shared<bool>(boost::any_cast<bool>(m["tee_enable"]));
    }
  }


  virtual ~NodepoolTeeConfig() = default;
};
class Nodepool : public Darabonba::Model {
public:
  shared_ptr<NodepoolAutoScaling> autoScaling{};
  shared_ptr<long> count{};
  shared_ptr<NodepoolInterconnectConfig> interconnectConfig{};
  shared_ptr<string> interconnectMode{};
  shared_ptr<NodepoolKubernetesConfig> kubernetesConfig{};
  shared_ptr<NodepoolManagement> management{};
  shared_ptr<long> maxNodes{};
  shared_ptr<NodepoolNodeConfig> nodeConfig{};
  shared_ptr<NodepoolNodepoolInfo> nodepoolInfo{};
  shared_ptr<NodepoolScalingGroup> scalingGroup{};
  shared_ptr<NodepoolTeeConfig> teeConfig{};

  Nodepool() {}

  explicit Nodepool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoScaling) {
      res["auto_scaling"] = autoScaling ? boost::any(autoScaling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (interconnectConfig) {
      res["interconnect_config"] = interconnectConfig ? boost::any(interconnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interconnectMode) {
      res["interconnect_mode"] = boost::any(*interconnectMode);
    }
    if (kubernetesConfig) {
      res["kubernetes_config"] = kubernetesConfig ? boost::any(kubernetesConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (management) {
      res["management"] = management ? boost::any(management->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxNodes) {
      res["max_nodes"] = boost::any(*maxNodes);
    }
    if (nodeConfig) {
      res["node_config"] = nodeConfig ? boost::any(nodeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodepoolInfo) {
      res["nodepool_info"] = nodepoolInfo ? boost::any(nodepoolInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scalingGroup) {
      res["scaling_group"] = scalingGroup ? boost::any(scalingGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (teeConfig) {
      res["tee_config"] = teeConfig ? boost::any(teeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_scaling") != m.end() && !m["auto_scaling"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_scaling"].type()) {
        NodepoolAutoScaling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_scaling"]));
        autoScaling = make_shared<NodepoolAutoScaling>(model1);
      }
    }
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("interconnect_config") != m.end() && !m["interconnect_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["interconnect_config"].type()) {
        NodepoolInterconnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["interconnect_config"]));
        interconnectConfig = make_shared<NodepoolInterconnectConfig>(model1);
      }
    }
    if (m.find("interconnect_mode") != m.end() && !m["interconnect_mode"].empty()) {
      interconnectMode = make_shared<string>(boost::any_cast<string>(m["interconnect_mode"]));
    }
    if (m.find("kubernetes_config") != m.end() && !m["kubernetes_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["kubernetes_config"].type()) {
        NodepoolKubernetesConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kubernetes_config"]));
        kubernetesConfig = make_shared<NodepoolKubernetesConfig>(model1);
      }
    }
    if (m.find("management") != m.end() && !m["management"].empty()) {
      if (typeid(map<string, boost::any>) == m["management"].type()) {
        NodepoolManagement model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["management"]));
        management = make_shared<NodepoolManagement>(model1);
      }
    }
    if (m.find("max_nodes") != m.end() && !m["max_nodes"].empty()) {
      maxNodes = make_shared<long>(boost::any_cast<long>(m["max_nodes"]));
    }
    if (m.find("node_config") != m.end() && !m["node_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["node_config"].type()) {
        NodepoolNodeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["node_config"]));
        nodeConfig = make_shared<NodepoolNodeConfig>(model1);
      }
    }
    if (m.find("nodepool_info") != m.end() && !m["nodepool_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodepool_info"].type()) {
        NodepoolNodepoolInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodepool_info"]));
        nodepoolInfo = make_shared<NodepoolNodepoolInfo>(model1);
      }
    }
    if (m.find("scaling_group") != m.end() && !m["scaling_group"].empty()) {
      if (typeid(map<string, boost::any>) == m["scaling_group"].type()) {
        NodepoolScalingGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["scaling_group"]));
        scalingGroup = make_shared<NodepoolScalingGroup>(model1);
      }
    }
    if (m.find("tee_config") != m.end() && !m["tee_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["tee_config"].type()) {
        NodepoolTeeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tee_config"]));
        teeConfig = make_shared<NodepoolTeeConfig>(model1);
      }
    }
  }


  virtual ~Nodepool() = default;
};
class Runtime : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> version{};

  Runtime() {}

  explicit Runtime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~Runtime() = default;
};
class StandardComponentsValue : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> version{};
  shared_ptr<string> description{};
  shared_ptr<string> required{};
  shared_ptr<bool> disabled{};

  StandardComponentsValue() {}

  explicit StandardComponentsValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (required) {
      res["required"] = boost::any(*required);
    }
    if (disabled) {
      res["disabled"] = boost::any(*disabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("required") != m.end() && !m["required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["required"]));
    }
    if (m.find("disabled") != m.end() && !m["disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["disabled"]));
    }
  }


  virtual ~StandardComponentsValue() = default;
};
class QuotasValue : public Darabonba::Model {
public:
  shared_ptr<string> quota{};
  shared_ptr<string> operationCode{};
  shared_ptr<bool> adjustable{};
  shared_ptr<string> unit{};

  QuotasValue() {}

  explicit QuotasValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quota) {
      res["quota"] = boost::any(*quota);
    }
    if (operationCode) {
      res["operation_code"] = boost::any(*operationCode);
    }
    if (adjustable) {
      res["adjustable"] = boost::any(*adjustable);
    }
    if (unit) {
      res["unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("quota") != m.end() && !m["quota"].empty()) {
      quota = make_shared<string>(boost::any_cast<string>(m["quota"]));
    }
    if (m.find("operation_code") != m.end() && !m["operation_code"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["operation_code"]));
    }
    if (m.find("adjustable") != m.end() && !m["adjustable"].empty()) {
      adjustable = make_shared<bool>(boost::any_cast<bool>(m["adjustable"]));
    }
    if (m.find("unit") != m.end() && !m["unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["unit"]));
    }
  }


  virtual ~QuotasValue() = default;
};
class AttachInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> cpuPolicy{};
  shared_ptr<bool> formatDisk{};
  shared_ptr<string> imageId{};
  shared_ptr<vector<string>> instances{};
  shared_ptr<bool> isEdgeWorker{};
  shared_ptr<bool> keepInstanceName{};
  shared_ptr<string> keyPair{};
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> password{};
  shared_ptr<vector<string>> rdsInstances{};
  shared_ptr<Runtime> runtime{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<string> userData{};

  AttachInstancesRequest() {}

  explicit AttachInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (formatDisk) {
      res["format_disk"] = boost::any(*formatDisk);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (instances) {
      res["instances"] = boost::any(*instances);
    }
    if (isEdgeWorker) {
      res["is_edge_worker"] = boost::any(*isEdgeWorker);
    }
    if (keepInstanceName) {
      res["keep_instance_name"] = boost::any(*keepInstanceName);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    if (rdsInstances) {
      res["rds_instances"] = boost::any(*rdsInstances);
    }
    if (runtime) {
      res["runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (userData) {
      res["user_data"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("format_disk") != m.end() && !m["format_disk"].empty()) {
      formatDisk = make_shared<bool>(boost::any_cast<bool>(m["format_disk"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("instances") != m.end() && !m["instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("is_edge_worker") != m.end() && !m["is_edge_worker"].empty()) {
      isEdgeWorker = make_shared<bool>(boost::any_cast<bool>(m["is_edge_worker"]));
    }
    if (m.find("keep_instance_name") != m.end() && !m["keep_instance_name"].empty()) {
      keepInstanceName = make_shared<bool>(boost::any_cast<bool>(m["keep_instance_name"]));
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
    if (m.find("rds_instances") != m.end() && !m["rds_instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["rds_instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["rds_instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rdsInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["runtime"].type()) {
        Runtime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["runtime"]));
        runtime = make_shared<Runtime>(model1);
      }
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("user_data") != m.end() && !m["user_data"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["user_data"]));
    }
  }


  virtual ~AttachInstancesRequest() = default;
};
class AttachInstancesResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> message{};

  AttachInstancesResponseBodyList() {}

  explicit AttachInstancesResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~AttachInstancesResponseBodyList() = default;
};
class AttachInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<AttachInstancesResponseBodyList>> list{};
  shared_ptr<string> taskId{};

  AttachInstancesResponseBody() {}

  explicit AttachInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["list"] = boost::any(temp1);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("list") != m.end() && !m["list"].empty()) {
      if (typeid(vector<boost::any>) == m["list"].type()) {
        vector<AttachInstancesResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachInstancesResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<AttachInstancesResponseBodyList>>(expect1);
      }
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~AttachInstancesResponseBody() = default;
};
class AttachInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachInstancesResponseBody> body{};

  AttachInstancesResponse() {}

  explicit AttachInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~AttachInstancesResponse() = default;
};
class AttachInstancesToNodePoolRequest : public Darabonba::Model {
public:
  shared_ptr<bool> formatDisk{};
  shared_ptr<vector<string>> instances{};
  shared_ptr<bool> keepInstanceName{};
  shared_ptr<string> password{};

  AttachInstancesToNodePoolRequest() {}

  explicit AttachInstancesToNodePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formatDisk) {
      res["format_disk"] = boost::any(*formatDisk);
    }
    if (instances) {
      res["instances"] = boost::any(*instances);
    }
    if (keepInstanceName) {
      res["keep_instance_name"] = boost::any(*keepInstanceName);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("format_disk") != m.end() && !m["format_disk"].empty()) {
      formatDisk = make_shared<bool>(boost::any_cast<bool>(m["format_disk"]));
    }
    if (m.find("instances") != m.end() && !m["instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("keep_instance_name") != m.end() && !m["keep_instance_name"].empty()) {
      keepInstanceName = make_shared<bool>(boost::any_cast<bool>(m["keep_instance_name"]));
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
  }


  virtual ~AttachInstancesToNodePoolRequest() = default;
};
class AttachInstancesToNodePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  AttachInstancesToNodePoolResponseBody() {}

  explicit AttachInstancesToNodePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~AttachInstancesToNodePoolResponseBody() = default;
};
class AttachInstancesToNodePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachInstancesToNodePoolResponseBody> body{};

  AttachInstancesToNodePoolResponse() {}

  explicit AttachInstancesToNodePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachInstancesToNodePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachInstancesToNodePoolResponseBody>(model1);
      }
    }
  }


  virtual ~AttachInstancesToNodePoolResponse() = default;
};
class CancelClusterUpgradeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  CancelClusterUpgradeResponse() {}

  explicit CancelClusterUpgradeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~CancelClusterUpgradeResponse() = default;
};
class CancelComponentUpgradeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  CancelComponentUpgradeResponse() {}

  explicit CancelComponentUpgradeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~CancelComponentUpgradeResponse() = default;
};
class CancelOperationPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelOperationPlanResponseBody() {}

  explicit CancelOperationPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
  }


  virtual ~CancelOperationPlanResponseBody() = default;
};
class CancelOperationPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelOperationPlanResponseBody> body{};

  CancelOperationPlanResponse() {}

  explicit CancelOperationPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOperationPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOperationPlanResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOperationPlanResponse() = default;
};
class CancelTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  CancelTaskResponse() {}

  explicit CancelTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~CancelTaskResponse() = default;
};
class CheckControlPlaneLogEnableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aliuid{};
  shared_ptr<vector<string>> components{};
  shared_ptr<string> logProject{};
  shared_ptr<string> logTtl{};

  CheckControlPlaneLogEnableResponseBody() {}

  explicit CheckControlPlaneLogEnableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliuid) {
      res["aliuid"] = boost::any(*aliuid);
    }
    if (components) {
      res["components"] = boost::any(*components);
    }
    if (logProject) {
      res["log_project"] = boost::any(*logProject);
    }
    if (logTtl) {
      res["log_ttl"] = boost::any(*logTtl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliuid") != m.end() && !m["aliuid"].empty()) {
      aliuid = make_shared<string>(boost::any_cast<string>(m["aliuid"]));
    }
    if (m.find("components") != m.end() && !m["components"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["components"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["components"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      components = make_shared<vector<string>>(toVec1);
    }
    if (m.find("log_project") != m.end() && !m["log_project"].empty()) {
      logProject = make_shared<string>(boost::any_cast<string>(m["log_project"]));
    }
    if (m.find("log_ttl") != m.end() && !m["log_ttl"].empty()) {
      logTtl = make_shared<string>(boost::any_cast<string>(m["log_ttl"]));
    }
  }


  virtual ~CheckControlPlaneLogEnableResponseBody() = default;
};
class CheckControlPlaneLogEnableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckControlPlaneLogEnableResponseBody> body{};

  CheckControlPlaneLogEnableResponse() {}

  explicit CheckControlPlaneLogEnableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckControlPlaneLogEnableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckControlPlaneLogEnableResponseBody>(model1);
      }
    }
  }


  virtual ~CheckControlPlaneLogEnableResponse() = default;
};
class CheckServiceRoleRequestRoles : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  CheckServiceRoleRequestRoles() {}

  explicit CheckServiceRoleRequestRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CheckServiceRoleRequestRoles() = default;
};
class CheckServiceRoleRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CheckServiceRoleRequestRoles>> roles{};

  CheckServiceRoleRequest() {}

  explicit CheckServiceRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roles) {
      vector<boost::any> temp1;
      for(auto item1:*roles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["roles"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("roles") != m.end() && !m["roles"].empty()) {
      if (typeid(vector<boost::any>) == m["roles"].type()) {
        vector<CheckServiceRoleRequestRoles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["roles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CheckServiceRoleRequestRoles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roles = make_shared<vector<CheckServiceRoleRequestRoles>>(expect1);
      }
    }
  }


  virtual ~CheckServiceRoleRequest() = default;
};
class CheckServiceRoleResponseBodyRoles : public Darabonba::Model {
public:
  shared_ptr<bool> granted{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};

  CheckServiceRoleResponseBodyRoles() {}

  explicit CheckServiceRoleResponseBodyRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (granted) {
      res["granted"] = boost::any(*granted);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("granted") != m.end() && !m["granted"].empty()) {
      granted = make_shared<bool>(boost::any_cast<bool>(m["granted"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CheckServiceRoleResponseBodyRoles() = default;
};
class CheckServiceRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CheckServiceRoleResponseBodyRoles>> roles{};

  CheckServiceRoleResponseBody() {}

  explicit CheckServiceRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roles) {
      vector<boost::any> temp1;
      for(auto item1:*roles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["roles"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("roles") != m.end() && !m["roles"].empty()) {
      if (typeid(vector<boost::any>) == m["roles"].type()) {
        vector<CheckServiceRoleResponseBodyRoles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["roles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CheckServiceRoleResponseBodyRoles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roles = make_shared<vector<CheckServiceRoleResponseBodyRoles>>(expect1);
      }
    }
  }


  virtual ~CheckServiceRoleResponseBody() = default;
};
class CheckServiceRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckServiceRoleResponseBody> body{};

  CheckServiceRoleResponse() {}

  explicit CheckServiceRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckServiceRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckServiceRoleResponseBody>(model1);
      }
    }
  }


  virtual ~CheckServiceRoleResponse() = default;
};
class CleanClusterUserPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> force{};

  CleanClusterUserPermissionsRequest() {}

  explicit CleanClusterUserPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["Force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
  }


  virtual ~CleanClusterUserPermissionsRequest() = default;
};
class CleanClusterUserPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  CleanClusterUserPermissionsResponse() {}

  explicit CleanClusterUserPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~CleanClusterUserPermissionsResponse() = default;
};
class CleanUserPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> clusterIds{};
  shared_ptr<bool> force{};

  CleanUserPermissionsRequest() {}

  explicit CleanUserPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
  }


  virtual ~CleanUserPermissionsRequest() = default;
};
class CleanUserPermissionsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterIdsShrink{};
  shared_ptr<bool> force{};

  CleanUserPermissionsShrinkRequest() {}

  explicit CleanUserPermissionsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIdsShrink) {
      res["ClusterIds"] = boost::any(*clusterIdsShrink);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      clusterIdsShrink = make_shared<string>(boost::any_cast<string>(m["ClusterIds"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
  }


  virtual ~CleanUserPermissionsShrinkRequest() = default;
};
class CleanUserPermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CleanUserPermissionsResponseBody() {}

  explicit CleanUserPermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~CleanUserPermissionsResponseBody() = default;
};
class CleanUserPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CleanUserPermissionsResponseBody> body{};

  CleanUserPermissionsResponse() {}

  explicit CleanUserPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CleanUserPermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CleanUserPermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~CleanUserPermissionsResponse() = default;
};
class CreateAutoscalingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> coolDownDuration{};
  shared_ptr<bool> daemonsetEvictionForNodes{};
  shared_ptr<string> expander{};
  shared_ptr<string> gpuUtilizationThreshold{};
  shared_ptr<long> maxGracefulTerminationSec{};
  shared_ptr<long> minReplicaCount{};
  shared_ptr<map<string, vector<string>>> priorities{};
  shared_ptr<bool> recycleNodeDeletionEnabled{};
  shared_ptr<bool> scaleDownEnabled{};
  shared_ptr<bool> scaleUpFromZero{};
  shared_ptr<string> scalerType{};
  shared_ptr<string> scanInterval{};
  shared_ptr<bool> skipNodesWithLocalStorage{};
  shared_ptr<bool> skipNodesWithSystemPods{};
  shared_ptr<string> unneededDuration{};
  shared_ptr<string> utilizationThreshold{};

  CreateAutoscalingConfigRequest() {}

  explicit CreateAutoscalingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coolDownDuration) {
      res["cool_down_duration"] = boost::any(*coolDownDuration);
    }
    if (daemonsetEvictionForNodes) {
      res["daemonset_eviction_for_nodes"] = boost::any(*daemonsetEvictionForNodes);
    }
    if (expander) {
      res["expander"] = boost::any(*expander);
    }
    if (gpuUtilizationThreshold) {
      res["gpu_utilization_threshold"] = boost::any(*gpuUtilizationThreshold);
    }
    if (maxGracefulTerminationSec) {
      res["max_graceful_termination_sec"] = boost::any(*maxGracefulTerminationSec);
    }
    if (minReplicaCount) {
      res["min_replica_count"] = boost::any(*minReplicaCount);
    }
    if (priorities) {
      res["priorities"] = boost::any(*priorities);
    }
    if (recycleNodeDeletionEnabled) {
      res["recycle_node_deletion_enabled"] = boost::any(*recycleNodeDeletionEnabled);
    }
    if (scaleDownEnabled) {
      res["scale_down_enabled"] = boost::any(*scaleDownEnabled);
    }
    if (scaleUpFromZero) {
      res["scale_up_from_zero"] = boost::any(*scaleUpFromZero);
    }
    if (scalerType) {
      res["scaler_type"] = boost::any(*scalerType);
    }
    if (scanInterval) {
      res["scan_interval"] = boost::any(*scanInterval);
    }
    if (skipNodesWithLocalStorage) {
      res["skip_nodes_with_local_storage"] = boost::any(*skipNodesWithLocalStorage);
    }
    if (skipNodesWithSystemPods) {
      res["skip_nodes_with_system_pods"] = boost::any(*skipNodesWithSystemPods);
    }
    if (unneededDuration) {
      res["unneeded_duration"] = boost::any(*unneededDuration);
    }
    if (utilizationThreshold) {
      res["utilization_threshold"] = boost::any(*utilizationThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cool_down_duration") != m.end() && !m["cool_down_duration"].empty()) {
      coolDownDuration = make_shared<string>(boost::any_cast<string>(m["cool_down_duration"]));
    }
    if (m.find("daemonset_eviction_for_nodes") != m.end() && !m["daemonset_eviction_for_nodes"].empty()) {
      daemonsetEvictionForNodes = make_shared<bool>(boost::any_cast<bool>(m["daemonset_eviction_for_nodes"]));
    }
    if (m.find("expander") != m.end() && !m["expander"].empty()) {
      expander = make_shared<string>(boost::any_cast<string>(m["expander"]));
    }
    if (m.find("gpu_utilization_threshold") != m.end() && !m["gpu_utilization_threshold"].empty()) {
      gpuUtilizationThreshold = make_shared<string>(boost::any_cast<string>(m["gpu_utilization_threshold"]));
    }
    if (m.find("max_graceful_termination_sec") != m.end() && !m["max_graceful_termination_sec"].empty()) {
      maxGracefulTerminationSec = make_shared<long>(boost::any_cast<long>(m["max_graceful_termination_sec"]));
    }
    if (m.find("min_replica_count") != m.end() && !m["min_replica_count"].empty()) {
      minReplicaCount = make_shared<long>(boost::any_cast<long>(m["min_replica_count"]));
    }
    if (m.find("priorities") != m.end() && !m["priorities"].empty()) {
      map<string, vector<string>> map1 = boost::any_cast<map<string, vector<string>>>(m["priorities"]);
      map<string, vector<string>> toMap1;
      for (auto item:map1) {
        vector<string> toVec2;
        if (typeid(vector<boost::any>) == item.second.type()) {
          vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item.second);
          for (auto item:vec2) {
             toVec2.push_back(boost::any_cast<string>(item));
          }
        }
         toMap1[item.first] = toVec2;
      }
      priorities = make_shared<map<string, vector<string>>>(toMap1);
    }
    if (m.find("recycle_node_deletion_enabled") != m.end() && !m["recycle_node_deletion_enabled"].empty()) {
      recycleNodeDeletionEnabled = make_shared<bool>(boost::any_cast<bool>(m["recycle_node_deletion_enabled"]));
    }
    if (m.find("scale_down_enabled") != m.end() && !m["scale_down_enabled"].empty()) {
      scaleDownEnabled = make_shared<bool>(boost::any_cast<bool>(m["scale_down_enabled"]));
    }
    if (m.find("scale_up_from_zero") != m.end() && !m["scale_up_from_zero"].empty()) {
      scaleUpFromZero = make_shared<bool>(boost::any_cast<bool>(m["scale_up_from_zero"]));
    }
    if (m.find("scaler_type") != m.end() && !m["scaler_type"].empty()) {
      scalerType = make_shared<string>(boost::any_cast<string>(m["scaler_type"]));
    }
    if (m.find("scan_interval") != m.end() && !m["scan_interval"].empty()) {
      scanInterval = make_shared<string>(boost::any_cast<string>(m["scan_interval"]));
    }
    if (m.find("skip_nodes_with_local_storage") != m.end() && !m["skip_nodes_with_local_storage"].empty()) {
      skipNodesWithLocalStorage = make_shared<bool>(boost::any_cast<bool>(m["skip_nodes_with_local_storage"]));
    }
    if (m.find("skip_nodes_with_system_pods") != m.end() && !m["skip_nodes_with_system_pods"].empty()) {
      skipNodesWithSystemPods = make_shared<bool>(boost::any_cast<bool>(m["skip_nodes_with_system_pods"]));
    }
    if (m.find("unneeded_duration") != m.end() && !m["unneeded_duration"].empty()) {
      unneededDuration = make_shared<string>(boost::any_cast<string>(m["unneeded_duration"]));
    }
    if (m.find("utilization_threshold") != m.end() && !m["utilization_threshold"].empty()) {
      utilizationThreshold = make_shared<string>(boost::any_cast<string>(m["utilization_threshold"]));
    }
  }


  virtual ~CreateAutoscalingConfigRequest() = default;
};
class CreateAutoscalingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateAutoscalingConfigResponseBody() {}

  explicit CreateAutoscalingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~CreateAutoscalingConfigResponseBody() = default;
};
class CreateAutoscalingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAutoscalingConfigResponseBody> body{};

  CreateAutoscalingConfigResponse() {}

  explicit CreateAutoscalingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAutoscalingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAutoscalingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAutoscalingConfigResponse() = default;
};
class CreateClusterRequestAuditLogConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> slsProjectName{};

  CreateClusterRequestAuditLogConfig() {}

  explicit CreateClusterRequestAuditLogConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (slsProjectName) {
      res["sls_project_name"] = boost::any(*slsProjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("sls_project_name") != m.end() && !m["sls_project_name"].empty()) {
      slsProjectName = make_shared<string>(boost::any_cast<string>(m["sls_project_name"]));
    }
  }


  virtual ~CreateClusterRequestAuditLogConfig() = default;
};
class CreateClusterRequestAutoMode : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};

  CreateClusterRequestAutoMode() {}

  explicit CreateClusterRequestAutoMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
  }


  virtual ~CreateClusterRequestAutoMode() = default;
};
class CreateClusterRequestControlPlaneConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<string> chargeType{};
  shared_ptr<bool> cloudMonitorFlags{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<string> deploymentsetId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<InstanceMetadataOptions> instanceMetadataOptions{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> keyPair{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> nodePortRange{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> runtime{};
  shared_ptr<bool> securityHardeningOs{};
  shared_ptr<long> size{};
  shared_ptr<bool> socEnabled{};
  shared_ptr<bool> systemDiskBurstingEnabled{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskPerformanceLevel{};
  shared_ptr<long> systemDiskProvisionedIops{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<string> systemDiskSnapshotPolicyId{};

  CreateClusterRequestControlPlaneConfig() {}

  explicit CreateClusterRequestControlPlaneConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["auto_renew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["auto_renew_period"] = boost::any(*autoRenewPeriod);
    }
    if (chargeType) {
      res["charge_type"] = boost::any(*chargeType);
    }
    if (cloudMonitorFlags) {
      res["cloud_monitor_flags"] = boost::any(*cloudMonitorFlags);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (deploymentsetId) {
      res["deploymentset_id"] = boost::any(*deploymentsetId);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (imageType) {
      res["image_type"] = boost::any(*imageType);
    }
    if (instanceMetadataOptions) {
      res["instance_metadata_options"] = instanceMetadataOptions ? boost::any(instanceMetadataOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTypes) {
      res["instance_types"] = boost::any(*instanceTypes);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (loginPassword) {
      res["login_password"] = boost::any(*loginPassword);
    }
    if (nodePortRange) {
      res["node_port_range"] = boost::any(*nodePortRange);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["period_unit"] = boost::any(*periodUnit);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (securityHardeningOs) {
      res["security_hardening_os"] = boost::any(*securityHardeningOs);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (socEnabled) {
      res["soc_enabled"] = boost::any(*socEnabled);
    }
    if (systemDiskBurstingEnabled) {
      res["system_disk_bursting_enabled"] = boost::any(*systemDiskBurstingEnabled);
    }
    if (systemDiskCategory) {
      res["system_disk_category"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskPerformanceLevel) {
      res["system_disk_performance_level"] = boost::any(*systemDiskPerformanceLevel);
    }
    if (systemDiskProvisionedIops) {
      res["system_disk_provisioned_iops"] = boost::any(*systemDiskProvisionedIops);
    }
    if (systemDiskSize) {
      res["system_disk_size"] = boost::any(*systemDiskSize);
    }
    if (systemDiskSnapshotPolicyId) {
      res["system_disk_snapshot_policy_id"] = boost::any(*systemDiskSnapshotPolicyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_renew") != m.end() && !m["auto_renew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["auto_renew"]));
    }
    if (m.find("auto_renew_period") != m.end() && !m["auto_renew_period"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["auto_renew_period"]));
    }
    if (m.find("charge_type") != m.end() && !m["charge_type"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["charge_type"]));
    }
    if (m.find("cloud_monitor_flags") != m.end() && !m["cloud_monitor_flags"].empty()) {
      cloudMonitorFlags = make_shared<bool>(boost::any_cast<bool>(m["cloud_monitor_flags"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("deploymentset_id") != m.end() && !m["deploymentset_id"].empty()) {
      deploymentsetId = make_shared<string>(boost::any_cast<string>(m["deploymentset_id"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("image_type") != m.end() && !m["image_type"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["image_type"]));
    }
    if (m.find("instance_metadata_options") != m.end() && !m["instance_metadata_options"].empty()) {
      if (typeid(map<string, boost::any>) == m["instance_metadata_options"].type()) {
        InstanceMetadataOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["instance_metadata_options"]));
        instanceMetadataOptions = make_shared<InstanceMetadataOptions>(model1);
      }
    }
    if (m.find("instance_types") != m.end() && !m["instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("login_password") != m.end() && !m["login_password"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["login_password"]));
    }
    if (m.find("node_port_range") != m.end() && !m["node_port_range"].empty()) {
      nodePortRange = make_shared<string>(boost::any_cast<string>(m["node_port_range"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("period_unit") != m.end() && !m["period_unit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["period_unit"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("security_hardening_os") != m.end() && !m["security_hardening_os"].empty()) {
      securityHardeningOs = make_shared<bool>(boost::any_cast<bool>(m["security_hardening_os"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("soc_enabled") != m.end() && !m["soc_enabled"].empty()) {
      socEnabled = make_shared<bool>(boost::any_cast<bool>(m["soc_enabled"]));
    }
    if (m.find("system_disk_bursting_enabled") != m.end() && !m["system_disk_bursting_enabled"].empty()) {
      systemDiskBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["system_disk_bursting_enabled"]));
    }
    if (m.find("system_disk_category") != m.end() && !m["system_disk_category"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["system_disk_category"]));
    }
    if (m.find("system_disk_performance_level") != m.end() && !m["system_disk_performance_level"].empty()) {
      systemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["system_disk_performance_level"]));
    }
    if (m.find("system_disk_provisioned_iops") != m.end() && !m["system_disk_provisioned_iops"].empty()) {
      systemDiskProvisionedIops = make_shared<long>(boost::any_cast<long>(m["system_disk_provisioned_iops"]));
    }
    if (m.find("system_disk_size") != m.end() && !m["system_disk_size"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["system_disk_size"]));
    }
    if (m.find("system_disk_snapshot_policy_id") != m.end() && !m["system_disk_snapshot_policy_id"].empty()) {
      systemDiskSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["system_disk_snapshot_policy_id"]));
    }
  }


  virtual ~CreateClusterRequestControlPlaneConfig() = default;
};
class CreateClusterRequestOperationPolicyClusterAutoUpgrade : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<bool> enabled{};

  CreateClusterRequestOperationPolicyClusterAutoUpgrade() {}

  explicit CreateClusterRequestOperationPolicyClusterAutoUpgrade(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["channel"] = boost::any(*channel);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("channel") != m.end() && !m["channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["channel"]));
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
  }


  virtual ~CreateClusterRequestOperationPolicyClusterAutoUpgrade() = default;
};
class CreateClusterRequestOperationPolicy : public Darabonba::Model {
public:
  shared_ptr<CreateClusterRequestOperationPolicyClusterAutoUpgrade> clusterAutoUpgrade{};

  CreateClusterRequestOperationPolicy() {}

  explicit CreateClusterRequestOperationPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterAutoUpgrade) {
      res["cluster_auto_upgrade"] = clusterAutoUpgrade ? boost::any(clusterAutoUpgrade->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_auto_upgrade") != m.end() && !m["cluster_auto_upgrade"].empty()) {
      if (typeid(map<string, boost::any>) == m["cluster_auto_upgrade"].type()) {
        CreateClusterRequestOperationPolicyClusterAutoUpgrade model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cluster_auto_upgrade"]));
        clusterAutoUpgrade = make_shared<CreateClusterRequestOperationPolicyClusterAutoUpgrade>(model1);
      }
    }
  }


  virtual ~CreateClusterRequestOperationPolicy() = default;
};
class CreateClusterRequestRrsaConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};

  CreateClusterRequestRrsaConfig() {}

  explicit CreateClusterRequestRrsaConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
  }


  virtual ~CreateClusterRequestRrsaConfig() = default;
};
class CreateClusterRequestWorkerDataDisks : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> size{};

  CreateClusterRequestWorkerDataDisks() {}

  explicit CreateClusterRequestWorkerDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (encrypted) {
      res["encrypted"] = boost::any(*encrypted);
    }
    if (performanceLevel) {
      res["performance_level"] = boost::any(*performanceLevel);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("encrypted") != m.end() && !m["encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["encrypted"]));
    }
    if (m.find("performance_level") != m.end() && !m["performance_level"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["performance_level"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["size"]));
    }
  }


  virtual ~CreateClusterRequestWorkerDataDisks() = default;
};
class CreateClusterRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> accessControlList{};
  shared_ptr<vector<Addon>> addons{};
  shared_ptr<string> apiAudiences{};
  shared_ptr<CreateClusterRequestAuditLogConfig> auditLogConfig{};
  shared_ptr<CreateClusterRequestAutoMode> autoMode{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<string> chargeType{};
  shared_ptr<bool> cisEnabled{};
  shared_ptr<bool> cloudMonitorFlags{};
  shared_ptr<string> clusterDomain{};
  shared_ptr<string> clusterSpec{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> containerCidr{};
  shared_ptr<CreateClusterRequestControlPlaneConfig> controlPlaneConfig{};
  shared_ptr<vector<string>> controlplaneLogComponents{};
  shared_ptr<string> controlplaneLogProject{};
  shared_ptr<string> controlplaneLogTtl{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<string> customSan{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<bool> disableRollback{};
  shared_ptr<bool> enableRrsa{};
  shared_ptr<string> encryptionProviderKey{};
  shared_ptr<bool> endpointPublicAccess{};
  shared_ptr<vector<string>> extraSans{};
  shared_ptr<bool> formatDisk{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<vector<string>> instances{};
  shared_ptr<string> ipStack{};
  shared_ptr<bool> isEnterpriseSecurityGroup{};
  shared_ptr<bool> keepInstanceName{};
  shared_ptr<string> keyPair{};
  shared_ptr<string> kubernetesVersion{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerSpec{};
  shared_ptr<string> loggingType{};
  shared_ptr<string> loginPassword{};
  shared_ptr<MaintenanceWindow> maintenanceWindow{};
  shared_ptr<bool> masterAutoRenew{};
  shared_ptr<long> masterAutoRenewPeriod{};
  shared_ptr<long> masterCount{};
  shared_ptr<string> masterInstanceChargeType{};
  shared_ptr<vector<string>> masterInstanceTypes{};
  shared_ptr<long> masterPeriod{};
  shared_ptr<string> masterPeriodUnit{};
  shared_ptr<string> masterSystemDiskCategory{};
  shared_ptr<string> masterSystemDiskPerformanceLevel{};
  shared_ptr<long> masterSystemDiskSize{};
  shared_ptr<string> masterSystemDiskSnapshotPolicyId{};
  shared_ptr<vector<string>> masterVswitchIds{};
  shared_ptr<string> name{};
  shared_ptr<bool> natGateway{};
  shared_ptr<string> nodeCidrMask{};
  shared_ptr<string> nodeNameMode{};
  shared_ptr<string> nodePortRange{};
  shared_ptr<vector<Nodepool>> nodepools{};
  shared_ptr<long> numOfNodes{};
  shared_ptr<CreateClusterRequestOperationPolicy> operationPolicy{};
  shared_ptr<string> osType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> platform{};
  shared_ptr<vector<string>> podVswitchIds{};
  shared_ptr<string> profile{};
  shared_ptr<string> proxyMode{};
  shared_ptr<vector<string>> rdsInstances{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<CreateClusterRequestRrsaConfig> rrsaConfig{};
  shared_ptr<Runtime> runtime{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<bool> securityHardeningOs{};
  shared_ptr<string> serviceAccountIssuer{};
  shared_ptr<string> serviceCidr{};
  shared_ptr<vector<string>> serviceDiscoveryTypes{};
  shared_ptr<bool> snatEntry{};
  shared_ptr<bool> socEnabled{};
  shared_ptr<bool> sshFlags{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<vector<Taint>> taints{};
  shared_ptr<long> timeoutMins{};
  shared_ptr<string> timezone{};
  shared_ptr<string> userCa{};
  shared_ptr<string> userData{};
  shared_ptr<string> vpcid{};
  shared_ptr<vector<string>> vswitchIds{};
  shared_ptr<bool> workerAutoRenew{};
  shared_ptr<long> workerAutoRenewPeriod{};
  shared_ptr<vector<CreateClusterRequestWorkerDataDisks>> workerDataDisks{};
  shared_ptr<string> workerInstanceChargeType{};
  shared_ptr<vector<string>> workerInstanceTypes{};
  shared_ptr<long> workerPeriod{};
  shared_ptr<string> workerPeriodUnit{};
  shared_ptr<string> workerSystemDiskCategory{};
  shared_ptr<string> workerSystemDiskPerformanceLevel{};
  shared_ptr<long> workerSystemDiskSize{};
  shared_ptr<string> workerSystemDiskSnapshotPolicyId{};
  shared_ptr<vector<string>> workerVswitchIds{};
  shared_ptr<string> zoneId{};
  shared_ptr<vector<string>> zoneIds{};

  CreateClusterRequest() {}

  explicit CreateClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessControlList) {
      res["access_control_list"] = boost::any(*accessControlList);
    }
    if (addons) {
      vector<boost::any> temp1;
      for(auto item1:*addons){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["addons"] = boost::any(temp1);
    }
    if (apiAudiences) {
      res["api_audiences"] = boost::any(*apiAudiences);
    }
    if (auditLogConfig) {
      res["audit_log_config"] = auditLogConfig ? boost::any(auditLogConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoMode) {
      res["auto_mode"] = autoMode ? boost::any(autoMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoRenew) {
      res["auto_renew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["auto_renew_period"] = boost::any(*autoRenewPeriod);
    }
    if (chargeType) {
      res["charge_type"] = boost::any(*chargeType);
    }
    if (cisEnabled) {
      res["cis_enabled"] = boost::any(*cisEnabled);
    }
    if (cloudMonitorFlags) {
      res["cloud_monitor_flags"] = boost::any(*cloudMonitorFlags);
    }
    if (clusterDomain) {
      res["cluster_domain"] = boost::any(*clusterDomain);
    }
    if (clusterSpec) {
      res["cluster_spec"] = boost::any(*clusterSpec);
    }
    if (clusterType) {
      res["cluster_type"] = boost::any(*clusterType);
    }
    if (containerCidr) {
      res["container_cidr"] = boost::any(*containerCidr);
    }
    if (controlPlaneConfig) {
      res["control_plane_config"] = controlPlaneConfig ? boost::any(controlPlaneConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (controlplaneLogComponents) {
      res["controlplane_log_components"] = boost::any(*controlplaneLogComponents);
    }
    if (controlplaneLogProject) {
      res["controlplane_log_project"] = boost::any(*controlplaneLogProject);
    }
    if (controlplaneLogTtl) {
      res["controlplane_log_ttl"] = boost::any(*controlplaneLogTtl);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (customSan) {
      res["custom_san"] = boost::any(*customSan);
    }
    if (deletionProtection) {
      res["deletion_protection"] = boost::any(*deletionProtection);
    }
    if (disableRollback) {
      res["disable_rollback"] = boost::any(*disableRollback);
    }
    if (enableRrsa) {
      res["enable_rrsa"] = boost::any(*enableRrsa);
    }
    if (encryptionProviderKey) {
      res["encryption_provider_key"] = boost::any(*encryptionProviderKey);
    }
    if (endpointPublicAccess) {
      res["endpoint_public_access"] = boost::any(*endpointPublicAccess);
    }
    if (extraSans) {
      res["extra_sans"] = boost::any(*extraSans);
    }
    if (formatDisk) {
      res["format_disk"] = boost::any(*formatDisk);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (imageType) {
      res["image_type"] = boost::any(*imageType);
    }
    if (instances) {
      res["instances"] = boost::any(*instances);
    }
    if (ipStack) {
      res["ip_stack"] = boost::any(*ipStack);
    }
    if (isEnterpriseSecurityGroup) {
      res["is_enterprise_security_group"] = boost::any(*isEnterpriseSecurityGroup);
    }
    if (keepInstanceName) {
      res["keep_instance_name"] = boost::any(*keepInstanceName);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (kubernetesVersion) {
      res["kubernetes_version"] = boost::any(*kubernetesVersion);
    }
    if (loadBalancerId) {
      res["load_balancer_id"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerSpec) {
      res["load_balancer_spec"] = boost::any(*loadBalancerSpec);
    }
    if (loggingType) {
      res["logging_type"] = boost::any(*loggingType);
    }
    if (loginPassword) {
      res["login_password"] = boost::any(*loginPassword);
    }
    if (maintenanceWindow) {
      res["maintenance_window"] = maintenanceWindow ? boost::any(maintenanceWindow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (masterAutoRenew) {
      res["master_auto_renew"] = boost::any(*masterAutoRenew);
    }
    if (masterAutoRenewPeriod) {
      res["master_auto_renew_period"] = boost::any(*masterAutoRenewPeriod);
    }
    if (masterCount) {
      res["master_count"] = boost::any(*masterCount);
    }
    if (masterInstanceChargeType) {
      res["master_instance_charge_type"] = boost::any(*masterInstanceChargeType);
    }
    if (masterInstanceTypes) {
      res["master_instance_types"] = boost::any(*masterInstanceTypes);
    }
    if (masterPeriod) {
      res["master_period"] = boost::any(*masterPeriod);
    }
    if (masterPeriodUnit) {
      res["master_period_unit"] = boost::any(*masterPeriodUnit);
    }
    if (masterSystemDiskCategory) {
      res["master_system_disk_category"] = boost::any(*masterSystemDiskCategory);
    }
    if (masterSystemDiskPerformanceLevel) {
      res["master_system_disk_performance_level"] = boost::any(*masterSystemDiskPerformanceLevel);
    }
    if (masterSystemDiskSize) {
      res["master_system_disk_size"] = boost::any(*masterSystemDiskSize);
    }
    if (masterSystemDiskSnapshotPolicyId) {
      res["master_system_disk_snapshot_policy_id"] = boost::any(*masterSystemDiskSnapshotPolicyId);
    }
    if (masterVswitchIds) {
      res["master_vswitch_ids"] = boost::any(*masterVswitchIds);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (natGateway) {
      res["nat_gateway"] = boost::any(*natGateway);
    }
    if (nodeCidrMask) {
      res["node_cidr_mask"] = boost::any(*nodeCidrMask);
    }
    if (nodeNameMode) {
      res["node_name_mode"] = boost::any(*nodeNameMode);
    }
    if (nodePortRange) {
      res["node_port_range"] = boost::any(*nodePortRange);
    }
    if (nodepools) {
      vector<boost::any> temp1;
      for(auto item1:*nodepools){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nodepools"] = boost::any(temp1);
    }
    if (numOfNodes) {
      res["num_of_nodes"] = boost::any(*numOfNodes);
    }
    if (operationPolicy) {
      res["operation_policy"] = operationPolicy ? boost::any(operationPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (osType) {
      res["os_type"] = boost::any(*osType);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["period_unit"] = boost::any(*periodUnit);
    }
    if (platform) {
      res["platform"] = boost::any(*platform);
    }
    if (podVswitchIds) {
      res["pod_vswitch_ids"] = boost::any(*podVswitchIds);
    }
    if (profile) {
      res["profile"] = boost::any(*profile);
    }
    if (proxyMode) {
      res["proxy_mode"] = boost::any(*proxyMode);
    }
    if (rdsInstances) {
      res["rds_instances"] = boost::any(*rdsInstances);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    if (rrsaConfig) {
      res["rrsa_config"] = rrsaConfig ? boost::any(rrsaConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtime) {
      res["runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityGroupId) {
      res["security_group_id"] = boost::any(*securityGroupId);
    }
    if (securityHardeningOs) {
      res["security_hardening_os"] = boost::any(*securityHardeningOs);
    }
    if (serviceAccountIssuer) {
      res["service_account_issuer"] = boost::any(*serviceAccountIssuer);
    }
    if (serviceCidr) {
      res["service_cidr"] = boost::any(*serviceCidr);
    }
    if (serviceDiscoveryTypes) {
      res["service_discovery_types"] = boost::any(*serviceDiscoveryTypes);
    }
    if (snatEntry) {
      res["snat_entry"] = boost::any(*snatEntry);
    }
    if (socEnabled) {
      res["soc_enabled"] = boost::any(*socEnabled);
    }
    if (sshFlags) {
      res["ssh_flags"] = boost::any(*sshFlags);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (taints) {
      vector<boost::any> temp1;
      for(auto item1:*taints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["taints"] = boost::any(temp1);
    }
    if (timeoutMins) {
      res["timeout_mins"] = boost::any(*timeoutMins);
    }
    if (timezone) {
      res["timezone"] = boost::any(*timezone);
    }
    if (userCa) {
      res["user_ca"] = boost::any(*userCa);
    }
    if (userData) {
      res["user_data"] = boost::any(*userData);
    }
    if (vpcid) {
      res["vpcid"] = boost::any(*vpcid);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    if (workerAutoRenew) {
      res["worker_auto_renew"] = boost::any(*workerAutoRenew);
    }
    if (workerAutoRenewPeriod) {
      res["worker_auto_renew_period"] = boost::any(*workerAutoRenewPeriod);
    }
    if (workerDataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*workerDataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["worker_data_disks"] = boost::any(temp1);
    }
    if (workerInstanceChargeType) {
      res["worker_instance_charge_type"] = boost::any(*workerInstanceChargeType);
    }
    if (workerInstanceTypes) {
      res["worker_instance_types"] = boost::any(*workerInstanceTypes);
    }
    if (workerPeriod) {
      res["worker_period"] = boost::any(*workerPeriod);
    }
    if (workerPeriodUnit) {
      res["worker_period_unit"] = boost::any(*workerPeriodUnit);
    }
    if (workerSystemDiskCategory) {
      res["worker_system_disk_category"] = boost::any(*workerSystemDiskCategory);
    }
    if (workerSystemDiskPerformanceLevel) {
      res["worker_system_disk_performance_level"] = boost::any(*workerSystemDiskPerformanceLevel);
    }
    if (workerSystemDiskSize) {
      res["worker_system_disk_size"] = boost::any(*workerSystemDiskSize);
    }
    if (workerSystemDiskSnapshotPolicyId) {
      res["worker_system_disk_snapshot_policy_id"] = boost::any(*workerSystemDiskSnapshotPolicyId);
    }
    if (workerVswitchIds) {
      res["worker_vswitch_ids"] = boost::any(*workerVswitchIds);
    }
    if (zoneId) {
      res["zone_id"] = boost::any(*zoneId);
    }
    if (zoneIds) {
      res["zone_ids"] = boost::any(*zoneIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("access_control_list") != m.end() && !m["access_control_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["access_control_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["access_control_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      accessControlList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("addons") != m.end() && !m["addons"].empty()) {
      if (typeid(vector<boost::any>) == m["addons"].type()) {
        vector<Addon> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["addons"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Addon model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addons = make_shared<vector<Addon>>(expect1);
      }
    }
    if (m.find("api_audiences") != m.end() && !m["api_audiences"].empty()) {
      apiAudiences = make_shared<string>(boost::any_cast<string>(m["api_audiences"]));
    }
    if (m.find("audit_log_config") != m.end() && !m["audit_log_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["audit_log_config"].type()) {
        CreateClusterRequestAuditLogConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["audit_log_config"]));
        auditLogConfig = make_shared<CreateClusterRequestAuditLogConfig>(model1);
      }
    }
    if (m.find("auto_mode") != m.end() && !m["auto_mode"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_mode"].type()) {
        CreateClusterRequestAutoMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_mode"]));
        autoMode = make_shared<CreateClusterRequestAutoMode>(model1);
      }
    }
    if (m.find("auto_renew") != m.end() && !m["auto_renew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["auto_renew"]));
    }
    if (m.find("auto_renew_period") != m.end() && !m["auto_renew_period"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["auto_renew_period"]));
    }
    if (m.find("charge_type") != m.end() && !m["charge_type"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["charge_type"]));
    }
    if (m.find("cis_enabled") != m.end() && !m["cis_enabled"].empty()) {
      cisEnabled = make_shared<bool>(boost::any_cast<bool>(m["cis_enabled"]));
    }
    if (m.find("cloud_monitor_flags") != m.end() && !m["cloud_monitor_flags"].empty()) {
      cloudMonitorFlags = make_shared<bool>(boost::any_cast<bool>(m["cloud_monitor_flags"]));
    }
    if (m.find("cluster_domain") != m.end() && !m["cluster_domain"].empty()) {
      clusterDomain = make_shared<string>(boost::any_cast<string>(m["cluster_domain"]));
    }
    if (m.find("cluster_spec") != m.end() && !m["cluster_spec"].empty()) {
      clusterSpec = make_shared<string>(boost::any_cast<string>(m["cluster_spec"]));
    }
    if (m.find("cluster_type") != m.end() && !m["cluster_type"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["cluster_type"]));
    }
    if (m.find("container_cidr") != m.end() && !m["container_cidr"].empty()) {
      containerCidr = make_shared<string>(boost::any_cast<string>(m["container_cidr"]));
    }
    if (m.find("control_plane_config") != m.end() && !m["control_plane_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["control_plane_config"].type()) {
        CreateClusterRequestControlPlaneConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["control_plane_config"]));
        controlPlaneConfig = make_shared<CreateClusterRequestControlPlaneConfig>(model1);
      }
    }
    if (m.find("controlplane_log_components") != m.end() && !m["controlplane_log_components"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["controlplane_log_components"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["controlplane_log_components"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      controlplaneLogComponents = make_shared<vector<string>>(toVec1);
    }
    if (m.find("controlplane_log_project") != m.end() && !m["controlplane_log_project"].empty()) {
      controlplaneLogProject = make_shared<string>(boost::any_cast<string>(m["controlplane_log_project"]));
    }
    if (m.find("controlplane_log_ttl") != m.end() && !m["controlplane_log_ttl"].empty()) {
      controlplaneLogTtl = make_shared<string>(boost::any_cast<string>(m["controlplane_log_ttl"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("custom_san") != m.end() && !m["custom_san"].empty()) {
      customSan = make_shared<string>(boost::any_cast<string>(m["custom_san"]));
    }
    if (m.find("deletion_protection") != m.end() && !m["deletion_protection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["deletion_protection"]));
    }
    if (m.find("disable_rollback") != m.end() && !m["disable_rollback"].empty()) {
      disableRollback = make_shared<bool>(boost::any_cast<bool>(m["disable_rollback"]));
    }
    if (m.find("enable_rrsa") != m.end() && !m["enable_rrsa"].empty()) {
      enableRrsa = make_shared<bool>(boost::any_cast<bool>(m["enable_rrsa"]));
    }
    if (m.find("encryption_provider_key") != m.end() && !m["encryption_provider_key"].empty()) {
      encryptionProviderKey = make_shared<string>(boost::any_cast<string>(m["encryption_provider_key"]));
    }
    if (m.find("endpoint_public_access") != m.end() && !m["endpoint_public_access"].empty()) {
      endpointPublicAccess = make_shared<bool>(boost::any_cast<bool>(m["endpoint_public_access"]));
    }
    if (m.find("extra_sans") != m.end() && !m["extra_sans"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["extra_sans"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_sans"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      extraSans = make_shared<vector<string>>(toVec1);
    }
    if (m.find("format_disk") != m.end() && !m["format_disk"].empty()) {
      formatDisk = make_shared<bool>(boost::any_cast<bool>(m["format_disk"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("image_type") != m.end() && !m["image_type"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["image_type"]));
    }
    if (m.find("instances") != m.end() && !m["instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ip_stack") != m.end() && !m["ip_stack"].empty()) {
      ipStack = make_shared<string>(boost::any_cast<string>(m["ip_stack"]));
    }
    if (m.find("is_enterprise_security_group") != m.end() && !m["is_enterprise_security_group"].empty()) {
      isEnterpriseSecurityGroup = make_shared<bool>(boost::any_cast<bool>(m["is_enterprise_security_group"]));
    }
    if (m.find("keep_instance_name") != m.end() && !m["keep_instance_name"].empty()) {
      keepInstanceName = make_shared<bool>(boost::any_cast<bool>(m["keep_instance_name"]));
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("kubernetes_version") != m.end() && !m["kubernetes_version"].empty()) {
      kubernetesVersion = make_shared<string>(boost::any_cast<string>(m["kubernetes_version"]));
    }
    if (m.find("load_balancer_id") != m.end() && !m["load_balancer_id"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["load_balancer_id"]));
    }
    if (m.find("load_balancer_spec") != m.end() && !m["load_balancer_spec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["load_balancer_spec"]));
    }
    if (m.find("logging_type") != m.end() && !m["logging_type"].empty()) {
      loggingType = make_shared<string>(boost::any_cast<string>(m["logging_type"]));
    }
    if (m.find("login_password") != m.end() && !m["login_password"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["login_password"]));
    }
    if (m.find("maintenance_window") != m.end() && !m["maintenance_window"].empty()) {
      if (typeid(map<string, boost::any>) == m["maintenance_window"].type()) {
        MaintenanceWindow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["maintenance_window"]));
        maintenanceWindow = make_shared<MaintenanceWindow>(model1);
      }
    }
    if (m.find("master_auto_renew") != m.end() && !m["master_auto_renew"].empty()) {
      masterAutoRenew = make_shared<bool>(boost::any_cast<bool>(m["master_auto_renew"]));
    }
    if (m.find("master_auto_renew_period") != m.end() && !m["master_auto_renew_period"].empty()) {
      masterAutoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["master_auto_renew_period"]));
    }
    if (m.find("master_count") != m.end() && !m["master_count"].empty()) {
      masterCount = make_shared<long>(boost::any_cast<long>(m["master_count"]));
    }
    if (m.find("master_instance_charge_type") != m.end() && !m["master_instance_charge_type"].empty()) {
      masterInstanceChargeType = make_shared<string>(boost::any_cast<string>(m["master_instance_charge_type"]));
    }
    if (m.find("master_instance_types") != m.end() && !m["master_instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["master_instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["master_instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      masterInstanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("master_period") != m.end() && !m["master_period"].empty()) {
      masterPeriod = make_shared<long>(boost::any_cast<long>(m["master_period"]));
    }
    if (m.find("master_period_unit") != m.end() && !m["master_period_unit"].empty()) {
      masterPeriodUnit = make_shared<string>(boost::any_cast<string>(m["master_period_unit"]));
    }
    if (m.find("master_system_disk_category") != m.end() && !m["master_system_disk_category"].empty()) {
      masterSystemDiskCategory = make_shared<string>(boost::any_cast<string>(m["master_system_disk_category"]));
    }
    if (m.find("master_system_disk_performance_level") != m.end() && !m["master_system_disk_performance_level"].empty()) {
      masterSystemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["master_system_disk_performance_level"]));
    }
    if (m.find("master_system_disk_size") != m.end() && !m["master_system_disk_size"].empty()) {
      masterSystemDiskSize = make_shared<long>(boost::any_cast<long>(m["master_system_disk_size"]));
    }
    if (m.find("master_system_disk_snapshot_policy_id") != m.end() && !m["master_system_disk_snapshot_policy_id"].empty()) {
      masterSystemDiskSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["master_system_disk_snapshot_policy_id"]));
    }
    if (m.find("master_vswitch_ids") != m.end() && !m["master_vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["master_vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["master_vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      masterVswitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nat_gateway") != m.end() && !m["nat_gateway"].empty()) {
      natGateway = make_shared<bool>(boost::any_cast<bool>(m["nat_gateway"]));
    }
    if (m.find("node_cidr_mask") != m.end() && !m["node_cidr_mask"].empty()) {
      nodeCidrMask = make_shared<string>(boost::any_cast<string>(m["node_cidr_mask"]));
    }
    if (m.find("node_name_mode") != m.end() && !m["node_name_mode"].empty()) {
      nodeNameMode = make_shared<string>(boost::any_cast<string>(m["node_name_mode"]));
    }
    if (m.find("node_port_range") != m.end() && !m["node_port_range"].empty()) {
      nodePortRange = make_shared<string>(boost::any_cast<string>(m["node_port_range"]));
    }
    if (m.find("nodepools") != m.end() && !m["nodepools"].empty()) {
      if (typeid(vector<boost::any>) == m["nodepools"].type()) {
        vector<Nodepool> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nodepools"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Nodepool model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodepools = make_shared<vector<Nodepool>>(expect1);
      }
    }
    if (m.find("num_of_nodes") != m.end() && !m["num_of_nodes"].empty()) {
      numOfNodes = make_shared<long>(boost::any_cast<long>(m["num_of_nodes"]));
    }
    if (m.find("operation_policy") != m.end() && !m["operation_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["operation_policy"].type()) {
        CreateClusterRequestOperationPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["operation_policy"]));
        operationPolicy = make_shared<CreateClusterRequestOperationPolicy>(model1);
      }
    }
    if (m.find("os_type") != m.end() && !m["os_type"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["os_type"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("period_unit") != m.end() && !m["period_unit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["period_unit"]));
    }
    if (m.find("platform") != m.end() && !m["platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["platform"]));
    }
    if (m.find("pod_vswitch_ids") != m.end() && !m["pod_vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["pod_vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["pod_vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      podVswitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("profile") != m.end() && !m["profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["profile"]));
    }
    if (m.find("proxy_mode") != m.end() && !m["proxy_mode"].empty()) {
      proxyMode = make_shared<string>(boost::any_cast<string>(m["proxy_mode"]));
    }
    if (m.find("rds_instances") != m.end() && !m["rds_instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["rds_instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["rds_instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rdsInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
    if (m.find("rrsa_config") != m.end() && !m["rrsa_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["rrsa_config"].type()) {
        CreateClusterRequestRrsaConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["rrsa_config"]));
        rrsaConfig = make_shared<CreateClusterRequestRrsaConfig>(model1);
      }
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["runtime"].type()) {
        Runtime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["runtime"]));
        runtime = make_shared<Runtime>(model1);
      }
    }
    if (m.find("security_group_id") != m.end() && !m["security_group_id"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["security_group_id"]));
    }
    if (m.find("security_hardening_os") != m.end() && !m["security_hardening_os"].empty()) {
      securityHardeningOs = make_shared<bool>(boost::any_cast<bool>(m["security_hardening_os"]));
    }
    if (m.find("service_account_issuer") != m.end() && !m["service_account_issuer"].empty()) {
      serviceAccountIssuer = make_shared<string>(boost::any_cast<string>(m["service_account_issuer"]));
    }
    if (m.find("service_cidr") != m.end() && !m["service_cidr"].empty()) {
      serviceCidr = make_shared<string>(boost::any_cast<string>(m["service_cidr"]));
    }
    if (m.find("service_discovery_types") != m.end() && !m["service_discovery_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["service_discovery_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["service_discovery_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceDiscoveryTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("snat_entry") != m.end() && !m["snat_entry"].empty()) {
      snatEntry = make_shared<bool>(boost::any_cast<bool>(m["snat_entry"]));
    }
    if (m.find("soc_enabled") != m.end() && !m["soc_enabled"].empty()) {
      socEnabled = make_shared<bool>(boost::any_cast<bool>(m["soc_enabled"]));
    }
    if (m.find("ssh_flags") != m.end() && !m["ssh_flags"].empty()) {
      sshFlags = make_shared<bool>(boost::any_cast<bool>(m["ssh_flags"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("taints") != m.end() && !m["taints"].empty()) {
      if (typeid(vector<boost::any>) == m["taints"].type()) {
        vector<Taint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["taints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Taint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taints = make_shared<vector<Taint>>(expect1);
      }
    }
    if (m.find("timeout_mins") != m.end() && !m["timeout_mins"].empty()) {
      timeoutMins = make_shared<long>(boost::any_cast<long>(m["timeout_mins"]));
    }
    if (m.find("timezone") != m.end() && !m["timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["timezone"]));
    }
    if (m.find("user_ca") != m.end() && !m["user_ca"].empty()) {
      userCa = make_shared<string>(boost::any_cast<string>(m["user_ca"]));
    }
    if (m.find("user_data") != m.end() && !m["user_data"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["user_data"]));
    }
    if (m.find("vpcid") != m.end() && !m["vpcid"].empty()) {
      vpcid = make_shared<string>(boost::any_cast<string>(m["vpcid"]));
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("worker_auto_renew") != m.end() && !m["worker_auto_renew"].empty()) {
      workerAutoRenew = make_shared<bool>(boost::any_cast<bool>(m["worker_auto_renew"]));
    }
    if (m.find("worker_auto_renew_period") != m.end() && !m["worker_auto_renew_period"].empty()) {
      workerAutoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["worker_auto_renew_period"]));
    }
    if (m.find("worker_data_disks") != m.end() && !m["worker_data_disks"].empty()) {
      if (typeid(vector<boost::any>) == m["worker_data_disks"].type()) {
        vector<CreateClusterRequestWorkerDataDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["worker_data_disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterRequestWorkerDataDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workerDataDisks = make_shared<vector<CreateClusterRequestWorkerDataDisks>>(expect1);
      }
    }
    if (m.find("worker_instance_charge_type") != m.end() && !m["worker_instance_charge_type"].empty()) {
      workerInstanceChargeType = make_shared<string>(boost::any_cast<string>(m["worker_instance_charge_type"]));
    }
    if (m.find("worker_instance_types") != m.end() && !m["worker_instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["worker_instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["worker_instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workerInstanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("worker_period") != m.end() && !m["worker_period"].empty()) {
      workerPeriod = make_shared<long>(boost::any_cast<long>(m["worker_period"]));
    }
    if (m.find("worker_period_unit") != m.end() && !m["worker_period_unit"].empty()) {
      workerPeriodUnit = make_shared<string>(boost::any_cast<string>(m["worker_period_unit"]));
    }
    if (m.find("worker_system_disk_category") != m.end() && !m["worker_system_disk_category"].empty()) {
      workerSystemDiskCategory = make_shared<string>(boost::any_cast<string>(m["worker_system_disk_category"]));
    }
    if (m.find("worker_system_disk_performance_level") != m.end() && !m["worker_system_disk_performance_level"].empty()) {
      workerSystemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["worker_system_disk_performance_level"]));
    }
    if (m.find("worker_system_disk_size") != m.end() && !m["worker_system_disk_size"].empty()) {
      workerSystemDiskSize = make_shared<long>(boost::any_cast<long>(m["worker_system_disk_size"]));
    }
    if (m.find("worker_system_disk_snapshot_policy_id") != m.end() && !m["worker_system_disk_snapshot_policy_id"].empty()) {
      workerSystemDiskSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["worker_system_disk_snapshot_policy_id"]));
    }
    if (m.find("worker_vswitch_ids") != m.end() && !m["worker_vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["worker_vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["worker_vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workerVswitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("zone_id") != m.end() && !m["zone_id"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zone_id"]));
    }
    if (m.find("zone_ids") != m.end() && !m["zone_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["zone_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["zone_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zoneIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateClusterRequest() = default;
};
class CreateClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateClusterResponseBody() {}

  explicit CreateClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~CreateClusterResponseBody() = default;
};
class CreateClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterResponseBody> body{};

  CreateClusterResponse() {}

  explicit CreateClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterResponse() = default;
};
class CreateClusterDiagnosisRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> target{};
  shared_ptr<string> type{};

  CreateClusterDiagnosisRequest() {}

  explicit CreateClusterDiagnosisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      res["target"] = boost::any(*target);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("target") != m.end() && !m["target"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["target"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      target = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateClusterDiagnosisRequest() = default;
};
class CreateClusterDiagnosisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> diagnosisId{};
  shared_ptr<string> requestId{};

  CreateClusterDiagnosisResponseBody() {}

  explicit CreateClusterDiagnosisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (diagnosisId) {
      res["diagnosis_id"] = boost::any(*diagnosisId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("diagnosis_id") != m.end() && !m["diagnosis_id"].empty()) {
      diagnosisId = make_shared<string>(boost::any_cast<string>(m["diagnosis_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
  }


  virtual ~CreateClusterDiagnosisResponseBody() = default;
};
class CreateClusterDiagnosisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterDiagnosisResponseBody> body{};

  CreateClusterDiagnosisResponse() {}

  explicit CreateClusterDiagnosisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterDiagnosisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterDiagnosisResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterDiagnosisResponse() = default;
};
class CreateClusterInspectConfigRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> disabledCheckItems{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> recurrence{};

  CreateClusterInspectConfigRequest() {}

  explicit CreateClusterInspectConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disabledCheckItems) {
      res["disabledCheckItems"] = boost::any(*disabledCheckItems);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (recurrence) {
      res["recurrence"] = boost::any(*recurrence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disabledCheckItems") != m.end() && !m["disabledCheckItems"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["disabledCheckItems"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["disabledCheckItems"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      disabledCheckItems = make_shared<vector<string>>(toVec1);
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("recurrence") != m.end() && !m["recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["recurrence"]));
    }
  }


  virtual ~CreateClusterInspectConfigRequest() = default;
};
class CreateClusterInspectConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateClusterInspectConfigResponseBody() {}

  explicit CreateClusterInspectConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateClusterInspectConfigResponseBody() = default;
};
class CreateClusterInspectConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterInspectConfigResponseBody> body{};

  CreateClusterInspectConfigResponse() {}

  explicit CreateClusterInspectConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterInspectConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterInspectConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterInspectConfigResponse() = default;
};
class CreateClusterNodePoolRequestAutoMode : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};

  CreateClusterNodePoolRequestAutoMode() {}

  explicit CreateClusterNodePoolRequestAutoMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestAutoMode() = default;
};
class CreateClusterNodePoolRequestAutoScaling : public Darabonba::Model {
public:
  shared_ptr<long> eipBandwidth{};
  shared_ptr<string> eipInternetChargeType{};
  shared_ptr<bool> enable{};
  shared_ptr<bool> isBondEip{};
  shared_ptr<long> maxInstances{};
  shared_ptr<long> minInstances{};
  shared_ptr<string> type{};

  CreateClusterNodePoolRequestAutoScaling() {}

  explicit CreateClusterNodePoolRequestAutoScaling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipBandwidth) {
      res["eip_bandwidth"] = boost::any(*eipBandwidth);
    }
    if (eipInternetChargeType) {
      res["eip_internet_charge_type"] = boost::any(*eipInternetChargeType);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (isBondEip) {
      res["is_bond_eip"] = boost::any(*isBondEip);
    }
    if (maxInstances) {
      res["max_instances"] = boost::any(*maxInstances);
    }
    if (minInstances) {
      res["min_instances"] = boost::any(*minInstances);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eip_bandwidth") != m.end() && !m["eip_bandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["eip_bandwidth"]));
    }
    if (m.find("eip_internet_charge_type") != m.end() && !m["eip_internet_charge_type"].empty()) {
      eipInternetChargeType = make_shared<string>(boost::any_cast<string>(m["eip_internet_charge_type"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("is_bond_eip") != m.end() && !m["is_bond_eip"].empty()) {
      isBondEip = make_shared<bool>(boost::any_cast<bool>(m["is_bond_eip"]));
    }
    if (m.find("max_instances") != m.end() && !m["max_instances"].empty()) {
      maxInstances = make_shared<long>(boost::any_cast<long>(m["max_instances"]));
    }
    if (m.find("min_instances") != m.end() && !m["min_instances"].empty()) {
      minInstances = make_shared<long>(boost::any_cast<long>(m["min_instances"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestAutoScaling() = default;
};
class CreateClusterNodePoolRequestEfloNodeGroup : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> groupId{};

  CreateClusterNodePoolRequestEfloNodeGroup() {}

  explicit CreateClusterNodePoolRequestEfloNodeGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (groupId) {
      res["group_id"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("group_id") != m.end() && !m["group_id"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["group_id"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestEfloNodeGroup() = default;
};
class CreateClusterNodePoolRequestInterconnectConfig : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> ccnId{};
  shared_ptr<string> ccnRegionId{};
  shared_ptr<string> cenId{};
  shared_ptr<string> improvedPeriod{};

  CreateClusterNodePoolRequestInterconnectConfig() {}

  explicit CreateClusterNodePoolRequestInterconnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["bandwidth"] = boost::any(*bandwidth);
    }
    if (ccnId) {
      res["ccn_id"] = boost::any(*ccnId);
    }
    if (ccnRegionId) {
      res["ccn_region_id"] = boost::any(*ccnRegionId);
    }
    if (cenId) {
      res["cen_id"] = boost::any(*cenId);
    }
    if (improvedPeriod) {
      res["improved_period"] = boost::any(*improvedPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bandwidth") != m.end() && !m["bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["bandwidth"]));
    }
    if (m.find("ccn_id") != m.end() && !m["ccn_id"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["ccn_id"]));
    }
    if (m.find("ccn_region_id") != m.end() && !m["ccn_region_id"].empty()) {
      ccnRegionId = make_shared<string>(boost::any_cast<string>(m["ccn_region_id"]));
    }
    if (m.find("cen_id") != m.end() && !m["cen_id"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["cen_id"]));
    }
    if (m.find("improved_period") != m.end() && !m["improved_period"].empty()) {
      improvedPeriod = make_shared<string>(boost::any_cast<string>(m["improved_period"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestInterconnectConfig() = default;
};
class CreateClusterNodePoolRequestKubernetesConfig : public Darabonba::Model {
public:
  shared_ptr<bool> cmsEnabled{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<vector<Tag>> labels{};
  shared_ptr<string> nodeNameMode{};
  shared_ptr<string> preUserData{};
  shared_ptr<string> runtime{};
  shared_ptr<string> runtimeVersion{};
  shared_ptr<vector<Taint>> taints{};
  shared_ptr<bool> unschedulable{};
  shared_ptr<string> userData{};

  CreateClusterNodePoolRequestKubernetesConfig() {}

  explicit CreateClusterNodePoolRequestKubernetesConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cmsEnabled) {
      res["cms_enabled"] = boost::any(*cmsEnabled);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["labels"] = boost::any(temp1);
    }
    if (nodeNameMode) {
      res["node_name_mode"] = boost::any(*nodeNameMode);
    }
    if (preUserData) {
      res["pre_user_data"] = boost::any(*preUserData);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (runtimeVersion) {
      res["runtime_version"] = boost::any(*runtimeVersion);
    }
    if (taints) {
      vector<boost::any> temp1;
      for(auto item1:*taints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["taints"] = boost::any(temp1);
    }
    if (unschedulable) {
      res["unschedulable"] = boost::any(*unschedulable);
    }
    if (userData) {
      res["user_data"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cms_enabled") != m.end() && !m["cms_enabled"].empty()) {
      cmsEnabled = make_shared<bool>(boost::any_cast<bool>(m["cms_enabled"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("labels") != m.end() && !m["labels"].empty()) {
      if (typeid(vector<boost::any>) == m["labels"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("node_name_mode") != m.end() && !m["node_name_mode"].empty()) {
      nodeNameMode = make_shared<string>(boost::any_cast<string>(m["node_name_mode"]));
    }
    if (m.find("pre_user_data") != m.end() && !m["pre_user_data"].empty()) {
      preUserData = make_shared<string>(boost::any_cast<string>(m["pre_user_data"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("runtime_version") != m.end() && !m["runtime_version"].empty()) {
      runtimeVersion = make_shared<string>(boost::any_cast<string>(m["runtime_version"]));
    }
    if (m.find("taints") != m.end() && !m["taints"].empty()) {
      if (typeid(vector<boost::any>) == m["taints"].type()) {
        vector<Taint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["taints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Taint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taints = make_shared<vector<Taint>>(expect1);
      }
    }
    if (m.find("unschedulable") != m.end() && !m["unschedulable"].empty()) {
      unschedulable = make_shared<bool>(boost::any_cast<bool>(m["unschedulable"]));
    }
    if (m.find("user_data") != m.end() && !m["user_data"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["user_data"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestKubernetesConfig() = default;
};
class CreateClusterNodePoolRequestManagementAutoRepairPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> approvalRequired{};
  shared_ptr<bool> restartNode{};

  CreateClusterNodePoolRequestManagementAutoRepairPolicy() {}

  explicit CreateClusterNodePoolRequestManagementAutoRepairPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalRequired) {
      res["approval_required"] = boost::any(*approvalRequired);
    }
    if (restartNode) {
      res["restart_node"] = boost::any(*restartNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("approval_required") != m.end() && !m["approval_required"].empty()) {
      approvalRequired = make_shared<bool>(boost::any_cast<bool>(m["approval_required"]));
    }
    if (m.find("restart_node") != m.end() && !m["restart_node"].empty()) {
      restartNode = make_shared<bool>(boost::any_cast<bool>(m["restart_node"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestManagementAutoRepairPolicy() = default;
};
class CreateClusterNodePoolRequestManagementAutoUpgradePolicy : public Darabonba::Model {
public:
  shared_ptr<bool> autoUpgradeKubelet{};
  shared_ptr<bool> autoUpgradeOs{};
  shared_ptr<bool> autoUpgradeRuntime{};

  CreateClusterNodePoolRequestManagementAutoUpgradePolicy() {}

  explicit CreateClusterNodePoolRequestManagementAutoUpgradePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpgradeKubelet) {
      res["auto_upgrade_kubelet"] = boost::any(*autoUpgradeKubelet);
    }
    if (autoUpgradeOs) {
      res["auto_upgrade_os"] = boost::any(*autoUpgradeOs);
    }
    if (autoUpgradeRuntime) {
      res["auto_upgrade_runtime"] = boost::any(*autoUpgradeRuntime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_upgrade_kubelet") != m.end() && !m["auto_upgrade_kubelet"].empty()) {
      autoUpgradeKubelet = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade_kubelet"]));
    }
    if (m.find("auto_upgrade_os") != m.end() && !m["auto_upgrade_os"].empty()) {
      autoUpgradeOs = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade_os"]));
    }
    if (m.find("auto_upgrade_runtime") != m.end() && !m["auto_upgrade_runtime"].empty()) {
      autoUpgradeRuntime = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade_runtime"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestManagementAutoUpgradePolicy() = default;
};
class CreateClusterNodePoolRequestManagementAutoVulFixPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> restartNode{};
  shared_ptr<string> vulLevel{};

  CreateClusterNodePoolRequestManagementAutoVulFixPolicy() {}

  explicit CreateClusterNodePoolRequestManagementAutoVulFixPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (restartNode) {
      res["restart_node"] = boost::any(*restartNode);
    }
    if (vulLevel) {
      res["vul_level"] = boost::any(*vulLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("restart_node") != m.end() && !m["restart_node"].empty()) {
      restartNode = make_shared<bool>(boost::any_cast<bool>(m["restart_node"]));
    }
    if (m.find("vul_level") != m.end() && !m["vul_level"].empty()) {
      vulLevel = make_shared<string>(boost::any_cast<string>(m["vul_level"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestManagementAutoVulFixPolicy() = default;
};
class CreateClusterNodePoolRequestManagementUpgradeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoUpgrade{};
  shared_ptr<long> maxUnavailable{};
  shared_ptr<long> surge{};
  shared_ptr<long> surgePercentage{};

  CreateClusterNodePoolRequestManagementUpgradeConfig() {}

  explicit CreateClusterNodePoolRequestManagementUpgradeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpgrade) {
      res["auto_upgrade"] = boost::any(*autoUpgrade);
    }
    if (maxUnavailable) {
      res["max_unavailable"] = boost::any(*maxUnavailable);
    }
    if (surge) {
      res["surge"] = boost::any(*surge);
    }
    if (surgePercentage) {
      res["surge_percentage"] = boost::any(*surgePercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_upgrade") != m.end() && !m["auto_upgrade"].empty()) {
      autoUpgrade = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade"]));
    }
    if (m.find("max_unavailable") != m.end() && !m["max_unavailable"].empty()) {
      maxUnavailable = make_shared<long>(boost::any_cast<long>(m["max_unavailable"]));
    }
    if (m.find("surge") != m.end() && !m["surge"].empty()) {
      surge = make_shared<long>(boost::any_cast<long>(m["surge"]));
    }
    if (m.find("surge_percentage") != m.end() && !m["surge_percentage"].empty()) {
      surgePercentage = make_shared<long>(boost::any_cast<long>(m["surge_percentage"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestManagementUpgradeConfig() = default;
};
class CreateClusterNodePoolRequestManagement : public Darabonba::Model {
public:
  shared_ptr<bool> autoRepair{};
  shared_ptr<CreateClusterNodePoolRequestManagementAutoRepairPolicy> autoRepairPolicy{};
  shared_ptr<bool> autoUpgrade{};
  shared_ptr<CreateClusterNodePoolRequestManagementAutoUpgradePolicy> autoUpgradePolicy{};
  shared_ptr<bool> autoVulFix{};
  shared_ptr<CreateClusterNodePoolRequestManagementAutoVulFixPolicy> autoVulFixPolicy{};
  shared_ptr<bool> enable{};
  shared_ptr<CreateClusterNodePoolRequestManagementUpgradeConfig> upgradeConfig{};

  CreateClusterNodePoolRequestManagement() {}

  explicit CreateClusterNodePoolRequestManagement(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRepair) {
      res["auto_repair"] = boost::any(*autoRepair);
    }
    if (autoRepairPolicy) {
      res["auto_repair_policy"] = autoRepairPolicy ? boost::any(autoRepairPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoUpgrade) {
      res["auto_upgrade"] = boost::any(*autoUpgrade);
    }
    if (autoUpgradePolicy) {
      res["auto_upgrade_policy"] = autoUpgradePolicy ? boost::any(autoUpgradePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoVulFix) {
      res["auto_vul_fix"] = boost::any(*autoVulFix);
    }
    if (autoVulFixPolicy) {
      res["auto_vul_fix_policy"] = autoVulFixPolicy ? boost::any(autoVulFixPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (upgradeConfig) {
      res["upgrade_config"] = upgradeConfig ? boost::any(upgradeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_repair") != m.end() && !m["auto_repair"].empty()) {
      autoRepair = make_shared<bool>(boost::any_cast<bool>(m["auto_repair"]));
    }
    if (m.find("auto_repair_policy") != m.end() && !m["auto_repair_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_repair_policy"].type()) {
        CreateClusterNodePoolRequestManagementAutoRepairPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_repair_policy"]));
        autoRepairPolicy = make_shared<CreateClusterNodePoolRequestManagementAutoRepairPolicy>(model1);
      }
    }
    if (m.find("auto_upgrade") != m.end() && !m["auto_upgrade"].empty()) {
      autoUpgrade = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade"]));
    }
    if (m.find("auto_upgrade_policy") != m.end() && !m["auto_upgrade_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_upgrade_policy"].type()) {
        CreateClusterNodePoolRequestManagementAutoUpgradePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_upgrade_policy"]));
        autoUpgradePolicy = make_shared<CreateClusterNodePoolRequestManagementAutoUpgradePolicy>(model1);
      }
    }
    if (m.find("auto_vul_fix") != m.end() && !m["auto_vul_fix"].empty()) {
      autoVulFix = make_shared<bool>(boost::any_cast<bool>(m["auto_vul_fix"]));
    }
    if (m.find("auto_vul_fix_policy") != m.end() && !m["auto_vul_fix_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_vul_fix_policy"].type()) {
        CreateClusterNodePoolRequestManagementAutoVulFixPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_vul_fix_policy"]));
        autoVulFixPolicy = make_shared<CreateClusterNodePoolRequestManagementAutoVulFixPolicy>(model1);
      }
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("upgrade_config") != m.end() && !m["upgrade_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_config"].type()) {
        CreateClusterNodePoolRequestManagementUpgradeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_config"]));
        upgradeConfig = make_shared<CreateClusterNodePoolRequestManagementUpgradeConfig>(model1);
      }
    }
  }


  virtual ~CreateClusterNodePoolRequestManagement() = default;
};
class CreateClusterNodePoolRequestNodeConfig : public Darabonba::Model {
public:
  shared_ptr<KubeletConfig> kubeletConfiguration{};

  CreateClusterNodePoolRequestNodeConfig() {}

  explicit CreateClusterNodePoolRequestNodeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kubeletConfiguration) {
      res["kubelet_configuration"] = kubeletConfiguration ? boost::any(kubeletConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("kubelet_configuration") != m.end() && !m["kubelet_configuration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kubelet_configuration"].type()) {
        KubeletConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kubelet_configuration"]));
        kubeletConfiguration = make_shared<KubeletConfig>(model1);
      }
    }
  }


  virtual ~CreateClusterNodePoolRequestNodeConfig() = default;
};
class CreateClusterNodePoolRequestNodepoolInfo : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> type{};

  CreateClusterNodePoolRequestNodepoolInfo() {}

  explicit CreateClusterNodePoolRequestNodepoolInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestNodepoolInfo() = default;
};
class CreateClusterNodePoolRequestScalingGroupPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  CreateClusterNodePoolRequestScalingGroupPrivatePoolOptions() {}

  explicit CreateClusterNodePoolRequestScalingGroupPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["match_criteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("match_criteria") != m.end() && !m["match_criteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["match_criteria"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestScalingGroupPrivatePoolOptions() = default;
};
class CreateClusterNodePoolRequestScalingGroupSpotPriceLimit : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> priceLimit{};

  CreateClusterNodePoolRequestScalingGroupSpotPriceLimit() {}

  explicit CreateClusterNodePoolRequestScalingGroupSpotPriceLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["instance_type"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["price_limit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instance_type") != m.end() && !m["instance_type"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instance_type"]));
    }
    if (m.find("price_limit") != m.end() && !m["price_limit"].empty()) {
      priceLimit = make_shared<string>(boost::any_cast<string>(m["price_limit"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestScalingGroupSpotPriceLimit() = default;
};
class CreateClusterNodePoolRequestScalingGroupTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateClusterNodePoolRequestScalingGroupTags() {}

  explicit CreateClusterNodePoolRequestScalingGroupTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestScalingGroupTags() = default;
};
class CreateClusterNodePoolRequestScalingGroup : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<bool> cisEnabled{};
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<vector<DataDisk>> dataDisks{};
  shared_ptr<string> deploymentsetId{};
  shared_ptr<long> desiredSize{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<InstanceMetadataOptions> instanceMetadataOptions{};
  shared_ptr<vector<InstancePatterns>> instancePatterns{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> keyPair{};
  shared_ptr<bool> loginAsNonRoot{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> multiAzPolicy{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> platform{};
  shared_ptr<CreateClusterNodePoolRequestScalingGroupPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<vector<string>> rdsInstances{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<bool> securityHardeningOs{};
  shared_ptr<bool> socEnabled{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<vector<CreateClusterNodePoolRequestScalingGroupSpotPriceLimit>> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<bool> systemDiskBurstingEnabled{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskEncryptAlgorithm{};
  shared_ptr<bool> systemDiskEncrypted{};
  shared_ptr<string> systemDiskKmsKeyId{};
  shared_ptr<string> systemDiskPerformanceLevel{};
  shared_ptr<long> systemDiskProvisionedIops{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<vector<CreateClusterNodePoolRequestScalingGroupTags>> tags{};
  shared_ptr<vector<string>> vswitchIds{};

  CreateClusterNodePoolRequestScalingGroup() {}

  explicit CreateClusterNodePoolRequestScalingGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["auto_renew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["auto_renew_period"] = boost::any(*autoRenewPeriod);
    }
    if (cisEnabled) {
      res["cis_enabled"] = boost::any(*cisEnabled);
    }
    if (compensateWithOnDemand) {
      res["compensate_with_on_demand"] = boost::any(*compensateWithOnDemand);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_disks"] = boost::any(temp1);
    }
    if (deploymentsetId) {
      res["deploymentset_id"] = boost::any(*deploymentsetId);
    }
    if (desiredSize) {
      res["desired_size"] = boost::any(*desiredSize);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (imageType) {
      res["image_type"] = boost::any(*imageType);
    }
    if (instanceChargeType) {
      res["instance_charge_type"] = boost::any(*instanceChargeType);
    }
    if (instanceMetadataOptions) {
      res["instance_metadata_options"] = instanceMetadataOptions ? boost::any(instanceMetadataOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instancePatterns) {
      vector<boost::any> temp1;
      for(auto item1:*instancePatterns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["instance_patterns"] = boost::any(temp1);
    }
    if (instanceTypes) {
      res["instance_types"] = boost::any(*instanceTypes);
    }
    if (internetChargeType) {
      res["internet_charge_type"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["internet_max_bandwidth_out"] = boost::any(*internetMaxBandwidthOut);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (loginAsNonRoot) {
      res["login_as_non_root"] = boost::any(*loginAsNonRoot);
    }
    if (loginPassword) {
      res["login_password"] = boost::any(*loginPassword);
    }
    if (multiAzPolicy) {
      res["multi_az_policy"] = boost::any(*multiAzPolicy);
    }
    if (onDemandBaseCapacity) {
      res["on_demand_base_capacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["on_demand_percentage_above_base_capacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["period_unit"] = boost::any(*periodUnit);
    }
    if (platform) {
      res["platform"] = boost::any(*platform);
    }
    if (privatePoolOptions) {
      res["private_pool_options"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ramRoleName) {
      res["ram_role_name"] = boost::any(*ramRoleName);
    }
    if (rdsInstances) {
      res["rds_instances"] = boost::any(*rdsInstances);
    }
    if (scalingPolicy) {
      res["scaling_policy"] = boost::any(*scalingPolicy);
    }
    if (securityGroupId) {
      res["security_group_id"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["security_group_ids"] = boost::any(*securityGroupIds);
    }
    if (securityHardeningOs) {
      res["security_hardening_os"] = boost::any(*securityHardeningOs);
    }
    if (socEnabled) {
      res["soc_enabled"] = boost::any(*socEnabled);
    }
    if (spotInstancePools) {
      res["spot_instance_pools"] = boost::any(*spotInstancePools);
    }
    if (spotInstanceRemedy) {
      res["spot_instance_remedy"] = boost::any(*spotInstanceRemedy);
    }
    if (spotPriceLimit) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["spot_price_limit"] = boost::any(temp1);
    }
    if (spotStrategy) {
      res["spot_strategy"] = boost::any(*spotStrategy);
    }
    if (systemDiskBurstingEnabled) {
      res["system_disk_bursting_enabled"] = boost::any(*systemDiskBurstingEnabled);
    }
    if (systemDiskCategories) {
      res["system_disk_categories"] = boost::any(*systemDiskCategories);
    }
    if (systemDiskCategory) {
      res["system_disk_category"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskEncryptAlgorithm) {
      res["system_disk_encrypt_algorithm"] = boost::any(*systemDiskEncryptAlgorithm);
    }
    if (systemDiskEncrypted) {
      res["system_disk_encrypted"] = boost::any(*systemDiskEncrypted);
    }
    if (systemDiskKmsKeyId) {
      res["system_disk_kms_key_id"] = boost::any(*systemDiskKmsKeyId);
    }
    if (systemDiskPerformanceLevel) {
      res["system_disk_performance_level"] = boost::any(*systemDiskPerformanceLevel);
    }
    if (systemDiskProvisionedIops) {
      res["system_disk_provisioned_iops"] = boost::any(*systemDiskProvisionedIops);
    }
    if (systemDiskSize) {
      res["system_disk_size"] = boost::any(*systemDiskSize);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_renew") != m.end() && !m["auto_renew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["auto_renew"]));
    }
    if (m.find("auto_renew_period") != m.end() && !m["auto_renew_period"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["auto_renew_period"]));
    }
    if (m.find("cis_enabled") != m.end() && !m["cis_enabled"].empty()) {
      cisEnabled = make_shared<bool>(boost::any_cast<bool>(m["cis_enabled"]));
    }
    if (m.find("compensate_with_on_demand") != m.end() && !m["compensate_with_on_demand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["compensate_with_on_demand"]));
    }
    if (m.find("data_disks") != m.end() && !m["data_disks"].empty()) {
      if (typeid(vector<boost::any>) == m["data_disks"].type()) {
        vector<DataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DataDisk>>(expect1);
      }
    }
    if (m.find("deploymentset_id") != m.end() && !m["deploymentset_id"].empty()) {
      deploymentsetId = make_shared<string>(boost::any_cast<string>(m["deploymentset_id"]));
    }
    if (m.find("desired_size") != m.end() && !m["desired_size"].empty()) {
      desiredSize = make_shared<long>(boost::any_cast<long>(m["desired_size"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("image_type") != m.end() && !m["image_type"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["image_type"]));
    }
    if (m.find("instance_charge_type") != m.end() && !m["instance_charge_type"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["instance_charge_type"]));
    }
    if (m.find("instance_metadata_options") != m.end() && !m["instance_metadata_options"].empty()) {
      if (typeid(map<string, boost::any>) == m["instance_metadata_options"].type()) {
        InstanceMetadataOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["instance_metadata_options"]));
        instanceMetadataOptions = make_shared<InstanceMetadataOptions>(model1);
      }
    }
    if (m.find("instance_patterns") != m.end() && !m["instance_patterns"].empty()) {
      if (typeid(vector<boost::any>) == m["instance_patterns"].type()) {
        vector<InstancePatterns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["instance_patterns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstancePatterns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancePatterns = make_shared<vector<InstancePatterns>>(expect1);
      }
    }
    if (m.find("instance_types") != m.end() && !m["instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("internet_charge_type") != m.end() && !m["internet_charge_type"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["internet_charge_type"]));
    }
    if (m.find("internet_max_bandwidth_out") != m.end() && !m["internet_max_bandwidth_out"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["internet_max_bandwidth_out"]));
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("login_as_non_root") != m.end() && !m["login_as_non_root"].empty()) {
      loginAsNonRoot = make_shared<bool>(boost::any_cast<bool>(m["login_as_non_root"]));
    }
    if (m.find("login_password") != m.end() && !m["login_password"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["login_password"]));
    }
    if (m.find("multi_az_policy") != m.end() && !m["multi_az_policy"].empty()) {
      multiAzPolicy = make_shared<string>(boost::any_cast<string>(m["multi_az_policy"]));
    }
    if (m.find("on_demand_base_capacity") != m.end() && !m["on_demand_base_capacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["on_demand_base_capacity"]));
    }
    if (m.find("on_demand_percentage_above_base_capacity") != m.end() && !m["on_demand_percentage_above_base_capacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["on_demand_percentage_above_base_capacity"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("period_unit") != m.end() && !m["period_unit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["period_unit"]));
    }
    if (m.find("platform") != m.end() && !m["platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["platform"]));
    }
    if (m.find("private_pool_options") != m.end() && !m["private_pool_options"].empty()) {
      if (typeid(map<string, boost::any>) == m["private_pool_options"].type()) {
        CreateClusterNodePoolRequestScalingGroupPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["private_pool_options"]));
        privatePoolOptions = make_shared<CreateClusterNodePoolRequestScalingGroupPrivatePoolOptions>(model1);
      }
    }
    if (m.find("ram_role_name") != m.end() && !m["ram_role_name"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["ram_role_name"]));
    }
    if (m.find("rds_instances") != m.end() && !m["rds_instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["rds_instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["rds_instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rdsInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("scaling_policy") != m.end() && !m["scaling_policy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["scaling_policy"]));
    }
    if (m.find("security_group_id") != m.end() && !m["security_group_id"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["security_group_id"]));
    }
    if (m.find("security_group_ids") != m.end() && !m["security_group_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["security_group_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["security_group_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("security_hardening_os") != m.end() && !m["security_hardening_os"].empty()) {
      securityHardeningOs = make_shared<bool>(boost::any_cast<bool>(m["security_hardening_os"]));
    }
    if (m.find("soc_enabled") != m.end() && !m["soc_enabled"].empty()) {
      socEnabled = make_shared<bool>(boost::any_cast<bool>(m["soc_enabled"]));
    }
    if (m.find("spot_instance_pools") != m.end() && !m["spot_instance_pools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["spot_instance_pools"]));
    }
    if (m.find("spot_instance_remedy") != m.end() && !m["spot_instance_remedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["spot_instance_remedy"]));
    }
    if (m.find("spot_price_limit") != m.end() && !m["spot_price_limit"].empty()) {
      if (typeid(vector<boost::any>) == m["spot_price_limit"].type()) {
        vector<CreateClusterNodePoolRequestScalingGroupSpotPriceLimit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["spot_price_limit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterNodePoolRequestScalingGroupSpotPriceLimit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimit = make_shared<vector<CreateClusterNodePoolRequestScalingGroupSpotPriceLimit>>(expect1);
      }
    }
    if (m.find("spot_strategy") != m.end() && !m["spot_strategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["spot_strategy"]));
    }
    if (m.find("system_disk_bursting_enabled") != m.end() && !m["system_disk_bursting_enabled"].empty()) {
      systemDiskBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["system_disk_bursting_enabled"]));
    }
    if (m.find("system_disk_categories") != m.end() && !m["system_disk_categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["system_disk_categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["system_disk_categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("system_disk_category") != m.end() && !m["system_disk_category"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["system_disk_category"]));
    }
    if (m.find("system_disk_encrypt_algorithm") != m.end() && !m["system_disk_encrypt_algorithm"].empty()) {
      systemDiskEncryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["system_disk_encrypt_algorithm"]));
    }
    if (m.find("system_disk_encrypted") != m.end() && !m["system_disk_encrypted"].empty()) {
      systemDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["system_disk_encrypted"]));
    }
    if (m.find("system_disk_kms_key_id") != m.end() && !m["system_disk_kms_key_id"].empty()) {
      systemDiskKmsKeyId = make_shared<string>(boost::any_cast<string>(m["system_disk_kms_key_id"]));
    }
    if (m.find("system_disk_performance_level") != m.end() && !m["system_disk_performance_level"].empty()) {
      systemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["system_disk_performance_level"]));
    }
    if (m.find("system_disk_provisioned_iops") != m.end() && !m["system_disk_provisioned_iops"].empty()) {
      systemDiskProvisionedIops = make_shared<long>(boost::any_cast<long>(m["system_disk_provisioned_iops"]));
    }
    if (m.find("system_disk_size") != m.end() && !m["system_disk_size"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["system_disk_size"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<CreateClusterNodePoolRequestScalingGroupTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterNodePoolRequestScalingGroupTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateClusterNodePoolRequestScalingGroupTags>>(expect1);
      }
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateClusterNodePoolRequestScalingGroup() = default;
};
class CreateClusterNodePoolRequestTeeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> teeEnable{};

  CreateClusterNodePoolRequestTeeConfig() {}

  explicit CreateClusterNodePoolRequestTeeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (teeEnable) {
      res["tee_enable"] = boost::any(*teeEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tee_enable") != m.end() && !m["tee_enable"].empty()) {
      teeEnable = make_shared<bool>(boost::any_cast<bool>(m["tee_enable"]));
    }
  }


  virtual ~CreateClusterNodePoolRequestTeeConfig() = default;
};
class CreateClusterNodePoolRequest : public Darabonba::Model {
public:
  shared_ptr<CreateClusterNodePoolRequestAutoMode> autoMode{};
  shared_ptr<CreateClusterNodePoolRequestAutoScaling> autoScaling{};
  shared_ptr<long> count{};
  shared_ptr<CreateClusterNodePoolRequestEfloNodeGroup> efloNodeGroup{};
  shared_ptr<bool> hostNetwork{};
  shared_ptr<CreateClusterNodePoolRequestInterconnectConfig> interconnectConfig{};
  shared_ptr<string> interconnectMode{};
  shared_ptr<bool> intranet{};
  shared_ptr<CreateClusterNodePoolRequestKubernetesConfig> kubernetesConfig{};
  shared_ptr<CreateClusterNodePoolRequestManagement> management{};
  shared_ptr<long> maxNodes{};
  shared_ptr<CreateClusterNodePoolRequestNodeConfig> nodeConfig{};
  shared_ptr<CreateClusterNodePoolRequestNodepoolInfo> nodepoolInfo{};
  shared_ptr<CreateClusterNodePoolRequestScalingGroup> scalingGroup{};
  shared_ptr<CreateClusterNodePoolRequestTeeConfig> teeConfig{};

  CreateClusterNodePoolRequest() {}

  explicit CreateClusterNodePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoMode) {
      res["auto_mode"] = autoMode ? boost::any(autoMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoScaling) {
      res["auto_scaling"] = autoScaling ? boost::any(autoScaling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (efloNodeGroup) {
      res["eflo_node_group"] = efloNodeGroup ? boost::any(efloNodeGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostNetwork) {
      res["host_network"] = boost::any(*hostNetwork);
    }
    if (interconnectConfig) {
      res["interconnect_config"] = interconnectConfig ? boost::any(interconnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interconnectMode) {
      res["interconnect_mode"] = boost::any(*interconnectMode);
    }
    if (intranet) {
      res["intranet"] = boost::any(*intranet);
    }
    if (kubernetesConfig) {
      res["kubernetes_config"] = kubernetesConfig ? boost::any(kubernetesConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (management) {
      res["management"] = management ? boost::any(management->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxNodes) {
      res["max_nodes"] = boost::any(*maxNodes);
    }
    if (nodeConfig) {
      res["node_config"] = nodeConfig ? boost::any(nodeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodepoolInfo) {
      res["nodepool_info"] = nodepoolInfo ? boost::any(nodepoolInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scalingGroup) {
      res["scaling_group"] = scalingGroup ? boost::any(scalingGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (teeConfig) {
      res["tee_config"] = teeConfig ? boost::any(teeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_mode") != m.end() && !m["auto_mode"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_mode"].type()) {
        CreateClusterNodePoolRequestAutoMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_mode"]));
        autoMode = make_shared<CreateClusterNodePoolRequestAutoMode>(model1);
      }
    }
    if (m.find("auto_scaling") != m.end() && !m["auto_scaling"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_scaling"].type()) {
        CreateClusterNodePoolRequestAutoScaling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_scaling"]));
        autoScaling = make_shared<CreateClusterNodePoolRequestAutoScaling>(model1);
      }
    }
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("eflo_node_group") != m.end() && !m["eflo_node_group"].empty()) {
      if (typeid(map<string, boost::any>) == m["eflo_node_group"].type()) {
        CreateClusterNodePoolRequestEfloNodeGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["eflo_node_group"]));
        efloNodeGroup = make_shared<CreateClusterNodePoolRequestEfloNodeGroup>(model1);
      }
    }
    if (m.find("host_network") != m.end() && !m["host_network"].empty()) {
      hostNetwork = make_shared<bool>(boost::any_cast<bool>(m["host_network"]));
    }
    if (m.find("interconnect_config") != m.end() && !m["interconnect_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["interconnect_config"].type()) {
        CreateClusterNodePoolRequestInterconnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["interconnect_config"]));
        interconnectConfig = make_shared<CreateClusterNodePoolRequestInterconnectConfig>(model1);
      }
    }
    if (m.find("interconnect_mode") != m.end() && !m["interconnect_mode"].empty()) {
      interconnectMode = make_shared<string>(boost::any_cast<string>(m["interconnect_mode"]));
    }
    if (m.find("intranet") != m.end() && !m["intranet"].empty()) {
      intranet = make_shared<bool>(boost::any_cast<bool>(m["intranet"]));
    }
    if (m.find("kubernetes_config") != m.end() && !m["kubernetes_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["kubernetes_config"].type()) {
        CreateClusterNodePoolRequestKubernetesConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kubernetes_config"]));
        kubernetesConfig = make_shared<CreateClusterNodePoolRequestKubernetesConfig>(model1);
      }
    }
    if (m.find("management") != m.end() && !m["management"].empty()) {
      if (typeid(map<string, boost::any>) == m["management"].type()) {
        CreateClusterNodePoolRequestManagement model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["management"]));
        management = make_shared<CreateClusterNodePoolRequestManagement>(model1);
      }
    }
    if (m.find("max_nodes") != m.end() && !m["max_nodes"].empty()) {
      maxNodes = make_shared<long>(boost::any_cast<long>(m["max_nodes"]));
    }
    if (m.find("node_config") != m.end() && !m["node_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["node_config"].type()) {
        CreateClusterNodePoolRequestNodeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["node_config"]));
        nodeConfig = make_shared<CreateClusterNodePoolRequestNodeConfig>(model1);
      }
    }
    if (m.find("nodepool_info") != m.end() && !m["nodepool_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodepool_info"].type()) {
        CreateClusterNodePoolRequestNodepoolInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodepool_info"]));
        nodepoolInfo = make_shared<CreateClusterNodePoolRequestNodepoolInfo>(model1);
      }
    }
    if (m.find("scaling_group") != m.end() && !m["scaling_group"].empty()) {
      if (typeid(map<string, boost::any>) == m["scaling_group"].type()) {
        CreateClusterNodePoolRequestScalingGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["scaling_group"]));
        scalingGroup = make_shared<CreateClusterNodePoolRequestScalingGroup>(model1);
      }
    }
    if (m.find("tee_config") != m.end() && !m["tee_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["tee_config"].type()) {
        CreateClusterNodePoolRequestTeeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tee_config"]));
        teeConfig = make_shared<CreateClusterNodePoolRequestTeeConfig>(model1);
      }
    }
  }


  virtual ~CreateClusterNodePoolRequest() = default;
};
class CreateClusterNodePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateClusterNodePoolResponseBody() {}

  explicit CreateClusterNodePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~CreateClusterNodePoolResponseBody() = default;
};
class CreateClusterNodePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterNodePoolResponseBody> body{};

  CreateClusterNodePoolResponse() {}

  explicit CreateClusterNodePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterNodePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterNodePoolResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterNodePoolResponse() = default;
};
class CreateEdgeMachineRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostname{};
  shared_ptr<string> model{};
  shared_ptr<string> sn{};

  CreateEdgeMachineRequest() {}

  explicit CreateEdgeMachineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostname) {
      res["hostname"] = boost::any(*hostname);
    }
    if (model) {
      res["model"] = boost::any(*model);
    }
    if (sn) {
      res["sn"] = boost::any(*sn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hostname") != m.end() && !m["hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["hostname"]));
    }
    if (m.find("model") != m.end() && !m["model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["model"]));
    }
    if (m.find("sn") != m.end() && !m["sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["sn"]));
    }
  }


  virtual ~CreateEdgeMachineRequest() = default;
};
class CreateEdgeMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> edgeMachineId{};
  shared_ptr<string> requestId{};

  CreateEdgeMachineResponseBody() {}

  explicit CreateEdgeMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edgeMachineId) {
      res["edge_machine_id"] = boost::any(*edgeMachineId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("edge_machine_id") != m.end() && !m["edge_machine_id"].empty()) {
      edgeMachineId = make_shared<string>(boost::any_cast<string>(m["edge_machine_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
  }


  virtual ~CreateEdgeMachineResponseBody() = default;
};
class CreateEdgeMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeMachineResponseBody> body{};

  CreateEdgeMachineResponse() {}

  explicit CreateEdgeMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeMachineResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeMachineResponse() = default;
};
class CreateKubernetesTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> type{};

  CreateKubernetesTriggerRequest() {}

  explicit CreateKubernetesTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["project_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateKubernetesTriggerRequest() = default;
};
class CreateKubernetesTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> type{};

  CreateKubernetesTriggerResponseBody() {}

  explicit CreateKubernetesTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["project_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateKubernetesTriggerResponseBody() = default;
};
class CreateKubernetesTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateKubernetesTriggerResponseBody> body{};

  CreateKubernetesTriggerResponse() {}

  explicit CreateKubernetesTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateKubernetesTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateKubernetesTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateKubernetesTriggerResponse() = default;
};
class CreateTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};

  CreateTemplateRequest() {}

  explicit CreateTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (template_) {
      res["template"] = boost::any(*template_);
    }
    if (templateType) {
      res["template_type"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["template"]));
    }
    if (m.find("template_type") != m.end() && !m["template_type"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["template_type"]));
    }
  }


  virtual ~CreateTemplateRequest() = default;
};
class CreateTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  CreateTemplateResponseBody() {}

  explicit CreateTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["template_id"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("template_id") != m.end() && !m["template_id"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["template_id"]));
    }
  }


  virtual ~CreateTemplateResponseBody() = default;
};
class CreateTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTemplateResponseBody> body{};

  CreateTemplateResponse() {}

  explicit CreateTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTemplateResponse() = default;
};
class CreateTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> type{};

  CreateTriggerRequest() {}

  explicit CreateTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["project_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateTriggerRequest() = default;
};
class CreateTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> type{};

  CreateTriggerResponseBody() {}

  explicit CreateTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["project_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateTriggerResponseBody() = default;
};
class CreateTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTriggerResponseBody> body{};

  CreateTriggerResponse() {}

  explicit CreateTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTriggerResponse() = default;
};
class DeleteAlertContactRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> contactIds{};

  DeleteAlertContactRequest() {}

  explicit DeleteAlertContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["contact_ids"] = boost::any(*contactIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact_ids") != m.end() && !m["contact_ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["contact_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["contact_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      contactIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DeleteAlertContactRequest() = default;
};
class DeleteAlertContactShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactIdsShrink{};

  DeleteAlertContactShrinkRequest() {}

  explicit DeleteAlertContactShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIdsShrink) {
      res["contact_ids"] = boost::any(*contactIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact_ids") != m.end() && !m["contact_ids"].empty()) {
      contactIdsShrink = make_shared<string>(boost::any_cast<string>(m["contact_ids"]));
    }
  }


  virtual ~DeleteAlertContactShrinkRequest() = default;
};
class DeleteAlertContactResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> status{};
  shared_ptr<string> msg{};
  shared_ptr<string> contactId{};

  DeleteAlertContactResponseBodyResult() {}

  explicit DeleteAlertContactResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (contactId) {
      res["contact_id"] = boost::any(*contactId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["status"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("contact_id") != m.end() && !m["contact_id"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["contact_id"]));
    }
  }


  virtual ~DeleteAlertContactResponseBodyResult() = default;
};
class DeleteAlertContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteAlertContactResponseBodyResult>> result{};

  DeleteAlertContactResponseBody() {}

  explicit DeleteAlertContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<DeleteAlertContactResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteAlertContactResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DeleteAlertContactResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DeleteAlertContactResponseBody() = default;
};
class DeleteAlertContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertContactResponseBody> body{};

  DeleteAlertContactResponse() {}

  explicit DeleteAlertContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertContactResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertContactResponse() = default;
};
class DeleteAlertContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> contactGroupIds{};

  DeleteAlertContactGroupRequest() {}

  explicit DeleteAlertContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupIds) {
      res["contact_group_ids"] = boost::any(*contactGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact_group_ids") != m.end() && !m["contact_group_ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["contact_group_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["contact_group_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      contactGroupIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DeleteAlertContactGroupRequest() = default;
};
class DeleteAlertContactGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupIdsShrink{};

  DeleteAlertContactGroupShrinkRequest() {}

  explicit DeleteAlertContactGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupIdsShrink) {
      res["contact_group_ids"] = boost::any(*contactGroupIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact_group_ids") != m.end() && !m["contact_group_ids"].empty()) {
      contactGroupIdsShrink = make_shared<string>(boost::any_cast<string>(m["contact_group_ids"]));
    }
  }


  virtual ~DeleteAlertContactGroupShrinkRequest() = default;
};
class DeleteAlertContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> status{};
  shared_ptr<string> msg{};
  shared_ptr<string> contactGroupId{};

  DeleteAlertContactGroupResponseBody() {}

  explicit DeleteAlertContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (contactGroupId) {
      res["contact_group_id"] = boost::any(*contactGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["status"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("contact_group_id") != m.end() && !m["contact_group_id"].empty()) {
      contactGroupId = make_shared<string>(boost::any_cast<string>(m["contact_group_id"]));
    }
  }


  virtual ~DeleteAlertContactGroupResponseBody() = default;
};
class DeleteAlertContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<DeleteAlertContactGroupResponseBody>> body{};

  DeleteAlertContactGroupResponse() {}

  explicit DeleteAlertContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<DeleteAlertContactGroupResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteAlertContactGroupResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<DeleteAlertContactGroupResponseBody>>(expect1);
      }
    }
  }


  virtual ~DeleteAlertContactGroupResponse() = default;
};
class DeleteClusterRequestDeleteOptions : public Darabonba::Model {
public:
  shared_ptr<string> deleteMode{};
  shared_ptr<string> resourceType{};

  DeleteClusterRequestDeleteOptions() {}

  explicit DeleteClusterRequestDeleteOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteMode) {
      res["delete_mode"] = boost::any(*deleteMode);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("delete_mode") != m.end() && !m["delete_mode"].empty()) {
      deleteMode = make_shared<string>(boost::any_cast<string>(m["delete_mode"]));
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
  }


  virtual ~DeleteClusterRequestDeleteOptions() = default;
};
class DeleteClusterRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteClusterRequestDeleteOptions>> deleteOptions{};
  shared_ptr<bool> keepSlb{};
  shared_ptr<bool> retainAllResources{};
  shared_ptr<vector<string>> retainResources{};

  DeleteClusterRequest() {}

  explicit DeleteClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteOptions) {
      vector<boost::any> temp1;
      for(auto item1:*deleteOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["delete_options"] = boost::any(temp1);
    }
    if (keepSlb) {
      res["keep_slb"] = boost::any(*keepSlb);
    }
    if (retainAllResources) {
      res["retain_all_resources"] = boost::any(*retainAllResources);
    }
    if (retainResources) {
      res["retain_resources"] = boost::any(*retainResources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("delete_options") != m.end() && !m["delete_options"].empty()) {
      if (typeid(vector<boost::any>) == m["delete_options"].type()) {
        vector<DeleteClusterRequestDeleteOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["delete_options"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteClusterRequestDeleteOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deleteOptions = make_shared<vector<DeleteClusterRequestDeleteOptions>>(expect1);
      }
    }
    if (m.find("keep_slb") != m.end() && !m["keep_slb"].empty()) {
      keepSlb = make_shared<bool>(boost::any_cast<bool>(m["keep_slb"]));
    }
    if (m.find("retain_all_resources") != m.end() && !m["retain_all_resources"].empty()) {
      retainAllResources = make_shared<bool>(boost::any_cast<bool>(m["retain_all_resources"]));
    }
    if (m.find("retain_resources") != m.end() && !m["retain_resources"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["retain_resources"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["retain_resources"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      retainResources = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteClusterRequest() = default;
};
class DeleteClusterShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteOptionsShrink{};
  shared_ptr<bool> keepSlb{};
  shared_ptr<bool> retainAllResources{};
  shared_ptr<string> retainResourcesShrink{};

  DeleteClusterShrinkRequest() {}

  explicit DeleteClusterShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteOptionsShrink) {
      res["delete_options"] = boost::any(*deleteOptionsShrink);
    }
    if (keepSlb) {
      res["keep_slb"] = boost::any(*keepSlb);
    }
    if (retainAllResources) {
      res["retain_all_resources"] = boost::any(*retainAllResources);
    }
    if (retainResourcesShrink) {
      res["retain_resources"] = boost::any(*retainResourcesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("delete_options") != m.end() && !m["delete_options"].empty()) {
      deleteOptionsShrink = make_shared<string>(boost::any_cast<string>(m["delete_options"]));
    }
    if (m.find("keep_slb") != m.end() && !m["keep_slb"].empty()) {
      keepSlb = make_shared<bool>(boost::any_cast<bool>(m["keep_slb"]));
    }
    if (m.find("retain_all_resources") != m.end() && !m["retain_all_resources"].empty()) {
      retainAllResources = make_shared<bool>(boost::any_cast<bool>(m["retain_all_resources"]));
    }
    if (m.find("retain_resources") != m.end() && !m["retain_resources"].empty()) {
      retainResourcesShrink = make_shared<string>(boost::any_cast<string>(m["retain_resources"]));
    }
  }


  virtual ~DeleteClusterShrinkRequest() = default;
};
class DeleteClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  DeleteClusterResponseBody() {}

  explicit DeleteClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~DeleteClusterResponseBody() = default;
};
class DeleteClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClusterResponseBody> body{};

  DeleteClusterResponse() {}

  explicit DeleteClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterResponse() = default;
};
class DeleteClusterInspectConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteClusterInspectConfigResponseBody() {}

  explicit DeleteClusterInspectConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteClusterInspectConfigResponseBody() = default;
};
class DeleteClusterInspectConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClusterInspectConfigResponseBody> body{};

  DeleteClusterInspectConfigResponse() {}

  explicit DeleteClusterInspectConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterInspectConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterInspectConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterInspectConfigResponse() = default;
};
class DeleteClusterNodepoolRequest : public Darabonba::Model {
public:
  shared_ptr<bool> force{};

  DeleteClusterNodepoolRequest() {}

  explicit DeleteClusterNodepoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("force") != m.end() && !m["force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["force"]));
    }
  }


  virtual ~DeleteClusterNodepoolRequest() = default;
};
class DeleteClusterNodepoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  DeleteClusterNodepoolResponseBody() {}

  explicit DeleteClusterNodepoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~DeleteClusterNodepoolResponseBody() = default;
};
class DeleteClusterNodepoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClusterNodepoolResponseBody> body{};

  DeleteClusterNodepoolResponse() {}

  explicit DeleteClusterNodepoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterNodepoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterNodepoolResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterNodepoolResponse() = default;
};
class DeleteClusterNodesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> drainNode{};
  shared_ptr<vector<string>> nodes{};
  shared_ptr<bool> releaseNode{};

  DeleteClusterNodesRequest() {}

  explicit DeleteClusterNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (drainNode) {
      res["drain_node"] = boost::any(*drainNode);
    }
    if (nodes) {
      res["nodes"] = boost::any(*nodes);
    }
    if (releaseNode) {
      res["release_node"] = boost::any(*releaseNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("drain_node") != m.end() && !m["drain_node"].empty()) {
      drainNode = make_shared<bool>(boost::any_cast<bool>(m["drain_node"]));
    }
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("release_node") != m.end() && !m["release_node"].empty()) {
      releaseNode = make_shared<bool>(boost::any_cast<bool>(m["release_node"]));
    }
  }


  virtual ~DeleteClusterNodesRequest() = default;
};
class DeleteClusterNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  DeleteClusterNodesResponseBody() {}

  explicit DeleteClusterNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~DeleteClusterNodesResponseBody() = default;
};
class DeleteClusterNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClusterNodesResponseBody> body{};

  DeleteClusterNodesResponse() {}

  explicit DeleteClusterNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterNodesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterNodesResponse() = default;
};
class DeleteEdgeMachineRequest : public Darabonba::Model {
public:
  shared_ptr<string> force{};

  DeleteEdgeMachineRequest() {}

  explicit DeleteEdgeMachineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("force") != m.end() && !m["force"].empty()) {
      force = make_shared<string>(boost::any_cast<string>(m["force"]));
    }
  }


  virtual ~DeleteEdgeMachineRequest() = default;
};
class DeleteEdgeMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  DeleteEdgeMachineResponse() {}

  explicit DeleteEdgeMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~DeleteEdgeMachineResponse() = default;
};
class DeleteKubernetesTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  DeleteKubernetesTriggerResponse() {}

  explicit DeleteKubernetesTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~DeleteKubernetesTriggerResponse() = default;
};
class DeletePolicyInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceName{};

  DeletePolicyInstanceRequest() {}

  explicit DeletePolicyInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceName) {
      res["instance_name"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instance_name") != m.end() && !m["instance_name"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["instance_name"]));
    }
  }


  virtual ~DeletePolicyInstanceRequest() = default;
};
class DeletePolicyInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instances{};

  DeletePolicyInstanceResponseBody() {}

  explicit DeletePolicyInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["instances"] = boost::any(*instances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instances") != m.end() && !m["instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instances = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeletePolicyInstanceResponseBody() = default;
};
class DeletePolicyInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePolicyInstanceResponseBody> body{};

  DeletePolicyInstanceResponse() {}

  explicit DeletePolicyInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePolicyInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePolicyInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePolicyInstanceResponse() = default;
};
class DeleteTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  DeleteTemplateResponse() {}

  explicit DeleteTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~DeleteTemplateResponse() = default;
};
class DeleteTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  DeleteTriggerResponse() {}

  explicit DeleteTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~DeleteTriggerResponse() = default;
};
class DeployPolicyInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<vector<string>> namespaces{};
  shared_ptr<map<string, boost::any>> parameters{};

  DeployPolicyInstanceRequest() {}

  explicit DeployPolicyInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (namespaces) {
      res["namespaces"] = boost::any(*namespaces);
    }
    if (parameters) {
      res["parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("namespaces") != m.end() && !m["namespaces"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["namespaces"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["namespaces"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      namespaces = make_shared<vector<string>>(toVec1);
    }
    if (m.find("parameters") != m.end() && !m["parameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["parameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      parameters = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DeployPolicyInstanceRequest() = default;
};
class DeployPolicyInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instances{};

  DeployPolicyInstanceResponseBody() {}

  explicit DeployPolicyInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["instances"] = boost::any(*instances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instances") != m.end() && !m["instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instances = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeployPolicyInstanceResponseBody() = default;
};
class DeployPolicyInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeployPolicyInstanceResponseBody> body{};

  DeployPolicyInstanceResponse() {}

  explicit DeployPolicyInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployPolicyInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployPolicyInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeployPolicyInstanceResponse() = default;
};
class DescribeAddonRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterSpec{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> clusterVersion{};
  shared_ptr<string> profile{};
  shared_ptr<string> regionId{};
  shared_ptr<string> version{};

  DescribeAddonRequest() {}

  explicit DescribeAddonRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (clusterSpec) {
      res["cluster_spec"] = boost::any(*clusterSpec);
    }
    if (clusterType) {
      res["cluster_type"] = boost::any(*clusterType);
    }
    if (clusterVersion) {
      res["cluster_version"] = boost::any(*clusterVersion);
    }
    if (profile) {
      res["profile"] = boost::any(*profile);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("cluster_spec") != m.end() && !m["cluster_spec"].empty()) {
      clusterSpec = make_shared<string>(boost::any_cast<string>(m["cluster_spec"]));
    }
    if (m.find("cluster_type") != m.end() && !m["cluster_type"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["cluster_type"]));
    }
    if (m.find("cluster_version") != m.end() && !m["cluster_version"].empty()) {
      clusterVersion = make_shared<string>(boost::any_cast<string>(m["cluster_version"]));
    }
    if (m.find("profile") != m.end() && !m["profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["profile"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~DescribeAddonRequest() = default;
};
class DescribeAddonResponseBodyNewerVersions : public Darabonba::Model {
public:
  shared_ptr<string> minimumClusterVersion{};
  shared_ptr<bool> upgradable{};
  shared_ptr<string> version{};

  DescribeAddonResponseBodyNewerVersions() {}

  explicit DescribeAddonResponseBodyNewerVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (minimumClusterVersion) {
      res["minimum_cluster_version"] = boost::any(*minimumClusterVersion);
    }
    if (upgradable) {
      res["upgradable"] = boost::any(*upgradable);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("minimum_cluster_version") != m.end() && !m["minimum_cluster_version"].empty()) {
      minimumClusterVersion = make_shared<string>(boost::any_cast<string>(m["minimum_cluster_version"]));
    }
    if (m.find("upgradable") != m.end() && !m["upgradable"].empty()) {
      upgradable = make_shared<bool>(boost::any_cast<bool>(m["upgradable"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~DescribeAddonResponseBodyNewerVersions() = default;
};
class DescribeAddonResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> architecture{};
  shared_ptr<string> category{};
  shared_ptr<string> configSchema{};
  shared_ptr<bool> installByDefault{};
  shared_ptr<bool> managed{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeAddonResponseBodyNewerVersions>> newerVersions{};
  shared_ptr<vector<string>> supportedActions{};
  shared_ptr<string> version{};

  DescribeAddonResponseBody() {}

  explicit DescribeAddonResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["architecture"] = boost::any(*architecture);
    }
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (configSchema) {
      res["config_schema"] = boost::any(*configSchema);
    }
    if (installByDefault) {
      res["install_by_default"] = boost::any(*installByDefault);
    }
    if (managed) {
      res["managed"] = boost::any(*managed);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (newerVersions) {
      vector<boost::any> temp1;
      for(auto item1:*newerVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["newer_versions"] = boost::any(temp1);
    }
    if (supportedActions) {
      res["supported_actions"] = boost::any(*supportedActions);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("architecture") != m.end() && !m["architecture"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["architecture"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["architecture"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      architecture = make_shared<vector<string>>(toVec1);
    }
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("config_schema") != m.end() && !m["config_schema"].empty()) {
      configSchema = make_shared<string>(boost::any_cast<string>(m["config_schema"]));
    }
    if (m.find("install_by_default") != m.end() && !m["install_by_default"].empty()) {
      installByDefault = make_shared<bool>(boost::any_cast<bool>(m["install_by_default"]));
    }
    if (m.find("managed") != m.end() && !m["managed"].empty()) {
      managed = make_shared<bool>(boost::any_cast<bool>(m["managed"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("newer_versions") != m.end() && !m["newer_versions"].empty()) {
      if (typeid(vector<boost::any>) == m["newer_versions"].type()) {
        vector<DescribeAddonResponseBodyNewerVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["newer_versions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAddonResponseBodyNewerVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        newerVersions = make_shared<vector<DescribeAddonResponseBodyNewerVersions>>(expect1);
      }
    }
    if (m.find("supported_actions") != m.end() && !m["supported_actions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supported_actions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supported_actions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~DescribeAddonResponseBody() = default;
};
class DescribeAddonResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAddonResponseBody> body{};

  DescribeAddonResponse() {}

  explicit DescribeAddonResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAddonResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAddonResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAddonResponse() = default;
};
class DescribeAddonsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterProfile{};
  shared_ptr<string> clusterSpec{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> clusterVersion{};
  shared_ptr<string> region{};

  DescribeAddonsRequest() {}

  explicit DescribeAddonsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterProfile) {
      res["cluster_profile"] = boost::any(*clusterProfile);
    }
    if (clusterSpec) {
      res["cluster_spec"] = boost::any(*clusterSpec);
    }
    if (clusterType) {
      res["cluster_type"] = boost::any(*clusterType);
    }
    if (clusterVersion) {
      res["cluster_version"] = boost::any(*clusterVersion);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_profile") != m.end() && !m["cluster_profile"].empty()) {
      clusterProfile = make_shared<string>(boost::any_cast<string>(m["cluster_profile"]));
    }
    if (m.find("cluster_spec") != m.end() && !m["cluster_spec"].empty()) {
      clusterSpec = make_shared<string>(boost::any_cast<string>(m["cluster_spec"]));
    }
    if (m.find("cluster_type") != m.end() && !m["cluster_type"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["cluster_type"]));
    }
    if (m.find("cluster_version") != m.end() && !m["cluster_version"].empty()) {
      clusterVersion = make_shared<string>(boost::any_cast<string>(m["cluster_version"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
  }


  virtual ~DescribeAddonsRequest() = default;
};
class DescribeAddonsResponseBodyComponentGroupsItems : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  DescribeAddonsResponseBodyComponentGroupsItems() {}

  explicit DescribeAddonsResponseBodyComponentGroupsItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeAddonsResponseBodyComponentGroupsItems() = default;
};
class DescribeAddonsResponseBodyComponentGroups : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<vector<DescribeAddonsResponseBodyComponentGroupsItems>> items{};

  DescribeAddonsResponseBodyComponentGroups() {}

  explicit DescribeAddonsResponseBodyComponentGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["group_name"] = boost::any(*groupName);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("group_name") != m.end() && !m["group_name"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["group_name"]));
    }
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<DescribeAddonsResponseBodyComponentGroupsItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAddonsResponseBodyComponentGroupsItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<DescribeAddonsResponseBodyComponentGroupsItems>>(expect1);
      }
    }
  }


  virtual ~DescribeAddonsResponseBodyComponentGroups() = default;
};
class DescribeAddonsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAddonsResponseBodyComponentGroups>> componentGroups{};
  shared_ptr<map<string, StandardComponentsValue>> standardComponents{};

  DescribeAddonsResponseBody() {}

  explicit DescribeAddonsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentGroups) {
      vector<boost::any> temp1;
      for(auto item1:*componentGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComponentGroups"] = boost::any(temp1);
    }
    if (standardComponents) {
      map<string, boost::any> temp1;
      for(auto item1:*standardComponents){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["StandardComponents"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentGroups") != m.end() && !m["ComponentGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ComponentGroups"].type()) {
        vector<DescribeAddonsResponseBodyComponentGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComponentGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAddonsResponseBodyComponentGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        componentGroups = make_shared<vector<DescribeAddonsResponseBodyComponentGroups>>(expect1);
      }
    }
    if (m.find("StandardComponents") != m.end() && !m["StandardComponents"].empty()) {
      if (typeid(map<string, boost::any>) == m["StandardComponents"].type()) {
        map<string, StandardComponentsValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["StandardComponents"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            StandardComponentsValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        standardComponents = make_shared<map<string, StandardComponentsValue>>(expect1);
      }
    }
  }


  virtual ~DescribeAddonsResponseBody() = default;
};
class DescribeAddonsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAddonsResponseBody> body{};

  DescribeAddonsResponse() {}

  explicit DescribeAddonsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAddonsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAddonsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAddonsResponse() = default;
};
class DescribeClusterAddonInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> version{};

  DescribeClusterAddonInstanceResponseBody() {}

  explicit DescribeClusterAddonInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~DescribeClusterAddonInstanceResponseBody() = default;
};
class DescribeClusterAddonInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterAddonInstanceResponseBody> body{};

  DescribeClusterAddonInstanceResponse() {}

  explicit DescribeClusterAddonInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterAddonInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterAddonInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterAddonInstanceResponse() = default;
};
class DescribeClusterAddonMetadataRequest : public Darabonba::Model {
public:
  shared_ptr<string> version{};

  DescribeClusterAddonMetadataRequest() {}

  explicit DescribeClusterAddonMetadataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~DescribeClusterAddonMetadataRequest() = default;
};
class DescribeClusterAddonMetadataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configSchema{};
  shared_ptr<string> name{};
  shared_ptr<string> version{};

  DescribeClusterAddonMetadataResponseBody() {}

  explicit DescribeClusterAddonMetadataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configSchema) {
      res["config_schema"] = boost::any(*configSchema);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config_schema") != m.end() && !m["config_schema"].empty()) {
      configSchema = make_shared<string>(boost::any_cast<string>(m["config_schema"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~DescribeClusterAddonMetadataResponseBody() = default;
};
class DescribeClusterAddonMetadataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterAddonMetadataResponseBody> body{};

  DescribeClusterAddonMetadataResponse() {}

  explicit DescribeClusterAddonMetadataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterAddonMetadataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterAddonMetadataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterAddonMetadataResponse() = default;
};
class DescribeClusterAddonUpgradeStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<map<string, boost::any>> body{};

  DescribeClusterAddonUpgradeStatusResponse() {}

  explicit DescribeClusterAddonUpgradeStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["body"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      body = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeClusterAddonUpgradeStatusResponse() = default;
};
class DescribeClusterAddonsUpgradeStatusRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentIds{};

  DescribeClusterAddonsUpgradeStatusRequest() {}

  explicit DescribeClusterAddonsUpgradeStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentIds) {
      res["componentIds"] = boost::any(*componentIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("componentIds") != m.end() && !m["componentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["componentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["componentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterAddonsUpgradeStatusRequest() = default;
};
class DescribeClusterAddonsUpgradeStatusShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> componentIdsShrink{};

  DescribeClusterAddonsUpgradeStatusShrinkRequest() {}

  explicit DescribeClusterAddonsUpgradeStatusShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentIdsShrink) {
      res["componentIds"] = boost::any(*componentIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("componentIds") != m.end() && !m["componentIds"].empty()) {
      componentIdsShrink = make_shared<string>(boost::any_cast<string>(m["componentIds"]));
    }
  }


  virtual ~DescribeClusterAddonsUpgradeStatusShrinkRequest() = default;
};
class DescribeClusterAddonsUpgradeStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<map<string, boost::any>> body{};

  DescribeClusterAddonsUpgradeStatusResponse() {}

  explicit DescribeClusterAddonsUpgradeStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["body"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      body = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeClusterAddonsUpgradeStatusResponse() = default;
};
class DescribeClusterAddonsVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<map<string, boost::any>> body{};

  DescribeClusterAddonsVersionResponse() {}

  explicit DescribeClusterAddonsVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["body"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      body = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeClusterAddonsVersionResponse() = default;
};
class DescribeClusterAttachScriptsRequest : public Darabonba::Model {
public:
  shared_ptr<string> arch{};
  shared_ptr<long> expired{};
  shared_ptr<bool> formatDisk{};
  shared_ptr<bool> keepInstanceName{};
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> options{};
  shared_ptr<vector<string>> rdsInstances{};

  DescribeClusterAttachScriptsRequest() {}

  explicit DescribeClusterAttachScriptsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arch) {
      res["arch"] = boost::any(*arch);
    }
    if (expired) {
      res["expired"] = boost::any(*expired);
    }
    if (formatDisk) {
      res["format_disk"] = boost::any(*formatDisk);
    }
    if (keepInstanceName) {
      res["keep_instance_name"] = boost::any(*keepInstanceName);
    }
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (options) {
      res["options"] = boost::any(*options);
    }
    if (rdsInstances) {
      res["rds_instances"] = boost::any(*rdsInstances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arch") != m.end() && !m["arch"].empty()) {
      arch = make_shared<string>(boost::any_cast<string>(m["arch"]));
    }
    if (m.find("expired") != m.end() && !m["expired"].empty()) {
      expired = make_shared<long>(boost::any_cast<long>(m["expired"]));
    }
    if (m.find("format_disk") != m.end() && !m["format_disk"].empty()) {
      formatDisk = make_shared<bool>(boost::any_cast<bool>(m["format_disk"]));
    }
    if (m.find("keep_instance_name") != m.end() && !m["keep_instance_name"].empty()) {
      keepInstanceName = make_shared<bool>(boost::any_cast<bool>(m["keep_instance_name"]));
    }
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("options") != m.end() && !m["options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["options"]));
    }
    if (m.find("rds_instances") != m.end() && !m["rds_instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["rds_instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["rds_instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rdsInstances = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterAttachScriptsRequest() = default;
};
class DescribeClusterAttachScriptsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<string> body{};

  DescribeClusterAttachScriptsResponse() {}

  explicit DescribeClusterAttachScriptsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~DescribeClusterAttachScriptsResponse() = default;
};
class DescribeClusterDetailResponseBodyAutoMode : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};

  DescribeClusterDetailResponseBodyAutoMode() {}

  explicit DescribeClusterDetailResponseBodyAutoMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
  }


  virtual ~DescribeClusterDetailResponseBodyAutoMode() = default;
};
class DescribeClusterDetailResponseBodyControlPlaneConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<string> chargeType{};
  shared_ptr<bool> cloudMonitorFlags{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<string> deploymentsetId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<InstanceMetadataOptions> instanceMetadataOptions{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> keyPair{};
  shared_ptr<string> nodePortRange{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> runtime{};
  shared_ptr<bool> securityHardeningOs{};
  shared_ptr<long> size{};
  shared_ptr<bool> socEnabled{};
  shared_ptr<bool> systemDiskBurstingEnabled{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskPerformanceLevel{};
  shared_ptr<long> systemDiskProvisionedIops{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<string> systemDiskSnapshotPolicyId{};

  DescribeClusterDetailResponseBodyControlPlaneConfig() {}

  explicit DescribeClusterDetailResponseBodyControlPlaneConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["auto_renew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["auto_renew_period"] = boost::any(*autoRenewPeriod);
    }
    if (chargeType) {
      res["charge_type"] = boost::any(*chargeType);
    }
    if (cloudMonitorFlags) {
      res["cloud_monitor_flags"] = boost::any(*cloudMonitorFlags);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (deploymentsetId) {
      res["deploymentset_id"] = boost::any(*deploymentsetId);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (imageType) {
      res["image_type"] = boost::any(*imageType);
    }
    if (instanceMetadataOptions) {
      res["instance_metadata_options"] = instanceMetadataOptions ? boost::any(instanceMetadataOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTypes) {
      res["instance_types"] = boost::any(*instanceTypes);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (nodePortRange) {
      res["node_port_range"] = boost::any(*nodePortRange);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["period_unit"] = boost::any(*periodUnit);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (securityHardeningOs) {
      res["security_hardening_os"] = boost::any(*securityHardeningOs);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (socEnabled) {
      res["soc_enabled"] = boost::any(*socEnabled);
    }
    if (systemDiskBurstingEnabled) {
      res["system_disk_bursting_enabled"] = boost::any(*systemDiskBurstingEnabled);
    }
    if (systemDiskCategory) {
      res["system_disk_category"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskPerformanceLevel) {
      res["system_disk_performance_level"] = boost::any(*systemDiskPerformanceLevel);
    }
    if (systemDiskProvisionedIops) {
      res["system_disk_provisioned_iops"] = boost::any(*systemDiskProvisionedIops);
    }
    if (systemDiskSize) {
      res["system_disk_size"] = boost::any(*systemDiskSize);
    }
    if (systemDiskSnapshotPolicyId) {
      res["system_disk_snapshot_policy_id"] = boost::any(*systemDiskSnapshotPolicyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_renew") != m.end() && !m["auto_renew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["auto_renew"]));
    }
    if (m.find("auto_renew_period") != m.end() && !m["auto_renew_period"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["auto_renew_period"]));
    }
    if (m.find("charge_type") != m.end() && !m["charge_type"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["charge_type"]));
    }
    if (m.find("cloud_monitor_flags") != m.end() && !m["cloud_monitor_flags"].empty()) {
      cloudMonitorFlags = make_shared<bool>(boost::any_cast<bool>(m["cloud_monitor_flags"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("deploymentset_id") != m.end() && !m["deploymentset_id"].empty()) {
      deploymentsetId = make_shared<string>(boost::any_cast<string>(m["deploymentset_id"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("image_type") != m.end() && !m["image_type"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["image_type"]));
    }
    if (m.find("instance_metadata_options") != m.end() && !m["instance_metadata_options"].empty()) {
      if (typeid(map<string, boost::any>) == m["instance_metadata_options"].type()) {
        InstanceMetadataOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["instance_metadata_options"]));
        instanceMetadataOptions = make_shared<InstanceMetadataOptions>(model1);
      }
    }
    if (m.find("instance_types") != m.end() && !m["instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("node_port_range") != m.end() && !m["node_port_range"].empty()) {
      nodePortRange = make_shared<string>(boost::any_cast<string>(m["node_port_range"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("period_unit") != m.end() && !m["period_unit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["period_unit"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("security_hardening_os") != m.end() && !m["security_hardening_os"].empty()) {
      securityHardeningOs = make_shared<bool>(boost::any_cast<bool>(m["security_hardening_os"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("soc_enabled") != m.end() && !m["soc_enabled"].empty()) {
      socEnabled = make_shared<bool>(boost::any_cast<bool>(m["soc_enabled"]));
    }
    if (m.find("system_disk_bursting_enabled") != m.end() && !m["system_disk_bursting_enabled"].empty()) {
      systemDiskBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["system_disk_bursting_enabled"]));
    }
    if (m.find("system_disk_category") != m.end() && !m["system_disk_category"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["system_disk_category"]));
    }
    if (m.find("system_disk_performance_level") != m.end() && !m["system_disk_performance_level"].empty()) {
      systemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["system_disk_performance_level"]));
    }
    if (m.find("system_disk_provisioned_iops") != m.end() && !m["system_disk_provisioned_iops"].empty()) {
      systemDiskProvisionedIops = make_shared<long>(boost::any_cast<long>(m["system_disk_provisioned_iops"]));
    }
    if (m.find("system_disk_size") != m.end() && !m["system_disk_size"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["system_disk_size"]));
    }
    if (m.find("system_disk_snapshot_policy_id") != m.end() && !m["system_disk_snapshot_policy_id"].empty()) {
      systemDiskSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["system_disk_snapshot_policy_id"]));
    }
  }


  virtual ~DescribeClusterDetailResponseBodyControlPlaneConfig() = default;
};
class DescribeClusterDetailResponseBodyOperationPolicyClusterAutoUpgrade : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<bool> enabled{};

  DescribeClusterDetailResponseBodyOperationPolicyClusterAutoUpgrade() {}

  explicit DescribeClusterDetailResponseBodyOperationPolicyClusterAutoUpgrade(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["channel"] = boost::any(*channel);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("channel") != m.end() && !m["channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["channel"]));
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
  }


  virtual ~DescribeClusterDetailResponseBodyOperationPolicyClusterAutoUpgrade() = default;
};
class DescribeClusterDetailResponseBodyOperationPolicy : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterDetailResponseBodyOperationPolicyClusterAutoUpgrade> clusterAutoUpgrade{};

  DescribeClusterDetailResponseBodyOperationPolicy() {}

  explicit DescribeClusterDetailResponseBodyOperationPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterAutoUpgrade) {
      res["cluster_auto_upgrade"] = clusterAutoUpgrade ? boost::any(clusterAutoUpgrade->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_auto_upgrade") != m.end() && !m["cluster_auto_upgrade"].empty()) {
      if (typeid(map<string, boost::any>) == m["cluster_auto_upgrade"].type()) {
        DescribeClusterDetailResponseBodyOperationPolicyClusterAutoUpgrade model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cluster_auto_upgrade"]));
        clusterAutoUpgrade = make_shared<DescribeClusterDetailResponseBodyOperationPolicyClusterAutoUpgrade>(model1);
      }
    }
  }


  virtual ~DescribeClusterDetailResponseBodyOperationPolicy() = default;
};
class DescribeClusterDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterDetailResponseBodyAutoMode> autoMode{};
  shared_ptr<string> clusterDomain{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterSpec{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> containerCidr{};
  shared_ptr<DescribeClusterDetailResponseBodyControlPlaneConfig> controlPlaneConfig{};
  shared_ptr<string> created{};
  shared_ptr<string> currentVersion{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> dockerVersion{};
  shared_ptr<string> externalLoadbalancerId{};
  shared_ptr<string> initVersion{};
  shared_ptr<string> ipStack{};
  shared_ptr<MaintenanceWindow> maintenanceWindow{};
  shared_ptr<string> masterUrl{};
  shared_ptr<string> metaData{};
  shared_ptr<string> name{};
  shared_ptr<string> networkMode{};
  shared_ptr<string> nextVersion{};
  shared_ptr<string> nodeCidrMask{};
  shared_ptr<DescribeClusterDetailResponseBodyOperationPolicy> operationPolicy{};
  shared_ptr<map<string, string>> parameters{};
  shared_ptr<bool> privateZone{};
  shared_ptr<string> profile{};
  shared_ptr<string> proxyMode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> serviceCidr{};
  shared_ptr<long> size{};
  shared_ptr<string> state{};
  shared_ptr<string> subnetCidr{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<string> timezone{};
  shared_ptr<string> updated{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};
  shared_ptr<vector<string>> vswitchIds{};
  shared_ptr<string> workerRamRoleName{};
  shared_ptr<string> zoneId{};

  DescribeClusterDetailResponseBody() {}

  explicit DescribeClusterDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoMode) {
      res["auto_mode"] = autoMode ? boost::any(autoMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clusterDomain) {
      res["cluster_domain"] = boost::any(*clusterDomain);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (clusterSpec) {
      res["cluster_spec"] = boost::any(*clusterSpec);
    }
    if (clusterType) {
      res["cluster_type"] = boost::any(*clusterType);
    }
    if (containerCidr) {
      res["container_cidr"] = boost::any(*containerCidr);
    }
    if (controlPlaneConfig) {
      res["control_plane_config"] = controlPlaneConfig ? boost::any(controlPlaneConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (currentVersion) {
      res["current_version"] = boost::any(*currentVersion);
    }
    if (deletionProtection) {
      res["deletion_protection"] = boost::any(*deletionProtection);
    }
    if (dockerVersion) {
      res["docker_version"] = boost::any(*dockerVersion);
    }
    if (externalLoadbalancerId) {
      res["external_loadbalancer_id"] = boost::any(*externalLoadbalancerId);
    }
    if (initVersion) {
      res["init_version"] = boost::any(*initVersion);
    }
    if (ipStack) {
      res["ip_stack"] = boost::any(*ipStack);
    }
    if (maintenanceWindow) {
      res["maintenance_window"] = maintenanceWindow ? boost::any(maintenanceWindow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (masterUrl) {
      res["master_url"] = boost::any(*masterUrl);
    }
    if (metaData) {
      res["meta_data"] = boost::any(*metaData);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (networkMode) {
      res["network_mode"] = boost::any(*networkMode);
    }
    if (nextVersion) {
      res["next_version"] = boost::any(*nextVersion);
    }
    if (nodeCidrMask) {
      res["node_cidr_mask"] = boost::any(*nodeCidrMask);
    }
    if (operationPolicy) {
      res["operation_policy"] = operationPolicy ? boost::any(operationPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parameters) {
      res["parameters"] = boost::any(*parameters);
    }
    if (privateZone) {
      res["private_zone"] = boost::any(*privateZone);
    }
    if (profile) {
      res["profile"] = boost::any(*profile);
    }
    if (proxyMode) {
      res["proxy_mode"] = boost::any(*proxyMode);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["security_group_id"] = boost::any(*securityGroupId);
    }
    if (serviceCidr) {
      res["service_cidr"] = boost::any(*serviceCidr);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (subnetCidr) {
      res["subnet_cidr"] = boost::any(*subnetCidr);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (timezone) {
      res["timezone"] = boost::any(*timezone);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    if (vpcId) {
      res["vpc_id"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["vswitch_id"] = boost::any(*vswitchId);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    if (workerRamRoleName) {
      res["worker_ram_role_name"] = boost::any(*workerRamRoleName);
    }
    if (zoneId) {
      res["zone_id"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_mode") != m.end() && !m["auto_mode"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_mode"].type()) {
        DescribeClusterDetailResponseBodyAutoMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_mode"]));
        autoMode = make_shared<DescribeClusterDetailResponseBodyAutoMode>(model1);
      }
    }
    if (m.find("cluster_domain") != m.end() && !m["cluster_domain"].empty()) {
      clusterDomain = make_shared<string>(boost::any_cast<string>(m["cluster_domain"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("cluster_spec") != m.end() && !m["cluster_spec"].empty()) {
      clusterSpec = make_shared<string>(boost::any_cast<string>(m["cluster_spec"]));
    }
    if (m.find("cluster_type") != m.end() && !m["cluster_type"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["cluster_type"]));
    }
    if (m.find("container_cidr") != m.end() && !m["container_cidr"].empty()) {
      containerCidr = make_shared<string>(boost::any_cast<string>(m["container_cidr"]));
    }
    if (m.find("control_plane_config") != m.end() && !m["control_plane_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["control_plane_config"].type()) {
        DescribeClusterDetailResponseBodyControlPlaneConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["control_plane_config"]));
        controlPlaneConfig = make_shared<DescribeClusterDetailResponseBodyControlPlaneConfig>(model1);
      }
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("current_version") != m.end() && !m["current_version"].empty()) {
      currentVersion = make_shared<string>(boost::any_cast<string>(m["current_version"]));
    }
    if (m.find("deletion_protection") != m.end() && !m["deletion_protection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["deletion_protection"]));
    }
    if (m.find("docker_version") != m.end() && !m["docker_version"].empty()) {
      dockerVersion = make_shared<string>(boost::any_cast<string>(m["docker_version"]));
    }
    if (m.find("external_loadbalancer_id") != m.end() && !m["external_loadbalancer_id"].empty()) {
      externalLoadbalancerId = make_shared<string>(boost::any_cast<string>(m["external_loadbalancer_id"]));
    }
    if (m.find("init_version") != m.end() && !m["init_version"].empty()) {
      initVersion = make_shared<string>(boost::any_cast<string>(m["init_version"]));
    }
    if (m.find("ip_stack") != m.end() && !m["ip_stack"].empty()) {
      ipStack = make_shared<string>(boost::any_cast<string>(m["ip_stack"]));
    }
    if (m.find("maintenance_window") != m.end() && !m["maintenance_window"].empty()) {
      if (typeid(map<string, boost::any>) == m["maintenance_window"].type()) {
        MaintenanceWindow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["maintenance_window"]));
        maintenanceWindow = make_shared<MaintenanceWindow>(model1);
      }
    }
    if (m.find("master_url") != m.end() && !m["master_url"].empty()) {
      masterUrl = make_shared<string>(boost::any_cast<string>(m["master_url"]));
    }
    if (m.find("meta_data") != m.end() && !m["meta_data"].empty()) {
      metaData = make_shared<string>(boost::any_cast<string>(m["meta_data"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("network_mode") != m.end() && !m["network_mode"].empty()) {
      networkMode = make_shared<string>(boost::any_cast<string>(m["network_mode"]));
    }
    if (m.find("next_version") != m.end() && !m["next_version"].empty()) {
      nextVersion = make_shared<string>(boost::any_cast<string>(m["next_version"]));
    }
    if (m.find("node_cidr_mask") != m.end() && !m["node_cidr_mask"].empty()) {
      nodeCidrMask = make_shared<string>(boost::any_cast<string>(m["node_cidr_mask"]));
    }
    if (m.find("operation_policy") != m.end() && !m["operation_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["operation_policy"].type()) {
        DescribeClusterDetailResponseBodyOperationPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["operation_policy"]));
        operationPolicy = make_shared<DescribeClusterDetailResponseBodyOperationPolicy>(model1);
      }
    }
    if (m.find("parameters") != m.end() && !m["parameters"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["parameters"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      parameters = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("private_zone") != m.end() && !m["private_zone"].empty()) {
      privateZone = make_shared<bool>(boost::any_cast<bool>(m["private_zone"]));
    }
    if (m.find("profile") != m.end() && !m["profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["profile"]));
    }
    if (m.find("proxy_mode") != m.end() && !m["proxy_mode"].empty()) {
      proxyMode = make_shared<string>(boost::any_cast<string>(m["proxy_mode"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
    if (m.find("security_group_id") != m.end() && !m["security_group_id"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["security_group_id"]));
    }
    if (m.find("service_cidr") != m.end() && !m["service_cidr"].empty()) {
      serviceCidr = make_shared<string>(boost::any_cast<string>(m["service_cidr"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("subnet_cidr") != m.end() && !m["subnet_cidr"].empty()) {
      subnetCidr = make_shared<string>(boost::any_cast<string>(m["subnet_cidr"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("timezone") != m.end() && !m["timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["timezone"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
    if (m.find("vpc_id") != m.end() && !m["vpc_id"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpc_id"]));
    }
    if (m.find("vswitch_id") != m.end() && !m["vswitch_id"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitch_id"]));
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("worker_ram_role_name") != m.end() && !m["worker_ram_role_name"].empty()) {
      workerRamRoleName = make_shared<string>(boost::any_cast<string>(m["worker_ram_role_name"]));
    }
    if (m.find("zone_id") != m.end() && !m["zone_id"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zone_id"]));
    }
  }


  virtual ~DescribeClusterDetailResponseBody() = default;
};
class DescribeClusterDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterDetailResponseBody> body{};

  DescribeClusterDetailResponse() {}

  explicit DescribeClusterDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterDetailResponse() = default;
};
class DescribeClusterEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> taskId{};

  DescribeClusterEventsRequest() {}

  explicit DescribeClusterEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~DescribeClusterEventsRequest() = default;
};
class DescribeClusterEventsResponseBodyEventsData : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> reason{};

  DescribeClusterEventsResponseBodyEventsData() {}

  explicit DescribeClusterEventsResponseBodyEventsData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
  }


  virtual ~DescribeClusterEventsResponseBodyEventsData() = default;
};
class DescribeClusterEventsResponseBodyEvents : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<DescribeClusterEventsResponseBodyEventsData> data{};
  shared_ptr<string> eventId{};
  shared_ptr<string> source{};
  shared_ptr<string> subject{};
  shared_ptr<string> time{};
  shared_ptr<string> type{};

  DescribeClusterEventsResponseBodyEvents() {}

  explicit DescribeClusterEventsResponseBodyEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventId) {
      res["event_id"] = boost::any(*eventId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (time) {
      res["time"] = boost::any(*time);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        DescribeClusterEventsResponseBodyEventsData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<DescribeClusterEventsResponseBodyEventsData>(model1);
      }
    }
    if (m.find("event_id") != m.end() && !m["event_id"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["event_id"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("time") != m.end() && !m["time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["time"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeClusterEventsResponseBodyEvents() = default;
};
class DescribeClusterEventsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeClusterEventsResponseBodyPageInfo() {}

  explicit DescribeClusterEventsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~DescribeClusterEventsResponseBodyPageInfo() = default;
};
class DescribeClusterEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterEventsResponseBodyEvents>> events{};
  shared_ptr<DescribeClusterEventsResponseBodyPageInfo> pageInfo{};

  DescribeClusterEventsResponseBody() {}

  explicit DescribeClusterEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["events"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("events") != m.end() && !m["events"].empty()) {
      if (typeid(vector<boost::any>) == m["events"].type()) {
        vector<DescribeClusterEventsResponseBodyEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterEventsResponseBodyEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<DescribeClusterEventsResponseBodyEvents>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        DescribeClusterEventsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<DescribeClusterEventsResponseBodyPageInfo>(model1);
      }
    }
  }


  virtual ~DescribeClusterEventsResponseBody() = default;
};
class DescribeClusterEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterEventsResponseBody> body{};

  DescribeClusterEventsResponse() {}

  explicit DescribeClusterEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterEventsResponse() = default;
};
class DescribeClusterLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> ID{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterLog{};
  shared_ptr<string> created{};
  shared_ptr<string> updated{};

  DescribeClusterLogsResponseBody() {}

  explicit DescribeClusterLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (clusterLog) {
      res["cluster_log"] = boost::any(*clusterLog);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<long>(boost::any_cast<long>(m["ID"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("cluster_log") != m.end() && !m["cluster_log"].empty()) {
      clusterLog = make_shared<string>(boost::any_cast<string>(m["cluster_log"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
  }


  virtual ~DescribeClusterLogsResponseBody() = default;
};
class DescribeClusterLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<DescribeClusterLogsResponseBody>> body{};

  DescribeClusterLogsResponse() {}

  explicit DescribeClusterLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<DescribeClusterLogsResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterLogsResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<DescribeClusterLogsResponseBody>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterLogsResponse() = default;
};
class DescribeClusterNodePoolDetailResponseBodyAutoMode : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};

  DescribeClusterNodePoolDetailResponseBodyAutoMode() {}

  explicit DescribeClusterNodePoolDetailResponseBodyAutoMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyAutoMode() = default;
};
class DescribeClusterNodePoolDetailResponseBodyAutoScaling : public Darabonba::Model {
public:
  shared_ptr<long> eipBandwidth{};
  shared_ptr<string> eipInternetChargeType{};
  shared_ptr<bool> enable{};
  shared_ptr<bool> isBondEip{};
  shared_ptr<long> maxInstances{};
  shared_ptr<long> minInstances{};
  shared_ptr<string> type{};

  DescribeClusterNodePoolDetailResponseBodyAutoScaling() {}

  explicit DescribeClusterNodePoolDetailResponseBodyAutoScaling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipBandwidth) {
      res["eip_bandwidth"] = boost::any(*eipBandwidth);
    }
    if (eipInternetChargeType) {
      res["eip_internet_charge_type"] = boost::any(*eipInternetChargeType);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (isBondEip) {
      res["is_bond_eip"] = boost::any(*isBondEip);
    }
    if (maxInstances) {
      res["max_instances"] = boost::any(*maxInstances);
    }
    if (minInstances) {
      res["min_instances"] = boost::any(*minInstances);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eip_bandwidth") != m.end() && !m["eip_bandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["eip_bandwidth"]));
    }
    if (m.find("eip_internet_charge_type") != m.end() && !m["eip_internet_charge_type"].empty()) {
      eipInternetChargeType = make_shared<string>(boost::any_cast<string>(m["eip_internet_charge_type"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("is_bond_eip") != m.end() && !m["is_bond_eip"].empty()) {
      isBondEip = make_shared<bool>(boost::any_cast<bool>(m["is_bond_eip"]));
    }
    if (m.find("max_instances") != m.end() && !m["max_instances"].empty()) {
      maxInstances = make_shared<long>(boost::any_cast<long>(m["max_instances"]));
    }
    if (m.find("min_instances") != m.end() && !m["min_instances"].empty()) {
      minInstances = make_shared<long>(boost::any_cast<long>(m["min_instances"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyAutoScaling() = default;
};
class DescribeClusterNodePoolDetailResponseBodyInterconnectConfig : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> ccnId{};
  shared_ptr<string> ccnRegionId{};
  shared_ptr<string> cenId{};
  shared_ptr<string> improvedPeriod{};

  DescribeClusterNodePoolDetailResponseBodyInterconnectConfig() {}

  explicit DescribeClusterNodePoolDetailResponseBodyInterconnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["bandwidth"] = boost::any(*bandwidth);
    }
    if (ccnId) {
      res["ccn_id"] = boost::any(*ccnId);
    }
    if (ccnRegionId) {
      res["ccn_region_id"] = boost::any(*ccnRegionId);
    }
    if (cenId) {
      res["cen_id"] = boost::any(*cenId);
    }
    if (improvedPeriod) {
      res["improved_period"] = boost::any(*improvedPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bandwidth") != m.end() && !m["bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["bandwidth"]));
    }
    if (m.find("ccn_id") != m.end() && !m["ccn_id"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["ccn_id"]));
    }
    if (m.find("ccn_region_id") != m.end() && !m["ccn_region_id"].empty()) {
      ccnRegionId = make_shared<string>(boost::any_cast<string>(m["ccn_region_id"]));
    }
    if (m.find("cen_id") != m.end() && !m["cen_id"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["cen_id"]));
    }
    if (m.find("improved_period") != m.end() && !m["improved_period"].empty()) {
      improvedPeriod = make_shared<string>(boost::any_cast<string>(m["improved_period"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyInterconnectConfig() = default;
};
class DescribeClusterNodePoolDetailResponseBodyKubernetesConfig : public Darabonba::Model {
public:
  shared_ptr<bool> cmsEnabled{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<vector<Tag>> labels{};
  shared_ptr<string> nodeNameMode{};
  shared_ptr<string> preUserData{};
  shared_ptr<string> runtime{};
  shared_ptr<string> runtimeVersion{};
  shared_ptr<vector<Taint>> taints{};
  shared_ptr<bool> unschedulable{};
  shared_ptr<string> userData{};

  DescribeClusterNodePoolDetailResponseBodyKubernetesConfig() {}

  explicit DescribeClusterNodePoolDetailResponseBodyKubernetesConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cmsEnabled) {
      res["cms_enabled"] = boost::any(*cmsEnabled);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["labels"] = boost::any(temp1);
    }
    if (nodeNameMode) {
      res["node_name_mode"] = boost::any(*nodeNameMode);
    }
    if (preUserData) {
      res["pre_user_data"] = boost::any(*preUserData);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (runtimeVersion) {
      res["runtime_version"] = boost::any(*runtimeVersion);
    }
    if (taints) {
      vector<boost::any> temp1;
      for(auto item1:*taints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["taints"] = boost::any(temp1);
    }
    if (unschedulable) {
      res["unschedulable"] = boost::any(*unschedulable);
    }
    if (userData) {
      res["user_data"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cms_enabled") != m.end() && !m["cms_enabled"].empty()) {
      cmsEnabled = make_shared<bool>(boost::any_cast<bool>(m["cms_enabled"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("labels") != m.end() && !m["labels"].empty()) {
      if (typeid(vector<boost::any>) == m["labels"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("node_name_mode") != m.end() && !m["node_name_mode"].empty()) {
      nodeNameMode = make_shared<string>(boost::any_cast<string>(m["node_name_mode"]));
    }
    if (m.find("pre_user_data") != m.end() && !m["pre_user_data"].empty()) {
      preUserData = make_shared<string>(boost::any_cast<string>(m["pre_user_data"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("runtime_version") != m.end() && !m["runtime_version"].empty()) {
      runtimeVersion = make_shared<string>(boost::any_cast<string>(m["runtime_version"]));
    }
    if (m.find("taints") != m.end() && !m["taints"].empty()) {
      if (typeid(vector<boost::any>) == m["taints"].type()) {
        vector<Taint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["taints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Taint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taints = make_shared<vector<Taint>>(expect1);
      }
    }
    if (m.find("unschedulable") != m.end() && !m["unschedulable"].empty()) {
      unschedulable = make_shared<bool>(boost::any_cast<bool>(m["unschedulable"]));
    }
    if (m.find("user_data") != m.end() && !m["user_data"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["user_data"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyKubernetesConfig() = default;
};
class DescribeClusterNodePoolDetailResponseBodyManagementAutoRepairPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> approvalRequired{};
  shared_ptr<bool> restartNode{};

  DescribeClusterNodePoolDetailResponseBodyManagementAutoRepairPolicy() {}

  explicit DescribeClusterNodePoolDetailResponseBodyManagementAutoRepairPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalRequired) {
      res["approval_required"] = boost::any(*approvalRequired);
    }
    if (restartNode) {
      res["restart_node"] = boost::any(*restartNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("approval_required") != m.end() && !m["approval_required"].empty()) {
      approvalRequired = make_shared<bool>(boost::any_cast<bool>(m["approval_required"]));
    }
    if (m.find("restart_node") != m.end() && !m["restart_node"].empty()) {
      restartNode = make_shared<bool>(boost::any_cast<bool>(m["restart_node"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyManagementAutoRepairPolicy() = default;
};
class DescribeClusterNodePoolDetailResponseBodyManagementAutoUpgradePolicy : public Darabonba::Model {
public:
  shared_ptr<bool> autoUpgradeKubelet{};

  DescribeClusterNodePoolDetailResponseBodyManagementAutoUpgradePolicy() {}

  explicit DescribeClusterNodePoolDetailResponseBodyManagementAutoUpgradePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpgradeKubelet) {
      res["auto_upgrade_kubelet"] = boost::any(*autoUpgradeKubelet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_upgrade_kubelet") != m.end() && !m["auto_upgrade_kubelet"].empty()) {
      autoUpgradeKubelet = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade_kubelet"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyManagementAutoUpgradePolicy() = default;
};
class DescribeClusterNodePoolDetailResponseBodyManagementAutoVulFixPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> restartNode{};
  shared_ptr<string> vulLevel{};

  DescribeClusterNodePoolDetailResponseBodyManagementAutoVulFixPolicy() {}

  explicit DescribeClusterNodePoolDetailResponseBodyManagementAutoVulFixPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (restartNode) {
      res["restart_node"] = boost::any(*restartNode);
    }
    if (vulLevel) {
      res["vul_level"] = boost::any(*vulLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("restart_node") != m.end() && !m["restart_node"].empty()) {
      restartNode = make_shared<bool>(boost::any_cast<bool>(m["restart_node"]));
    }
    if (m.find("vul_level") != m.end() && !m["vul_level"].empty()) {
      vulLevel = make_shared<string>(boost::any_cast<string>(m["vul_level"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyManagementAutoVulFixPolicy() = default;
};
class DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoUpgrade{};
  shared_ptr<long> maxUnavailable{};
  shared_ptr<long> surge{};
  shared_ptr<long> surgePercentage{};

  DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig() {}

  explicit DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpgrade) {
      res["auto_upgrade"] = boost::any(*autoUpgrade);
    }
    if (maxUnavailable) {
      res["max_unavailable"] = boost::any(*maxUnavailable);
    }
    if (surge) {
      res["surge"] = boost::any(*surge);
    }
    if (surgePercentage) {
      res["surge_percentage"] = boost::any(*surgePercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_upgrade") != m.end() && !m["auto_upgrade"].empty()) {
      autoUpgrade = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade"]));
    }
    if (m.find("max_unavailable") != m.end() && !m["max_unavailable"].empty()) {
      maxUnavailable = make_shared<long>(boost::any_cast<long>(m["max_unavailable"]));
    }
    if (m.find("surge") != m.end() && !m["surge"].empty()) {
      surge = make_shared<long>(boost::any_cast<long>(m["surge"]));
    }
    if (m.find("surge_percentage") != m.end() && !m["surge_percentage"].empty()) {
      surgePercentage = make_shared<long>(boost::any_cast<long>(m["surge_percentage"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig() = default;
};
class DescribeClusterNodePoolDetailResponseBodyManagement : public Darabonba::Model {
public:
  shared_ptr<bool> autoRepair{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyManagementAutoRepairPolicy> autoRepairPolicy{};
  shared_ptr<bool> autoUpgrade{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyManagementAutoUpgradePolicy> autoUpgradePolicy{};
  shared_ptr<bool> autoVulFix{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyManagementAutoVulFixPolicy> autoVulFixPolicy{};
  shared_ptr<bool> enable{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig> upgradeConfig{};

  DescribeClusterNodePoolDetailResponseBodyManagement() {}

  explicit DescribeClusterNodePoolDetailResponseBodyManagement(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRepair) {
      res["auto_repair"] = boost::any(*autoRepair);
    }
    if (autoRepairPolicy) {
      res["auto_repair_policy"] = autoRepairPolicy ? boost::any(autoRepairPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoUpgrade) {
      res["auto_upgrade"] = boost::any(*autoUpgrade);
    }
    if (autoUpgradePolicy) {
      res["auto_upgrade_policy"] = autoUpgradePolicy ? boost::any(autoUpgradePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoVulFix) {
      res["auto_vul_fix"] = boost::any(*autoVulFix);
    }
    if (autoVulFixPolicy) {
      res["auto_vul_fix_policy"] = autoVulFixPolicy ? boost::any(autoVulFixPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (upgradeConfig) {
      res["upgrade_config"] = upgradeConfig ? boost::any(upgradeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_repair") != m.end() && !m["auto_repair"].empty()) {
      autoRepair = make_shared<bool>(boost::any_cast<bool>(m["auto_repair"]));
    }
    if (m.find("auto_repair_policy") != m.end() && !m["auto_repair_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_repair_policy"].type()) {
        DescribeClusterNodePoolDetailResponseBodyManagementAutoRepairPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_repair_policy"]));
        autoRepairPolicy = make_shared<DescribeClusterNodePoolDetailResponseBodyManagementAutoRepairPolicy>(model1);
      }
    }
    if (m.find("auto_upgrade") != m.end() && !m["auto_upgrade"].empty()) {
      autoUpgrade = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade"]));
    }
    if (m.find("auto_upgrade_policy") != m.end() && !m["auto_upgrade_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_upgrade_policy"].type()) {
        DescribeClusterNodePoolDetailResponseBodyManagementAutoUpgradePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_upgrade_policy"]));
        autoUpgradePolicy = make_shared<DescribeClusterNodePoolDetailResponseBodyManagementAutoUpgradePolicy>(model1);
      }
    }
    if (m.find("auto_vul_fix") != m.end() && !m["auto_vul_fix"].empty()) {
      autoVulFix = make_shared<bool>(boost::any_cast<bool>(m["auto_vul_fix"]));
    }
    if (m.find("auto_vul_fix_policy") != m.end() && !m["auto_vul_fix_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_vul_fix_policy"].type()) {
        DescribeClusterNodePoolDetailResponseBodyManagementAutoVulFixPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_vul_fix_policy"]));
        autoVulFixPolicy = make_shared<DescribeClusterNodePoolDetailResponseBodyManagementAutoVulFixPolicy>(model1);
      }
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("upgrade_config") != m.end() && !m["upgrade_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_config"].type()) {
        DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_config"]));
        upgradeConfig = make_shared<DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig>(model1);
      }
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyManagement() = default;
};
class DescribeClusterNodePoolDetailResponseBodyNodeConfig : public Darabonba::Model {
public:
  shared_ptr<KubeletConfig> kubeletConfiguration{};

  DescribeClusterNodePoolDetailResponseBodyNodeConfig() {}

  explicit DescribeClusterNodePoolDetailResponseBodyNodeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kubeletConfiguration) {
      res["kubelet_configuration"] = kubeletConfiguration ? boost::any(kubeletConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("kubelet_configuration") != m.end() && !m["kubelet_configuration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kubelet_configuration"].type()) {
        KubeletConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kubelet_configuration"]));
        kubeletConfiguration = make_shared<KubeletConfig>(model1);
      }
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyNodeConfig() = default;
};
class DescribeClusterNodePoolDetailResponseBodyNodepoolInfo : public Darabonba::Model {
public:
  shared_ptr<string> created{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> name{};
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> type{};
  shared_ptr<string> updated{};

  DescribeClusterNodePoolDetailResponseBodyNodepoolInfo() {}

  explicit DescribeClusterNodePoolDetailResponseBodyNodepoolInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (isDefault) {
      res["is_default"] = boost::any(*isDefault);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("is_default") != m.end() && !m["is_default"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["is_default"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyNodepoolInfo() = default;
};
class DescribeClusterNodePoolDetailResponseBodyScalingGroupPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  DescribeClusterNodePoolDetailResponseBodyScalingGroupPrivatePoolOptions() {}

  explicit DescribeClusterNodePoolDetailResponseBodyScalingGroupPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["match_criteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("match_criteria") != m.end() && !m["match_criteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["match_criteria"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyScalingGroupPrivatePoolOptions() = default;
};
class DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> priceLimit{};

  DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit() {}

  explicit DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["instance_type"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["price_limit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instance_type") != m.end() && !m["instance_type"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instance_type"]));
    }
    if (m.find("price_limit") != m.end() && !m["price_limit"].empty()) {
      priceLimit = make_shared<string>(boost::any_cast<string>(m["price_limit"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit() = default;
};
class DescribeClusterNodePoolDetailResponseBodyScalingGroup : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<bool> cisEnabled{};
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<vector<DataDisk>> dataDisks{};
  shared_ptr<string> deploymentsetId{};
  shared_ptr<long> desiredSize{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<InstanceMetadataOptions> instanceMetadataOptions{};
  shared_ptr<vector<InstancePatterns>> instancePatterns{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> keyPair{};
  shared_ptr<bool> loginAsNonRoot{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> multiAzPolicy{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> platform{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyScalingGroupPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<string> ramPolicy{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<vector<string>> rdsInstances{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<bool> securityHardeningOs{};
  shared_ptr<bool> socEnabled{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<vector<DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit>> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<bool> systemDiskBurstingEnabled{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskEncryptAlgorithm{};
  shared_ptr<bool> systemDiskEncrypted{};
  shared_ptr<string> systemDiskKmsKeyId{};
  shared_ptr<string> systemDiskPerformanceLevel{};
  shared_ptr<long> systemDiskProvisionedIops{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<vector<string>> vswitchIds{};

  DescribeClusterNodePoolDetailResponseBodyScalingGroup() {}

  explicit DescribeClusterNodePoolDetailResponseBodyScalingGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["auto_renew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["auto_renew_period"] = boost::any(*autoRenewPeriod);
    }
    if (cisEnabled) {
      res["cis_enabled"] = boost::any(*cisEnabled);
    }
    if (compensateWithOnDemand) {
      res["compensate_with_on_demand"] = boost::any(*compensateWithOnDemand);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_disks"] = boost::any(temp1);
    }
    if (deploymentsetId) {
      res["deploymentset_id"] = boost::any(*deploymentsetId);
    }
    if (desiredSize) {
      res["desired_size"] = boost::any(*desiredSize);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (imageType) {
      res["image_type"] = boost::any(*imageType);
    }
    if (instanceChargeType) {
      res["instance_charge_type"] = boost::any(*instanceChargeType);
    }
    if (instanceMetadataOptions) {
      res["instance_metadata_options"] = instanceMetadataOptions ? boost::any(instanceMetadataOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instancePatterns) {
      vector<boost::any> temp1;
      for(auto item1:*instancePatterns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["instance_patterns"] = boost::any(temp1);
    }
    if (instanceTypes) {
      res["instance_types"] = boost::any(*instanceTypes);
    }
    if (internetChargeType) {
      res["internet_charge_type"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["internet_max_bandwidth_out"] = boost::any(*internetMaxBandwidthOut);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (loginAsNonRoot) {
      res["login_as_non_root"] = boost::any(*loginAsNonRoot);
    }
    if (loginPassword) {
      res["login_password"] = boost::any(*loginPassword);
    }
    if (multiAzPolicy) {
      res["multi_az_policy"] = boost::any(*multiAzPolicy);
    }
    if (onDemandBaseCapacity) {
      res["on_demand_base_capacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["on_demand_percentage_above_base_capacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["period_unit"] = boost::any(*periodUnit);
    }
    if (platform) {
      res["platform"] = boost::any(*platform);
    }
    if (privatePoolOptions) {
      res["private_pool_options"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ramPolicy) {
      res["ram_policy"] = boost::any(*ramPolicy);
    }
    if (ramRoleName) {
      res["ram_role_name"] = boost::any(*ramRoleName);
    }
    if (rdsInstances) {
      res["rds_instances"] = boost::any(*rdsInstances);
    }
    if (scalingGroupId) {
      res["scaling_group_id"] = boost::any(*scalingGroupId);
    }
    if (scalingPolicy) {
      res["scaling_policy"] = boost::any(*scalingPolicy);
    }
    if (securityGroupId) {
      res["security_group_id"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["security_group_ids"] = boost::any(*securityGroupIds);
    }
    if (securityHardeningOs) {
      res["security_hardening_os"] = boost::any(*securityHardeningOs);
    }
    if (socEnabled) {
      res["soc_enabled"] = boost::any(*socEnabled);
    }
    if (spotInstancePools) {
      res["spot_instance_pools"] = boost::any(*spotInstancePools);
    }
    if (spotInstanceRemedy) {
      res["spot_instance_remedy"] = boost::any(*spotInstanceRemedy);
    }
    if (spotPriceLimit) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["spot_price_limit"] = boost::any(temp1);
    }
    if (spotStrategy) {
      res["spot_strategy"] = boost::any(*spotStrategy);
    }
    if (systemDiskBurstingEnabled) {
      res["system_disk_bursting_enabled"] = boost::any(*systemDiskBurstingEnabled);
    }
    if (systemDiskCategories) {
      res["system_disk_categories"] = boost::any(*systemDiskCategories);
    }
    if (systemDiskCategory) {
      res["system_disk_category"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskEncryptAlgorithm) {
      res["system_disk_encrypt_algorithm"] = boost::any(*systemDiskEncryptAlgorithm);
    }
    if (systemDiskEncrypted) {
      res["system_disk_encrypted"] = boost::any(*systemDiskEncrypted);
    }
    if (systemDiskKmsKeyId) {
      res["system_disk_kms_key_id"] = boost::any(*systemDiskKmsKeyId);
    }
    if (systemDiskPerformanceLevel) {
      res["system_disk_performance_level"] = boost::any(*systemDiskPerformanceLevel);
    }
    if (systemDiskProvisionedIops) {
      res["system_disk_provisioned_iops"] = boost::any(*systemDiskProvisionedIops);
    }
    if (systemDiskSize) {
      res["system_disk_size"] = boost::any(*systemDiskSize);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_renew") != m.end() && !m["auto_renew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["auto_renew"]));
    }
    if (m.find("auto_renew_period") != m.end() && !m["auto_renew_period"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["auto_renew_period"]));
    }
    if (m.find("cis_enabled") != m.end() && !m["cis_enabled"].empty()) {
      cisEnabled = make_shared<bool>(boost::any_cast<bool>(m["cis_enabled"]));
    }
    if (m.find("compensate_with_on_demand") != m.end() && !m["compensate_with_on_demand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["compensate_with_on_demand"]));
    }
    if (m.find("data_disks") != m.end() && !m["data_disks"].empty()) {
      if (typeid(vector<boost::any>) == m["data_disks"].type()) {
        vector<DataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DataDisk>>(expect1);
      }
    }
    if (m.find("deploymentset_id") != m.end() && !m["deploymentset_id"].empty()) {
      deploymentsetId = make_shared<string>(boost::any_cast<string>(m["deploymentset_id"]));
    }
    if (m.find("desired_size") != m.end() && !m["desired_size"].empty()) {
      desiredSize = make_shared<long>(boost::any_cast<long>(m["desired_size"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("image_type") != m.end() && !m["image_type"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["image_type"]));
    }
    if (m.find("instance_charge_type") != m.end() && !m["instance_charge_type"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["instance_charge_type"]));
    }
    if (m.find("instance_metadata_options") != m.end() && !m["instance_metadata_options"].empty()) {
      if (typeid(map<string, boost::any>) == m["instance_metadata_options"].type()) {
        InstanceMetadataOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["instance_metadata_options"]));
        instanceMetadataOptions = make_shared<InstanceMetadataOptions>(model1);
      }
    }
    if (m.find("instance_patterns") != m.end() && !m["instance_patterns"].empty()) {
      if (typeid(vector<boost::any>) == m["instance_patterns"].type()) {
        vector<InstancePatterns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["instance_patterns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstancePatterns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancePatterns = make_shared<vector<InstancePatterns>>(expect1);
      }
    }
    if (m.find("instance_types") != m.end() && !m["instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("internet_charge_type") != m.end() && !m["internet_charge_type"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["internet_charge_type"]));
    }
    if (m.find("internet_max_bandwidth_out") != m.end() && !m["internet_max_bandwidth_out"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["internet_max_bandwidth_out"]));
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("login_as_non_root") != m.end() && !m["login_as_non_root"].empty()) {
      loginAsNonRoot = make_shared<bool>(boost::any_cast<bool>(m["login_as_non_root"]));
    }
    if (m.find("login_password") != m.end() && !m["login_password"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["login_password"]));
    }
    if (m.find("multi_az_policy") != m.end() && !m["multi_az_policy"].empty()) {
      multiAzPolicy = make_shared<string>(boost::any_cast<string>(m["multi_az_policy"]));
    }
    if (m.find("on_demand_base_capacity") != m.end() && !m["on_demand_base_capacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["on_demand_base_capacity"]));
    }
    if (m.find("on_demand_percentage_above_base_capacity") != m.end() && !m["on_demand_percentage_above_base_capacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["on_demand_percentage_above_base_capacity"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("period_unit") != m.end() && !m["period_unit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["period_unit"]));
    }
    if (m.find("platform") != m.end() && !m["platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["platform"]));
    }
    if (m.find("private_pool_options") != m.end() && !m["private_pool_options"].empty()) {
      if (typeid(map<string, boost::any>) == m["private_pool_options"].type()) {
        DescribeClusterNodePoolDetailResponseBodyScalingGroupPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["private_pool_options"]));
        privatePoolOptions = make_shared<DescribeClusterNodePoolDetailResponseBodyScalingGroupPrivatePoolOptions>(model1);
      }
    }
    if (m.find("ram_policy") != m.end() && !m["ram_policy"].empty()) {
      ramPolicy = make_shared<string>(boost::any_cast<string>(m["ram_policy"]));
    }
    if (m.find("ram_role_name") != m.end() && !m["ram_role_name"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["ram_role_name"]));
    }
    if (m.find("rds_instances") != m.end() && !m["rds_instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["rds_instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["rds_instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rdsInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("scaling_group_id") != m.end() && !m["scaling_group_id"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["scaling_group_id"]));
    }
    if (m.find("scaling_policy") != m.end() && !m["scaling_policy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["scaling_policy"]));
    }
    if (m.find("security_group_id") != m.end() && !m["security_group_id"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["security_group_id"]));
    }
    if (m.find("security_group_ids") != m.end() && !m["security_group_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["security_group_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["security_group_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("security_hardening_os") != m.end() && !m["security_hardening_os"].empty()) {
      securityHardeningOs = make_shared<bool>(boost::any_cast<bool>(m["security_hardening_os"]));
    }
    if (m.find("soc_enabled") != m.end() && !m["soc_enabled"].empty()) {
      socEnabled = make_shared<bool>(boost::any_cast<bool>(m["soc_enabled"]));
    }
    if (m.find("spot_instance_pools") != m.end() && !m["spot_instance_pools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["spot_instance_pools"]));
    }
    if (m.find("spot_instance_remedy") != m.end() && !m["spot_instance_remedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["spot_instance_remedy"]));
    }
    if (m.find("spot_price_limit") != m.end() && !m["spot_price_limit"].empty()) {
      if (typeid(vector<boost::any>) == m["spot_price_limit"].type()) {
        vector<DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["spot_price_limit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimit = make_shared<vector<DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit>>(expect1);
      }
    }
    if (m.find("spot_strategy") != m.end() && !m["spot_strategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["spot_strategy"]));
    }
    if (m.find("system_disk_bursting_enabled") != m.end() && !m["system_disk_bursting_enabled"].empty()) {
      systemDiskBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["system_disk_bursting_enabled"]));
    }
    if (m.find("system_disk_categories") != m.end() && !m["system_disk_categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["system_disk_categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["system_disk_categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("system_disk_category") != m.end() && !m["system_disk_category"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["system_disk_category"]));
    }
    if (m.find("system_disk_encrypt_algorithm") != m.end() && !m["system_disk_encrypt_algorithm"].empty()) {
      systemDiskEncryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["system_disk_encrypt_algorithm"]));
    }
    if (m.find("system_disk_encrypted") != m.end() && !m["system_disk_encrypted"].empty()) {
      systemDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["system_disk_encrypted"]));
    }
    if (m.find("system_disk_kms_key_id") != m.end() && !m["system_disk_kms_key_id"].empty()) {
      systemDiskKmsKeyId = make_shared<string>(boost::any_cast<string>(m["system_disk_kms_key_id"]));
    }
    if (m.find("system_disk_performance_level") != m.end() && !m["system_disk_performance_level"].empty()) {
      systemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["system_disk_performance_level"]));
    }
    if (m.find("system_disk_provisioned_iops") != m.end() && !m["system_disk_provisioned_iops"].empty()) {
      systemDiskProvisionedIops = make_shared<long>(boost::any_cast<long>(m["system_disk_provisioned_iops"]));
    }
    if (m.find("system_disk_size") != m.end() && !m["system_disk_size"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["system_disk_size"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyScalingGroup() = default;
};
class DescribeClusterNodePoolDetailResponseBodyStatus : public Darabonba::Model {
public:
  shared_ptr<long> failedNodes{};
  shared_ptr<long> healthyNodes{};
  shared_ptr<long> initialNodes{};
  shared_ptr<long> offlineNodes{};
  shared_ptr<long> removingNodes{};
  shared_ptr<long> servingNodes{};
  shared_ptr<string> state{};
  shared_ptr<long> totalNodes{};

  DescribeClusterNodePoolDetailResponseBodyStatus() {}

  explicit DescribeClusterNodePoolDetailResponseBodyStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedNodes) {
      res["failed_nodes"] = boost::any(*failedNodes);
    }
    if (healthyNodes) {
      res["healthy_nodes"] = boost::any(*healthyNodes);
    }
    if (initialNodes) {
      res["initial_nodes"] = boost::any(*initialNodes);
    }
    if (offlineNodes) {
      res["offline_nodes"] = boost::any(*offlineNodes);
    }
    if (removingNodes) {
      res["removing_nodes"] = boost::any(*removingNodes);
    }
    if (servingNodes) {
      res["serving_nodes"] = boost::any(*servingNodes);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (totalNodes) {
      res["total_nodes"] = boost::any(*totalNodes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("failed_nodes") != m.end() && !m["failed_nodes"].empty()) {
      failedNodes = make_shared<long>(boost::any_cast<long>(m["failed_nodes"]));
    }
    if (m.find("healthy_nodes") != m.end() && !m["healthy_nodes"].empty()) {
      healthyNodes = make_shared<long>(boost::any_cast<long>(m["healthy_nodes"]));
    }
    if (m.find("initial_nodes") != m.end() && !m["initial_nodes"].empty()) {
      initialNodes = make_shared<long>(boost::any_cast<long>(m["initial_nodes"]));
    }
    if (m.find("offline_nodes") != m.end() && !m["offline_nodes"].empty()) {
      offlineNodes = make_shared<long>(boost::any_cast<long>(m["offline_nodes"]));
    }
    if (m.find("removing_nodes") != m.end() && !m["removing_nodes"].empty()) {
      removingNodes = make_shared<long>(boost::any_cast<long>(m["removing_nodes"]));
    }
    if (m.find("serving_nodes") != m.end() && !m["serving_nodes"].empty()) {
      servingNodes = make_shared<long>(boost::any_cast<long>(m["serving_nodes"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("total_nodes") != m.end() && !m["total_nodes"].empty()) {
      totalNodes = make_shared<long>(boost::any_cast<long>(m["total_nodes"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyStatus() = default;
};
class DescribeClusterNodePoolDetailResponseBodyTeeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> teeEnable{};

  DescribeClusterNodePoolDetailResponseBodyTeeConfig() {}

  explicit DescribeClusterNodePoolDetailResponseBodyTeeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (teeEnable) {
      res["tee_enable"] = boost::any(*teeEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tee_enable") != m.end() && !m["tee_enable"].empty()) {
      teeEnable = make_shared<bool>(boost::any_cast<bool>(m["tee_enable"]));
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBodyTeeConfig() = default;
};
class DescribeClusterNodePoolDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyAutoMode> autoMode{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyAutoScaling> autoScaling{};
  shared_ptr<bool> hostNetwork{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyInterconnectConfig> interconnectConfig{};
  shared_ptr<string> interconnectMode{};
  shared_ptr<bool> intranet{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyKubernetesConfig> kubernetesConfig{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyManagement> management{};
  shared_ptr<long> maxNodes{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyNodeConfig> nodeConfig{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyNodepoolInfo> nodepoolInfo{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyScalingGroup> scalingGroup{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyStatus> status{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBodyTeeConfig> teeConfig{};

  DescribeClusterNodePoolDetailResponseBody() {}

  explicit DescribeClusterNodePoolDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoMode) {
      res["auto_mode"] = autoMode ? boost::any(autoMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoScaling) {
      res["auto_scaling"] = autoScaling ? boost::any(autoScaling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostNetwork) {
      res["host_network"] = boost::any(*hostNetwork);
    }
    if (interconnectConfig) {
      res["interconnect_config"] = interconnectConfig ? boost::any(interconnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interconnectMode) {
      res["interconnect_mode"] = boost::any(*interconnectMode);
    }
    if (intranet) {
      res["intranet"] = boost::any(*intranet);
    }
    if (kubernetesConfig) {
      res["kubernetes_config"] = kubernetesConfig ? boost::any(kubernetesConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (management) {
      res["management"] = management ? boost::any(management->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxNodes) {
      res["max_nodes"] = boost::any(*maxNodes);
    }
    if (nodeConfig) {
      res["node_config"] = nodeConfig ? boost::any(nodeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodepoolInfo) {
      res["nodepool_info"] = nodepoolInfo ? boost::any(nodepoolInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scalingGroup) {
      res["scaling_group"] = scalingGroup ? boost::any(scalingGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["status"] = status ? boost::any(status->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (teeConfig) {
      res["tee_config"] = teeConfig ? boost::any(teeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_mode") != m.end() && !m["auto_mode"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_mode"].type()) {
        DescribeClusterNodePoolDetailResponseBodyAutoMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_mode"]));
        autoMode = make_shared<DescribeClusterNodePoolDetailResponseBodyAutoMode>(model1);
      }
    }
    if (m.find("auto_scaling") != m.end() && !m["auto_scaling"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_scaling"].type()) {
        DescribeClusterNodePoolDetailResponseBodyAutoScaling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_scaling"]));
        autoScaling = make_shared<DescribeClusterNodePoolDetailResponseBodyAutoScaling>(model1);
      }
    }
    if (m.find("host_network") != m.end() && !m["host_network"].empty()) {
      hostNetwork = make_shared<bool>(boost::any_cast<bool>(m["host_network"]));
    }
    if (m.find("interconnect_config") != m.end() && !m["interconnect_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["interconnect_config"].type()) {
        DescribeClusterNodePoolDetailResponseBodyInterconnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["interconnect_config"]));
        interconnectConfig = make_shared<DescribeClusterNodePoolDetailResponseBodyInterconnectConfig>(model1);
      }
    }
    if (m.find("interconnect_mode") != m.end() && !m["interconnect_mode"].empty()) {
      interconnectMode = make_shared<string>(boost::any_cast<string>(m["interconnect_mode"]));
    }
    if (m.find("intranet") != m.end() && !m["intranet"].empty()) {
      intranet = make_shared<bool>(boost::any_cast<bool>(m["intranet"]));
    }
    if (m.find("kubernetes_config") != m.end() && !m["kubernetes_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["kubernetes_config"].type()) {
        DescribeClusterNodePoolDetailResponseBodyKubernetesConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kubernetes_config"]));
        kubernetesConfig = make_shared<DescribeClusterNodePoolDetailResponseBodyKubernetesConfig>(model1);
      }
    }
    if (m.find("management") != m.end() && !m["management"].empty()) {
      if (typeid(map<string, boost::any>) == m["management"].type()) {
        DescribeClusterNodePoolDetailResponseBodyManagement model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["management"]));
        management = make_shared<DescribeClusterNodePoolDetailResponseBodyManagement>(model1);
      }
    }
    if (m.find("max_nodes") != m.end() && !m["max_nodes"].empty()) {
      maxNodes = make_shared<long>(boost::any_cast<long>(m["max_nodes"]));
    }
    if (m.find("node_config") != m.end() && !m["node_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["node_config"].type()) {
        DescribeClusterNodePoolDetailResponseBodyNodeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["node_config"]));
        nodeConfig = make_shared<DescribeClusterNodePoolDetailResponseBodyNodeConfig>(model1);
      }
    }
    if (m.find("nodepool_info") != m.end() && !m["nodepool_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodepool_info"].type()) {
        DescribeClusterNodePoolDetailResponseBodyNodepoolInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodepool_info"]));
        nodepoolInfo = make_shared<DescribeClusterNodePoolDetailResponseBodyNodepoolInfo>(model1);
      }
    }
    if (m.find("scaling_group") != m.end() && !m["scaling_group"].empty()) {
      if (typeid(map<string, boost::any>) == m["scaling_group"].type()) {
        DescribeClusterNodePoolDetailResponseBodyScalingGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["scaling_group"]));
        scalingGroup = make_shared<DescribeClusterNodePoolDetailResponseBodyScalingGroup>(model1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      if (typeid(map<string, boost::any>) == m["status"].type()) {
        DescribeClusterNodePoolDetailResponseBodyStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["status"]));
        status = make_shared<DescribeClusterNodePoolDetailResponseBodyStatus>(model1);
      }
    }
    if (m.find("tee_config") != m.end() && !m["tee_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["tee_config"].type()) {
        DescribeClusterNodePoolDetailResponseBodyTeeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tee_config"]));
        teeConfig = make_shared<DescribeClusterNodePoolDetailResponseBodyTeeConfig>(model1);
      }
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponseBody() = default;
};
class DescribeClusterNodePoolDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterNodePoolDetailResponseBody> body{};

  DescribeClusterNodePoolDetailResponse() {}

  explicit DescribeClusterNodePoolDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterNodePoolDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterNodePoolDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterNodePoolDetailResponse() = default;
};
class DescribeClusterNodePoolsRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodepoolName{};

  DescribeClusterNodePoolsRequest() {}

  explicit DescribeClusterNodePoolsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodepoolName) {
      res["NodepoolName"] = boost::any(*nodepoolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodepoolName") != m.end() && !m["NodepoolName"].empty()) {
      nodepoolName = make_shared<string>(boost::any_cast<string>(m["NodepoolName"]));
    }
  }


  virtual ~DescribeClusterNodePoolsRequest() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsAutoMode : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};

  DescribeClusterNodePoolsResponseBodyNodepoolsAutoMode() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsAutoMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsAutoMode() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling : public Darabonba::Model {
public:
  shared_ptr<long> eipBandwidth{};
  shared_ptr<string> eipInternetChargeType{};
  shared_ptr<bool> enable{};
  shared_ptr<bool> isBondEip{};
  shared_ptr<long> maxInstances{};
  shared_ptr<long> minInstances{};
  shared_ptr<string> type{};

  DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipBandwidth) {
      res["eip_bandwidth"] = boost::any(*eipBandwidth);
    }
    if (eipInternetChargeType) {
      res["eip_internet_charge_type"] = boost::any(*eipInternetChargeType);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (isBondEip) {
      res["is_bond_eip"] = boost::any(*isBondEip);
    }
    if (maxInstances) {
      res["max_instances"] = boost::any(*maxInstances);
    }
    if (minInstances) {
      res["min_instances"] = boost::any(*minInstances);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eip_bandwidth") != m.end() && !m["eip_bandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["eip_bandwidth"]));
    }
    if (m.find("eip_internet_charge_type") != m.end() && !m["eip_internet_charge_type"].empty()) {
      eipInternetChargeType = make_shared<string>(boost::any_cast<string>(m["eip_internet_charge_type"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("is_bond_eip") != m.end() && !m["is_bond_eip"].empty()) {
      isBondEip = make_shared<bool>(boost::any_cast<bool>(m["is_bond_eip"]));
    }
    if (m.find("max_instances") != m.end() && !m["max_instances"].empty()) {
      maxInstances = make_shared<long>(boost::any_cast<long>(m["max_instances"]));
    }
    if (m.find("min_instances") != m.end() && !m["min_instances"].empty()) {
      minInstances = make_shared<long>(boost::any_cast<long>(m["min_instances"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> ccnId{};
  shared_ptr<string> ccnRegionId{};
  shared_ptr<string> cenId{};
  shared_ptr<string> improvedPeriod{};

  DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["bandwidth"] = boost::any(*bandwidth);
    }
    if (ccnId) {
      res["ccn_id"] = boost::any(*ccnId);
    }
    if (ccnRegionId) {
      res["ccn_region_id"] = boost::any(*ccnRegionId);
    }
    if (cenId) {
      res["cen_id"] = boost::any(*cenId);
    }
    if (improvedPeriod) {
      res["improved_period"] = boost::any(*improvedPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bandwidth") != m.end() && !m["bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["bandwidth"]));
    }
    if (m.find("ccn_id") != m.end() && !m["ccn_id"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["ccn_id"]));
    }
    if (m.find("ccn_region_id") != m.end() && !m["ccn_region_id"].empty()) {
      ccnRegionId = make_shared<string>(boost::any_cast<string>(m["ccn_region_id"]));
    }
    if (m.find("cen_id") != m.end() && !m["cen_id"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["cen_id"]));
    }
    if (m.find("improved_period") != m.end() && !m["improved_period"].empty()) {
      improvedPeriod = make_shared<string>(boost::any_cast<string>(m["improved_period"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig : public Darabonba::Model {
public:
  shared_ptr<bool> cmsEnabled{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<vector<Tag>> labels{};
  shared_ptr<string> nodeNameMode{};
  shared_ptr<string> preUserData{};
  shared_ptr<string> runtime{};
  shared_ptr<string> runtimeVersion{};
  shared_ptr<vector<Taint>> taints{};
  shared_ptr<bool> unschedulable{};
  shared_ptr<string> userData{};

  DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cmsEnabled) {
      res["cms_enabled"] = boost::any(*cmsEnabled);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["labels"] = boost::any(temp1);
    }
    if (nodeNameMode) {
      res["node_name_mode"] = boost::any(*nodeNameMode);
    }
    if (preUserData) {
      res["pre_user_data"] = boost::any(*preUserData);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (runtimeVersion) {
      res["runtime_version"] = boost::any(*runtimeVersion);
    }
    if (taints) {
      vector<boost::any> temp1;
      for(auto item1:*taints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["taints"] = boost::any(temp1);
    }
    if (unschedulable) {
      res["unschedulable"] = boost::any(*unschedulable);
    }
    if (userData) {
      res["user_data"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cms_enabled") != m.end() && !m["cms_enabled"].empty()) {
      cmsEnabled = make_shared<bool>(boost::any_cast<bool>(m["cms_enabled"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("labels") != m.end() && !m["labels"].empty()) {
      if (typeid(vector<boost::any>) == m["labels"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("node_name_mode") != m.end() && !m["node_name_mode"].empty()) {
      nodeNameMode = make_shared<string>(boost::any_cast<string>(m["node_name_mode"]));
    }
    if (m.find("pre_user_data") != m.end() && !m["pre_user_data"].empty()) {
      preUserData = make_shared<string>(boost::any_cast<string>(m["pre_user_data"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("runtime_version") != m.end() && !m["runtime_version"].empty()) {
      runtimeVersion = make_shared<string>(boost::any_cast<string>(m["runtime_version"]));
    }
    if (m.find("taints") != m.end() && !m["taints"].empty()) {
      if (typeid(vector<boost::any>) == m["taints"].type()) {
        vector<Taint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["taints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Taint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taints = make_shared<vector<Taint>>(expect1);
      }
    }
    if (m.find("unschedulable") != m.end() && !m["unschedulable"].empty()) {
      unschedulable = make_shared<bool>(boost::any_cast<bool>(m["unschedulable"]));
    }
    if (m.find("user_data") != m.end() && !m["user_data"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["user_data"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoRepairPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> approvalRequired{};
  shared_ptr<bool> restartNode{};

  DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoRepairPolicy() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoRepairPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalRequired) {
      res["approval_required"] = boost::any(*approvalRequired);
    }
    if (restartNode) {
      res["restart_node"] = boost::any(*restartNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("approval_required") != m.end() && !m["approval_required"].empty()) {
      approvalRequired = make_shared<bool>(boost::any_cast<bool>(m["approval_required"]));
    }
    if (m.find("restart_node") != m.end() && !m["restart_node"].empty()) {
      restartNode = make_shared<bool>(boost::any_cast<bool>(m["restart_node"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoRepairPolicy() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoUpgradePolicy : public Darabonba::Model {
public:
  shared_ptr<bool> autoUpgradeKubelet{};

  DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoUpgradePolicy() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoUpgradePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpgradeKubelet) {
      res["auto_upgrade_kubelet"] = boost::any(*autoUpgradeKubelet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_upgrade_kubelet") != m.end() && !m["auto_upgrade_kubelet"].empty()) {
      autoUpgradeKubelet = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade_kubelet"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoUpgradePolicy() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoVulFixPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> restartNode{};
  shared_ptr<string> vulLevel{};

  DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoVulFixPolicy() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoVulFixPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (restartNode) {
      res["restart_node"] = boost::any(*restartNode);
    }
    if (vulLevel) {
      res["vul_level"] = boost::any(*vulLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("restart_node") != m.end() && !m["restart_node"].empty()) {
      restartNode = make_shared<bool>(boost::any_cast<bool>(m["restart_node"]));
    }
    if (m.find("vul_level") != m.end() && !m["vul_level"].empty()) {
      vulLevel = make_shared<string>(boost::any_cast<string>(m["vul_level"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoVulFixPolicy() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoUpgrade{};
  shared_ptr<long> maxUnavailable{};
  shared_ptr<long> surge{};
  shared_ptr<long> surgePercentage{};

  DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpgrade) {
      res["auto_upgrade"] = boost::any(*autoUpgrade);
    }
    if (maxUnavailable) {
      res["max_unavailable"] = boost::any(*maxUnavailable);
    }
    if (surge) {
      res["surge"] = boost::any(*surge);
    }
    if (surgePercentage) {
      res["surge_percentage"] = boost::any(*surgePercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_upgrade") != m.end() && !m["auto_upgrade"].empty()) {
      autoUpgrade = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade"]));
    }
    if (m.find("max_unavailable") != m.end() && !m["max_unavailable"].empty()) {
      maxUnavailable = make_shared<long>(boost::any_cast<long>(m["max_unavailable"]));
    }
    if (m.find("surge") != m.end() && !m["surge"].empty()) {
      surge = make_shared<long>(boost::any_cast<long>(m["surge"]));
    }
    if (m.find("surge_percentage") != m.end() && !m["surge_percentage"].empty()) {
      surgePercentage = make_shared<long>(boost::any_cast<long>(m["surge_percentage"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsManagement : public Darabonba::Model {
public:
  shared_ptr<bool> autoRepair{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoRepairPolicy> autoRepairPolicy{};
  shared_ptr<bool> autoUpgrade{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoUpgradePolicy> autoUpgradePolicy{};
  shared_ptr<bool> autoVulFix{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoVulFixPolicy> autoVulFixPolicy{};
  shared_ptr<bool> enable{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig> upgradeConfig{};

  DescribeClusterNodePoolsResponseBodyNodepoolsManagement() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsManagement(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRepair) {
      res["auto_repair"] = boost::any(*autoRepair);
    }
    if (autoRepairPolicy) {
      res["auto_repair_policy"] = autoRepairPolicy ? boost::any(autoRepairPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoUpgrade) {
      res["auto_upgrade"] = boost::any(*autoUpgrade);
    }
    if (autoUpgradePolicy) {
      res["auto_upgrade_policy"] = autoUpgradePolicy ? boost::any(autoUpgradePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoVulFix) {
      res["auto_vul_fix"] = boost::any(*autoVulFix);
    }
    if (autoVulFixPolicy) {
      res["auto_vul_fix_policy"] = autoVulFixPolicy ? boost::any(autoVulFixPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (upgradeConfig) {
      res["upgrade_config"] = upgradeConfig ? boost::any(upgradeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_repair") != m.end() && !m["auto_repair"].empty()) {
      autoRepair = make_shared<bool>(boost::any_cast<bool>(m["auto_repair"]));
    }
    if (m.find("auto_repair_policy") != m.end() && !m["auto_repair_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_repair_policy"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoRepairPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_repair_policy"]));
        autoRepairPolicy = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoRepairPolicy>(model1);
      }
    }
    if (m.find("auto_upgrade") != m.end() && !m["auto_upgrade"].empty()) {
      autoUpgrade = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade"]));
    }
    if (m.find("auto_upgrade_policy") != m.end() && !m["auto_upgrade_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_upgrade_policy"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoUpgradePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_upgrade_policy"]));
        autoUpgradePolicy = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoUpgradePolicy>(model1);
      }
    }
    if (m.find("auto_vul_fix") != m.end() && !m["auto_vul_fix"].empty()) {
      autoVulFix = make_shared<bool>(boost::any_cast<bool>(m["auto_vul_fix"]));
    }
    if (m.find("auto_vul_fix_policy") != m.end() && !m["auto_vul_fix_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_vul_fix_policy"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoVulFixPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_vul_fix_policy"]));
        autoVulFixPolicy = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsManagementAutoVulFixPolicy>(model1);
      }
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("upgrade_config") != m.end() && !m["upgrade_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_config"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_config"]));
        upgradeConfig = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig>(model1);
      }
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsManagement() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsNodeConfig : public Darabonba::Model {
public:
  shared_ptr<KubeletConfig> kubeletConfiguration{};

  DescribeClusterNodePoolsResponseBodyNodepoolsNodeConfig() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsNodeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kubeletConfiguration) {
      res["kubelet_configuration"] = kubeletConfiguration ? boost::any(kubeletConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("kubelet_configuration") != m.end() && !m["kubelet_configuration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kubelet_configuration"].type()) {
        KubeletConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kubelet_configuration"]));
        kubeletConfiguration = make_shared<KubeletConfig>(model1);
      }
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsNodeConfig() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo : public Darabonba::Model {
public:
  shared_ptr<string> created{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> name{};
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> type{};
  shared_ptr<string> updated{};

  DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (isDefault) {
      res["is_default"] = boost::any(*isDefault);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("is_default") != m.end() && !m["is_default"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["is_default"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupPrivatePoolOptions() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["match_criteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("match_criteria") != m.end() && !m["match_criteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["match_criteria"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupPrivatePoolOptions() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> priceLimit{};

  DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["instance_type"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["price_limit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instance_type") != m.end() && !m["instance_type"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instance_type"]));
    }
    if (m.find("price_limit") != m.end() && !m["price_limit"].empty()) {
      priceLimit = make_shared<string>(boost::any_cast<string>(m["price_limit"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<bool> cisEnabled{};
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<vector<DataDisk>> dataDisks{};
  shared_ptr<string> deploymentsetId{};
  shared_ptr<long> desiredSize{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<vector<InstancePatterns>> instancePatterns{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> keyPair{};
  shared_ptr<bool> loginAsNonRoot{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> multiAzPolicy{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> platform{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<string> ramPolicy{};
  shared_ptr<string> ramRoleName{};
  shared_ptr<vector<string>> rdsInstances{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<bool> securityHardeningOs{};
  shared_ptr<bool> socEnabled{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<vector<DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit>> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<bool> systemDiskBurstingEnabled{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskEncryptAlgorithm{};
  shared_ptr<bool> systemDiskEncrypted{};
  shared_ptr<string> systemDiskKmsKeyId{};
  shared_ptr<string> systemDiskPerformanceLevel{};
  shared_ptr<long> systemDiskProvisionedIops{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<vector<string>> vswitchIds{};

  DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["auto_renew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["auto_renew_period"] = boost::any(*autoRenewPeriod);
    }
    if (cisEnabled) {
      res["cis_enabled"] = boost::any(*cisEnabled);
    }
    if (compensateWithOnDemand) {
      res["compensate_with_on_demand"] = boost::any(*compensateWithOnDemand);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_disks"] = boost::any(temp1);
    }
    if (deploymentsetId) {
      res["deploymentset_id"] = boost::any(*deploymentsetId);
    }
    if (desiredSize) {
      res["desired_size"] = boost::any(*desiredSize);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (imageType) {
      res["image_type"] = boost::any(*imageType);
    }
    if (instanceChargeType) {
      res["instance_charge_type"] = boost::any(*instanceChargeType);
    }
    if (instancePatterns) {
      vector<boost::any> temp1;
      for(auto item1:*instancePatterns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["instance_patterns"] = boost::any(temp1);
    }
    if (instanceTypes) {
      res["instance_types"] = boost::any(*instanceTypes);
    }
    if (internetChargeType) {
      res["internet_charge_type"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["internet_max_bandwidth_out"] = boost::any(*internetMaxBandwidthOut);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (loginAsNonRoot) {
      res["login_as_non_root"] = boost::any(*loginAsNonRoot);
    }
    if (loginPassword) {
      res["login_password"] = boost::any(*loginPassword);
    }
    if (multiAzPolicy) {
      res["multi_az_policy"] = boost::any(*multiAzPolicy);
    }
    if (onDemandBaseCapacity) {
      res["on_demand_base_capacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["on_demand_percentage_above_base_capacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["period_unit"] = boost::any(*periodUnit);
    }
    if (platform) {
      res["platform"] = boost::any(*platform);
    }
    if (privatePoolOptions) {
      res["private_pool_options"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ramPolicy) {
      res["ram_policy"] = boost::any(*ramPolicy);
    }
    if (ramRoleName) {
      res["ram_role_name"] = boost::any(*ramRoleName);
    }
    if (rdsInstances) {
      res["rds_instances"] = boost::any(*rdsInstances);
    }
    if (scalingGroupId) {
      res["scaling_group_id"] = boost::any(*scalingGroupId);
    }
    if (scalingPolicy) {
      res["scaling_policy"] = boost::any(*scalingPolicy);
    }
    if (securityGroupId) {
      res["security_group_id"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["security_group_ids"] = boost::any(*securityGroupIds);
    }
    if (securityHardeningOs) {
      res["security_hardening_os"] = boost::any(*securityHardeningOs);
    }
    if (socEnabled) {
      res["soc_enabled"] = boost::any(*socEnabled);
    }
    if (spotInstancePools) {
      res["spot_instance_pools"] = boost::any(*spotInstancePools);
    }
    if (spotInstanceRemedy) {
      res["spot_instance_remedy"] = boost::any(*spotInstanceRemedy);
    }
    if (spotPriceLimit) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["spot_price_limit"] = boost::any(temp1);
    }
    if (spotStrategy) {
      res["spot_strategy"] = boost::any(*spotStrategy);
    }
    if (systemDiskBurstingEnabled) {
      res["system_disk_bursting_enabled"] = boost::any(*systemDiskBurstingEnabled);
    }
    if (systemDiskCategories) {
      res["system_disk_categories"] = boost::any(*systemDiskCategories);
    }
    if (systemDiskCategory) {
      res["system_disk_category"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskEncryptAlgorithm) {
      res["system_disk_encrypt_algorithm"] = boost::any(*systemDiskEncryptAlgorithm);
    }
    if (systemDiskEncrypted) {
      res["system_disk_encrypted"] = boost::any(*systemDiskEncrypted);
    }
    if (systemDiskKmsKeyId) {
      res["system_disk_kms_key_id"] = boost::any(*systemDiskKmsKeyId);
    }
    if (systemDiskPerformanceLevel) {
      res["system_disk_performance_level"] = boost::any(*systemDiskPerformanceLevel);
    }
    if (systemDiskProvisionedIops) {
      res["system_disk_provisioned_iops"] = boost::any(*systemDiskProvisionedIops);
    }
    if (systemDiskSize) {
      res["system_disk_size"] = boost::any(*systemDiskSize);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_renew") != m.end() && !m["auto_renew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["auto_renew"]));
    }
    if (m.find("auto_renew_period") != m.end() && !m["auto_renew_period"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["auto_renew_period"]));
    }
    if (m.find("cis_enabled") != m.end() && !m["cis_enabled"].empty()) {
      cisEnabled = make_shared<bool>(boost::any_cast<bool>(m["cis_enabled"]));
    }
    if (m.find("compensate_with_on_demand") != m.end() && !m["compensate_with_on_demand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["compensate_with_on_demand"]));
    }
    if (m.find("data_disks") != m.end() && !m["data_disks"].empty()) {
      if (typeid(vector<boost::any>) == m["data_disks"].type()) {
        vector<DataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DataDisk>>(expect1);
      }
    }
    if (m.find("deploymentset_id") != m.end() && !m["deploymentset_id"].empty()) {
      deploymentsetId = make_shared<string>(boost::any_cast<string>(m["deploymentset_id"]));
    }
    if (m.find("desired_size") != m.end() && !m["desired_size"].empty()) {
      desiredSize = make_shared<long>(boost::any_cast<long>(m["desired_size"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("image_type") != m.end() && !m["image_type"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["image_type"]));
    }
    if (m.find("instance_charge_type") != m.end() && !m["instance_charge_type"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["instance_charge_type"]));
    }
    if (m.find("instance_patterns") != m.end() && !m["instance_patterns"].empty()) {
      if (typeid(vector<boost::any>) == m["instance_patterns"].type()) {
        vector<InstancePatterns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["instance_patterns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstancePatterns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancePatterns = make_shared<vector<InstancePatterns>>(expect1);
      }
    }
    if (m.find("instance_types") != m.end() && !m["instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("internet_charge_type") != m.end() && !m["internet_charge_type"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["internet_charge_type"]));
    }
    if (m.find("internet_max_bandwidth_out") != m.end() && !m["internet_max_bandwidth_out"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["internet_max_bandwidth_out"]));
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("login_as_non_root") != m.end() && !m["login_as_non_root"].empty()) {
      loginAsNonRoot = make_shared<bool>(boost::any_cast<bool>(m["login_as_non_root"]));
    }
    if (m.find("login_password") != m.end() && !m["login_password"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["login_password"]));
    }
    if (m.find("multi_az_policy") != m.end() && !m["multi_az_policy"].empty()) {
      multiAzPolicy = make_shared<string>(boost::any_cast<string>(m["multi_az_policy"]));
    }
    if (m.find("on_demand_base_capacity") != m.end() && !m["on_demand_base_capacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["on_demand_base_capacity"]));
    }
    if (m.find("on_demand_percentage_above_base_capacity") != m.end() && !m["on_demand_percentage_above_base_capacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["on_demand_percentage_above_base_capacity"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("period_unit") != m.end() && !m["period_unit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["period_unit"]));
    }
    if (m.find("platform") != m.end() && !m["platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["platform"]));
    }
    if (m.find("private_pool_options") != m.end() && !m["private_pool_options"].empty()) {
      if (typeid(map<string, boost::any>) == m["private_pool_options"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["private_pool_options"]));
        privatePoolOptions = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupPrivatePoolOptions>(model1);
      }
    }
    if (m.find("ram_policy") != m.end() && !m["ram_policy"].empty()) {
      ramPolicy = make_shared<string>(boost::any_cast<string>(m["ram_policy"]));
    }
    if (m.find("ram_role_name") != m.end() && !m["ram_role_name"].empty()) {
      ramRoleName = make_shared<string>(boost::any_cast<string>(m["ram_role_name"]));
    }
    if (m.find("rds_instances") != m.end() && !m["rds_instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["rds_instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["rds_instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rdsInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("scaling_group_id") != m.end() && !m["scaling_group_id"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["scaling_group_id"]));
    }
    if (m.find("scaling_policy") != m.end() && !m["scaling_policy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["scaling_policy"]));
    }
    if (m.find("security_group_id") != m.end() && !m["security_group_id"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["security_group_id"]));
    }
    if (m.find("security_group_ids") != m.end() && !m["security_group_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["security_group_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["security_group_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("security_hardening_os") != m.end() && !m["security_hardening_os"].empty()) {
      securityHardeningOs = make_shared<bool>(boost::any_cast<bool>(m["security_hardening_os"]));
    }
    if (m.find("soc_enabled") != m.end() && !m["soc_enabled"].empty()) {
      socEnabled = make_shared<bool>(boost::any_cast<bool>(m["soc_enabled"]));
    }
    if (m.find("spot_instance_pools") != m.end() && !m["spot_instance_pools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["spot_instance_pools"]));
    }
    if (m.find("spot_instance_remedy") != m.end() && !m["spot_instance_remedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["spot_instance_remedy"]));
    }
    if (m.find("spot_price_limit") != m.end() && !m["spot_price_limit"].empty()) {
      if (typeid(vector<boost::any>) == m["spot_price_limit"].type()) {
        vector<DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["spot_price_limit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimit = make_shared<vector<DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit>>(expect1);
      }
    }
    if (m.find("spot_strategy") != m.end() && !m["spot_strategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["spot_strategy"]));
    }
    if (m.find("system_disk_bursting_enabled") != m.end() && !m["system_disk_bursting_enabled"].empty()) {
      systemDiskBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["system_disk_bursting_enabled"]));
    }
    if (m.find("system_disk_categories") != m.end() && !m["system_disk_categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["system_disk_categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["system_disk_categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("system_disk_category") != m.end() && !m["system_disk_category"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["system_disk_category"]));
    }
    if (m.find("system_disk_encrypt_algorithm") != m.end() && !m["system_disk_encrypt_algorithm"].empty()) {
      systemDiskEncryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["system_disk_encrypt_algorithm"]));
    }
    if (m.find("system_disk_encrypted") != m.end() && !m["system_disk_encrypted"].empty()) {
      systemDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["system_disk_encrypted"]));
    }
    if (m.find("system_disk_kms_key_id") != m.end() && !m["system_disk_kms_key_id"].empty()) {
      systemDiskKmsKeyId = make_shared<string>(boost::any_cast<string>(m["system_disk_kms_key_id"]));
    }
    if (m.find("system_disk_performance_level") != m.end() && !m["system_disk_performance_level"].empty()) {
      systemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["system_disk_performance_level"]));
    }
    if (m.find("system_disk_provisioned_iops") != m.end() && !m["system_disk_provisioned_iops"].empty()) {
      systemDiskProvisionedIops = make_shared<long>(boost::any_cast<long>(m["system_disk_provisioned_iops"]));
    }
    if (m.find("system_disk_size") != m.end() && !m["system_disk_size"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["system_disk_size"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsStatus : public Darabonba::Model {
public:
  shared_ptr<long> failedNodes{};
  shared_ptr<long> healthyNodes{};
  shared_ptr<long> initialNodes{};
  shared_ptr<long> offlineNodes{};
  shared_ptr<long> removingNodes{};
  shared_ptr<long> servingNodes{};
  shared_ptr<string> state{};
  shared_ptr<long> totalNodes{};

  DescribeClusterNodePoolsResponseBodyNodepoolsStatus() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedNodes) {
      res["failed_nodes"] = boost::any(*failedNodes);
    }
    if (healthyNodes) {
      res["healthy_nodes"] = boost::any(*healthyNodes);
    }
    if (initialNodes) {
      res["initial_nodes"] = boost::any(*initialNodes);
    }
    if (offlineNodes) {
      res["offline_nodes"] = boost::any(*offlineNodes);
    }
    if (removingNodes) {
      res["removing_nodes"] = boost::any(*removingNodes);
    }
    if (servingNodes) {
      res["serving_nodes"] = boost::any(*servingNodes);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (totalNodes) {
      res["total_nodes"] = boost::any(*totalNodes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("failed_nodes") != m.end() && !m["failed_nodes"].empty()) {
      failedNodes = make_shared<long>(boost::any_cast<long>(m["failed_nodes"]));
    }
    if (m.find("healthy_nodes") != m.end() && !m["healthy_nodes"].empty()) {
      healthyNodes = make_shared<long>(boost::any_cast<long>(m["healthy_nodes"]));
    }
    if (m.find("initial_nodes") != m.end() && !m["initial_nodes"].empty()) {
      initialNodes = make_shared<long>(boost::any_cast<long>(m["initial_nodes"]));
    }
    if (m.find("offline_nodes") != m.end() && !m["offline_nodes"].empty()) {
      offlineNodes = make_shared<long>(boost::any_cast<long>(m["offline_nodes"]));
    }
    if (m.find("removing_nodes") != m.end() && !m["removing_nodes"].empty()) {
      removingNodes = make_shared<long>(boost::any_cast<long>(m["removing_nodes"]));
    }
    if (m.find("serving_nodes") != m.end() && !m["serving_nodes"].empty()) {
      servingNodes = make_shared<long>(boost::any_cast<long>(m["serving_nodes"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("total_nodes") != m.end() && !m["total_nodes"].empty()) {
      totalNodes = make_shared<long>(boost::any_cast<long>(m["total_nodes"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsStatus() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> teeEnable{};

  DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (teeEnable) {
      res["tee_enable"] = boost::any(*teeEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tee_enable") != m.end() && !m["tee_enable"].empty()) {
      teeEnable = make_shared<bool>(boost::any_cast<bool>(m["tee_enable"]));
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig() = default;
};
class DescribeClusterNodePoolsResponseBodyNodepools : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsAutoMode> autoMode{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling> autoScaling{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig> interconnectConfig{};
  shared_ptr<string> interconnectMode{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig> kubernetesConfig{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsManagement> management{};
  shared_ptr<long> maxNodes{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsNodeConfig> nodeConfig{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo> nodepoolInfo{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup> scalingGroup{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsStatus> status{};
  shared_ptr<DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig> teeConfig{};

  DescribeClusterNodePoolsResponseBodyNodepools() {}

  explicit DescribeClusterNodePoolsResponseBodyNodepools(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoMode) {
      res["auto_mode"] = autoMode ? boost::any(autoMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoScaling) {
      res["auto_scaling"] = autoScaling ? boost::any(autoScaling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interconnectConfig) {
      res["interconnect_config"] = interconnectConfig ? boost::any(interconnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interconnectMode) {
      res["interconnect_mode"] = boost::any(*interconnectMode);
    }
    if (kubernetesConfig) {
      res["kubernetes_config"] = kubernetesConfig ? boost::any(kubernetesConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (management) {
      res["management"] = management ? boost::any(management->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxNodes) {
      res["max_nodes"] = boost::any(*maxNodes);
    }
    if (nodeConfig) {
      res["node_config"] = nodeConfig ? boost::any(nodeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodepoolInfo) {
      res["nodepool_info"] = nodepoolInfo ? boost::any(nodepoolInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scalingGroup) {
      res["scaling_group"] = scalingGroup ? boost::any(scalingGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["status"] = status ? boost::any(status->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (teeConfig) {
      res["tee_config"] = teeConfig ? boost::any(teeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_mode") != m.end() && !m["auto_mode"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_mode"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsAutoMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_mode"]));
        autoMode = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsAutoMode>(model1);
      }
    }
    if (m.find("auto_scaling") != m.end() && !m["auto_scaling"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_scaling"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_scaling"]));
        autoScaling = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling>(model1);
      }
    }
    if (m.find("interconnect_config") != m.end() && !m["interconnect_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["interconnect_config"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["interconnect_config"]));
        interconnectConfig = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig>(model1);
      }
    }
    if (m.find("interconnect_mode") != m.end() && !m["interconnect_mode"].empty()) {
      interconnectMode = make_shared<string>(boost::any_cast<string>(m["interconnect_mode"]));
    }
    if (m.find("kubernetes_config") != m.end() && !m["kubernetes_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["kubernetes_config"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kubernetes_config"]));
        kubernetesConfig = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig>(model1);
      }
    }
    if (m.find("management") != m.end() && !m["management"].empty()) {
      if (typeid(map<string, boost::any>) == m["management"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsManagement model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["management"]));
        management = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsManagement>(model1);
      }
    }
    if (m.find("max_nodes") != m.end() && !m["max_nodes"].empty()) {
      maxNodes = make_shared<long>(boost::any_cast<long>(m["max_nodes"]));
    }
    if (m.find("node_config") != m.end() && !m["node_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["node_config"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsNodeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["node_config"]));
        nodeConfig = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsNodeConfig>(model1);
      }
    }
    if (m.find("nodepool_info") != m.end() && !m["nodepool_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodepool_info"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodepool_info"]));
        nodepoolInfo = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo>(model1);
      }
    }
    if (m.find("scaling_group") != m.end() && !m["scaling_group"].empty()) {
      if (typeid(map<string, boost::any>) == m["scaling_group"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["scaling_group"]));
        scalingGroup = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup>(model1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      if (typeid(map<string, boost::any>) == m["status"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["status"]));
        status = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsStatus>(model1);
      }
    }
    if (m.find("tee_config") != m.end() && !m["tee_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["tee_config"].type()) {
        DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tee_config"]));
        teeConfig = make_shared<DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig>(model1);
      }
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBodyNodepools() = default;
};
class DescribeClusterNodePoolsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterNodePoolsResponseBodyNodepools>> nodepools{};

  DescribeClusterNodePoolsResponseBody() {}

  explicit DescribeClusterNodePoolsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodepools) {
      vector<boost::any> temp1;
      for(auto item1:*nodepools){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nodepools"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nodepools") != m.end() && !m["nodepools"].empty()) {
      if (typeid(vector<boost::any>) == m["nodepools"].type()) {
        vector<DescribeClusterNodePoolsResponseBodyNodepools> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nodepools"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterNodePoolsResponseBodyNodepools model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodepools = make_shared<vector<DescribeClusterNodePoolsResponseBodyNodepools>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterNodePoolsResponseBody() = default;
};
class DescribeClusterNodePoolsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterNodePoolsResponseBody> body{};

  DescribeClusterNodePoolsResponse() {}

  explicit DescribeClusterNodePoolsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterNodePoolsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterNodePoolsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterNodePoolsResponse() = default;
};
class DescribeClusterNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIds{};
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> state{};

  DescribeClusterNodesRequest() {}

  explicit DescribeClusterNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["instanceIds"] = boost::any(*instanceIds);
    }
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceIds") != m.end() && !m["instanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["instanceIds"]));
    }
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["pageSize"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~DescribeClusterNodesRequest() = default;
};
class DescribeClusterNodesResponseBodyNodes : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceRole{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<vector<string>> ipAddress{};
  shared_ptr<bool> isAliyunNode{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodeStatus{};
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> source{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> state{};

  DescribeClusterNodesResponseBodyNodes() {}

  explicit DescribeClusterNodesResponseBodyNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["creation_time"] = boost::any(*creationTime);
    }
    if (errorMessage) {
      res["error_message"] = boost::any(*errorMessage);
    }
    if (expiredTime) {
      res["expired_time"] = boost::any(*expiredTime);
    }
    if (hostName) {
      res["host_name"] = boost::any(*hostName);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (instanceChargeType) {
      res["instance_charge_type"] = boost::any(*instanceChargeType);
    }
    if (instanceId) {
      res["instance_id"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["instance_name"] = boost::any(*instanceName);
    }
    if (instanceRole) {
      res["instance_role"] = boost::any(*instanceRole);
    }
    if (instanceStatus) {
      res["instance_status"] = boost::any(*instanceStatus);
    }
    if (instanceType) {
      res["instance_type"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["instance_type_family"] = boost::any(*instanceTypeFamily);
    }
    if (ipAddress) {
      res["ip_address"] = boost::any(*ipAddress);
    }
    if (isAliyunNode) {
      res["is_aliyun_node"] = boost::any(*isAliyunNode);
    }
    if (nodeName) {
      res["node_name"] = boost::any(*nodeName);
    }
    if (nodeStatus) {
      res["node_status"] = boost::any(*nodeStatus);
    }
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (spotStrategy) {
      res["spot_strategy"] = boost::any(*spotStrategy);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creation_time") != m.end() && !m["creation_time"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["creation_time"]));
    }
    if (m.find("error_message") != m.end() && !m["error_message"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["error_message"]));
    }
    if (m.find("expired_time") != m.end() && !m["expired_time"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["expired_time"]));
    }
    if (m.find("host_name") != m.end() && !m["host_name"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["host_name"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("instance_charge_type") != m.end() && !m["instance_charge_type"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["instance_charge_type"]));
    }
    if (m.find("instance_id") != m.end() && !m["instance_id"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instance_id"]));
    }
    if (m.find("instance_name") != m.end() && !m["instance_name"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["instance_name"]));
    }
    if (m.find("instance_role") != m.end() && !m["instance_role"].empty()) {
      instanceRole = make_shared<string>(boost::any_cast<string>(m["instance_role"]));
    }
    if (m.find("instance_status") != m.end() && !m["instance_status"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["instance_status"]));
    }
    if (m.find("instance_type") != m.end() && !m["instance_type"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instance_type"]));
    }
    if (m.find("instance_type_family") != m.end() && !m["instance_type_family"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["instance_type_family"]));
    }
    if (m.find("ip_address") != m.end() && !m["ip_address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ip_address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ip_address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("is_aliyun_node") != m.end() && !m["is_aliyun_node"].empty()) {
      isAliyunNode = make_shared<bool>(boost::any_cast<bool>(m["is_aliyun_node"]));
    }
    if (m.find("node_name") != m.end() && !m["node_name"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["node_name"]));
    }
    if (m.find("node_status") != m.end() && !m["node_status"].empty()) {
      nodeStatus = make_shared<string>(boost::any_cast<string>(m["node_status"]));
    }
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("spot_strategy") != m.end() && !m["spot_strategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["spot_strategy"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~DescribeClusterNodesResponseBodyNodes() = default;
};
class DescribeClusterNodesResponseBodyPage : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeClusterNodesResponseBodyPage() {}

  explicit DescribeClusterNodesResponseBodyPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~DescribeClusterNodesResponseBodyPage() = default;
};
class DescribeClusterNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterNodesResponseBodyNodes>> nodes{};
  shared_ptr<DescribeClusterNodesResponseBodyPage> page{};

  DescribeClusterNodesResponseBody() {}

  explicit DescribeClusterNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nodes"] = boost::any(temp1);
    }
    if (page) {
      res["page"] = page ? boost::any(page->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<DescribeClusterNodesResponseBodyNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterNodesResponseBodyNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<DescribeClusterNodesResponseBodyNodes>>(expect1);
      }
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      if (typeid(map<string, boost::any>) == m["page"].type()) {
        DescribeClusterNodesResponseBodyPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page"]));
        page = make_shared<DescribeClusterNodesResponseBodyPage>(model1);
      }
    }
  }


  virtual ~DescribeClusterNodesResponseBody() = default;
};
class DescribeClusterNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterNodesResponseBody> body{};

  DescribeClusterNodesResponse() {}

  explicit DescribeClusterNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterNodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterNodesResponse() = default;
};
class DescribeClusterResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> withAddonResources{};

  DescribeClusterResourcesRequest() {}

  explicit DescribeClusterResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (withAddonResources) {
      res["with_addon_resources"] = boost::any(*withAddonResources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("with_addon_resources") != m.end() && !m["with_addon_resources"].empty()) {
      withAddonResources = make_shared<bool>(boost::any_cast<bool>(m["with_addon_resources"]));
    }
  }


  virtual ~DescribeClusterResourcesRequest() = default;
};
class DescribeClusterResourcesResponseBodyDependencies : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> instanceId{};

  DescribeClusterResourcesResponseBodyDependencies() {}

  explicit DescribeClusterResourcesResponseBodyDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (instanceId) {
      res["instance_id"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("instance_id") != m.end() && !m["instance_id"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instance_id"]));
    }
  }


  virtual ~DescribeClusterResourcesResponseBodyDependencies() = default;
};
class DescribeClusterResourcesResponseBodyAssociatedObject : public Darabonba::Model {
public:
  shared_ptr<string> kind{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> name{};

  DescribeClusterResourcesResponseBodyAssociatedObject() {}

  explicit DescribeClusterResourcesResponseBodyAssociatedObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kind) {
      res["kind"] = boost::any(*kind);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("kind") != m.end() && !m["kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["kind"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeClusterResourcesResponseBodyAssociatedObject() = default;
};
class DescribeClusterResourcesResponseBodyDeleteBehavior : public Darabonba::Model {
public:
  shared_ptr<bool> deleteByDefault{};
  shared_ptr<bool> changeable{};

  DescribeClusterResourcesResponseBodyDeleteBehavior() {}

  explicit DescribeClusterResourcesResponseBodyDeleteBehavior(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteByDefault) {
      res["delete_by_default"] = boost::any(*deleteByDefault);
    }
    if (changeable) {
      res["changeable"] = boost::any(*changeable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("delete_by_default") != m.end() && !m["delete_by_default"].empty()) {
      deleteByDefault = make_shared<bool>(boost::any_cast<bool>(m["delete_by_default"]));
    }
    if (m.find("changeable") != m.end() && !m["changeable"].empty()) {
      changeable = make_shared<bool>(boost::any_cast<bool>(m["changeable"]));
    }
  }


  virtual ~DescribeClusterResourcesResponseBodyDeleteBehavior() = default;
};
class DescribeClusterResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> created{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> resourceInfo{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> state{};
  shared_ptr<long> autoCreate{};
  shared_ptr<vector<DescribeClusterResourcesResponseBodyDependencies>> dependencies{};
  shared_ptr<DescribeClusterResourcesResponseBodyAssociatedObject> associatedObject{};
  shared_ptr<DescribeClusterResourcesResponseBodyDeleteBehavior> deleteBehavior{};
  shared_ptr<string> creatorType{};
  shared_ptr<map<string, boost::any>> extraInfo{};

  DescribeClusterResourcesResponseBody() {}

  explicit DescribeClusterResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (instanceId) {
      res["instance_id"] = boost::any(*instanceId);
    }
    if (resourceInfo) {
      res["resource_info"] = boost::any(*resourceInfo);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (autoCreate) {
      res["auto_create"] = boost::any(*autoCreate);
    }
    if (dependencies) {
      vector<boost::any> temp1;
      for(auto item1:*dependencies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dependencies"] = boost::any(temp1);
    }
    if (associatedObject) {
      res["associated_object"] = associatedObject ? boost::any(associatedObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deleteBehavior) {
      res["delete_behavior"] = deleteBehavior ? boost::any(deleteBehavior->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creatorType) {
      res["creator_type"] = boost::any(*creatorType);
    }
    if (extraInfo) {
      res["extra_info"] = boost::any(*extraInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("instance_id") != m.end() && !m["instance_id"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instance_id"]));
    }
    if (m.find("resource_info") != m.end() && !m["resource_info"].empty()) {
      resourceInfo = make_shared<string>(boost::any_cast<string>(m["resource_info"]));
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("auto_create") != m.end() && !m["auto_create"].empty()) {
      autoCreate = make_shared<long>(boost::any_cast<long>(m["auto_create"]));
    }
    if (m.find("dependencies") != m.end() && !m["dependencies"].empty()) {
      if (typeid(vector<boost::any>) == m["dependencies"].type()) {
        vector<DescribeClusterResourcesResponseBodyDependencies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dependencies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterResourcesResponseBodyDependencies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependencies = make_shared<vector<DescribeClusterResourcesResponseBodyDependencies>>(expect1);
      }
    }
    if (m.find("associated_object") != m.end() && !m["associated_object"].empty()) {
      if (typeid(map<string, boost::any>) == m["associated_object"].type()) {
        DescribeClusterResourcesResponseBodyAssociatedObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["associated_object"]));
        associatedObject = make_shared<DescribeClusterResourcesResponseBodyAssociatedObject>(model1);
      }
    }
    if (m.find("delete_behavior") != m.end() && !m["delete_behavior"].empty()) {
      if (typeid(map<string, boost::any>) == m["delete_behavior"].type()) {
        DescribeClusterResourcesResponseBodyDeleteBehavior model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["delete_behavior"]));
        deleteBehavior = make_shared<DescribeClusterResourcesResponseBodyDeleteBehavior>(model1);
      }
    }
    if (m.find("creator_type") != m.end() && !m["creator_type"].empty()) {
      creatorType = make_shared<string>(boost::any_cast<string>(m["creator_type"]));
    }
    if (m.find("extra_info") != m.end() && !m["extra_info"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["extra_info"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeClusterResourcesResponseBody() = default;
};
class DescribeClusterResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<DescribeClusterResourcesResponseBody>> body{};

  DescribeClusterResourcesResponse() {}

  explicit DescribeClusterResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<DescribeClusterResourcesResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterResourcesResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<DescribeClusterResourcesResponseBody>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterResourcesResponse() = default;
};
class DescribeClusterTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeClusterTasksRequest() {}

  explicit DescribeClusterTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
  }


  virtual ~DescribeClusterTasksRequest() = default;
};
class DescribeClusterTasksResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeClusterTasksResponseBodyPageInfo() {}

  explicit DescribeClusterTasksResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~DescribeClusterTasksResponseBodyPageInfo() = default;
};
class DescribeClusterTasksResponseBodyTasksError : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  DescribeClusterTasksResponseBodyTasksError() {}

  explicit DescribeClusterTasksResponseBodyTasksError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~DescribeClusterTasksResponseBodyTasksError() = default;
};
class DescribeClusterTasksResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> created{};
  shared_ptr<DescribeClusterTasksResponseBodyTasksError> error{};
  shared_ptr<string> state{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> updated{};

  DescribeClusterTasksResponseBodyTasks() {}

  explicit DescribeClusterTasksResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (error) {
      res["error"] = error ? boost::any(error->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    if (taskType) {
      res["task_type"] = boost::any(*taskType);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("error") != m.end() && !m["error"].empty()) {
      if (typeid(map<string, boost::any>) == m["error"].type()) {
        DescribeClusterTasksResponseBodyTasksError model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["error"]));
        error = make_shared<DescribeClusterTasksResponseBodyTasksError>(model1);
      }
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
    if (m.find("task_type") != m.end() && !m["task_type"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["task_type"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
  }


  virtual ~DescribeClusterTasksResponseBodyTasks() = default;
};
class DescribeClusterTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterTasksResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeClusterTasksResponseBodyTasks>> tasks{};

  DescribeClusterTasksResponseBody() {}

  explicit DescribeClusterTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        DescribeClusterTasksResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<DescribeClusterTasksResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("tasks") != m.end() && !m["tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["tasks"].type()) {
        vector<DescribeClusterTasksResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterTasksResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<DescribeClusterTasksResponseBodyTasks>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterTasksResponseBody() = default;
};
class DescribeClusterTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterTasksResponseBody> body{};

  DescribeClusterTasksResponse() {}

  explicit DescribeClusterTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterTasksResponse() = default;
};
class DescribeClusterUserKubeconfigRequest : public Darabonba::Model {
public:
  shared_ptr<bool> privateIpAddress{};
  shared_ptr<long> temporaryDurationMinutes{};

  DescribeClusterUserKubeconfigRequest() {}

  explicit DescribeClusterUserKubeconfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (temporaryDurationMinutes) {
      res["TemporaryDurationMinutes"] = boost::any(*temporaryDurationMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<bool>(boost::any_cast<bool>(m["PrivateIpAddress"]));
    }
    if (m.find("TemporaryDurationMinutes") != m.end() && !m["TemporaryDurationMinutes"].empty()) {
      temporaryDurationMinutes = make_shared<long>(boost::any_cast<long>(m["TemporaryDurationMinutes"]));
    }
  }


  virtual ~DescribeClusterUserKubeconfigRequest() = default;
};
class DescribeClusterUserKubeconfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> expiration{};

  DescribeClusterUserKubeconfigResponseBody() {}

  explicit DescribeClusterUserKubeconfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (expiration) {
      res["expiration"] = boost::any(*expiration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
    if (m.find("expiration") != m.end() && !m["expiration"].empty()) {
      expiration = make_shared<string>(boost::any_cast<string>(m["expiration"]));
    }
  }


  virtual ~DescribeClusterUserKubeconfigResponseBody() = default;
};
class DescribeClusterUserKubeconfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterUserKubeconfigResponseBody> body{};

  DescribeClusterUserKubeconfigResponse() {}

  explicit DescribeClusterUserKubeconfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterUserKubeconfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterUserKubeconfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterUserKubeconfigResponse() = default;
};
class DescribeClusterV2UserKubeconfigRequest : public Darabonba::Model {
public:
  shared_ptr<bool> privateIpAddress{};
  shared_ptr<long> temporaryDurationMinutes{};

  DescribeClusterV2UserKubeconfigRequest() {}

  explicit DescribeClusterV2UserKubeconfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (temporaryDurationMinutes) {
      res["TemporaryDurationMinutes"] = boost::any(*temporaryDurationMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<bool>(boost::any_cast<bool>(m["PrivateIpAddress"]));
    }
    if (m.find("TemporaryDurationMinutes") != m.end() && !m["TemporaryDurationMinutes"].empty()) {
      temporaryDurationMinutes = make_shared<long>(boost::any_cast<long>(m["TemporaryDurationMinutes"]));
    }
  }


  virtual ~DescribeClusterV2UserKubeconfigRequest() = default;
};
class DescribeClusterV2UserKubeconfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> config{};

  DescribeClusterV2UserKubeconfigResponseBody() {}

  explicit DescribeClusterV2UserKubeconfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["config"] = boost::any(*config);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
  }


  virtual ~DescribeClusterV2UserKubeconfigResponseBody() = default;
};
class DescribeClusterV2UserKubeconfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterV2UserKubeconfigResponseBody> body{};

  DescribeClusterV2UserKubeconfigResponse() {}

  explicit DescribeClusterV2UserKubeconfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterV2UserKubeconfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterV2UserKubeconfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2UserKubeconfigResponse() = default;
};
class DescribeClusterVulsResponseBodyVulRecords : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cveList{};
  shared_ptr<string> necessity{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> nodepoolName{};
  shared_ptr<string> vulAliasName{};
  shared_ptr<string> vulName{};
  shared_ptr<string> vulType{};

  DescribeClusterVulsResponseBodyVulRecords() {}

  explicit DescribeClusterVulsResponseBodyVulRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cveList) {
      res["cve_list"] = boost::any(*cveList);
    }
    if (necessity) {
      res["necessity"] = boost::any(*necessity);
    }
    if (nodeCount) {
      res["node_count"] = boost::any(*nodeCount);
    }
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (nodepoolName) {
      res["nodepool_name"] = boost::any(*nodepoolName);
    }
    if (vulAliasName) {
      res["vul_alias_name"] = boost::any(*vulAliasName);
    }
    if (vulName) {
      res["vul_name"] = boost::any(*vulName);
    }
    if (vulType) {
      res["vul_type"] = boost::any(*vulType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cve_list") != m.end() && !m["cve_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["cve_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["cve_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cveList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("necessity") != m.end() && !m["necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["necessity"]));
    }
    if (m.find("node_count") != m.end() && !m["node_count"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["node_count"]));
    }
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("nodepool_name") != m.end() && !m["nodepool_name"].empty()) {
      nodepoolName = make_shared<string>(boost::any_cast<string>(m["nodepool_name"]));
    }
    if (m.find("vul_alias_name") != m.end() && !m["vul_alias_name"].empty()) {
      vulAliasName = make_shared<string>(boost::any_cast<string>(m["vul_alias_name"]));
    }
    if (m.find("vul_name") != m.end() && !m["vul_name"].empty()) {
      vulName = make_shared<string>(boost::any_cast<string>(m["vul_name"]));
    }
    if (m.find("vul_type") != m.end() && !m["vul_type"].empty()) {
      vulType = make_shared<string>(boost::any_cast<string>(m["vul_type"]));
    }
  }


  virtual ~DescribeClusterVulsResponseBodyVulRecords() = default;
};
class DescribeClusterVulsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterVulsResponseBodyVulRecords>> vulRecords{};

  DescribeClusterVulsResponseBody() {}

  explicit DescribeClusterVulsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vulRecords) {
      vector<boost::any> temp1;
      for(auto item1:*vulRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["vul_records"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("vul_records") != m.end() && !m["vul_records"].empty()) {
      if (typeid(vector<boost::any>) == m["vul_records"].type()) {
        vector<DescribeClusterVulsResponseBodyVulRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["vul_records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterVulsResponseBodyVulRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulRecords = make_shared<vector<DescribeClusterVulsResponseBodyVulRecords>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterVulsResponseBody() = default;
};
class DescribeClusterVulsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterVulsResponseBody> body{};

  DescribeClusterVulsResponse() {}

  explicit DescribeClusterVulsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterVulsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterVulsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterVulsResponse() = default;
};
class DescribeClustersRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};

  DescribeClustersRequest() {}

  explicit DescribeClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["clusterType"] = boost::any(*clusterType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusterType") != m.end() && !m["clusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["clusterType"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
  }


  virtual ~DescribeClustersRequest() = default;
};
class DescribeClustersResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeClustersResponseBodyTags() {}

  explicit DescribeClustersResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~DescribeClustersResponseBodyTags() = default;
};
class DescribeClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> created{};
  shared_ptr<string> currentVersion{};
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> dockerVersion{};
  shared_ptr<string> externalLoadbalancerId{};
  shared_ptr<string> initVersion{};
  shared_ptr<string> masterUrl{};
  shared_ptr<string> metaData{};
  shared_ptr<string> name{};
  shared_ptr<string> networkMode{};
  shared_ptr<bool> privateZone{};
  shared_ptr<string> profile{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<long> size{};
  shared_ptr<string> state{};
  shared_ptr<string> subnetCidr{};
  shared_ptr<vector<DescribeClustersResponseBodyTags>> tags{};
  shared_ptr<string> updated{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchCidr{};
  shared_ptr<string> vswitchId{};
  shared_ptr<string> workerRamRoleName{};
  shared_ptr<string> zoneId{};

  DescribeClustersResponseBody() {}

  explicit DescribeClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["cluster_type"] = boost::any(*clusterType);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (currentVersion) {
      res["current_version"] = boost::any(*currentVersion);
    }
    if (dataDiskCategory) {
      res["data_disk_category"] = boost::any(*dataDiskCategory);
    }
    if (dataDiskSize) {
      res["data_disk_size"] = boost::any(*dataDiskSize);
    }
    if (deletionProtection) {
      res["deletion_protection"] = boost::any(*deletionProtection);
    }
    if (dockerVersion) {
      res["docker_version"] = boost::any(*dockerVersion);
    }
    if (externalLoadbalancerId) {
      res["external_loadbalancer_id"] = boost::any(*externalLoadbalancerId);
    }
    if (initVersion) {
      res["init_version"] = boost::any(*initVersion);
    }
    if (masterUrl) {
      res["master_url"] = boost::any(*masterUrl);
    }
    if (metaData) {
      res["meta_data"] = boost::any(*metaData);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (networkMode) {
      res["network_mode"] = boost::any(*networkMode);
    }
    if (privateZone) {
      res["private_zone"] = boost::any(*privateZone);
    }
    if (profile) {
      res["profile"] = boost::any(*profile);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["security_group_id"] = boost::any(*securityGroupId);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (subnetCidr) {
      res["subnet_cidr"] = boost::any(*subnetCidr);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    if (vpcId) {
      res["vpc_id"] = boost::any(*vpcId);
    }
    if (vswitchCidr) {
      res["vswitch_cidr"] = boost::any(*vswitchCidr);
    }
    if (vswitchId) {
      res["vswitch_id"] = boost::any(*vswitchId);
    }
    if (workerRamRoleName) {
      res["worker_ram_role_name"] = boost::any(*workerRamRoleName);
    }
    if (zoneId) {
      res["zone_id"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("cluster_type") != m.end() && !m["cluster_type"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["cluster_type"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("current_version") != m.end() && !m["current_version"].empty()) {
      currentVersion = make_shared<string>(boost::any_cast<string>(m["current_version"]));
    }
    if (m.find("data_disk_category") != m.end() && !m["data_disk_category"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["data_disk_category"]));
    }
    if (m.find("data_disk_size") != m.end() && !m["data_disk_size"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["data_disk_size"]));
    }
    if (m.find("deletion_protection") != m.end() && !m["deletion_protection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["deletion_protection"]));
    }
    if (m.find("docker_version") != m.end() && !m["docker_version"].empty()) {
      dockerVersion = make_shared<string>(boost::any_cast<string>(m["docker_version"]));
    }
    if (m.find("external_loadbalancer_id") != m.end() && !m["external_loadbalancer_id"].empty()) {
      externalLoadbalancerId = make_shared<string>(boost::any_cast<string>(m["external_loadbalancer_id"]));
    }
    if (m.find("init_version") != m.end() && !m["init_version"].empty()) {
      initVersion = make_shared<string>(boost::any_cast<string>(m["init_version"]));
    }
    if (m.find("master_url") != m.end() && !m["master_url"].empty()) {
      masterUrl = make_shared<string>(boost::any_cast<string>(m["master_url"]));
    }
    if (m.find("meta_data") != m.end() && !m["meta_data"].empty()) {
      metaData = make_shared<string>(boost::any_cast<string>(m["meta_data"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("network_mode") != m.end() && !m["network_mode"].empty()) {
      networkMode = make_shared<string>(boost::any_cast<string>(m["network_mode"]));
    }
    if (m.find("private_zone") != m.end() && !m["private_zone"].empty()) {
      privateZone = make_shared<bool>(boost::any_cast<bool>(m["private_zone"]));
    }
    if (m.find("profile") != m.end() && !m["profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["profile"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
    if (m.find("security_group_id") != m.end() && !m["security_group_id"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["security_group_id"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("subnet_cidr") != m.end() && !m["subnet_cidr"].empty()) {
      subnetCidr = make_shared<string>(boost::any_cast<string>(m["subnet_cidr"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<DescribeClustersResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClustersResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeClustersResponseBodyTags>>(expect1);
      }
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
    if (m.find("vpc_id") != m.end() && !m["vpc_id"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpc_id"]));
    }
    if (m.find("vswitch_cidr") != m.end() && !m["vswitch_cidr"].empty()) {
      vswitchCidr = make_shared<string>(boost::any_cast<string>(m["vswitch_cidr"]));
    }
    if (m.find("vswitch_id") != m.end() && !m["vswitch_id"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitch_id"]));
    }
    if (m.find("worker_ram_role_name") != m.end() && !m["worker_ram_role_name"].empty()) {
      workerRamRoleName = make_shared<string>(boost::any_cast<string>(m["worker_ram_role_name"]));
    }
    if (m.find("zone_id") != m.end() && !m["zone_id"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zone_id"]));
    }
  }


  virtual ~DescribeClustersResponseBody() = default;
};
class DescribeClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<DescribeClustersResponseBody>> body{};

  DescribeClustersResponse() {}

  explicit DescribeClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<DescribeClustersResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClustersResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<DescribeClustersResponseBody>>(expect1);
      }
    }
  }


  virtual ~DescribeClustersResponse() = default;
};
class DescribeClustersForRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterSpec{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> profile{};

  DescribeClustersForRegionRequest() {}

  explicit DescribeClustersForRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (clusterSpec) {
      res["cluster_spec"] = boost::any(*clusterSpec);
    }
    if (clusterType) {
      res["cluster_type"] = boost::any(*clusterType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (profile) {
      res["profile"] = boost::any(*profile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("cluster_spec") != m.end() && !m["cluster_spec"].empty()) {
      clusterSpec = make_shared<string>(boost::any_cast<string>(m["cluster_spec"]));
    }
    if (m.find("cluster_type") != m.end() && !m["cluster_type"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["cluster_type"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("profile") != m.end() && !m["profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["profile"]));
    }
  }


  virtual ~DescribeClustersForRegionRequest() = default;
};
class DescribeClustersForRegionResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<string> clusterDomain{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterSpec{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> containerCidr{};
  shared_ptr<string> created{};
  shared_ptr<string> currentVersion{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> initVersion{};
  shared_ptr<string> ipStack{};
  shared_ptr<string> name{};
  shared_ptr<string> nextVersion{};
  shared_ptr<string> profile{};
  shared_ptr<string> proxyMode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> serviceCidr{};
  shared_ptr<long> size{};
  shared_ptr<string> state{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<string> timezone{};
  shared_ptr<string> updated{};
  shared_ptr<string> vpcId{};
  shared_ptr<vector<string>> vswitchIds{};

  DescribeClustersForRegionResponseBodyClusters() {}

  explicit DescribeClustersForRegionResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterDomain) {
      res["cluster_domain"] = boost::any(*clusterDomain);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (clusterSpec) {
      res["cluster_spec"] = boost::any(*clusterSpec);
    }
    if (clusterType) {
      res["cluster_type"] = boost::any(*clusterType);
    }
    if (containerCidr) {
      res["container_cidr"] = boost::any(*containerCidr);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (currentVersion) {
      res["current_version"] = boost::any(*currentVersion);
    }
    if (deletionProtection) {
      res["deletion_protection"] = boost::any(*deletionProtection);
    }
    if (initVersion) {
      res["init_version"] = boost::any(*initVersion);
    }
    if (ipStack) {
      res["ip_stack"] = boost::any(*ipStack);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nextVersion) {
      res["next_version"] = boost::any(*nextVersion);
    }
    if (profile) {
      res["profile"] = boost::any(*profile);
    }
    if (proxyMode) {
      res["proxy_mode"] = boost::any(*proxyMode);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["security_group_id"] = boost::any(*securityGroupId);
    }
    if (serviceCidr) {
      res["service_cidr"] = boost::any(*serviceCidr);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (timezone) {
      res["timezone"] = boost::any(*timezone);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    if (vpcId) {
      res["vpc_id"] = boost::any(*vpcId);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_domain") != m.end() && !m["cluster_domain"].empty()) {
      clusterDomain = make_shared<string>(boost::any_cast<string>(m["cluster_domain"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("cluster_spec") != m.end() && !m["cluster_spec"].empty()) {
      clusterSpec = make_shared<string>(boost::any_cast<string>(m["cluster_spec"]));
    }
    if (m.find("cluster_type") != m.end() && !m["cluster_type"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["cluster_type"]));
    }
    if (m.find("container_cidr") != m.end() && !m["container_cidr"].empty()) {
      containerCidr = make_shared<string>(boost::any_cast<string>(m["container_cidr"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("current_version") != m.end() && !m["current_version"].empty()) {
      currentVersion = make_shared<string>(boost::any_cast<string>(m["current_version"]));
    }
    if (m.find("deletion_protection") != m.end() && !m["deletion_protection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["deletion_protection"]));
    }
    if (m.find("init_version") != m.end() && !m["init_version"].empty()) {
      initVersion = make_shared<string>(boost::any_cast<string>(m["init_version"]));
    }
    if (m.find("ip_stack") != m.end() && !m["ip_stack"].empty()) {
      ipStack = make_shared<string>(boost::any_cast<string>(m["ip_stack"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("next_version") != m.end() && !m["next_version"].empty()) {
      nextVersion = make_shared<string>(boost::any_cast<string>(m["next_version"]));
    }
    if (m.find("profile") != m.end() && !m["profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["profile"]));
    }
    if (m.find("proxy_mode") != m.end() && !m["proxy_mode"].empty()) {
      proxyMode = make_shared<string>(boost::any_cast<string>(m["proxy_mode"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
    if (m.find("security_group_id") != m.end() && !m["security_group_id"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["security_group_id"]));
    }
    if (m.find("service_cidr") != m.end() && !m["service_cidr"].empty()) {
      serviceCidr = make_shared<string>(boost::any_cast<string>(m["service_cidr"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("timezone") != m.end() && !m["timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["timezone"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
    if (m.find("vpc_id") != m.end() && !m["vpc_id"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpc_id"]));
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClustersForRegionResponseBodyClusters() = default;
};
class DescribeClustersForRegionResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeClustersForRegionResponseBodyPageInfo() {}

  explicit DescribeClustersForRegionResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~DescribeClustersForRegionResponseBodyPageInfo() = default;
};
class DescribeClustersForRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClustersForRegionResponseBodyClusters>> clusters{};
  shared_ptr<DescribeClustersForRegionResponseBodyPageInfo> pageInfo{};

  DescribeClustersForRegionResponseBody() {}

  explicit DescribeClustersForRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      vector<boost::any> temp1;
      for(auto item1:*clusters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["clusters"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusters") != m.end() && !m["clusters"].empty()) {
      if (typeid(vector<boost::any>) == m["clusters"].type()) {
        vector<DescribeClustersForRegionResponseBodyClusters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["clusters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClustersForRegionResponseBodyClusters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusters = make_shared<vector<DescribeClustersForRegionResponseBodyClusters>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        DescribeClustersForRegionResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<DescribeClustersForRegionResponseBodyPageInfo>(model1);
      }
    }
  }


  virtual ~DescribeClustersForRegionResponseBody() = default;
};
class DescribeClustersForRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClustersForRegionResponseBody> body{};

  DescribeClustersForRegionResponse() {}

  explicit DescribeClustersForRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClustersForRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClustersForRegionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClustersForRegionResponse() = default;
};
class DescribeClustersV1Request : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterSpec{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> profile{};
  shared_ptr<string> regionId{};

  DescribeClustersV1Request() {}

  explicit DescribeClustersV1Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (clusterSpec) {
      res["cluster_spec"] = boost::any(*clusterSpec);
    }
    if (clusterType) {
      res["cluster_type"] = boost::any(*clusterType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (profile) {
      res["profile"] = boost::any(*profile);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("cluster_spec") != m.end() && !m["cluster_spec"].empty()) {
      clusterSpec = make_shared<string>(boost::any_cast<string>(m["cluster_spec"]));
    }
    if (m.find("cluster_type") != m.end() && !m["cluster_type"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["cluster_type"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("profile") != m.end() && !m["profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["profile"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
  }


  virtual ~DescribeClustersV1Request() = default;
};
class DescribeClustersV1ResponseBodyClustersOperationPolicyClusterAutoUpgrade : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<bool> enabled{};

  DescribeClustersV1ResponseBodyClustersOperationPolicyClusterAutoUpgrade() {}

  explicit DescribeClustersV1ResponseBodyClustersOperationPolicyClusterAutoUpgrade(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["channel"] = boost::any(*channel);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("channel") != m.end() && !m["channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["channel"]));
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
  }


  virtual ~DescribeClustersV1ResponseBodyClustersOperationPolicyClusterAutoUpgrade() = default;
};
class DescribeClustersV1ResponseBodyClustersOperationPolicy : public Darabonba::Model {
public:
  shared_ptr<DescribeClustersV1ResponseBodyClustersOperationPolicyClusterAutoUpgrade> clusterAutoUpgrade{};

  DescribeClustersV1ResponseBodyClustersOperationPolicy() {}

  explicit DescribeClustersV1ResponseBodyClustersOperationPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterAutoUpgrade) {
      res["cluster_auto_upgrade"] = clusterAutoUpgrade ? boost::any(clusterAutoUpgrade->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_auto_upgrade") != m.end() && !m["cluster_auto_upgrade"].empty()) {
      if (typeid(map<string, boost::any>) == m["cluster_auto_upgrade"].type()) {
        DescribeClustersV1ResponseBodyClustersOperationPolicyClusterAutoUpgrade model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cluster_auto_upgrade"]));
        clusterAutoUpgrade = make_shared<DescribeClustersV1ResponseBodyClustersOperationPolicyClusterAutoUpgrade>(model1);
      }
    }
  }


  virtual ~DescribeClustersV1ResponseBodyClustersOperationPolicy() = default;
};
class DescribeClustersV1ResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<string> clusterDomain{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterSpec{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> containerCidr{};
  shared_ptr<string> created{};
  shared_ptr<string> currentVersion{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> dockerVersion{};
  shared_ptr<string> externalLoadbalancerId{};
  shared_ptr<string> initVersion{};
  shared_ptr<string> ipStack{};
  shared_ptr<MaintenanceWindow> maintenanceWindow{};
  shared_ptr<string> masterUrl{};
  shared_ptr<string> metaData{};
  shared_ptr<string> name{};
  shared_ptr<string> networkMode{};
  shared_ptr<string> nextVersion{};
  shared_ptr<DescribeClustersV1ResponseBodyClustersOperationPolicy> operationPolicy{};
  shared_ptr<bool> privateZone{};
  shared_ptr<string> profile{};
  shared_ptr<string> proxyMode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> serviceCidr{};
  shared_ptr<long> size{};
  shared_ptr<string> state{};
  shared_ptr<string> subnetCidr{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<string> timezone{};
  shared_ptr<string> updated{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};
  shared_ptr<vector<string>> vswitchIds{};
  shared_ptr<string> workerRamRoleName{};
  shared_ptr<string> zoneId{};

  DescribeClustersV1ResponseBodyClusters() {}

  explicit DescribeClustersV1ResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterDomain) {
      res["cluster_domain"] = boost::any(*clusterDomain);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (clusterSpec) {
      res["cluster_spec"] = boost::any(*clusterSpec);
    }
    if (clusterType) {
      res["cluster_type"] = boost::any(*clusterType);
    }
    if (containerCidr) {
      res["container_cidr"] = boost::any(*containerCidr);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (currentVersion) {
      res["current_version"] = boost::any(*currentVersion);
    }
    if (deletionProtection) {
      res["deletion_protection"] = boost::any(*deletionProtection);
    }
    if (dockerVersion) {
      res["docker_version"] = boost::any(*dockerVersion);
    }
    if (externalLoadbalancerId) {
      res["external_loadbalancer_id"] = boost::any(*externalLoadbalancerId);
    }
    if (initVersion) {
      res["init_version"] = boost::any(*initVersion);
    }
    if (ipStack) {
      res["ip_stack"] = boost::any(*ipStack);
    }
    if (maintenanceWindow) {
      res["maintenance_window"] = maintenanceWindow ? boost::any(maintenanceWindow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (masterUrl) {
      res["master_url"] = boost::any(*masterUrl);
    }
    if (metaData) {
      res["meta_data"] = boost::any(*metaData);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (networkMode) {
      res["network_mode"] = boost::any(*networkMode);
    }
    if (nextVersion) {
      res["next_version"] = boost::any(*nextVersion);
    }
    if (operationPolicy) {
      res["operation_policy"] = operationPolicy ? boost::any(operationPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateZone) {
      res["private_zone"] = boost::any(*privateZone);
    }
    if (profile) {
      res["profile"] = boost::any(*profile);
    }
    if (proxyMode) {
      res["proxy_mode"] = boost::any(*proxyMode);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["security_group_id"] = boost::any(*securityGroupId);
    }
    if (serviceCidr) {
      res["service_cidr"] = boost::any(*serviceCidr);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (subnetCidr) {
      res["subnet_cidr"] = boost::any(*subnetCidr);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (timezone) {
      res["timezone"] = boost::any(*timezone);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    if (vpcId) {
      res["vpc_id"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["vswitch_id"] = boost::any(*vswitchId);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    if (workerRamRoleName) {
      res["worker_ram_role_name"] = boost::any(*workerRamRoleName);
    }
    if (zoneId) {
      res["zone_id"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_domain") != m.end() && !m["cluster_domain"].empty()) {
      clusterDomain = make_shared<string>(boost::any_cast<string>(m["cluster_domain"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("cluster_spec") != m.end() && !m["cluster_spec"].empty()) {
      clusterSpec = make_shared<string>(boost::any_cast<string>(m["cluster_spec"]));
    }
    if (m.find("cluster_type") != m.end() && !m["cluster_type"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["cluster_type"]));
    }
    if (m.find("container_cidr") != m.end() && !m["container_cidr"].empty()) {
      containerCidr = make_shared<string>(boost::any_cast<string>(m["container_cidr"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("current_version") != m.end() && !m["current_version"].empty()) {
      currentVersion = make_shared<string>(boost::any_cast<string>(m["current_version"]));
    }
    if (m.find("deletion_protection") != m.end() && !m["deletion_protection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["deletion_protection"]));
    }
    if (m.find("docker_version") != m.end() && !m["docker_version"].empty()) {
      dockerVersion = make_shared<string>(boost::any_cast<string>(m["docker_version"]));
    }
    if (m.find("external_loadbalancer_id") != m.end() && !m["external_loadbalancer_id"].empty()) {
      externalLoadbalancerId = make_shared<string>(boost::any_cast<string>(m["external_loadbalancer_id"]));
    }
    if (m.find("init_version") != m.end() && !m["init_version"].empty()) {
      initVersion = make_shared<string>(boost::any_cast<string>(m["init_version"]));
    }
    if (m.find("ip_stack") != m.end() && !m["ip_stack"].empty()) {
      ipStack = make_shared<string>(boost::any_cast<string>(m["ip_stack"]));
    }
    if (m.find("maintenance_window") != m.end() && !m["maintenance_window"].empty()) {
      if (typeid(map<string, boost::any>) == m["maintenance_window"].type()) {
        MaintenanceWindow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["maintenance_window"]));
        maintenanceWindow = make_shared<MaintenanceWindow>(model1);
      }
    }
    if (m.find("master_url") != m.end() && !m["master_url"].empty()) {
      masterUrl = make_shared<string>(boost::any_cast<string>(m["master_url"]));
    }
    if (m.find("meta_data") != m.end() && !m["meta_data"].empty()) {
      metaData = make_shared<string>(boost::any_cast<string>(m["meta_data"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("network_mode") != m.end() && !m["network_mode"].empty()) {
      networkMode = make_shared<string>(boost::any_cast<string>(m["network_mode"]));
    }
    if (m.find("next_version") != m.end() && !m["next_version"].empty()) {
      nextVersion = make_shared<string>(boost::any_cast<string>(m["next_version"]));
    }
    if (m.find("operation_policy") != m.end() && !m["operation_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["operation_policy"].type()) {
        DescribeClustersV1ResponseBodyClustersOperationPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["operation_policy"]));
        operationPolicy = make_shared<DescribeClustersV1ResponseBodyClustersOperationPolicy>(model1);
      }
    }
    if (m.find("private_zone") != m.end() && !m["private_zone"].empty()) {
      privateZone = make_shared<bool>(boost::any_cast<bool>(m["private_zone"]));
    }
    if (m.find("profile") != m.end() && !m["profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["profile"]));
    }
    if (m.find("proxy_mode") != m.end() && !m["proxy_mode"].empty()) {
      proxyMode = make_shared<string>(boost::any_cast<string>(m["proxy_mode"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
    if (m.find("security_group_id") != m.end() && !m["security_group_id"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["security_group_id"]));
    }
    if (m.find("service_cidr") != m.end() && !m["service_cidr"].empty()) {
      serviceCidr = make_shared<string>(boost::any_cast<string>(m["service_cidr"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("subnet_cidr") != m.end() && !m["subnet_cidr"].empty()) {
      subnetCidr = make_shared<string>(boost::any_cast<string>(m["subnet_cidr"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("timezone") != m.end() && !m["timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["timezone"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
    if (m.find("vpc_id") != m.end() && !m["vpc_id"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpc_id"]));
    }
    if (m.find("vswitch_id") != m.end() && !m["vswitch_id"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitch_id"]));
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("worker_ram_role_name") != m.end() && !m["worker_ram_role_name"].empty()) {
      workerRamRoleName = make_shared<string>(boost::any_cast<string>(m["worker_ram_role_name"]));
    }
    if (m.find("zone_id") != m.end() && !m["zone_id"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zone_id"]));
    }
  }


  virtual ~DescribeClustersV1ResponseBodyClusters() = default;
};
class DescribeClustersV1ResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeClustersV1ResponseBodyPageInfo() {}

  explicit DescribeClustersV1ResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~DescribeClustersV1ResponseBodyPageInfo() = default;
};
class DescribeClustersV1ResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClustersV1ResponseBodyClusters>> clusters{};
  shared_ptr<DescribeClustersV1ResponseBodyPageInfo> pageInfo{};

  DescribeClustersV1ResponseBody() {}

  explicit DescribeClustersV1ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      vector<boost::any> temp1;
      for(auto item1:*clusters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["clusters"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusters") != m.end() && !m["clusters"].empty()) {
      if (typeid(vector<boost::any>) == m["clusters"].type()) {
        vector<DescribeClustersV1ResponseBodyClusters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["clusters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClustersV1ResponseBodyClusters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusters = make_shared<vector<DescribeClustersV1ResponseBodyClusters>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        DescribeClustersV1ResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<DescribeClustersV1ResponseBodyPageInfo>(model1);
      }
    }
  }


  virtual ~DescribeClustersV1ResponseBody() = default;
};
class DescribeClustersV1Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClustersV1ResponseBody> body{};

  DescribeClustersV1Response() {}

  explicit DescribeClustersV1Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClustersV1ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClustersV1ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClustersV1Response() = default;
};
class DescribeEdgeMachineActiveProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> logs{};
  shared_ptr<long> progress{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<string> step{};

  DescribeEdgeMachineActiveProcessResponseBody() {}

  explicit DescribeEdgeMachineActiveProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logs) {
      res["logs"] = boost::any(*logs);
    }
    if (progress) {
      res["progress"] = boost::any(*progress);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (step) {
      res["step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logs") != m.end() && !m["logs"].empty()) {
      logs = make_shared<string>(boost::any_cast<string>(m["logs"]));
    }
    if (m.find("progress") != m.end() && !m["progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["progress"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("step") != m.end() && !m["step"].empty()) {
      step = make_shared<string>(boost::any_cast<string>(m["step"]));
    }
  }


  virtual ~DescribeEdgeMachineActiveProcessResponseBody() = default;
};
class DescribeEdgeMachineActiveProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEdgeMachineActiveProcessResponseBody> body{};

  DescribeEdgeMachineActiveProcessResponse() {}

  explicit DescribeEdgeMachineActiveProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEdgeMachineActiveProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEdgeMachineActiveProcessResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEdgeMachineActiveProcessResponse() = default;
};
class DescribeEdgeMachineModelsResponseBodyModels : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<string> cpuArch{};
  shared_ptr<string> created{};
  shared_ptr<string> description{};
  shared_ptr<long> manageRuntime{};
  shared_ptr<long> memory{};
  shared_ptr<string> model{};
  shared_ptr<string> modelId{};

  DescribeEdgeMachineModelsResponseBodyModels() {}

  explicit DescribeEdgeMachineModelsResponseBodyModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["cpu"] = boost::any(*cpu);
    }
    if (cpuArch) {
      res["cpu_arch"] = boost::any(*cpuArch);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (manageRuntime) {
      res["manage_runtime"] = boost::any(*manageRuntime);
    }
    if (memory) {
      res["memory"] = boost::any(*memory);
    }
    if (model) {
      res["model"] = boost::any(*model);
    }
    if (modelId) {
      res["model_id"] = boost::any(*modelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cpu") != m.end() && !m["cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["cpu"]));
    }
    if (m.find("cpu_arch") != m.end() && !m["cpu_arch"].empty()) {
      cpuArch = make_shared<string>(boost::any_cast<string>(m["cpu_arch"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("manage_runtime") != m.end() && !m["manage_runtime"].empty()) {
      manageRuntime = make_shared<long>(boost::any_cast<long>(m["manage_runtime"]));
    }
    if (m.find("memory") != m.end() && !m["memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["memory"]));
    }
    if (m.find("model") != m.end() && !m["model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["model"]));
    }
    if (m.find("model_id") != m.end() && !m["model_id"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["model_id"]));
    }
  }


  virtual ~DescribeEdgeMachineModelsResponseBodyModels() = default;
};
class DescribeEdgeMachineModelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEdgeMachineModelsResponseBodyModels>> models{};

  DescribeEdgeMachineModelsResponseBody() {}

  explicit DescribeEdgeMachineModelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (models) {
      vector<boost::any> temp1;
      for(auto item1:*models){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["models"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("models") != m.end() && !m["models"].empty()) {
      if (typeid(vector<boost::any>) == m["models"].type()) {
        vector<DescribeEdgeMachineModelsResponseBodyModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["models"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEdgeMachineModelsResponseBodyModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        models = make_shared<vector<DescribeEdgeMachineModelsResponseBodyModels>>(expect1);
      }
    }
  }


  virtual ~DescribeEdgeMachineModelsResponseBody() = default;
};
class DescribeEdgeMachineModelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEdgeMachineModelsResponseBody> body{};

  DescribeEdgeMachineModelsResponse() {}

  explicit DescribeEdgeMachineModelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEdgeMachineModelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEdgeMachineModelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEdgeMachineModelsResponse() = default;
};
class DescribeEdgeMachineTunnelConfigDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> model{};
  shared_ptr<string> productKey{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sn{};
  shared_ptr<string> token{};
  shared_ptr<string> tunnelEndpoint{};

  DescribeEdgeMachineTunnelConfigDetailResponseBody() {}

  explicit DescribeEdgeMachineTunnelConfigDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["device_name"] = boost::any(*deviceName);
    }
    if (model) {
      res["model"] = boost::any(*model);
    }
    if (productKey) {
      res["product_key"] = boost::any(*productKey);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (sn) {
      res["sn"] = boost::any(*sn);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    if (tunnelEndpoint) {
      res["tunnel_endpoint"] = boost::any(*tunnelEndpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("device_name") != m.end() && !m["device_name"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["device_name"]));
    }
    if (m.find("model") != m.end() && !m["model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["model"]));
    }
    if (m.find("product_key") != m.end() && !m["product_key"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["product_key"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("sn") != m.end() && !m["sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["sn"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
    if (m.find("tunnel_endpoint") != m.end() && !m["tunnel_endpoint"].empty()) {
      tunnelEndpoint = make_shared<string>(boost::any_cast<string>(m["tunnel_endpoint"]));
    }
  }


  virtual ~DescribeEdgeMachineTunnelConfigDetailResponseBody() = default;
};
class DescribeEdgeMachineTunnelConfigDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEdgeMachineTunnelConfigDetailResponseBody> body{};

  DescribeEdgeMachineTunnelConfigDetailResponse() {}

  explicit DescribeEdgeMachineTunnelConfigDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEdgeMachineTunnelConfigDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEdgeMachineTunnelConfigDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEdgeMachineTunnelConfigDetailResponse() = default;
};
class DescribeEdgeMachinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostname{};
  shared_ptr<string> lifeState{};
  shared_ptr<string> model{};
  shared_ptr<string> onlineState{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeEdgeMachinesRequest() {}

  explicit DescribeEdgeMachinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostname) {
      res["hostname"] = boost::any(*hostname);
    }
    if (lifeState) {
      res["life_state"] = boost::any(*lifeState);
    }
    if (model) {
      res["model"] = boost::any(*model);
    }
    if (onlineState) {
      res["online_state"] = boost::any(*onlineState);
    }
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hostname") != m.end() && !m["hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["hostname"]));
    }
    if (m.find("life_state") != m.end() && !m["life_state"].empty()) {
      lifeState = make_shared<string>(boost::any_cast<string>(m["life_state"]));
    }
    if (m.find("model") != m.end() && !m["model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["model"]));
    }
    if (m.find("online_state") != m.end() && !m["online_state"].empty()) {
      onlineState = make_shared<string>(boost::any_cast<string>(m["online_state"]));
    }
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
  }


  virtual ~DescribeEdgeMachinesRequest() = default;
};
class DescribeEdgeMachinesResponseBodyEdgeMachines : public Darabonba::Model {
public:
  shared_ptr<string> activeTime{};
  shared_ptr<string> created{};
  shared_ptr<string> edgeMachineId{};
  shared_ptr<string> hostname{};
  shared_ptr<string> lifeState{};
  shared_ptr<string> model{};
  shared_ptr<string> name{};
  shared_ptr<string> onlineState{};
  shared_ptr<string> sn{};
  shared_ptr<string> updated{};

  DescribeEdgeMachinesResponseBodyEdgeMachines() {}

  explicit DescribeEdgeMachinesResponseBodyEdgeMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeTime) {
      res["active_time"] = boost::any(*activeTime);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (edgeMachineId) {
      res["edge_machine_id"] = boost::any(*edgeMachineId);
    }
    if (hostname) {
      res["hostname"] = boost::any(*hostname);
    }
    if (lifeState) {
      res["life_state"] = boost::any(*lifeState);
    }
    if (model) {
      res["model"] = boost::any(*model);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (onlineState) {
      res["online_state"] = boost::any(*onlineState);
    }
    if (sn) {
      res["sn"] = boost::any(*sn);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("active_time") != m.end() && !m["active_time"].empty()) {
      activeTime = make_shared<string>(boost::any_cast<string>(m["active_time"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("edge_machine_id") != m.end() && !m["edge_machine_id"].empty()) {
      edgeMachineId = make_shared<string>(boost::any_cast<string>(m["edge_machine_id"]));
    }
    if (m.find("hostname") != m.end() && !m["hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["hostname"]));
    }
    if (m.find("life_state") != m.end() && !m["life_state"].empty()) {
      lifeState = make_shared<string>(boost::any_cast<string>(m["life_state"]));
    }
    if (m.find("model") != m.end() && !m["model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["model"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("online_state") != m.end() && !m["online_state"].empty()) {
      onlineState = make_shared<string>(boost::any_cast<string>(m["online_state"]));
    }
    if (m.find("sn") != m.end() && !m["sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["sn"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
  }


  virtual ~DescribeEdgeMachinesResponseBodyEdgeMachines() = default;
};
class DescribeEdgeMachinesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeEdgeMachinesResponseBodyPageInfo() {}

  explicit DescribeEdgeMachinesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~DescribeEdgeMachinesResponseBodyPageInfo() = default;
};
class DescribeEdgeMachinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEdgeMachinesResponseBodyEdgeMachines>> edgeMachines{};
  shared_ptr<DescribeEdgeMachinesResponseBodyPageInfo> pageInfo{};

  DescribeEdgeMachinesResponseBody() {}

  explicit DescribeEdgeMachinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edgeMachines) {
      vector<boost::any> temp1;
      for(auto item1:*edgeMachines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["edge_machines"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("edge_machines") != m.end() && !m["edge_machines"].empty()) {
      if (typeid(vector<boost::any>) == m["edge_machines"].type()) {
        vector<DescribeEdgeMachinesResponseBodyEdgeMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["edge_machines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEdgeMachinesResponseBodyEdgeMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        edgeMachines = make_shared<vector<DescribeEdgeMachinesResponseBodyEdgeMachines>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        DescribeEdgeMachinesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<DescribeEdgeMachinesResponseBodyPageInfo>(model1);
      }
    }
  }


  virtual ~DescribeEdgeMachinesResponseBody() = default;
};
class DescribeEdgeMachinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEdgeMachinesResponseBody> body{};

  DescribeEdgeMachinesResponse() {}

  explicit DescribeEdgeMachinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEdgeMachinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEdgeMachinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEdgeMachinesResponse() = default;
};
class DescribeEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> type{};

  DescribeEventsRequest() {}

  explicit DescribeEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeEventsRequest() = default;
};
class DescribeEventsResponseBodyEventsData : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> reason{};

  DescribeEventsResponseBodyEventsData() {}

  explicit DescribeEventsResponseBodyEventsData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
  }


  virtual ~DescribeEventsResponseBodyEventsData() = default;
};
class DescribeEventsResponseBodyEvents : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<DescribeEventsResponseBodyEventsData> data{};
  shared_ptr<string> eventId{};
  shared_ptr<string> source{};
  shared_ptr<string> subject{};
  shared_ptr<string> time{};
  shared_ptr<string> type{};

  DescribeEventsResponseBodyEvents() {}

  explicit DescribeEventsResponseBodyEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventId) {
      res["event_id"] = boost::any(*eventId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (time) {
      res["time"] = boost::any(*time);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        DescribeEventsResponseBodyEventsData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<DescribeEventsResponseBodyEventsData>(model1);
      }
    }
    if (m.find("event_id") != m.end() && !m["event_id"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["event_id"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("time") != m.end() && !m["time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["time"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeEventsResponseBodyEvents() = default;
};
class DescribeEventsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeEventsResponseBodyPageInfo() {}

  explicit DescribeEventsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~DescribeEventsResponseBodyPageInfo() = default;
};
class DescribeEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventsResponseBodyEvents>> events{};
  shared_ptr<DescribeEventsResponseBodyPageInfo> pageInfo{};

  DescribeEventsResponseBody() {}

  explicit DescribeEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["events"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("events") != m.end() && !m["events"].empty()) {
      if (typeid(vector<boost::any>) == m["events"].type()) {
        vector<DescribeEventsResponseBodyEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventsResponseBodyEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<DescribeEventsResponseBodyEvents>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        DescribeEventsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<DescribeEventsResponseBodyPageInfo>(model1);
      }
    }
  }


  virtual ~DescribeEventsResponseBody() = default;
};
class DescribeEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventsResponseBody> body{};

  DescribeEventsResponse() {}

  explicit DescribeEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventsResponse() = default;
};
class DescribeEventsForRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeEventsForRegionRequest() {}

  explicit DescribeEventsForRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
  }


  virtual ~DescribeEventsForRegionRequest() = default;
};
class DescribeEventsForRegionResponseBodyEventsData : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> reason{};

  DescribeEventsForRegionResponseBodyEventsData() {}

  explicit DescribeEventsForRegionResponseBodyEventsData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
  }


  virtual ~DescribeEventsForRegionResponseBodyEventsData() = default;
};
class DescribeEventsForRegionResponseBodyEvents : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<DescribeEventsForRegionResponseBodyEventsData> data{};
  shared_ptr<string> eventId{};
  shared_ptr<string> source{};
  shared_ptr<string> subject{};
  shared_ptr<string> time{};
  shared_ptr<string> type{};

  DescribeEventsForRegionResponseBodyEvents() {}

  explicit DescribeEventsForRegionResponseBodyEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventId) {
      res["event_id"] = boost::any(*eventId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (time) {
      res["time"] = boost::any(*time);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        DescribeEventsForRegionResponseBodyEventsData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<DescribeEventsForRegionResponseBodyEventsData>(model1);
      }
    }
    if (m.find("event_id") != m.end() && !m["event_id"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["event_id"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("time") != m.end() && !m["time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["time"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeEventsForRegionResponseBodyEvents() = default;
};
class DescribeEventsForRegionResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeEventsForRegionResponseBodyPageInfo() {}

  explicit DescribeEventsForRegionResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~DescribeEventsForRegionResponseBodyPageInfo() = default;
};
class DescribeEventsForRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventsForRegionResponseBodyEvents>> events{};
  shared_ptr<DescribeEventsForRegionResponseBodyPageInfo> pageInfo{};

  DescribeEventsForRegionResponseBody() {}

  explicit DescribeEventsForRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["events"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("events") != m.end() && !m["events"].empty()) {
      if (typeid(vector<boost::any>) == m["events"].type()) {
        vector<DescribeEventsForRegionResponseBodyEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventsForRegionResponseBodyEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<DescribeEventsForRegionResponseBodyEvents>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        DescribeEventsForRegionResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<DescribeEventsForRegionResponseBodyPageInfo>(model1);
      }
    }
  }


  virtual ~DescribeEventsForRegionResponseBody() = default;
};
class DescribeEventsForRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventsForRegionResponseBody> body{};

  DescribeEventsForRegionResponse() {}

  explicit DescribeEventsForRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventsForRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventsForRegionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventsForRegionResponse() = default;
};
class DescribeExternalAgentRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentMode{};
  shared_ptr<string> privateIpAddress{};

  DescribeExternalAgentRequest() {}

  explicit DescribeExternalAgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentMode) {
      res["AgentMode"] = boost::any(*agentMode);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentMode") != m.end() && !m["AgentMode"].empty()) {
      agentMode = make_shared<string>(boost::any_cast<string>(m["AgentMode"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
  }


  virtual ~DescribeExternalAgentRequest() = default;
};
class DescribeExternalAgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> config{};

  DescribeExternalAgentResponseBody() {}

  explicit DescribeExternalAgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["config"] = boost::any(*config);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
  }


  virtual ~DescribeExternalAgentResponseBody() = default;
};
class DescribeExternalAgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExternalAgentResponseBody> body{};

  DescribeExternalAgentResponse() {}

  explicit DescribeExternalAgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExternalAgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExternalAgentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExternalAgentResponse() = default;
};
class DescribeKubernetesVersionMetadataRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> kubernetesVersion{};
  shared_ptr<string> mode{};
  shared_ptr<string> profile{};
  shared_ptr<bool> queryUpgradableVersion{};
  shared_ptr<string> region{};
  shared_ptr<string> runtime{};

  DescribeKubernetesVersionMetadataRequest() {}

  explicit DescribeKubernetesVersionMetadataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (kubernetesVersion) {
      res["KubernetesVersion"] = boost::any(*kubernetesVersion);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (queryUpgradableVersion) {
      res["QueryUpgradableVersion"] = boost::any(*queryUpgradableVersion);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("KubernetesVersion") != m.end() && !m["KubernetesVersion"].empty()) {
      kubernetesVersion = make_shared<string>(boost::any_cast<string>(m["KubernetesVersion"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("QueryUpgradableVersion") != m.end() && !m["QueryUpgradableVersion"].empty()) {
      queryUpgradableVersion = make_shared<bool>(boost::any_cast<bool>(m["QueryUpgradableVersion"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
  }


  virtual ~DescribeKubernetesVersionMetadataRequest() = default;
};
class DescribeKubernetesVersionMetadataResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> platform{};
  shared_ptr<string> osVersion{};
  shared_ptr<string> imageType{};
  shared_ptr<string> osType{};
  shared_ptr<string> imageCategory{};
  shared_ptr<string> architecture{};

  DescribeKubernetesVersionMetadataResponseBodyImages() {}

  explicit DescribeKubernetesVersionMetadataResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (imageName) {
      res["image_name"] = boost::any(*imageName);
    }
    if (platform) {
      res["platform"] = boost::any(*platform);
    }
    if (osVersion) {
      res["os_version"] = boost::any(*osVersion);
    }
    if (imageType) {
      res["image_type"] = boost::any(*imageType);
    }
    if (osType) {
      res["os_type"] = boost::any(*osType);
    }
    if (imageCategory) {
      res["image_category"] = boost::any(*imageCategory);
    }
    if (architecture) {
      res["architecture"] = boost::any(*architecture);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("image_name") != m.end() && !m["image_name"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["image_name"]));
    }
    if (m.find("platform") != m.end() && !m["platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["platform"]));
    }
    if (m.find("os_version") != m.end() && !m["os_version"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["os_version"]));
    }
    if (m.find("image_type") != m.end() && !m["image_type"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["image_type"]));
    }
    if (m.find("os_type") != m.end() && !m["os_type"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["os_type"]));
    }
    if (m.find("image_category") != m.end() && !m["image_category"].empty()) {
      imageCategory = make_shared<string>(boost::any_cast<string>(m["image_category"]));
    }
    if (m.find("architecture") != m.end() && !m["architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["architecture"]));
    }
  }


  virtual ~DescribeKubernetesVersionMetadataResponseBodyImages() = default;
};
class DescribeKubernetesVersionMetadataResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> capabilities{};
  shared_ptr<vector<DescribeKubernetesVersionMetadataResponseBodyImages>> images{};
  shared_ptr<map<string, boost::any>> metaData{};
  shared_ptr<vector<Runtime>> runtimes{};
  shared_ptr<string> version{};
  shared_ptr<string> releaseDate{};
  shared_ptr<string> expirationDate{};
  shared_ptr<bool> creatable{};
  shared_ptr<vector<string>> upgradableVersions{};

  DescribeKubernetesVersionMetadataResponseBody() {}

  explicit DescribeKubernetesVersionMetadataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capabilities) {
      res["capabilities"] = boost::any(*capabilities);
    }
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["images"] = boost::any(temp1);
    }
    if (metaData) {
      res["meta_data"] = boost::any(*metaData);
    }
    if (runtimes) {
      vector<boost::any> temp1;
      for(auto item1:*runtimes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["runtimes"] = boost::any(temp1);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    if (releaseDate) {
      res["release_date"] = boost::any(*releaseDate);
    }
    if (expirationDate) {
      res["expiration_date"] = boost::any(*expirationDate);
    }
    if (creatable) {
      res["creatable"] = boost::any(*creatable);
    }
    if (upgradableVersions) {
      res["upgradable_versions"] = boost::any(*upgradableVersions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("capabilities") != m.end() && !m["capabilities"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["capabilities"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      capabilities = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("images") != m.end() && !m["images"].empty()) {
      if (typeid(vector<boost::any>) == m["images"].type()) {
        vector<DescribeKubernetesVersionMetadataResponseBodyImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeKubernetesVersionMetadataResponseBodyImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<DescribeKubernetesVersionMetadataResponseBodyImages>>(expect1);
      }
    }
    if (m.find("meta_data") != m.end() && !m["meta_data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["meta_data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      metaData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("runtimes") != m.end() && !m["runtimes"].empty()) {
      if (typeid(vector<boost::any>) == m["runtimes"].type()) {
        vector<Runtime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["runtimes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Runtime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runtimes = make_shared<vector<Runtime>>(expect1);
      }
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
    if (m.find("release_date") != m.end() && !m["release_date"].empty()) {
      releaseDate = make_shared<string>(boost::any_cast<string>(m["release_date"]));
    }
    if (m.find("expiration_date") != m.end() && !m["expiration_date"].empty()) {
      expirationDate = make_shared<string>(boost::any_cast<string>(m["expiration_date"]));
    }
    if (m.find("creatable") != m.end() && !m["creatable"].empty()) {
      creatable = make_shared<bool>(boost::any_cast<bool>(m["creatable"]));
    }
    if (m.find("upgradable_versions") != m.end() && !m["upgradable_versions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["upgradable_versions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["upgradable_versions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      upgradableVersions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeKubernetesVersionMetadataResponseBody() = default;
};
class DescribeKubernetesVersionMetadataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<DescribeKubernetesVersionMetadataResponseBody>> body{};

  DescribeKubernetesVersionMetadataResponse() {}

  explicit DescribeKubernetesVersionMetadataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<DescribeKubernetesVersionMetadataResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeKubernetesVersionMetadataResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<DescribeKubernetesVersionMetadataResponseBody>>(expect1);
      }
    }
  }


  virtual ~DescribeKubernetesVersionMetadataResponse() = default;
};
class DescribeNodePoolVulsRequest : public Darabonba::Model {
public:
  shared_ptr<string> necessity{};

  DescribeNodePoolVulsRequest() {}

  explicit DescribeNodePoolVulsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (necessity) {
      res["necessity"] = boost::any(*necessity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("necessity") != m.end() && !m["necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["necessity"]));
    }
  }


  virtual ~DescribeNodePoolVulsRequest() = default;
};
class DescribeNodePoolVulsResponseBodyVulRecordsVulList : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<vector<string>> cveList{};
  shared_ptr<string> name{};
  shared_ptr<string> necessity{};
  shared_ptr<bool> needReboot{};

  DescribeNodePoolVulsResponseBodyVulRecordsVulList() {}

  explicit DescribeNodePoolVulsResponseBodyVulRecordsVulList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["alias_name"] = boost::any(*aliasName);
    }
    if (cveList) {
      res["cve_list"] = boost::any(*cveList);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (necessity) {
      res["necessity"] = boost::any(*necessity);
    }
    if (needReboot) {
      res["need_reboot"] = boost::any(*needReboot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alias_name") != m.end() && !m["alias_name"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["alias_name"]));
    }
    if (m.find("cve_list") != m.end() && !m["cve_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["cve_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["cve_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cveList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("necessity") != m.end() && !m["necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["necessity"]));
    }
    if (m.find("need_reboot") != m.end() && !m["need_reboot"].empty()) {
      needReboot = make_shared<bool>(boost::any_cast<bool>(m["need_reboot"]));
    }
  }


  virtual ~DescribeNodePoolVulsResponseBodyVulRecordsVulList() = default;
};
class DescribeNodePoolVulsResponseBodyVulRecords : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeName{};
  shared_ptr<vector<DescribeNodePoolVulsResponseBodyVulRecordsVulList>> vulList{};

  DescribeNodePoolVulsResponseBodyVulRecords() {}

  explicit DescribeNodePoolVulsResponseBodyVulRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instance_id"] = boost::any(*instanceId);
    }
    if (nodeName) {
      res["node_name"] = boost::any(*nodeName);
    }
    if (vulList) {
      vector<boost::any> temp1;
      for(auto item1:*vulList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["vul_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instance_id") != m.end() && !m["instance_id"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instance_id"]));
    }
    if (m.find("node_name") != m.end() && !m["node_name"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["node_name"]));
    }
    if (m.find("vul_list") != m.end() && !m["vul_list"].empty()) {
      if (typeid(vector<boost::any>) == m["vul_list"].type()) {
        vector<DescribeNodePoolVulsResponseBodyVulRecordsVulList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["vul_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNodePoolVulsResponseBodyVulRecordsVulList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulList = make_shared<vector<DescribeNodePoolVulsResponseBodyVulRecordsVulList>>(expect1);
      }
    }
  }


  virtual ~DescribeNodePoolVulsResponseBodyVulRecords() = default;
};
class DescribeNodePoolVulsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNodePoolVulsResponseBodyVulRecords>> vulRecords{};
  shared_ptr<bool> vulsFixServicePurchased{};

  DescribeNodePoolVulsResponseBody() {}

  explicit DescribeNodePoolVulsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vulRecords) {
      vector<boost::any> temp1;
      for(auto item1:*vulRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["vul_records"] = boost::any(temp1);
    }
    if (vulsFixServicePurchased) {
      res["vuls_fix_service_purchased"] = boost::any(*vulsFixServicePurchased);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("vul_records") != m.end() && !m["vul_records"].empty()) {
      if (typeid(vector<boost::any>) == m["vul_records"].type()) {
        vector<DescribeNodePoolVulsResponseBodyVulRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["vul_records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNodePoolVulsResponseBodyVulRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulRecords = make_shared<vector<DescribeNodePoolVulsResponseBodyVulRecords>>(expect1);
      }
    }
    if (m.find("vuls_fix_service_purchased") != m.end() && !m["vuls_fix_service_purchased"].empty()) {
      vulsFixServicePurchased = make_shared<bool>(boost::any_cast<bool>(m["vuls_fix_service_purchased"]));
    }
  }


  virtual ~DescribeNodePoolVulsResponseBody() = default;
};
class DescribeNodePoolVulsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNodePoolVulsResponseBody> body{};

  DescribeNodePoolVulsResponse() {}

  explicit DescribeNodePoolVulsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNodePoolVulsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNodePoolVulsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNodePoolVulsResponse() = default;
};
class DescribePoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<map<string, boost::any>> body{};

  DescribePoliciesResponse() {}

  explicit DescribePoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["body"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      body = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribePoliciesResponse() = default;
};
class DescribePolicyDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<long> isDeleted{};
  shared_ptr<string> name{};
  shared_ptr<long> noConfig{};
  shared_ptr<string> severity{};
  shared_ptr<string> template_{};

  DescribePolicyDetailsResponseBody() {}

  explicit DescribePolicyDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (isDeleted) {
      res["is_deleted"] = boost::any(*isDeleted);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (noConfig) {
      res["no_config"] = boost::any(*noConfig);
    }
    if (severity) {
      res["severity"] = boost::any(*severity);
    }
    if (template_) {
      res["template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("is_deleted") != m.end() && !m["is_deleted"].empty()) {
      isDeleted = make_shared<long>(boost::any_cast<long>(m["is_deleted"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("no_config") != m.end() && !m["no_config"].empty()) {
      noConfig = make_shared<long>(boost::any_cast<long>(m["no_config"]));
    }
    if (m.find("severity") != m.end() && !m["severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["severity"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["template"]));
    }
  }


  virtual ~DescribePolicyDetailsResponseBody() = default;
};
class DescribePolicyDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePolicyDetailsResponseBody> body{};

  DescribePolicyDetailsResponse() {}

  explicit DescribePolicyDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePolicyDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePolicyDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePolicyDetailsResponse() = default;
};
class DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> constraintKind{};
  shared_ptr<string> msg{};
  shared_ptr<string> resourceKind{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceNamespace{};

  DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog() {}

  explicit DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (constraintKind) {
      res["constraint_kind"] = boost::any(*constraintKind);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (resourceKind) {
      res["resource_kind"] = boost::any(*resourceKind);
    }
    if (resourceName) {
      res["resource_name"] = boost::any(*resourceName);
    }
    if (resourceNamespace) {
      res["resource_namespace"] = boost::any(*resourceNamespace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("constraint_kind") != m.end() && !m["constraint_kind"].empty()) {
      constraintKind = make_shared<string>(boost::any_cast<string>(m["constraint_kind"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("resource_kind") != m.end() && !m["resource_kind"].empty()) {
      resourceKind = make_shared<string>(boost::any_cast<string>(m["resource_kind"]));
    }
    if (m.find("resource_name") != m.end() && !m["resource_name"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["resource_name"]));
    }
    if (m.find("resource_namespace") != m.end() && !m["resource_namespace"].empty()) {
      resourceNamespace = make_shared<string>(boost::any_cast<string>(m["resource_namespace"]));
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog() = default;
};
class DescribePolicyGovernanceInClusterResponseBodyAdmitLog : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog> log{};
  shared_ptr<string> progress{};

  DescribePolicyGovernanceInClusterResponseBodyAdmitLog() {}

  explicit DescribePolicyGovernanceInClusterResponseBodyAdmitLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (log) {
      res["log"] = log ? boost::any(log->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (progress) {
      res["progress"] = boost::any(*progress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("log") != m.end() && !m["log"].empty()) {
      if (typeid(map<string, boost::any>) == m["log"].type()) {
        DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["log"]));
        log = make_shared<DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog>(model1);
      }
    }
    if (m.find("progress") != m.end() && !m["progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["progress"]));
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponseBodyAdmitLog() = default;
};
class DescribePolicyGovernanceInClusterResponseBodyOnState : public Darabonba::Model {
public:
  shared_ptr<long> enabledCount{};
  shared_ptr<string> severity{};
  shared_ptr<long> total{};

  DescribePolicyGovernanceInClusterResponseBodyOnState() {}

  explicit DescribePolicyGovernanceInClusterResponseBodyOnState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabledCount) {
      res["enabled_count"] = boost::any(*enabledCount);
    }
    if (severity) {
      res["severity"] = boost::any(*severity);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled_count") != m.end() && !m["enabled_count"].empty()) {
      enabledCount = make_shared<long>(boost::any_cast<long>(m["enabled_count"]));
    }
    if (m.find("severity") != m.end() && !m["severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["severity"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponseBodyOnState() = default;
};
class DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny : public Darabonba::Model {
public:
  shared_ptr<string> severity{};
  shared_ptr<long> violations{};

  DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny() {}

  explicit DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (severity) {
      res["severity"] = boost::any(*severity);
    }
    if (violations) {
      res["violations"] = boost::any(*violations);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("severity") != m.end() && !m["severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["severity"]));
    }
    if (m.find("violations") != m.end() && !m["violations"].empty()) {
      violations = make_shared<long>(boost::any_cast<long>(m["violations"]));
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny() = default;
};
class DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> severity{};
  shared_ptr<long> violations{};

  DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn() {}

  explicit DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (severity) {
      res["severity"] = boost::any(*severity);
    }
    if (violations) {
      res["violations"] = boost::any(*violations);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("severity") != m.end() && !m["severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["severity"]));
    }
    if (m.find("violations") != m.end() && !m["violations"].empty()) {
      violations = make_shared<long>(boost::any_cast<long>(m["violations"]));
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn() = default;
};
class DescribePolicyGovernanceInClusterResponseBodyTotalViolations : public Darabonba::Model {
public:
  shared_ptr<DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny> deny{};
  shared_ptr<DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn> warn{};

  DescribePolicyGovernanceInClusterResponseBodyTotalViolations() {}

  explicit DescribePolicyGovernanceInClusterResponseBodyTotalViolations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deny) {
      res["deny"] = deny ? boost::any(deny->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deny") != m.end() && !m["deny"].empty()) {
      if (typeid(map<string, boost::any>) == m["deny"].type()) {
        DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["deny"]));
        deny = make_shared<DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny>(model1);
      }
    }
    if (m.find("warn") != m.end() && !m["warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["warn"].type()) {
        DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["warn"]));
        warn = make_shared<DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn>(model1);
      }
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponseBodyTotalViolations() = default;
};
class DescribePolicyGovernanceInClusterResponseBodyViolationsDeny : public Darabonba::Model {
public:
  shared_ptr<string> policyDescription{};
  shared_ptr<string> policyName{};
  shared_ptr<string> severity{};
  shared_ptr<long> violations{};

  DescribePolicyGovernanceInClusterResponseBodyViolationsDeny() {}

  explicit DescribePolicyGovernanceInClusterResponseBodyViolationsDeny(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyDescription) {
      res["policyDescription"] = boost::any(*policyDescription);
    }
    if (policyName) {
      res["policyName"] = boost::any(*policyName);
    }
    if (severity) {
      res["severity"] = boost::any(*severity);
    }
    if (violations) {
      res["violations"] = boost::any(*violations);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("policyDescription") != m.end() && !m["policyDescription"].empty()) {
      policyDescription = make_shared<string>(boost::any_cast<string>(m["policyDescription"]));
    }
    if (m.find("policyName") != m.end() && !m["policyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["policyName"]));
    }
    if (m.find("severity") != m.end() && !m["severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["severity"]));
    }
    if (m.find("violations") != m.end() && !m["violations"].empty()) {
      violations = make_shared<long>(boost::any_cast<long>(m["violations"]));
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponseBodyViolationsDeny() = default;
};
class DescribePolicyGovernanceInClusterResponseBodyViolationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> policyDescription{};
  shared_ptr<string> policyName{};
  shared_ptr<string> severity{};
  shared_ptr<long> violations{};

  DescribePolicyGovernanceInClusterResponseBodyViolationsWarn() {}

  explicit DescribePolicyGovernanceInClusterResponseBodyViolationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyDescription) {
      res["policyDescription"] = boost::any(*policyDescription);
    }
    if (policyName) {
      res["policyName"] = boost::any(*policyName);
    }
    if (severity) {
      res["severity"] = boost::any(*severity);
    }
    if (violations) {
      res["violations"] = boost::any(*violations);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("policyDescription") != m.end() && !m["policyDescription"].empty()) {
      policyDescription = make_shared<string>(boost::any_cast<string>(m["policyDescription"]));
    }
    if (m.find("policyName") != m.end() && !m["policyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["policyName"]));
    }
    if (m.find("severity") != m.end() && !m["severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["severity"]));
    }
    if (m.find("violations") != m.end() && !m["violations"].empty()) {
      violations = make_shared<long>(boost::any_cast<long>(m["violations"]));
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponseBodyViolationsWarn() = default;
};
class DescribePolicyGovernanceInClusterResponseBodyViolations : public Darabonba::Model {
public:
  shared_ptr<DescribePolicyGovernanceInClusterResponseBodyViolationsDeny> deny{};
  shared_ptr<DescribePolicyGovernanceInClusterResponseBodyViolationsWarn> warn{};

  DescribePolicyGovernanceInClusterResponseBodyViolations() {}

  explicit DescribePolicyGovernanceInClusterResponseBodyViolations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deny) {
      res["deny"] = deny ? boost::any(deny->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deny") != m.end() && !m["deny"].empty()) {
      if (typeid(map<string, boost::any>) == m["deny"].type()) {
        DescribePolicyGovernanceInClusterResponseBodyViolationsDeny model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["deny"]));
        deny = make_shared<DescribePolicyGovernanceInClusterResponseBodyViolationsDeny>(model1);
      }
    }
    if (m.find("warn") != m.end() && !m["warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["warn"].type()) {
        DescribePolicyGovernanceInClusterResponseBodyViolationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["warn"]));
        warn = make_shared<DescribePolicyGovernanceInClusterResponseBodyViolationsWarn>(model1);
      }
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponseBodyViolations() = default;
};
class DescribePolicyGovernanceInClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePolicyGovernanceInClusterResponseBodyAdmitLog> admitLog{};
  shared_ptr<vector<DescribePolicyGovernanceInClusterResponseBodyOnState>> onState{};
  shared_ptr<DescribePolicyGovernanceInClusterResponseBodyTotalViolations> totalViolations{};
  shared_ptr<DescribePolicyGovernanceInClusterResponseBodyViolations> violations{};

  DescribePolicyGovernanceInClusterResponseBody() {}

  explicit DescribePolicyGovernanceInClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (admitLog) {
      res["admit_log"] = admitLog ? boost::any(admitLog->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (onState) {
      vector<boost::any> temp1;
      for(auto item1:*onState){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["on_state"] = boost::any(temp1);
    }
    if (totalViolations) {
      res["totalViolations"] = totalViolations ? boost::any(totalViolations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (violations) {
      res["violations"] = violations ? boost::any(violations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("admit_log") != m.end() && !m["admit_log"].empty()) {
      if (typeid(map<string, boost::any>) == m["admit_log"].type()) {
        DescribePolicyGovernanceInClusterResponseBodyAdmitLog model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["admit_log"]));
        admitLog = make_shared<DescribePolicyGovernanceInClusterResponseBodyAdmitLog>(model1);
      }
    }
    if (m.find("on_state") != m.end() && !m["on_state"].empty()) {
      if (typeid(vector<boost::any>) == m["on_state"].type()) {
        vector<DescribePolicyGovernanceInClusterResponseBodyOnState> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["on_state"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyGovernanceInClusterResponseBodyOnState model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        onState = make_shared<vector<DescribePolicyGovernanceInClusterResponseBodyOnState>>(expect1);
      }
    }
    if (m.find("totalViolations") != m.end() && !m["totalViolations"].empty()) {
      if (typeid(map<string, boost::any>) == m["totalViolations"].type()) {
        DescribePolicyGovernanceInClusterResponseBodyTotalViolations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["totalViolations"]));
        totalViolations = make_shared<DescribePolicyGovernanceInClusterResponseBodyTotalViolations>(model1);
      }
    }
    if (m.find("violations") != m.end() && !m["violations"].empty()) {
      if (typeid(map<string, boost::any>) == m["violations"].type()) {
        DescribePolicyGovernanceInClusterResponseBodyViolations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["violations"]));
        violations = make_shared<DescribePolicyGovernanceInClusterResponseBodyViolations>(model1);
      }
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponseBody() = default;
};
class DescribePolicyGovernanceInClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePolicyGovernanceInClusterResponseBody> body{};

  DescribePolicyGovernanceInClusterResponse() {}

  explicit DescribePolicyGovernanceInClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePolicyGovernanceInClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePolicyGovernanceInClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePolicyGovernanceInClusterResponse() = default;
};
class DescribePolicyInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceName{};
  shared_ptr<string> policyName{};

  DescribePolicyInstancesRequest() {}

  explicit DescribePolicyInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceName) {
      res["instance_name"] = boost::any(*instanceName);
    }
    if (policyName) {
      res["policy_name"] = boost::any(*policyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instance_name") != m.end() && !m["instance_name"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["instance_name"]));
    }
    if (m.find("policy_name") != m.end() && !m["policy_name"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["policy_name"]));
    }
  }


  virtual ~DescribePolicyInstancesRequest() = default;
};
class DescribePolicyInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aliUid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyCategory{};
  shared_ptr<string> policyDescription{};
  shared_ptr<string> policyParameters{};
  shared_ptr<string> policySeverity{};
  shared_ptr<string> policyScope{};
  shared_ptr<string> policyAction{};
  shared_ptr<string> created{};
  shared_ptr<string> updated{};
  shared_ptr<string> resourceId{};
  shared_ptr<long> totalViolations{};
  shared_ptr<long> isDeleted{};

  DescribePolicyInstancesResponseBody() {}

  explicit DescribePolicyInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["ali_uid"] = boost::any(*aliUid);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (instanceName) {
      res["instance_name"] = boost::any(*instanceName);
    }
    if (policyName) {
      res["policy_name"] = boost::any(*policyName);
    }
    if (policyCategory) {
      res["policy_category"] = boost::any(*policyCategory);
    }
    if (policyDescription) {
      res["policy_description"] = boost::any(*policyDescription);
    }
    if (policyParameters) {
      res["policy_parameters"] = boost::any(*policyParameters);
    }
    if (policySeverity) {
      res["policy_severity"] = boost::any(*policySeverity);
    }
    if (policyScope) {
      res["policy_scope"] = boost::any(*policyScope);
    }
    if (policyAction) {
      res["policy_action"] = boost::any(*policyAction);
    }
    if (created) {
      res["Created"] = boost::any(*created);
    }
    if (updated) {
      res["Updated"] = boost::any(*updated);
    }
    if (resourceId) {
      res["resource_id"] = boost::any(*resourceId);
    }
    if (totalViolations) {
      res["total_violations"] = boost::any(*totalViolations);
    }
    if (isDeleted) {
      res["is_deleted"] = boost::any(*isDeleted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ali_uid") != m.end() && !m["ali_uid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["ali_uid"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("instance_name") != m.end() && !m["instance_name"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["instance_name"]));
    }
    if (m.find("policy_name") != m.end() && !m["policy_name"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["policy_name"]));
    }
    if (m.find("policy_category") != m.end() && !m["policy_category"].empty()) {
      policyCategory = make_shared<string>(boost::any_cast<string>(m["policy_category"]));
    }
    if (m.find("policy_description") != m.end() && !m["policy_description"].empty()) {
      policyDescription = make_shared<string>(boost::any_cast<string>(m["policy_description"]));
    }
    if (m.find("policy_parameters") != m.end() && !m["policy_parameters"].empty()) {
      policyParameters = make_shared<string>(boost::any_cast<string>(m["policy_parameters"]));
    }
    if (m.find("policy_severity") != m.end() && !m["policy_severity"].empty()) {
      policySeverity = make_shared<string>(boost::any_cast<string>(m["policy_severity"]));
    }
    if (m.find("policy_scope") != m.end() && !m["policy_scope"].empty()) {
      policyScope = make_shared<string>(boost::any_cast<string>(m["policy_scope"]));
    }
    if (m.find("policy_action") != m.end() && !m["policy_action"].empty()) {
      policyAction = make_shared<string>(boost::any_cast<string>(m["policy_action"]));
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["Created"]));
    }
    if (m.find("Updated") != m.end() && !m["Updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["Updated"]));
    }
    if (m.find("resource_id") != m.end() && !m["resource_id"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["resource_id"]));
    }
    if (m.find("total_violations") != m.end() && !m["total_violations"].empty()) {
      totalViolations = make_shared<long>(boost::any_cast<long>(m["total_violations"]));
    }
    if (m.find("is_deleted") != m.end() && !m["is_deleted"].empty()) {
      isDeleted = make_shared<long>(boost::any_cast<long>(m["is_deleted"]));
    }
  }


  virtual ~DescribePolicyInstancesResponseBody() = default;
};
class DescribePolicyInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<DescribePolicyInstancesResponseBody>> body{};

  DescribePolicyInstancesResponse() {}

  explicit DescribePolicyInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<DescribePolicyInstancesResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyInstancesResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<DescribePolicyInstancesResponseBody>>(expect1);
      }
    }
  }


  virtual ~DescribePolicyInstancesResponse() = default;
};
class DescribePolicyInstancesStatusResponseBodyPolicyInstances : public Darabonba::Model {
public:
  shared_ptr<string> policyCategory{};
  shared_ptr<string> policyDescription{};
  shared_ptr<long> policyInstancesCount{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policySeverity{};

  DescribePolicyInstancesStatusResponseBodyPolicyInstances() {}

  explicit DescribePolicyInstancesStatusResponseBodyPolicyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyCategory) {
      res["policy_category"] = boost::any(*policyCategory);
    }
    if (policyDescription) {
      res["policy_description"] = boost::any(*policyDescription);
    }
    if (policyInstancesCount) {
      res["policy_instances_count"] = boost::any(*policyInstancesCount);
    }
    if (policyName) {
      res["policy_name"] = boost::any(*policyName);
    }
    if (policySeverity) {
      res["policy_severity"] = boost::any(*policySeverity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("policy_category") != m.end() && !m["policy_category"].empty()) {
      policyCategory = make_shared<string>(boost::any_cast<string>(m["policy_category"]));
    }
    if (m.find("policy_description") != m.end() && !m["policy_description"].empty()) {
      policyDescription = make_shared<string>(boost::any_cast<string>(m["policy_description"]));
    }
    if (m.find("policy_instances_count") != m.end() && !m["policy_instances_count"].empty()) {
      policyInstancesCount = make_shared<long>(boost::any_cast<long>(m["policy_instances_count"]));
    }
    if (m.find("policy_name") != m.end() && !m["policy_name"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["policy_name"]));
    }
    if (m.find("policy_severity") != m.end() && !m["policy_severity"].empty()) {
      policySeverity = make_shared<string>(boost::any_cast<string>(m["policy_severity"]));
    }
  }


  virtual ~DescribePolicyInstancesStatusResponseBodyPolicyInstances() = default;
};
class DescribePolicyInstancesStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> instancesSeverityCount{};
  shared_ptr<vector<DescribePolicyInstancesStatusResponseBodyPolicyInstances>> policyInstances{};

  DescribePolicyInstancesStatusResponseBody() {}

  explicit DescribePolicyInstancesStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instancesSeverityCount) {
      res["instances_severity_count"] = boost::any(*instancesSeverityCount);
    }
    if (policyInstances) {
      vector<boost::any> temp1;
      for(auto item1:*policyInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["policy_instances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instances_severity_count") != m.end() && !m["instances_severity_count"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["instances_severity_count"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      instancesSeverityCount = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("policy_instances") != m.end() && !m["policy_instances"].empty()) {
      if (typeid(vector<boost::any>) == m["policy_instances"].type()) {
        vector<DescribePolicyInstancesStatusResponseBodyPolicyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["policy_instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePolicyInstancesStatusResponseBodyPolicyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policyInstances = make_shared<vector<DescribePolicyInstancesStatusResponseBodyPolicyInstances>>(expect1);
      }
    }
  }


  virtual ~DescribePolicyInstancesStatusResponseBody() = default;
};
class DescribePolicyInstancesStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePolicyInstancesStatusResponseBody> body{};

  DescribePolicyInstancesStatusResponse() {}

  explicit DescribePolicyInstancesStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePolicyInstancesStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePolicyInstancesStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePolicyInstancesStatusResponse() = default;
};
class DescribeResourcesDeleteProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<string> resources{};

  DescribeResourcesDeleteProtectionRequest() {}

  explicit DescribeResourcesDeleteProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (resources) {
      res["resources"] = boost::any(*resources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("resources") != m.end() && !m["resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["resources"]));
    }
  }


  virtual ~DescribeResourcesDeleteProtectionRequest() = default;
};
class DescribeResourcesDeleteProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> resource{};
  shared_ptr<bool> protection{};

  DescribeResourcesDeleteProtectionResponseBody() {}

  explicit DescribeResourcesDeleteProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (resource) {
      res["resource"] = boost::any(*resource);
    }
    if (protection) {
      res["protection"] = boost::any(*protection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("resource") != m.end() && !m["resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["resource"]));
    }
    if (m.find("protection") != m.end() && !m["protection"].empty()) {
      protection = make_shared<bool>(boost::any_cast<bool>(m["protection"]));
    }
  }


  virtual ~DescribeResourcesDeleteProtectionResponseBody() = default;
};
class DescribeResourcesDeleteProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<DescribeResourcesDeleteProtectionResponseBody>> body{};

  DescribeResourcesDeleteProtectionResponse() {}

  explicit DescribeResourcesDeleteProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<DescribeResourcesDeleteProtectionResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourcesDeleteProtectionResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<DescribeResourcesDeleteProtectionResponseBody>>(expect1);
      }
    }
  }


  virtual ~DescribeResourcesDeleteProtectionResponse() = default;
};
class DescribeSubaccountK8sClusterUserConfigRequest : public Darabonba::Model {
public:
  shared_ptr<bool> privateIpAddress{};
  shared_ptr<long> temporaryDurationMinutes{};

  DescribeSubaccountK8sClusterUserConfigRequest() {}

  explicit DescribeSubaccountK8sClusterUserConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (temporaryDurationMinutes) {
      res["TemporaryDurationMinutes"] = boost::any(*temporaryDurationMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<bool>(boost::any_cast<bool>(m["PrivateIpAddress"]));
    }
    if (m.find("TemporaryDurationMinutes") != m.end() && !m["TemporaryDurationMinutes"].empty()) {
      temporaryDurationMinutes = make_shared<long>(boost::any_cast<long>(m["TemporaryDurationMinutes"]));
    }
  }


  virtual ~DescribeSubaccountK8sClusterUserConfigRequest() = default;
};
class DescribeSubaccountK8sClusterUserConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> expiration{};

  DescribeSubaccountK8sClusterUserConfigResponseBody() {}

  explicit DescribeSubaccountK8sClusterUserConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (expiration) {
      res["expiration"] = boost::any(*expiration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
    if (m.find("expiration") != m.end() && !m["expiration"].empty()) {
      expiration = make_shared<string>(boost::any_cast<string>(m["expiration"]));
    }
  }


  virtual ~DescribeSubaccountK8sClusterUserConfigResponseBody() = default;
};
class DescribeSubaccountK8sClusterUserConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSubaccountK8sClusterUserConfigResponseBody> body{};

  DescribeSubaccountK8sClusterUserConfigResponse() {}

  explicit DescribeSubaccountK8sClusterUserConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSubaccountK8sClusterUserConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSubaccountK8sClusterUserConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSubaccountK8sClusterUserConfigResponse() = default;
};
class DescribeTaskInfoResponseBodyError : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  DescribeTaskInfoResponseBodyError() {}

  explicit DescribeTaskInfoResponseBodyError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~DescribeTaskInfoResponseBodyError() = default;
};
class DescribeTaskInfoResponseBodyEvents : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> reason{};
  shared_ptr<string> source{};
  shared_ptr<string> timestamp{};

  DescribeTaskInfoResponseBodyEvents() {}

  explicit DescribeTaskInfoResponseBodyEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
  }


  virtual ~DescribeTaskInfoResponseBodyEvents() = default;
};
class DescribeTaskInfoResponseBodyStages : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> message{};
  shared_ptr<map<string, boost::any>> outputs{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};

  DescribeTaskInfoResponseBodyStages() {}

  explicit DescribeTaskInfoResponseBodyStages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (outputs) {
      res["outputs"] = boost::any(*outputs);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("outputs") != m.end() && !m["outputs"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["outputs"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      outputs = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~DescribeTaskInfoResponseBodyStages() = default;
};
class DescribeTaskInfoResponseBodyTarget : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  DescribeTaskInfoResponseBodyTarget() {}

  explicit DescribeTaskInfoResponseBodyTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeTaskInfoResponseBodyTarget() = default;
};
class DescribeTaskInfoResponseBodyTaskResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> status{};

  DescribeTaskInfoResponseBodyTaskResult() {}

  explicit DescribeTaskInfoResponseBodyTaskResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeTaskInfoResponseBodyTaskResult() = default;
};
class DescribeTaskInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> created{};
  shared_ptr<string> currentStage{};
  shared_ptr<DescribeTaskInfoResponseBodyError> error{};
  shared_ptr<vector<DescribeTaskInfoResponseBodyEvents>> events{};
  shared_ptr<map<string, boost::any>> parameters{};
  shared_ptr<vector<DescribeTaskInfoResponseBodyStages>> stages{};
  shared_ptr<string> state{};
  shared_ptr<DescribeTaskInfoResponseBodyTarget> target{};
  shared_ptr<string> taskId{};
  shared_ptr<vector<DescribeTaskInfoResponseBodyTaskResult>> taskResult{};
  shared_ptr<string> taskType{};
  shared_ptr<string> updated{};

  DescribeTaskInfoResponseBody() {}

  explicit DescribeTaskInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (currentStage) {
      res["current_stage"] = boost::any(*currentStage);
    }
    if (error) {
      res["error"] = error ? boost::any(error->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["events"] = boost::any(temp1);
    }
    if (parameters) {
      res["parameters"] = boost::any(*parameters);
    }
    if (stages) {
      vector<boost::any> temp1;
      for(auto item1:*stages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["stages"] = boost::any(temp1);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (target) {
      res["target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    if (taskResult) {
      vector<boost::any> temp1;
      for(auto item1:*taskResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["task_result"] = boost::any(temp1);
    }
    if (taskType) {
      res["task_type"] = boost::any(*taskType);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("current_stage") != m.end() && !m["current_stage"].empty()) {
      currentStage = make_shared<string>(boost::any_cast<string>(m["current_stage"]));
    }
    if (m.find("error") != m.end() && !m["error"].empty()) {
      if (typeid(map<string, boost::any>) == m["error"].type()) {
        DescribeTaskInfoResponseBodyError model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["error"]));
        error = make_shared<DescribeTaskInfoResponseBodyError>(model1);
      }
    }
    if (m.find("events") != m.end() && !m["events"].empty()) {
      if (typeid(vector<boost::any>) == m["events"].type()) {
        vector<DescribeTaskInfoResponseBodyEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTaskInfoResponseBodyEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<DescribeTaskInfoResponseBodyEvents>>(expect1);
      }
    }
    if (m.find("parameters") != m.end() && !m["parameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["parameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      parameters = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("stages") != m.end() && !m["stages"].empty()) {
      if (typeid(vector<boost::any>) == m["stages"].type()) {
        vector<DescribeTaskInfoResponseBodyStages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["stages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTaskInfoResponseBodyStages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stages = make_shared<vector<DescribeTaskInfoResponseBodyStages>>(expect1);
      }
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("target") != m.end() && !m["target"].empty()) {
      if (typeid(map<string, boost::any>) == m["target"].type()) {
        DescribeTaskInfoResponseBodyTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["target"]));
        target = make_shared<DescribeTaskInfoResponseBodyTarget>(model1);
      }
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
    if (m.find("task_result") != m.end() && !m["task_result"].empty()) {
      if (typeid(vector<boost::any>) == m["task_result"].type()) {
        vector<DescribeTaskInfoResponseBodyTaskResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["task_result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTaskInfoResponseBodyTaskResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskResult = make_shared<vector<DescribeTaskInfoResponseBodyTaskResult>>(expect1);
      }
    }
    if (m.find("task_type") != m.end() && !m["task_type"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["task_type"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
  }


  virtual ~DescribeTaskInfoResponseBody() = default;
};
class DescribeTaskInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTaskInfoResponseBody> body{};

  DescribeTaskInfoResponse() {}

  explicit DescribeTaskInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTaskInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTaskInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTaskInfoResponse() = default;
};
class DescribeTemplateAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateType{};

  DescribeTemplateAttributeRequest() {}

  explicit DescribeTemplateAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateType) {
      res["template_type"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("template_type") != m.end() && !m["template_type"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["template_type"]));
    }
  }


  virtual ~DescribeTemplateAttributeRequest() = default;
};
class DescribeTemplateAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> acl{};
  shared_ptr<string> name{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};
  shared_ptr<string> description{};
  shared_ptr<string> tags{};
  shared_ptr<string> templateWithHistId{};
  shared_ptr<string> created{};
  shared_ptr<string> updated{};

  DescribeTemplateAttributeResponseBody() {}

  explicit DescribeTemplateAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (acl) {
      res["acl"] = boost::any(*acl);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (template_) {
      res["template"] = boost::any(*template_);
    }
    if (templateType) {
      res["template_type"] = boost::any(*templateType);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (templateWithHistId) {
      res["template_with_hist_id"] = boost::any(*templateWithHistId);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("acl") != m.end() && !m["acl"].empty()) {
      acl = make_shared<string>(boost::any_cast<string>(m["acl"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["template"]));
    }
    if (m.find("template_type") != m.end() && !m["template_type"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["template_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
    if (m.find("template_with_hist_id") != m.end() && !m["template_with_hist_id"].empty()) {
      templateWithHistId = make_shared<string>(boost::any_cast<string>(m["template_with_hist_id"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
  }


  virtual ~DescribeTemplateAttributeResponseBody() = default;
};
class DescribeTemplateAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<DescribeTemplateAttributeResponseBody>> body{};

  DescribeTemplateAttributeResponse() {}

  explicit DescribeTemplateAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<DescribeTemplateAttributeResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplateAttributeResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<DescribeTemplateAttributeResponseBody>>(expect1);
      }
    }
  }


  virtual ~DescribeTemplateAttributeResponse() = default;
};
class DescribeTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> templateType{};

  DescribeTemplatesRequest() {}

  explicit DescribeTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["page_num"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (templateType) {
      res["template_type"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_num") != m.end() && !m["page_num"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["page_num"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("template_type") != m.end() && !m["template_type"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["template_type"]));
    }
  }


  virtual ~DescribeTemplatesRequest() = default;
};
class DescribeTemplatesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeTemplatesResponseBodyPageInfo() {}

  explicit DescribeTemplatesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~DescribeTemplatesResponseBodyPageInfo() = default;
};
class DescribeTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<string> acl{};
  shared_ptr<string> created{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};
  shared_ptr<string> templateWithHistId{};
  shared_ptr<string> updated{};

  DescribeTemplatesResponseBodyTemplates() {}

  explicit DescribeTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acl) {
      res["acl"] = boost::any(*acl);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (template_) {
      res["template"] = boost::any(*template_);
    }
    if (templateType) {
      res["template_type"] = boost::any(*templateType);
    }
    if (templateWithHistId) {
      res["template_with_hist_id"] = boost::any(*templateWithHistId);
    }
    if (updated) {
      res["updated"] = boost::any(*updated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("acl") != m.end() && !m["acl"].empty()) {
      acl = make_shared<string>(boost::any_cast<string>(m["acl"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["template"]));
    }
    if (m.find("template_type") != m.end() && !m["template_type"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["template_type"]));
    }
    if (m.find("template_with_hist_id") != m.end() && !m["template_with_hist_id"].empty()) {
      templateWithHistId = make_shared<string>(boost::any_cast<string>(m["template_with_hist_id"]));
    }
    if (m.find("updated") != m.end() && !m["updated"].empty()) {
      updated = make_shared<string>(boost::any_cast<string>(m["updated"]));
    }
  }


  virtual ~DescribeTemplatesResponseBodyTemplates() = default;
};
class DescribeTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeTemplatesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeTemplatesResponseBodyTemplates>> templates{};

  DescribeTemplatesResponseBody() {}

  explicit DescribeTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templates) {
      vector<boost::any> temp1;
      for(auto item1:*templates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["templates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        DescribeTemplatesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<DescribeTemplatesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("templates") != m.end() && !m["templates"].empty()) {
      if (typeid(vector<boost::any>) == m["templates"].type()) {
        vector<DescribeTemplatesResponseBodyTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["templates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplatesResponseBodyTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templates = make_shared<vector<DescribeTemplatesResponseBodyTemplates>>(expect1);
      }
    }
  }


  virtual ~DescribeTemplatesResponseBody() = default;
};
class DescribeTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplatesResponseBody> body{};

  DescribeTemplatesResponse() {}

  explicit DescribeTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplatesResponse() = default;
};
class DescribeTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> type{};
  shared_ptr<string> action{};

  DescribeTriggerRequest() {}

  explicit DescribeTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (action) {
      res["action"] = boost::any(*action);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
  }


  virtual ~DescribeTriggerRequest() = default;
};
class DescribeTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> type{};
  shared_ptr<string> action{};
  shared_ptr<string> token{};

  DescribeTriggerResponseBody() {}

  explicit DescribeTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["project_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~DescribeTriggerResponseBody() = default;
};
class DescribeTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<DescribeTriggerResponseBody>> body{};

  DescribeTriggerResponse() {}

  explicit DescribeTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<DescribeTriggerResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTriggerResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<DescribeTriggerResponseBody>>(expect1);
      }
    }
  }


  virtual ~DescribeTriggerResponse() = default;
};
class DescribeUserClusterNamespacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<string>> body{};

  DescribeUserClusterNamespacesResponse() {}

  explicit DescribeUserClusterNamespacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["body"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      body = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeUserClusterNamespacesResponse() = default;
};
class DescribeUserPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleType{};
  shared_ptr<long> isOwner{};
  shared_ptr<long> isRamRole{};

  DescribeUserPermissionResponseBody() {}

  explicit DescribeUserPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["resource_id"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (roleName) {
      res["role_name"] = boost::any(*roleName);
    }
    if (roleType) {
      res["role_type"] = boost::any(*roleType);
    }
    if (isOwner) {
      res["is_owner"] = boost::any(*isOwner);
    }
    if (isRamRole) {
      res["is_ram_role"] = boost::any(*isRamRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("resource_id") != m.end() && !m["resource_id"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["resource_id"]));
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("role_name") != m.end() && !m["role_name"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["role_name"]));
    }
    if (m.find("role_type") != m.end() && !m["role_type"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["role_type"]));
    }
    if (m.find("is_owner") != m.end() && !m["is_owner"].empty()) {
      isOwner = make_shared<long>(boost::any_cast<long>(m["is_owner"]));
    }
    if (m.find("is_ram_role") != m.end() && !m["is_ram_role"].empty()) {
      isRamRole = make_shared<long>(boost::any_cast<long>(m["is_ram_role"]));
    }
  }


  virtual ~DescribeUserPermissionResponseBody() = default;
};
class DescribeUserPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<DescribeUserPermissionResponseBody>> body{};

  DescribeUserPermissionResponse() {}

  explicit DescribeUserPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<DescribeUserPermissionResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserPermissionResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<DescribeUserPermissionResponseBody>>(expect1);
      }
    }
  }


  virtual ~DescribeUserPermissionResponse() = default;
};
class DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<long> count{};
  shared_ptr<long> period{};

  DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota() {}

  explicit DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["bandwidth"] = boost::any(*bandwidth);
    }
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bandwidth") != m.end() && !m["bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["bandwidth"]));
    }
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
  }


  virtual ~DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota() = default;
};
class DescribeUserQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> amkClusterQuota{};
  shared_ptr<long> askClusterQuota{};
  shared_ptr<long> clusterNodepoolQuota{};
  shared_ptr<long> clusterQuota{};
  shared_ptr<DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota> edgeImprovedNodepoolQuota{};
  shared_ptr<long> nodeQuota{};
  shared_ptr<map<string, QuotasValue>> quotas{};

  DescribeUserQuotaResponseBody() {}

  explicit DescribeUserQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amkClusterQuota) {
      res["amk_cluster_quota"] = boost::any(*amkClusterQuota);
    }
    if (askClusterQuota) {
      res["ask_cluster_quota"] = boost::any(*askClusterQuota);
    }
    if (clusterNodepoolQuota) {
      res["cluster_nodepool_quota"] = boost::any(*clusterNodepoolQuota);
    }
    if (clusterQuota) {
      res["cluster_quota"] = boost::any(*clusterQuota);
    }
    if (edgeImprovedNodepoolQuota) {
      res["edge_improved_nodepool_quota"] = edgeImprovedNodepoolQuota ? boost::any(edgeImprovedNodepoolQuota->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeQuota) {
      res["node_quota"] = boost::any(*nodeQuota);
    }
    if (quotas) {
      map<string, boost::any> temp1;
      for(auto item1:*quotas){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["quotas"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amk_cluster_quota") != m.end() && !m["amk_cluster_quota"].empty()) {
      amkClusterQuota = make_shared<long>(boost::any_cast<long>(m["amk_cluster_quota"]));
    }
    if (m.find("ask_cluster_quota") != m.end() && !m["ask_cluster_quota"].empty()) {
      askClusterQuota = make_shared<long>(boost::any_cast<long>(m["ask_cluster_quota"]));
    }
    if (m.find("cluster_nodepool_quota") != m.end() && !m["cluster_nodepool_quota"].empty()) {
      clusterNodepoolQuota = make_shared<long>(boost::any_cast<long>(m["cluster_nodepool_quota"]));
    }
    if (m.find("cluster_quota") != m.end() && !m["cluster_quota"].empty()) {
      clusterQuota = make_shared<long>(boost::any_cast<long>(m["cluster_quota"]));
    }
    if (m.find("edge_improved_nodepool_quota") != m.end() && !m["edge_improved_nodepool_quota"].empty()) {
      if (typeid(map<string, boost::any>) == m["edge_improved_nodepool_quota"].type()) {
        DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["edge_improved_nodepool_quota"]));
        edgeImprovedNodepoolQuota = make_shared<DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota>(model1);
      }
    }
    if (m.find("node_quota") != m.end() && !m["node_quota"].empty()) {
      nodeQuota = make_shared<long>(boost::any_cast<long>(m["node_quota"]));
    }
    if (m.find("quotas") != m.end() && !m["quotas"].empty()) {
      if (typeid(map<string, boost::any>) == m["quotas"].type()) {
        map<string, QuotasValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["quotas"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            QuotasValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        quotas = make_shared<map<string, QuotasValue>>(expect1);
      }
    }
  }


  virtual ~DescribeUserQuotaResponseBody() = default;
};
class DescribeUserQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserQuotaResponseBody> body{};

  DescribeUserQuotaResponse() {}

  explicit DescribeUserQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserQuotaResponse() = default;
};
class EdgeClusterAddEdgeMachineRequest : public Darabonba::Model {
public:
  shared_ptr<long> expired{};
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> options{};

  EdgeClusterAddEdgeMachineRequest() {}

  explicit EdgeClusterAddEdgeMachineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expired) {
      res["expired"] = boost::any(*expired);
    }
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (options) {
      res["options"] = boost::any(*options);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expired") != m.end() && !m["expired"].empty()) {
      expired = make_shared<long>(boost::any_cast<long>(m["expired"]));
    }
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("options") != m.end() && !m["options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["options"]));
    }
  }


  virtual ~EdgeClusterAddEdgeMachineRequest() = default;
};
class EdgeClusterAddEdgeMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> edgeMachineId{};
  shared_ptr<string> requestId{};

  EdgeClusterAddEdgeMachineResponseBody() {}

  explicit EdgeClusterAddEdgeMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edgeMachineId) {
      res["edge_machine_id"] = boost::any(*edgeMachineId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("edge_machine_id") != m.end() && !m["edge_machine_id"].empty()) {
      edgeMachineId = make_shared<string>(boost::any_cast<string>(m["edge_machine_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
  }


  virtual ~EdgeClusterAddEdgeMachineResponseBody() = default;
};
class EdgeClusterAddEdgeMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EdgeClusterAddEdgeMachineResponseBody> body{};

  EdgeClusterAddEdgeMachineResponse() {}

  explicit EdgeClusterAddEdgeMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EdgeClusterAddEdgeMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EdgeClusterAddEdgeMachineResponseBody>(model1);
      }
    }
  }


  virtual ~EdgeClusterAddEdgeMachineResponse() = default;
};
class FixNodePoolVulsRequestRolloutPolicy : public Darabonba::Model {
public:
  shared_ptr<long> maxParallelism{};

  FixNodePoolVulsRequestRolloutPolicy() {}

  explicit FixNodePoolVulsRequestRolloutPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxParallelism) {
      res["max_parallelism"] = boost::any(*maxParallelism);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("max_parallelism") != m.end() && !m["max_parallelism"].empty()) {
      maxParallelism = make_shared<long>(boost::any_cast<long>(m["max_parallelism"]));
    }
  }


  virtual ~FixNodePoolVulsRequestRolloutPolicy() = default;
};
class FixNodePoolVulsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRestart{};
  shared_ptr<vector<string>> nodes{};
  shared_ptr<FixNodePoolVulsRequestRolloutPolicy> rolloutPolicy{};
  shared_ptr<vector<string>> vuls{};

  FixNodePoolVulsRequest() {}

  explicit FixNodePoolVulsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRestart) {
      res["auto_restart"] = boost::any(*autoRestart);
    }
    if (nodes) {
      res["nodes"] = boost::any(*nodes);
    }
    if (rolloutPolicy) {
      res["rollout_policy"] = rolloutPolicy ? boost::any(rolloutPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vuls) {
      res["vuls"] = boost::any(*vuls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_restart") != m.end() && !m["auto_restart"].empty()) {
      autoRestart = make_shared<bool>(boost::any_cast<bool>(m["auto_restart"]));
    }
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("rollout_policy") != m.end() && !m["rollout_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["rollout_policy"].type()) {
        FixNodePoolVulsRequestRolloutPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["rollout_policy"]));
        rolloutPolicy = make_shared<FixNodePoolVulsRequestRolloutPolicy>(model1);
      }
    }
    if (m.find("vuls") != m.end() && !m["vuls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vuls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vuls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vuls = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FixNodePoolVulsRequest() = default;
};
class FixNodePoolVulsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  FixNodePoolVulsResponseBody() {}

  explicit FixNodePoolVulsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~FixNodePoolVulsResponseBody() = default;
};
class FixNodePoolVulsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FixNodePoolVulsResponseBody> body{};

  FixNodePoolVulsResponse() {}

  explicit FixNodePoolVulsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FixNodePoolVulsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FixNodePoolVulsResponseBody>(model1);
      }
    }
  }


  virtual ~FixNodePoolVulsResponse() = default;
};
class GetClusterAddonInstanceResponseBodyLogging : public Darabonba::Model {
public:
  shared_ptr<bool> capable{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> logProject{};
  shared_ptr<string> logstore{};

  GetClusterAddonInstanceResponseBodyLogging() {}

  explicit GetClusterAddonInstanceResponseBodyLogging(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capable) {
      res["capable"] = boost::any(*capable);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (logProject) {
      res["log_project"] = boost::any(*logProject);
    }
    if (logstore) {
      res["logstore"] = boost::any(*logstore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("capable") != m.end() && !m["capable"].empty()) {
      capable = make_shared<bool>(boost::any_cast<bool>(m["capable"]));
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("log_project") != m.end() && !m["log_project"].empty()) {
      logProject = make_shared<string>(boost::any_cast<string>(m["log_project"]));
    }
    if (m.find("logstore") != m.end() && !m["logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["logstore"]));
    }
  }


  virtual ~GetClusterAddonInstanceResponseBodyLogging() = default;
};
class GetClusterAddonInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<GetClusterAddonInstanceResponseBodyLogging> logging{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> version{};

  GetClusterAddonInstanceResponseBody() {}

  explicit GetClusterAddonInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (logging) {
      res["logging"] = logging ? boost::any(logging->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
    if (m.find("logging") != m.end() && !m["logging"].empty()) {
      if (typeid(map<string, boost::any>) == m["logging"].type()) {
        GetClusterAddonInstanceResponseBodyLogging model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["logging"]));
        logging = make_shared<GetClusterAddonInstanceResponseBodyLogging>(model1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~GetClusterAddonInstanceResponseBody() = default;
};
class GetClusterAddonInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterAddonInstanceResponseBody> body{};

  GetClusterAddonInstanceResponse() {}

  explicit GetClusterAddonInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterAddonInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterAddonInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterAddonInstanceResponse() = default;
};
class GetClusterAuditProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> auditEnabled{};
  shared_ptr<string> slsProjectName{};

  GetClusterAuditProjectResponseBody() {}

  explicit GetClusterAuditProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditEnabled) {
      res["audit_enabled"] = boost::any(*auditEnabled);
    }
    if (slsProjectName) {
      res["sls_project_name"] = boost::any(*slsProjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("audit_enabled") != m.end() && !m["audit_enabled"].empty()) {
      auditEnabled = make_shared<bool>(boost::any_cast<bool>(m["audit_enabled"]));
    }
    if (m.find("sls_project_name") != m.end() && !m["sls_project_name"].empty()) {
      slsProjectName = make_shared<string>(boost::any_cast<string>(m["sls_project_name"]));
    }
  }


  virtual ~GetClusterAuditProjectResponseBody() = default;
};
class GetClusterAuditProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterAuditProjectResponseBody> body{};

  GetClusterAuditProjectResponse() {}

  explicit GetClusterAuditProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterAuditProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterAuditProjectResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterAuditProjectResponse() = default;
};
class GetClusterCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> checkId{};
  shared_ptr<map<string, vector<map<string, boost::any>>>> checkItems{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> finishedAt{};
  shared_ptr<string> message{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetClusterCheckResponseBody() {}

  explicit GetClusterCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["check_id"] = boost::any(*checkId);
    }
    if (checkItems) {
      res["check_items"] = boost::any(*checkItems);
    }
    if (createdAt) {
      res["created_at"] = boost::any(*createdAt);
    }
    if (finishedAt) {
      res["finished_at"] = boost::any(*finishedAt);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_id") != m.end() && !m["check_id"].empty()) {
      checkId = make_shared<string>(boost::any_cast<string>(m["check_id"]));
    }
    if (m.find("check_items") != m.end() && !m["check_items"].empty()) {
      map<string, vector<map<string, boost::any>>> map1 = boost::any_cast<map<string, vector<map<string, boost::any>>>>(m["check_items"]);
      map<string, vector<map<string, boost::any>>> toMap1;
      for (auto item:map1) {
        vector<map<string, boost::any>> toVec2;
        if (typeid(vector<boost::any>) == item.second.type()) {
          vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item.second);
          for (auto item:vec2) {
            map<string, boost::any> map3 = boost::any_cast<map<string, boost::any>>(item);
            map<string, boost::any> toMap3;
            for (auto item:map3) {
               toMap3[item.first] = item.second;
            }
             toVec2.push_back(toMap3);
          }
        }
         toMap1[item.first] = toVec2;
      }
      checkItems = make_shared<map<string, vector<map<string, boost::any>>>>(toMap1);
    }
    if (m.find("created_at") != m.end() && !m["created_at"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["created_at"]));
    }
    if (m.find("finished_at") != m.end() && !m["finished_at"].empty()) {
      finishedAt = make_shared<string>(boost::any_cast<string>(m["finished_at"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetClusterCheckResponseBody() = default;
};
class GetClusterCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterCheckResponseBody> body{};

  GetClusterCheckResponse() {}

  explicit GetClusterCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterCheckResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterCheckResponse() = default;
};
class GetClusterDiagnosisCheckItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};

  GetClusterDiagnosisCheckItemsRequest() {}

  explicit GetClusterDiagnosisCheckItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
  }


  virtual ~GetClusterDiagnosisCheckItemsRequest() = default;
};
class GetClusterDiagnosisCheckItemsResponseBodyCheckItems : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> display{};
  shared_ptr<string> group{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> refer{};
  shared_ptr<string> value{};

  GetClusterDiagnosisCheckItemsResponseBodyCheckItems() {}

  explicit GetClusterDiagnosisCheckItemsResponseBodyCheckItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (display) {
      res["display"] = boost::any(*display);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (refer) {
      res["refer"] = boost::any(*refer);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("display") != m.end() && !m["display"].empty()) {
      display = make_shared<string>(boost::any_cast<string>(m["display"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("refer") != m.end() && !m["refer"].empty()) {
      refer = make_shared<string>(boost::any_cast<string>(m["refer"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GetClusterDiagnosisCheckItemsResponseBodyCheckItems() = default;
};
class GetClusterDiagnosisCheckItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetClusterDiagnosisCheckItemsResponseBodyCheckItems>> checkItems{};
  shared_ptr<string> code{};
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  GetClusterDiagnosisCheckItemsResponseBody() {}

  explicit GetClusterDiagnosisCheckItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItems) {
      vector<boost::any> temp1;
      for(auto item1:*checkItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["check_items"] = boost::any(temp1);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (isSuccess) {
      res["is_success"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_items") != m.end() && !m["check_items"].empty()) {
      if (typeid(vector<boost::any>) == m["check_items"].type()) {
        vector<GetClusterDiagnosisCheckItemsResponseBodyCheckItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["check_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetClusterDiagnosisCheckItemsResponseBodyCheckItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkItems = make_shared<vector<GetClusterDiagnosisCheckItemsResponseBodyCheckItems>>(expect1);
      }
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("is_success") != m.end() && !m["is_success"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["is_success"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
  }


  virtual ~GetClusterDiagnosisCheckItemsResponseBody() = default;
};
class GetClusterDiagnosisCheckItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterDiagnosisCheckItemsResponseBody> body{};

  GetClusterDiagnosisCheckItemsResponse() {}

  explicit GetClusterDiagnosisCheckItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterDiagnosisCheckItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterDiagnosisCheckItemsResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterDiagnosisCheckItemsResponse() = default;
};
class GetClusterDiagnosisResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};

  GetClusterDiagnosisResultRequest() {}

  explicit GetClusterDiagnosisResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
  }


  virtual ~GetClusterDiagnosisResultRequest() = default;
};
class GetClusterDiagnosisResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> created{};
  shared_ptr<string> diagnosisId{};
  shared_ptr<string> finished{};
  shared_ptr<string> message{};
  shared_ptr<string> result{};
  shared_ptr<long> status{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  GetClusterDiagnosisResultResponseBody() {}

  explicit GetClusterDiagnosisResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (diagnosisId) {
      res["diagnosis_id"] = boost::any(*diagnosisId);
    }
    if (finished) {
      res["finished"] = boost::any(*finished);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (target) {
      res["target"] = boost::any(*target);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["code"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("diagnosis_id") != m.end() && !m["diagnosis_id"].empty()) {
      diagnosisId = make_shared<string>(boost::any_cast<string>(m["diagnosis_id"]));
    }
    if (m.find("finished") != m.end() && !m["finished"].empty()) {
      finished = make_shared<string>(boost::any_cast<string>(m["finished"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("target") != m.end() && !m["target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["target"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetClusterDiagnosisResultResponseBody() = default;
};
class GetClusterDiagnosisResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterDiagnosisResultResponseBody> body{};

  GetClusterDiagnosisResultResponse() {}

  explicit GetClusterDiagnosisResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterDiagnosisResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterDiagnosisResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterDiagnosisResultResponse() = default;
};
class GetClusterInspectConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> disabledCheckItems{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> recurrence{};
  shared_ptr<string> requestId{};

  GetClusterInspectConfigResponseBody() {}

  explicit GetClusterInspectConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disabledCheckItems) {
      res["disabledCheckItems"] = boost::any(*disabledCheckItems);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (recurrence) {
      res["recurrence"] = boost::any(*recurrence);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disabledCheckItems") != m.end() && !m["disabledCheckItems"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["disabledCheckItems"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["disabledCheckItems"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      disabledCheckItems = make_shared<vector<string>>(toVec1);
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("recurrence") != m.end() && !m["recurrence"].empty()) {
      recurrence = make_shared<string>(boost::any_cast<string>(m["recurrence"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetClusterInspectConfigResponseBody() = default;
};
class GetClusterInspectConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterInspectConfigResponseBody> body{};

  GetClusterInspectConfigResponse() {}

  explicit GetClusterInspectConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterInspectConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterInspectConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterInspectConfigResponse() = default;
};
class GetClusterInspectReportDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<bool> enableFilter{};
  shared_ptr<string> language{};
  shared_ptr<string> level{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> targetType{};

  GetClusterInspectReportDetailRequest() {}

  explicit GetClusterInspectReportDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (enableFilter) {
      res["enableFilter"] = boost::any(*enableFilter);
    }
    if (language) {
      res["language"] = boost::any(*language);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("enableFilter") != m.end() && !m["enableFilter"].empty()) {
      enableFilter = make_shared<bool>(boost::any_cast<bool>(m["enableFilter"]));
    }
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
  }


  virtual ~GetClusterInspectReportDetailRequest() = default;
};
class GetClusterInspectReportDetailResponseBodyCheckItemResults : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> checkItemUid{};
  shared_ptr<string> description{};
  shared_ptr<string> fix{};
  shared_ptr<string> level{};
  shared_ptr<string> name{};
  shared_ptr<string> result{};
  shared_ptr<string> targetType{};
  shared_ptr<vector<string>> targets{};

  GetClusterInspectReportDetailResponseBodyCheckItemResults() {}

  explicit GetClusterInspectReportDetailResponseBodyCheckItemResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (checkItemUid) {
      res["checkItemUid"] = boost::any(*checkItemUid);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (fix) {
      res["fix"] = boost::any(*fix);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    if (targets) {
      res["targets"] = boost::any(*targets);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("checkItemUid") != m.end() && !m["checkItemUid"].empty()) {
      checkItemUid = make_shared<string>(boost::any_cast<string>(m["checkItemUid"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("fix") != m.end() && !m["fix"].empty()) {
      fix = make_shared<string>(boost::any_cast<string>(m["fix"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
    if (m.find("targets") != m.end() && !m["targets"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["targets"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["targets"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targets = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetClusterInspectReportDetailResponseBodyCheckItemResults() = default;
};
class GetClusterInspectReportDetailResponseBodySummary : public Darabonba::Model {
public:
  shared_ptr<long> adviceCount{};
  shared_ptr<string> code{};
  shared_ptr<long> errorCount{};
  shared_ptr<long> normalCount{};
  shared_ptr<long> warnCount{};

  GetClusterInspectReportDetailResponseBodySummary() {}

  explicit GetClusterInspectReportDetailResponseBodySummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adviceCount) {
      res["adviceCount"] = boost::any(*adviceCount);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (errorCount) {
      res["errorCount"] = boost::any(*errorCount);
    }
    if (normalCount) {
      res["normalCount"] = boost::any(*normalCount);
    }
    if (warnCount) {
      res["warnCount"] = boost::any(*warnCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adviceCount") != m.end() && !m["adviceCount"].empty()) {
      adviceCount = make_shared<long>(boost::any_cast<long>(m["adviceCount"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("errorCount") != m.end() && !m["errorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["errorCount"]));
    }
    if (m.find("normalCount") != m.end() && !m["normalCount"].empty()) {
      normalCount = make_shared<long>(boost::any_cast<long>(m["normalCount"]));
    }
    if (m.find("warnCount") != m.end() && !m["warnCount"].empty()) {
      warnCount = make_shared<long>(boost::any_cast<long>(m["warnCount"]));
    }
  }


  virtual ~GetClusterInspectReportDetailResponseBodySummary() = default;
};
class GetClusterInspectReportDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetClusterInspectReportDetailResponseBodyCheckItemResults>> checkItemResults{};
  shared_ptr<string> endTime{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> reportId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<GetClusterInspectReportDetailResponseBodySummary> summary{};

  GetClusterInspectReportDetailResponseBody() {}

  explicit GetClusterInspectReportDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItemResults) {
      vector<boost::any> temp1;
      for(auto item1:*checkItemResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["checkItemResults"] = boost::any(temp1);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (reportId) {
      res["reportId"] = boost::any(*reportId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (summary) {
      res["summary"] = summary ? boost::any(summary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkItemResults") != m.end() && !m["checkItemResults"].empty()) {
      if (typeid(vector<boost::any>) == m["checkItemResults"].type()) {
        vector<GetClusterInspectReportDetailResponseBodyCheckItemResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["checkItemResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetClusterInspectReportDetailResponseBodyCheckItemResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkItemResults = make_shared<vector<GetClusterInspectReportDetailResponseBodyCheckItemResults>>(expect1);
      }
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("reportId") != m.end() && !m["reportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["reportId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      if (typeid(map<string, boost::any>) == m["summary"].type()) {
        GetClusterInspectReportDetailResponseBodySummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["summary"]));
        summary = make_shared<GetClusterInspectReportDetailResponseBodySummary>(model1);
      }
    }
  }


  virtual ~GetClusterInspectReportDetailResponseBody() = default;
};
class GetClusterInspectReportDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterInspectReportDetailResponseBody> body{};

  GetClusterInspectReportDetailResponse() {}

  explicit GetClusterInspectReportDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterInspectReportDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterInspectReportDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterInspectReportDetailResponse() = default;
};
class GetKubernetesTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> type{};
  shared_ptr<string> action{};

  GetKubernetesTriggerRequest() {}

  explicit GetKubernetesTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (action) {
      res["action"] = boost::any(*action);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
  }


  virtual ~GetKubernetesTriggerRequest() = default;
};
class GetKubernetesTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> type{};
  shared_ptr<string> action{};
  shared_ptr<string> token{};

  GetKubernetesTriggerResponseBody() {}

  explicit GetKubernetesTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["project_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~GetKubernetesTriggerResponseBody() = default;
};
class GetKubernetesTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<GetKubernetesTriggerResponseBody>> body{};

  GetKubernetesTriggerResponse() {}

  explicit GetKubernetesTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<GetKubernetesTriggerResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetKubernetesTriggerResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<GetKubernetesTriggerResponseBody>>(expect1);
      }
    }
  }


  virtual ~GetKubernetesTriggerResponse() = default;
};
class GetUpgradeStatusResponseBodyUpgradeTask : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> status{};

  GetUpgradeStatusResponseBodyUpgradeTask() {}

  explicit GetUpgradeStatusResponseBodyUpgradeTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~GetUpgradeStatusResponseBodyUpgradeTask() = default;
};
class GetUpgradeStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> precheckReportId{};
  shared_ptr<string> status{};
  shared_ptr<string> upgradeStep{};
  shared_ptr<GetUpgradeStatusResponseBodyUpgradeTask> upgradeTask{};

  GetUpgradeStatusResponseBody() {}

  explicit GetUpgradeStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["error_message"] = boost::any(*errorMessage);
    }
    if (precheckReportId) {
      res["precheck_report_id"] = boost::any(*precheckReportId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (upgradeStep) {
      res["upgrade_step"] = boost::any(*upgradeStep);
    }
    if (upgradeTask) {
      res["upgrade_task"] = upgradeTask ? boost::any(upgradeTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("error_message") != m.end() && !m["error_message"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["error_message"]));
    }
    if (m.find("precheck_report_id") != m.end() && !m["precheck_report_id"].empty()) {
      precheckReportId = make_shared<string>(boost::any_cast<string>(m["precheck_report_id"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("upgrade_step") != m.end() && !m["upgrade_step"].empty()) {
      upgradeStep = make_shared<string>(boost::any_cast<string>(m["upgrade_step"]));
    }
    if (m.find("upgrade_task") != m.end() && !m["upgrade_task"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_task"].type()) {
        GetUpgradeStatusResponseBodyUpgradeTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_task"]));
        upgradeTask = make_shared<GetUpgradeStatusResponseBodyUpgradeTask>(model1);
      }
    }
  }


  virtual ~GetUpgradeStatusResponseBody() = default;
};
class GetUpgradeStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUpgradeStatusResponseBody> body{};

  GetUpgradeStatusResponse() {}

  explicit GetUpgradeStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUpgradeStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUpgradeStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetUpgradeStatusResponse() = default;
};
class GrantPermissionsRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> cluster{};
  shared_ptr<bool> isCustom{};
  shared_ptr<bool> isRamRole{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleType{};

  GrantPermissionsRequestBody() {}

  explicit GrantPermissionsRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      res["cluster"] = boost::any(*cluster);
    }
    if (isCustom) {
      res["is_custom"] = boost::any(*isCustom);
    }
    if (isRamRole) {
      res["is_ram_role"] = boost::any(*isRamRole);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (roleName) {
      res["role_name"] = boost::any(*roleName);
    }
    if (roleType) {
      res["role_type"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster") != m.end() && !m["cluster"].empty()) {
      cluster = make_shared<string>(boost::any_cast<string>(m["cluster"]));
    }
    if (m.find("is_custom") != m.end() && !m["is_custom"].empty()) {
      isCustom = make_shared<bool>(boost::any_cast<bool>(m["is_custom"]));
    }
    if (m.find("is_ram_role") != m.end() && !m["is_ram_role"].empty()) {
      isRamRole = make_shared<bool>(boost::any_cast<bool>(m["is_ram_role"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("role_name") != m.end() && !m["role_name"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["role_name"]));
    }
    if (m.find("role_type") != m.end() && !m["role_type"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["role_type"]));
    }
  }


  virtual ~GrantPermissionsRequestBody() = default;
};
class GrantPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<GrantPermissionsRequestBody>> body{};

  GrantPermissionsRequest() {}

  explicit GrantPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<GrantPermissionsRequestBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrantPermissionsRequestBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<GrantPermissionsRequestBody>>(expect1);
      }
    }
  }


  virtual ~GrantPermissionsRequest() = default;
};
class GrantPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  GrantPermissionsResponse() {}

  explicit GrantPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~GrantPermissionsResponse() = default;
};
class InstallClusterAddonsRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> name{};
  shared_ptr<string> version{};

  InstallClusterAddonsRequestBody() {}

  explicit InstallClusterAddonsRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~InstallClusterAddonsRequestBody() = default;
};
class InstallClusterAddonsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<InstallClusterAddonsRequestBody>> body{};

  InstallClusterAddonsRequest() {}

  explicit InstallClusterAddonsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<InstallClusterAddonsRequestBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstallClusterAddonsRequestBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<InstallClusterAddonsRequestBody>>(expect1);
      }
    }
  }


  virtual ~InstallClusterAddonsRequest() = default;
};
class InstallClusterAddonsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  InstallClusterAddonsResponseBody() {}

  explicit InstallClusterAddonsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~InstallClusterAddonsResponseBody() = default;
};
class InstallClusterAddonsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallClusterAddonsResponseBody> body{};

  InstallClusterAddonsResponse() {}

  explicit InstallClusterAddonsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallClusterAddonsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallClusterAddonsResponseBody>(model1);
      }
    }
  }


  virtual ~InstallClusterAddonsResponse() = default;
};
class ListAddonsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterSpec{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> clusterVersion{};
  shared_ptr<string> profile{};
  shared_ptr<string> regionId{};

  ListAddonsRequest() {}

  explicit ListAddonsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (clusterSpec) {
      res["cluster_spec"] = boost::any(*clusterSpec);
    }
    if (clusterType) {
      res["cluster_type"] = boost::any(*clusterType);
    }
    if (clusterVersion) {
      res["cluster_version"] = boost::any(*clusterVersion);
    }
    if (profile) {
      res["profile"] = boost::any(*profile);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("cluster_spec") != m.end() && !m["cluster_spec"].empty()) {
      clusterSpec = make_shared<string>(boost::any_cast<string>(m["cluster_spec"]));
    }
    if (m.find("cluster_type") != m.end() && !m["cluster_type"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["cluster_type"]));
    }
    if (m.find("cluster_version") != m.end() && !m["cluster_version"].empty()) {
      clusterVersion = make_shared<string>(boost::any_cast<string>(m["cluster_version"]));
    }
    if (m.find("profile") != m.end() && !m["profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["profile"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
  }


  virtual ~ListAddonsRequest() = default;
};
class ListAddonsResponseBodyAddons : public Darabonba::Model {
public:
  shared_ptr<vector<string>> architecture{};
  shared_ptr<string> category{};
  shared_ptr<string> configSchema{};
  shared_ptr<bool> installByDefault{};
  shared_ptr<bool> managed{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> supportedActions{};
  shared_ptr<string> version{};

  ListAddonsResponseBodyAddons() {}

  explicit ListAddonsResponseBodyAddons(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["architecture"] = boost::any(*architecture);
    }
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (configSchema) {
      res["config_schema"] = boost::any(*configSchema);
    }
    if (installByDefault) {
      res["install_by_default"] = boost::any(*installByDefault);
    }
    if (managed) {
      res["managed"] = boost::any(*managed);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (supportedActions) {
      res["supported_actions"] = boost::any(*supportedActions);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("architecture") != m.end() && !m["architecture"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["architecture"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["architecture"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      architecture = make_shared<vector<string>>(toVec1);
    }
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("config_schema") != m.end() && !m["config_schema"].empty()) {
      configSchema = make_shared<string>(boost::any_cast<string>(m["config_schema"]));
    }
    if (m.find("install_by_default") != m.end() && !m["install_by_default"].empty()) {
      installByDefault = make_shared<bool>(boost::any_cast<bool>(m["install_by_default"]));
    }
    if (m.find("managed") != m.end() && !m["managed"].empty()) {
      managed = make_shared<bool>(boost::any_cast<bool>(m["managed"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("supported_actions") != m.end() && !m["supported_actions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supported_actions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supported_actions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~ListAddonsResponseBodyAddons() = default;
};
class ListAddonsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAddonsResponseBodyAddons>> addons{};

  ListAddonsResponseBody() {}

  explicit ListAddonsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addons) {
      vector<boost::any> temp1;
      for(auto item1:*addons){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["addons"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("addons") != m.end() && !m["addons"].empty()) {
      if (typeid(vector<boost::any>) == m["addons"].type()) {
        vector<ListAddonsResponseBodyAddons> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["addons"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAddonsResponseBodyAddons model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addons = make_shared<vector<ListAddonsResponseBodyAddons>>(expect1);
      }
    }
  }


  virtual ~ListAddonsResponseBody() = default;
};
class ListAddonsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAddonsResponseBody> body{};

  ListAddonsResponse() {}

  explicit ListAddonsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAddonsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAddonsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAddonsResponse() = default;
};
class ListClusterAddonInstancesResponseBodyAddons : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> version{};

  ListClusterAddonInstancesResponseBodyAddons() {}

  explicit ListClusterAddonInstancesResponseBodyAddons(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~ListClusterAddonInstancesResponseBodyAddons() = default;
};
class ListClusterAddonInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterAddonInstancesResponseBodyAddons>> addons{};

  ListClusterAddonInstancesResponseBody() {}

  explicit ListClusterAddonInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addons) {
      vector<boost::any> temp1;
      for(auto item1:*addons){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["addons"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("addons") != m.end() && !m["addons"].empty()) {
      if (typeid(vector<boost::any>) == m["addons"].type()) {
        vector<ListClusterAddonInstancesResponseBodyAddons> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["addons"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterAddonInstancesResponseBodyAddons model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addons = make_shared<vector<ListClusterAddonInstancesResponseBodyAddons>>(expect1);
      }
    }
  }


  virtual ~ListClusterAddonInstancesResponseBody() = default;
};
class ListClusterAddonInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterAddonInstancesResponseBody> body{};

  ListClusterAddonInstancesResponse() {}

  explicit ListClusterAddonInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterAddonInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterAddonInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterAddonInstancesResponse() = default;
};
class ListClusterChecksRequest : public Darabonba::Model {
public:
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  ListClusterChecksRequest() {}

  explicit ListClusterChecksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      res["target"] = boost::any(*target);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("target") != m.end() && !m["target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["target"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListClusterChecksRequest() = default;
};
class ListClusterChecksResponseBodyChecks : public Darabonba::Model {
public:
  shared_ptr<string> checkId{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> finishedAt{};
  shared_ptr<string> message{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListClusterChecksResponseBodyChecks() {}

  explicit ListClusterChecksResponseBodyChecks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["check_id"] = boost::any(*checkId);
    }
    if (createdAt) {
      res["created_at"] = boost::any(*createdAt);
    }
    if (finishedAt) {
      res["finished_at"] = boost::any(*finishedAt);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_id") != m.end() && !m["check_id"].empty()) {
      checkId = make_shared<string>(boost::any_cast<string>(m["check_id"]));
    }
    if (m.find("created_at") != m.end() && !m["created_at"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["created_at"]));
    }
    if (m.find("finished_at") != m.end() && !m["finished_at"].empty()) {
      finishedAt = make_shared<string>(boost::any_cast<string>(m["finished_at"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListClusterChecksResponseBodyChecks() = default;
};
class ListClusterChecksResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterChecksResponseBodyChecks>> checks{};

  ListClusterChecksResponseBody() {}

  explicit ListClusterChecksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checks) {
      vector<boost::any> temp1;
      for(auto item1:*checks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["checks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checks") != m.end() && !m["checks"].empty()) {
      if (typeid(vector<boost::any>) == m["checks"].type()) {
        vector<ListClusterChecksResponseBodyChecks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["checks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterChecksResponseBodyChecks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checks = make_shared<vector<ListClusterChecksResponseBodyChecks>>(expect1);
      }
    }
  }


  virtual ~ListClusterChecksResponseBody() = default;
};
class ListClusterChecksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterChecksResponseBody> body{};

  ListClusterChecksResponse() {}

  explicit ListClusterChecksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterChecksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterChecksResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterChecksResponse() = default;
};
class ListClusterInspectReportsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListClusterInspectReportsRequest() {}

  explicit ListClusterInspectReportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
  }


  virtual ~ListClusterInspectReportsRequest() = default;
};
class ListClusterInspectReportsResponseBodyReportsSummary : public Darabonba::Model {
public:
  shared_ptr<long> adviceCount{};
  shared_ptr<string> code{};
  shared_ptr<long> errorCount{};
  shared_ptr<long> normalCount{};
  shared_ptr<long> warnCount{};

  ListClusterInspectReportsResponseBodyReportsSummary() {}

  explicit ListClusterInspectReportsResponseBodyReportsSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adviceCount) {
      res["adviceCount"] = boost::any(*adviceCount);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (errorCount) {
      res["errorCount"] = boost::any(*errorCount);
    }
    if (normalCount) {
      res["normalCount"] = boost::any(*normalCount);
    }
    if (warnCount) {
      res["warnCount"] = boost::any(*warnCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adviceCount") != m.end() && !m["adviceCount"].empty()) {
      adviceCount = make_shared<long>(boost::any_cast<long>(m["adviceCount"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("errorCount") != m.end() && !m["errorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["errorCount"]));
    }
    if (m.find("normalCount") != m.end() && !m["normalCount"].empty()) {
      normalCount = make_shared<long>(boost::any_cast<long>(m["normalCount"]));
    }
    if (m.find("warnCount") != m.end() && !m["warnCount"].empty()) {
      warnCount = make_shared<long>(boost::any_cast<long>(m["warnCount"]));
    }
  }


  virtual ~ListClusterInspectReportsResponseBodyReportsSummary() = default;
};
class ListClusterInspectReportsResponseBodyReports : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> reportId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<ListClusterInspectReportsResponseBodyReportsSummary> summary{};

  ListClusterInspectReportsResponseBodyReports() {}

  explicit ListClusterInspectReportsResponseBodyReports(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (reportId) {
      res["reportId"] = boost::any(*reportId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (summary) {
      res["summary"] = summary ? boost::any(summary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("reportId") != m.end() && !m["reportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["reportId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      if (typeid(map<string, boost::any>) == m["summary"].type()) {
        ListClusterInspectReportsResponseBodyReportsSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["summary"]));
        summary = make_shared<ListClusterInspectReportsResponseBodyReportsSummary>(model1);
      }
    }
  }


  virtual ~ListClusterInspectReportsResponseBodyReports() = default;
};
class ListClusterInspectReportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListClusterInspectReportsResponseBodyReports>> reports{};
  shared_ptr<string> requestId{};

  ListClusterInspectReportsResponseBody() {}

  explicit ListClusterInspectReportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (reports) {
      vector<boost::any> temp1;
      for(auto item1:*reports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reports"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("reports") != m.end() && !m["reports"].empty()) {
      if (typeid(vector<boost::any>) == m["reports"].type()) {
        vector<ListClusterInspectReportsResponseBodyReports> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterInspectReportsResponseBodyReports model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reports = make_shared<vector<ListClusterInspectReportsResponseBodyReports>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListClusterInspectReportsResponseBody() = default;
};
class ListClusterInspectReportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterInspectReportsResponseBody> body{};

  ListClusterInspectReportsResponse() {}

  explicit ListClusterInspectReportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterInspectReportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterInspectReportsResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterInspectReportsResponse() = default;
};
class ListClusterKubeconfigStatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListClusterKubeconfigStatesRequest() {}

  explicit ListClusterKubeconfigStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
  }


  virtual ~ListClusterKubeconfigStatesRequest() = default;
};
class ListClusterKubeconfigStatesResponseBodyPage : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListClusterKubeconfigStatesResponseBodyPage() {}

  explicit ListClusterKubeconfigStatesResponseBodyPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~ListClusterKubeconfigStatesResponseBodyPage() = default;
};
class ListClusterKubeconfigStatesResponseBodyStates : public Darabonba::Model {
public:
  shared_ptr<string> accountDisplayName{};
  shared_ptr<string> accountId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountState{};
  shared_ptr<string> accountType{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certState{};
  shared_ptr<bool> revokable{};

  ListClusterKubeconfigStatesResponseBodyStates() {}

  explicit ListClusterKubeconfigStatesResponseBodyStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountDisplayName) {
      res["account_display_name"] = boost::any(*accountDisplayName);
    }
    if (accountId) {
      res["account_id"] = boost::any(*accountId);
    }
    if (accountName) {
      res["account_name"] = boost::any(*accountName);
    }
    if (accountState) {
      res["account_state"] = boost::any(*accountState);
    }
    if (accountType) {
      res["account_type"] = boost::any(*accountType);
    }
    if (certExpireTime) {
      res["cert_expire_time"] = boost::any(*certExpireTime);
    }
    if (certState) {
      res["cert_state"] = boost::any(*certState);
    }
    if (revokable) {
      res["revokable"] = boost::any(*revokable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("account_display_name") != m.end() && !m["account_display_name"].empty()) {
      accountDisplayName = make_shared<string>(boost::any_cast<string>(m["account_display_name"]));
    }
    if (m.find("account_id") != m.end() && !m["account_id"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["account_id"]));
    }
    if (m.find("account_name") != m.end() && !m["account_name"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["account_name"]));
    }
    if (m.find("account_state") != m.end() && !m["account_state"].empty()) {
      accountState = make_shared<string>(boost::any_cast<string>(m["account_state"]));
    }
    if (m.find("account_type") != m.end() && !m["account_type"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["account_type"]));
    }
    if (m.find("cert_expire_time") != m.end() && !m["cert_expire_time"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["cert_expire_time"]));
    }
    if (m.find("cert_state") != m.end() && !m["cert_state"].empty()) {
      certState = make_shared<string>(boost::any_cast<string>(m["cert_state"]));
    }
    if (m.find("revokable") != m.end() && !m["revokable"].empty()) {
      revokable = make_shared<bool>(boost::any_cast<bool>(m["revokable"]));
    }
  }


  virtual ~ListClusterKubeconfigStatesResponseBodyStates() = default;
};
class ListClusterKubeconfigStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterKubeconfigStatesResponseBodyPage> page{};
  shared_ptr<vector<ListClusterKubeconfigStatesResponseBodyStates>> states{};

  ListClusterKubeconfigStatesResponseBody() {}

  explicit ListClusterKubeconfigStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = page ? boost::any(page->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (states) {
      vector<boost::any> temp1;
      for(auto item1:*states){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["states"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      if (typeid(map<string, boost::any>) == m["page"].type()) {
        ListClusterKubeconfigStatesResponseBodyPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page"]));
        page = make_shared<ListClusterKubeconfigStatesResponseBodyPage>(model1);
      }
    }
    if (m.find("states") != m.end() && !m["states"].empty()) {
      if (typeid(vector<boost::any>) == m["states"].type()) {
        vector<ListClusterKubeconfigStatesResponseBodyStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["states"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterKubeconfigStatesResponseBodyStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        states = make_shared<vector<ListClusterKubeconfigStatesResponseBodyStates>>(expect1);
      }
    }
  }


  virtual ~ListClusterKubeconfigStatesResponseBody() = default;
};
class ListClusterKubeconfigStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterKubeconfigStatesResponseBody> body{};

  ListClusterKubeconfigStatesResponse() {}

  explicit ListClusterKubeconfigStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterKubeconfigStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterKubeconfigStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterKubeconfigStatesResponse() = default;
};
class ListOperationPlansRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> type{};

  ListOperationPlansRequest() {}

  explicit ListOperationPlansRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListOperationPlansRequest() = default;
};
class ListOperationPlansResponseBodyPlans : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> created{};
  shared_ptr<string> endTime{};
  shared_ptr<string> planId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetType{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  ListOperationPlansResponseBodyPlans() {}

  explicit ListOperationPlansResponseBodyPlans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (created) {
      res["created"] = boost::any(*created);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (planId) {
      res["plan_id"] = boost::any(*planId);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (targetId) {
      res["target_id"] = boost::any(*targetId);
    }
    if (targetType) {
      res["target_type"] = boost::any(*targetType);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("created") != m.end() && !m["created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["created"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("plan_id") != m.end() && !m["plan_id"].empty()) {
      planId = make_shared<string>(boost::any_cast<string>(m["plan_id"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("target_id") != m.end() && !m["target_id"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["target_id"]));
    }
    if (m.find("target_type") != m.end() && !m["target_type"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["target_type"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListOperationPlansResponseBodyPlans() = default;
};
class ListOperationPlansResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListOperationPlansResponseBodyPlans>> plans{};

  ListOperationPlansResponseBody() {}

  explicit ListOperationPlansResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (plans) {
      vector<boost::any> temp1;
      for(auto item1:*plans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["plans"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("plans") != m.end() && !m["plans"].empty()) {
      if (typeid(vector<boost::any>) == m["plans"].type()) {
        vector<ListOperationPlansResponseBodyPlans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["plans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOperationPlansResponseBodyPlans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        plans = make_shared<vector<ListOperationPlansResponseBodyPlans>>(expect1);
      }
    }
  }


  virtual ~ListOperationPlansResponseBody() = default;
};
class ListOperationPlansResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOperationPlansResponseBody> body{};

  ListOperationPlansResponse() {}

  explicit ListOperationPlansResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOperationPlansResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOperationPlansResponseBody>(model1);
      }
    }
  }


  virtual ~ListOperationPlansResponse() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<Tag>> tags{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["next_token"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["resource_ids"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("next_token") != m.end() && !m["next_token"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["next_token"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_ids") != m.end() && !m["resource_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["resource_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["resource_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceIdsShrink{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagsShrink{};

  ListTagResourcesShrinkRequest() {}

  explicit ListTagResourcesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["next_token"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceIdsShrink) {
      res["resource_ids"] = boost::any(*resourceIdsShrink);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (tagsShrink) {
      res["tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("next_token") != m.end() && !m["next_token"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["next_token"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_ids") != m.end() && !m["resource_ids"].empty()) {
      resourceIdsShrink = make_shared<string>(boost::any_cast<string>(m["resource_ids"]));
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
  }


  virtual ~ListTagResourcesShrinkRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["resource_id"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["tag_key"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["tag_value"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("resource_id") != m.end() && !m["resource_id"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["resource_id"]));
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("tag_key") != m.end() && !m["tag_key"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["tag_key"]));
    }
    if (m.find("tag_value") != m.end() && !m["tag_value"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["tag_value"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tag_resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tag_resource") != m.end() && !m["tag_resource"].empty()) {
      if (typeid(vector<boost::any>) == m["tag_resource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tag_resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["next_token"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["tag_resources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("next_token") != m.end() && !m["next_token"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["next_token"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("tag_resources") != m.end() && !m["tag_resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["tag_resources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tag_resources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListUserKubeConfigStatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListUserKubeConfigStatesRequest() {}

  explicit ListUserKubeConfigStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
  }


  virtual ~ListUserKubeConfigStatesRequest() = default;
};
class ListUserKubeConfigStatesResponseBodyPage : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUserKubeConfigStatesResponseBodyPage() {}

  explicit ListUserKubeConfigStatesResponseBodyPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["total_count"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_count") != m.end() && !m["total_count"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["total_count"]));
    }
  }


  virtual ~ListUserKubeConfigStatesResponseBodyPage() = default;
};
class ListUserKubeConfigStatesResponseBodyStates : public Darabonba::Model {
public:
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certState{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterState{};

  ListUserKubeConfigStatesResponseBodyStates() {}

  explicit ListUserKubeConfigStatesResponseBodyStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certExpireTime) {
      res["cert_expire_time"] = boost::any(*certExpireTime);
    }
    if (certState) {
      res["cert_state"] = boost::any(*certState);
    }
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["cluster_name"] = boost::any(*clusterName);
    }
    if (clusterState) {
      res["cluster_state"] = boost::any(*clusterState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cert_expire_time") != m.end() && !m["cert_expire_time"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["cert_expire_time"]));
    }
    if (m.find("cert_state") != m.end() && !m["cert_state"].empty()) {
      certState = make_shared<string>(boost::any_cast<string>(m["cert_state"]));
    }
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("cluster_name") != m.end() && !m["cluster_name"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["cluster_name"]));
    }
    if (m.find("cluster_state") != m.end() && !m["cluster_state"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["cluster_state"]));
    }
  }


  virtual ~ListUserKubeConfigStatesResponseBodyStates() = default;
};
class ListUserKubeConfigStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListUserKubeConfigStatesResponseBodyPage> page{};
  shared_ptr<vector<ListUserKubeConfigStatesResponseBodyStates>> states{};

  ListUserKubeConfigStatesResponseBody() {}

  explicit ListUserKubeConfigStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = page ? boost::any(page->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (states) {
      vector<boost::any> temp1;
      for(auto item1:*states){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["states"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      if (typeid(map<string, boost::any>) == m["page"].type()) {
        ListUserKubeConfigStatesResponseBodyPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page"]));
        page = make_shared<ListUserKubeConfigStatesResponseBodyPage>(model1);
      }
    }
    if (m.find("states") != m.end() && !m["states"].empty()) {
      if (typeid(vector<boost::any>) == m["states"].type()) {
        vector<ListUserKubeConfigStatesResponseBodyStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["states"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserKubeConfigStatesResponseBodyStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        states = make_shared<vector<ListUserKubeConfigStatesResponseBodyStates>>(expect1);
      }
    }
  }


  virtual ~ListUserKubeConfigStatesResponseBody() = default;
};
class ListUserKubeConfigStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserKubeConfigStatesResponseBody> body{};

  ListUserKubeConfigStatesResponse() {}

  explicit ListUserKubeConfigStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserKubeConfigStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserKubeConfigStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserKubeConfigStatesResponse() = default;
};
class MigrateClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> ossBucketEndpoint{};
  shared_ptr<string> ossBucketName{};

  MigrateClusterRequest() {}

  explicit MigrateClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossBucketEndpoint) {
      res["oss_bucket_endpoint"] = boost::any(*ossBucketEndpoint);
    }
    if (ossBucketName) {
      res["oss_bucket_name"] = boost::any(*ossBucketName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("oss_bucket_endpoint") != m.end() && !m["oss_bucket_endpoint"].empty()) {
      ossBucketEndpoint = make_shared<string>(boost::any_cast<string>(m["oss_bucket_endpoint"]));
    }
    if (m.find("oss_bucket_name") != m.end() && !m["oss_bucket_name"].empty()) {
      ossBucketName = make_shared<string>(boost::any_cast<string>(m["oss_bucket_name"]));
    }
  }


  virtual ~MigrateClusterRequest() = default;
};
class MigrateClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  MigrateClusterResponseBody() {}

  explicit MigrateClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~MigrateClusterResponseBody() = default;
};
class MigrateClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MigrateClusterResponseBody> body{};

  MigrateClusterResponse() {}

  explicit MigrateClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MigrateClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MigrateClusterResponseBody>(model1);
      }
    }
  }


  virtual ~MigrateClusterResponse() = default;
};
class ModifyClusterRequestApiServerCustomCertSans : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<vector<string>> subjectAlternativeNames{};

  ModifyClusterRequestApiServerCustomCertSans() {}

  explicit ModifyClusterRequestApiServerCustomCertSans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (subjectAlternativeNames) {
      res["subject_alternative_names"] = boost::any(*subjectAlternativeNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("subject_alternative_names") != m.end() && !m["subject_alternative_names"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["subject_alternative_names"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["subject_alternative_names"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subjectAlternativeNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyClusterRequestApiServerCustomCertSans() = default;
};
class ModifyClusterRequestControlPlaneConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<string> chargeType{};
  shared_ptr<bool> cloudMonitorFlags{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<string> deploymentsetId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> keyPair{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> nodePortRange{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> runtime{};
  shared_ptr<bool> securityHardeningOs{};
  shared_ptr<long> size{};
  shared_ptr<bool> socEnabled{};
  shared_ptr<bool> systemDiskBurstingEnabled{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskPerformanceLevel{};
  shared_ptr<long> systemDiskProvisionedIops{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<string> systemDiskSnapshotPolicyId{};

  ModifyClusterRequestControlPlaneConfig() {}

  explicit ModifyClusterRequestControlPlaneConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["auto_renew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["auto_renew_period"] = boost::any(*autoRenewPeriod);
    }
    if (chargeType) {
      res["charge_type"] = boost::any(*chargeType);
    }
    if (cloudMonitorFlags) {
      res["cloud_monitor_flags"] = boost::any(*cloudMonitorFlags);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (deploymentsetId) {
      res["deploymentset_id"] = boost::any(*deploymentsetId);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (imageType) {
      res["image_type"] = boost::any(*imageType);
    }
    if (instanceTypes) {
      res["instance_types"] = boost::any(*instanceTypes);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (loginPassword) {
      res["login_password"] = boost::any(*loginPassword);
    }
    if (nodePortRange) {
      res["node_port_range"] = boost::any(*nodePortRange);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["period_unit"] = boost::any(*periodUnit);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (securityHardeningOs) {
      res["security_hardening_os"] = boost::any(*securityHardeningOs);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (socEnabled) {
      res["soc_enabled"] = boost::any(*socEnabled);
    }
    if (systemDiskBurstingEnabled) {
      res["system_disk_bursting_enabled"] = boost::any(*systemDiskBurstingEnabled);
    }
    if (systemDiskCategory) {
      res["system_disk_category"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskPerformanceLevel) {
      res["system_disk_performance_level"] = boost::any(*systemDiskPerformanceLevel);
    }
    if (systemDiskProvisionedIops) {
      res["system_disk_provisioned_iops"] = boost::any(*systemDiskProvisionedIops);
    }
    if (systemDiskSize) {
      res["system_disk_size"] = boost::any(*systemDiskSize);
    }
    if (systemDiskSnapshotPolicyId) {
      res["system_disk_snapshot_policy_id"] = boost::any(*systemDiskSnapshotPolicyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_renew") != m.end() && !m["auto_renew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["auto_renew"]));
    }
    if (m.find("auto_renew_period") != m.end() && !m["auto_renew_period"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["auto_renew_period"]));
    }
    if (m.find("charge_type") != m.end() && !m["charge_type"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["charge_type"]));
    }
    if (m.find("cloud_monitor_flags") != m.end() && !m["cloud_monitor_flags"].empty()) {
      cloudMonitorFlags = make_shared<bool>(boost::any_cast<bool>(m["cloud_monitor_flags"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("deploymentset_id") != m.end() && !m["deploymentset_id"].empty()) {
      deploymentsetId = make_shared<string>(boost::any_cast<string>(m["deploymentset_id"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("image_type") != m.end() && !m["image_type"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["image_type"]));
    }
    if (m.find("instance_types") != m.end() && !m["instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("login_password") != m.end() && !m["login_password"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["login_password"]));
    }
    if (m.find("node_port_range") != m.end() && !m["node_port_range"].empty()) {
      nodePortRange = make_shared<string>(boost::any_cast<string>(m["node_port_range"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("period_unit") != m.end() && !m["period_unit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["period_unit"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("security_hardening_os") != m.end() && !m["security_hardening_os"].empty()) {
      securityHardeningOs = make_shared<bool>(boost::any_cast<bool>(m["security_hardening_os"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("soc_enabled") != m.end() && !m["soc_enabled"].empty()) {
      socEnabled = make_shared<bool>(boost::any_cast<bool>(m["soc_enabled"]));
    }
    if (m.find("system_disk_bursting_enabled") != m.end() && !m["system_disk_bursting_enabled"].empty()) {
      systemDiskBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["system_disk_bursting_enabled"]));
    }
    if (m.find("system_disk_category") != m.end() && !m["system_disk_category"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["system_disk_category"]));
    }
    if (m.find("system_disk_performance_level") != m.end() && !m["system_disk_performance_level"].empty()) {
      systemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["system_disk_performance_level"]));
    }
    if (m.find("system_disk_provisioned_iops") != m.end() && !m["system_disk_provisioned_iops"].empty()) {
      systemDiskProvisionedIops = make_shared<long>(boost::any_cast<long>(m["system_disk_provisioned_iops"]));
    }
    if (m.find("system_disk_size") != m.end() && !m["system_disk_size"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["system_disk_size"]));
    }
    if (m.find("system_disk_snapshot_policy_id") != m.end() && !m["system_disk_snapshot_policy_id"].empty()) {
      systemDiskSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["system_disk_snapshot_policy_id"]));
    }
  }


  virtual ~ModifyClusterRequestControlPlaneConfig() = default;
};
class ModifyClusterRequestOperationPolicyClusterAutoUpgrade : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<bool> enabled{};

  ModifyClusterRequestOperationPolicyClusterAutoUpgrade() {}

  explicit ModifyClusterRequestOperationPolicyClusterAutoUpgrade(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["channel"] = boost::any(*channel);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("channel") != m.end() && !m["channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["channel"]));
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
  }


  virtual ~ModifyClusterRequestOperationPolicyClusterAutoUpgrade() = default;
};
class ModifyClusterRequestOperationPolicy : public Darabonba::Model {
public:
  shared_ptr<ModifyClusterRequestOperationPolicyClusterAutoUpgrade> clusterAutoUpgrade{};

  ModifyClusterRequestOperationPolicy() {}

  explicit ModifyClusterRequestOperationPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterAutoUpgrade) {
      res["cluster_auto_upgrade"] = clusterAutoUpgrade ? boost::any(clusterAutoUpgrade->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_auto_upgrade") != m.end() && !m["cluster_auto_upgrade"].empty()) {
      if (typeid(map<string, boost::any>) == m["cluster_auto_upgrade"].type()) {
        ModifyClusterRequestOperationPolicyClusterAutoUpgrade model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cluster_auto_upgrade"]));
        clusterAutoUpgrade = make_shared<ModifyClusterRequestOperationPolicyClusterAutoUpgrade>(model1);
      }
    }
  }


  virtual ~ModifyClusterRequestOperationPolicy() = default;
};
class ModifyClusterRequestSystemEventsLogging : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> loggingProject{};

  ModifyClusterRequestSystemEventsLogging() {}

  explicit ModifyClusterRequestSystemEventsLogging(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (loggingProject) {
      res["logging_project"] = boost::any(*loggingProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("logging_project") != m.end() && !m["logging_project"].empty()) {
      loggingProject = make_shared<string>(boost::any_cast<string>(m["logging_project"]));
    }
  }


  virtual ~ModifyClusterRequestSystemEventsLogging() = default;
};
class ModifyClusterRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> accessControlList{};
  shared_ptr<ModifyClusterRequestApiServerCustomCertSans> apiServerCustomCertSans{};
  shared_ptr<bool> apiServerEip{};
  shared_ptr<string> apiServerEipId{};
  shared_ptr<string> clusterName{};
  shared_ptr<ModifyClusterRequestControlPlaneConfig> controlPlaneConfig{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<bool> enableRrsa{};
  shared_ptr<bool> ingressDomainRebinding{};
  shared_ptr<string> ingressLoadbalancerId{};
  shared_ptr<bool> instanceDeletionProtection{};
  shared_ptr<MaintenanceWindow> maintenanceWindow{};
  shared_ptr<ModifyClusterRequestOperationPolicy> operationPolicy{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<ModifyClusterRequestSystemEventsLogging> systemEventsLogging{};
  shared_ptr<string> timezone{};
  shared_ptr<vector<string>> vswitchIds{};

  ModifyClusterRequest() {}

  explicit ModifyClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessControlList) {
      res["access_control_list"] = boost::any(*accessControlList);
    }
    if (apiServerCustomCertSans) {
      res["api_server_custom_cert_sans"] = apiServerCustomCertSans ? boost::any(apiServerCustomCertSans->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (apiServerEip) {
      res["api_server_eip"] = boost::any(*apiServerEip);
    }
    if (apiServerEipId) {
      res["api_server_eip_id"] = boost::any(*apiServerEipId);
    }
    if (clusterName) {
      res["cluster_name"] = boost::any(*clusterName);
    }
    if (controlPlaneConfig) {
      res["control_plane_config"] = controlPlaneConfig ? boost::any(controlPlaneConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deletionProtection) {
      res["deletion_protection"] = boost::any(*deletionProtection);
    }
    if (enableRrsa) {
      res["enable_rrsa"] = boost::any(*enableRrsa);
    }
    if (ingressDomainRebinding) {
      res["ingress_domain_rebinding"] = boost::any(*ingressDomainRebinding);
    }
    if (ingressLoadbalancerId) {
      res["ingress_loadbalancer_id"] = boost::any(*ingressLoadbalancerId);
    }
    if (instanceDeletionProtection) {
      res["instance_deletion_protection"] = boost::any(*instanceDeletionProtection);
    }
    if (maintenanceWindow) {
      res["maintenance_window"] = maintenanceWindow ? boost::any(maintenanceWindow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operationPolicy) {
      res["operation_policy"] = operationPolicy ? boost::any(operationPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["security_group_id"] = boost::any(*securityGroupId);
    }
    if (systemEventsLogging) {
      res["system_events_logging"] = systemEventsLogging ? boost::any(systemEventsLogging->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timezone) {
      res["timezone"] = boost::any(*timezone);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("access_control_list") != m.end() && !m["access_control_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["access_control_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["access_control_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      accessControlList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("api_server_custom_cert_sans") != m.end() && !m["api_server_custom_cert_sans"].empty()) {
      if (typeid(map<string, boost::any>) == m["api_server_custom_cert_sans"].type()) {
        ModifyClusterRequestApiServerCustomCertSans model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["api_server_custom_cert_sans"]));
        apiServerCustomCertSans = make_shared<ModifyClusterRequestApiServerCustomCertSans>(model1);
      }
    }
    if (m.find("api_server_eip") != m.end() && !m["api_server_eip"].empty()) {
      apiServerEip = make_shared<bool>(boost::any_cast<bool>(m["api_server_eip"]));
    }
    if (m.find("api_server_eip_id") != m.end() && !m["api_server_eip_id"].empty()) {
      apiServerEipId = make_shared<string>(boost::any_cast<string>(m["api_server_eip_id"]));
    }
    if (m.find("cluster_name") != m.end() && !m["cluster_name"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["cluster_name"]));
    }
    if (m.find("control_plane_config") != m.end() && !m["control_plane_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["control_plane_config"].type()) {
        ModifyClusterRequestControlPlaneConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["control_plane_config"]));
        controlPlaneConfig = make_shared<ModifyClusterRequestControlPlaneConfig>(model1);
      }
    }
    if (m.find("deletion_protection") != m.end() && !m["deletion_protection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["deletion_protection"]));
    }
    if (m.find("enable_rrsa") != m.end() && !m["enable_rrsa"].empty()) {
      enableRrsa = make_shared<bool>(boost::any_cast<bool>(m["enable_rrsa"]));
    }
    if (m.find("ingress_domain_rebinding") != m.end() && !m["ingress_domain_rebinding"].empty()) {
      ingressDomainRebinding = make_shared<bool>(boost::any_cast<bool>(m["ingress_domain_rebinding"]));
    }
    if (m.find("ingress_loadbalancer_id") != m.end() && !m["ingress_loadbalancer_id"].empty()) {
      ingressLoadbalancerId = make_shared<string>(boost::any_cast<string>(m["ingress_loadbalancer_id"]));
    }
    if (m.find("instance_deletion_protection") != m.end() && !m["instance_deletion_protection"].empty()) {
      instanceDeletionProtection = make_shared<bool>(boost::any_cast<bool>(m["instance_deletion_protection"]));
    }
    if (m.find("maintenance_window") != m.end() && !m["maintenance_window"].empty()) {
      if (typeid(map<string, boost::any>) == m["maintenance_window"].type()) {
        MaintenanceWindow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["maintenance_window"]));
        maintenanceWindow = make_shared<MaintenanceWindow>(model1);
      }
    }
    if (m.find("operation_policy") != m.end() && !m["operation_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["operation_policy"].type()) {
        ModifyClusterRequestOperationPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["operation_policy"]));
        operationPolicy = make_shared<ModifyClusterRequestOperationPolicy>(model1);
      }
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
    if (m.find("security_group_id") != m.end() && !m["security_group_id"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["security_group_id"]));
    }
    if (m.find("system_events_logging") != m.end() && !m["system_events_logging"].empty()) {
      if (typeid(map<string, boost::any>) == m["system_events_logging"].type()) {
        ModifyClusterRequestSystemEventsLogging model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["system_events_logging"]));
        systemEventsLogging = make_shared<ModifyClusterRequestSystemEventsLogging>(model1);
      }
    }
    if (m.find("timezone") != m.end() && !m["timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["timezone"]));
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyClusterRequest() = default;
};
class ModifyClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  ModifyClusterResponseBody() {}

  explicit ModifyClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~ModifyClusterResponseBody() = default;
};
class ModifyClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyClusterResponseBody> body{};

  ModifyClusterResponse() {}

  explicit ModifyClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClusterResponse() = default;
};
class ModifyClusterAddonRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};

  ModifyClusterAddonRequest() {}

  explicit ModifyClusterAddonRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["config"] = boost::any(*config);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
  }


  virtual ~ModifyClusterAddonRequest() = default;
};
class ModifyClusterAddonResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  ModifyClusterAddonResponse() {}

  explicit ModifyClusterAddonResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~ModifyClusterAddonResponse() = default;
};
class ModifyClusterConfigurationRequestCustomizeConfigConfigs : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyClusterConfigurationRequestCustomizeConfigConfigs() {}

  explicit ModifyClusterConfigurationRequestCustomizeConfigConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ModifyClusterConfigurationRequestCustomizeConfigConfigs() = default;
};
class ModifyClusterConfigurationRequestCustomizeConfig : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyClusterConfigurationRequestCustomizeConfigConfigs>> configs{};
  shared_ptr<string> name{};

  ModifyClusterConfigurationRequestCustomizeConfig() {}

  explicit ModifyClusterConfigurationRequestCustomizeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["configs"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("configs") != m.end() && !m["configs"].empty()) {
      if (typeid(vector<boost::any>) == m["configs"].type()) {
        vector<ModifyClusterConfigurationRequestCustomizeConfigConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterConfigurationRequestCustomizeConfigConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<ModifyClusterConfigurationRequestCustomizeConfigConfigs>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ModifyClusterConfigurationRequestCustomizeConfig() = default;
};
class ModifyClusterConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyClusterConfigurationRequestCustomizeConfig>> customizeConfig{};

  ModifyClusterConfigurationRequest() {}

  explicit ModifyClusterConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customizeConfig) {
      vector<boost::any> temp1;
      for(auto item1:*customizeConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["customize_config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("customize_config") != m.end() && !m["customize_config"].empty()) {
      if (typeid(vector<boost::any>) == m["customize_config"].type()) {
        vector<ModifyClusterConfigurationRequestCustomizeConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["customize_config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterConfigurationRequestCustomizeConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customizeConfig = make_shared<vector<ModifyClusterConfigurationRequestCustomizeConfig>>(expect1);
      }
    }
  }


  virtual ~ModifyClusterConfigurationRequest() = default;
};
class ModifyClusterConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  ModifyClusterConfigurationResponse() {}

  explicit ModifyClusterConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~ModifyClusterConfigurationResponse() = default;
};
class ModifyClusterNodePoolRequestAutoScaling : public Darabonba::Model {
public:
  shared_ptr<long> eipBandwidth{};
  shared_ptr<string> eipInternetChargeType{};
  shared_ptr<bool> enable{};
  shared_ptr<bool> isBondEip{};
  shared_ptr<long> maxInstances{};
  shared_ptr<long> minInstances{};
  shared_ptr<string> type{};

  ModifyClusterNodePoolRequestAutoScaling() {}

  explicit ModifyClusterNodePoolRequestAutoScaling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipBandwidth) {
      res["eip_bandwidth"] = boost::any(*eipBandwidth);
    }
    if (eipInternetChargeType) {
      res["eip_internet_charge_type"] = boost::any(*eipInternetChargeType);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (isBondEip) {
      res["is_bond_eip"] = boost::any(*isBondEip);
    }
    if (maxInstances) {
      res["max_instances"] = boost::any(*maxInstances);
    }
    if (minInstances) {
      res["min_instances"] = boost::any(*minInstances);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eip_bandwidth") != m.end() && !m["eip_bandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["eip_bandwidth"]));
    }
    if (m.find("eip_internet_charge_type") != m.end() && !m["eip_internet_charge_type"].empty()) {
      eipInternetChargeType = make_shared<string>(boost::any_cast<string>(m["eip_internet_charge_type"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("is_bond_eip") != m.end() && !m["is_bond_eip"].empty()) {
      isBondEip = make_shared<bool>(boost::any_cast<bool>(m["is_bond_eip"]));
    }
    if (m.find("max_instances") != m.end() && !m["max_instances"].empty()) {
      maxInstances = make_shared<long>(boost::any_cast<long>(m["max_instances"]));
    }
    if (m.find("min_instances") != m.end() && !m["min_instances"].empty()) {
      minInstances = make_shared<long>(boost::any_cast<long>(m["min_instances"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequestAutoScaling() = default;
};
class ModifyClusterNodePoolRequestKubernetesConfig : public Darabonba::Model {
public:
  shared_ptr<bool> cmsEnabled{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<vector<Tag>> labels{};
  shared_ptr<string> preUserData{};
  shared_ptr<string> runtime{};
  shared_ptr<string> runtimeVersion{};
  shared_ptr<vector<Taint>> taints{};
  shared_ptr<bool> unschedulable{};
  shared_ptr<string> userData{};

  ModifyClusterNodePoolRequestKubernetesConfig() {}

  explicit ModifyClusterNodePoolRequestKubernetesConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cmsEnabled) {
      res["cms_enabled"] = boost::any(*cmsEnabled);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["labels"] = boost::any(temp1);
    }
    if (preUserData) {
      res["pre_user_data"] = boost::any(*preUserData);
    }
    if (runtime) {
      res["runtime"] = boost::any(*runtime);
    }
    if (runtimeVersion) {
      res["runtime_version"] = boost::any(*runtimeVersion);
    }
    if (taints) {
      vector<boost::any> temp1;
      for(auto item1:*taints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["taints"] = boost::any(temp1);
    }
    if (unschedulable) {
      res["unschedulable"] = boost::any(*unschedulable);
    }
    if (userData) {
      res["user_data"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cms_enabled") != m.end() && !m["cms_enabled"].empty()) {
      cmsEnabled = make_shared<bool>(boost::any_cast<bool>(m["cms_enabled"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("labels") != m.end() && !m["labels"].empty()) {
      if (typeid(vector<boost::any>) == m["labels"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("pre_user_data") != m.end() && !m["pre_user_data"].empty()) {
      preUserData = make_shared<string>(boost::any_cast<string>(m["pre_user_data"]));
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["runtime"]));
    }
    if (m.find("runtime_version") != m.end() && !m["runtime_version"].empty()) {
      runtimeVersion = make_shared<string>(boost::any_cast<string>(m["runtime_version"]));
    }
    if (m.find("taints") != m.end() && !m["taints"].empty()) {
      if (typeid(vector<boost::any>) == m["taints"].type()) {
        vector<Taint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["taints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Taint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taints = make_shared<vector<Taint>>(expect1);
      }
    }
    if (m.find("unschedulable") != m.end() && !m["unschedulable"].empty()) {
      unschedulable = make_shared<bool>(boost::any_cast<bool>(m["unschedulable"]));
    }
    if (m.find("user_data") != m.end() && !m["user_data"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["user_data"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequestKubernetesConfig() = default;
};
class ModifyClusterNodePoolRequestManagementAutoRepairPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> approvalRequired{};
  shared_ptr<bool> restartNode{};

  ModifyClusterNodePoolRequestManagementAutoRepairPolicy() {}

  explicit ModifyClusterNodePoolRequestManagementAutoRepairPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalRequired) {
      res["approval_required"] = boost::any(*approvalRequired);
    }
    if (restartNode) {
      res["restart_node"] = boost::any(*restartNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("approval_required") != m.end() && !m["approval_required"].empty()) {
      approvalRequired = make_shared<bool>(boost::any_cast<bool>(m["approval_required"]));
    }
    if (m.find("restart_node") != m.end() && !m["restart_node"].empty()) {
      restartNode = make_shared<bool>(boost::any_cast<bool>(m["restart_node"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequestManagementAutoRepairPolicy() = default;
};
class ModifyClusterNodePoolRequestManagementAutoUpgradePolicy : public Darabonba::Model {
public:
  shared_ptr<bool> autoUpgradeKubelet{};
  shared_ptr<bool> autoUpgradeOs{};
  shared_ptr<bool> autoUpgradeRuntime{};

  ModifyClusterNodePoolRequestManagementAutoUpgradePolicy() {}

  explicit ModifyClusterNodePoolRequestManagementAutoUpgradePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpgradeKubelet) {
      res["auto_upgrade_kubelet"] = boost::any(*autoUpgradeKubelet);
    }
    if (autoUpgradeOs) {
      res["auto_upgrade_os"] = boost::any(*autoUpgradeOs);
    }
    if (autoUpgradeRuntime) {
      res["auto_upgrade_runtime"] = boost::any(*autoUpgradeRuntime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_upgrade_kubelet") != m.end() && !m["auto_upgrade_kubelet"].empty()) {
      autoUpgradeKubelet = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade_kubelet"]));
    }
    if (m.find("auto_upgrade_os") != m.end() && !m["auto_upgrade_os"].empty()) {
      autoUpgradeOs = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade_os"]));
    }
    if (m.find("auto_upgrade_runtime") != m.end() && !m["auto_upgrade_runtime"].empty()) {
      autoUpgradeRuntime = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade_runtime"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequestManagementAutoUpgradePolicy() = default;
};
class ModifyClusterNodePoolRequestManagementAutoVulFixPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> restartNode{};
  shared_ptr<string> vulLevel{};

  ModifyClusterNodePoolRequestManagementAutoVulFixPolicy() {}

  explicit ModifyClusterNodePoolRequestManagementAutoVulFixPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (restartNode) {
      res["restart_node"] = boost::any(*restartNode);
    }
    if (vulLevel) {
      res["vul_level"] = boost::any(*vulLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("restart_node") != m.end() && !m["restart_node"].empty()) {
      restartNode = make_shared<bool>(boost::any_cast<bool>(m["restart_node"]));
    }
    if (m.find("vul_level") != m.end() && !m["vul_level"].empty()) {
      vulLevel = make_shared<string>(boost::any_cast<string>(m["vul_level"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequestManagementAutoVulFixPolicy() = default;
};
class ModifyClusterNodePoolRequestManagementUpgradeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoUpgrade{};
  shared_ptr<long> maxUnavailable{};
  shared_ptr<long> surge{};
  shared_ptr<long> surgePercentage{};

  ModifyClusterNodePoolRequestManagementUpgradeConfig() {}

  explicit ModifyClusterNodePoolRequestManagementUpgradeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpgrade) {
      res["auto_upgrade"] = boost::any(*autoUpgrade);
    }
    if (maxUnavailable) {
      res["max_unavailable"] = boost::any(*maxUnavailable);
    }
    if (surge) {
      res["surge"] = boost::any(*surge);
    }
    if (surgePercentage) {
      res["surge_percentage"] = boost::any(*surgePercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_upgrade") != m.end() && !m["auto_upgrade"].empty()) {
      autoUpgrade = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade"]));
    }
    if (m.find("max_unavailable") != m.end() && !m["max_unavailable"].empty()) {
      maxUnavailable = make_shared<long>(boost::any_cast<long>(m["max_unavailable"]));
    }
    if (m.find("surge") != m.end() && !m["surge"].empty()) {
      surge = make_shared<long>(boost::any_cast<long>(m["surge"]));
    }
    if (m.find("surge_percentage") != m.end() && !m["surge_percentage"].empty()) {
      surgePercentage = make_shared<long>(boost::any_cast<long>(m["surge_percentage"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequestManagementUpgradeConfig() = default;
};
class ModifyClusterNodePoolRequestManagement : public Darabonba::Model {
public:
  shared_ptr<bool> autoRepair{};
  shared_ptr<ModifyClusterNodePoolRequestManagementAutoRepairPolicy> autoRepairPolicy{};
  shared_ptr<bool> autoUpgrade{};
  shared_ptr<ModifyClusterNodePoolRequestManagementAutoUpgradePolicy> autoUpgradePolicy{};
  shared_ptr<bool> autoVulFix{};
  shared_ptr<ModifyClusterNodePoolRequestManagementAutoVulFixPolicy> autoVulFixPolicy{};
  shared_ptr<bool> enable{};
  shared_ptr<ModifyClusterNodePoolRequestManagementUpgradeConfig> upgradeConfig{};

  ModifyClusterNodePoolRequestManagement() {}

  explicit ModifyClusterNodePoolRequestManagement(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRepair) {
      res["auto_repair"] = boost::any(*autoRepair);
    }
    if (autoRepairPolicy) {
      res["auto_repair_policy"] = autoRepairPolicy ? boost::any(autoRepairPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoUpgrade) {
      res["auto_upgrade"] = boost::any(*autoUpgrade);
    }
    if (autoUpgradePolicy) {
      res["auto_upgrade_policy"] = autoUpgradePolicy ? boost::any(autoUpgradePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoVulFix) {
      res["auto_vul_fix"] = boost::any(*autoVulFix);
    }
    if (autoVulFixPolicy) {
      res["auto_vul_fix_policy"] = autoVulFixPolicy ? boost::any(autoVulFixPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (upgradeConfig) {
      res["upgrade_config"] = upgradeConfig ? boost::any(upgradeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_repair") != m.end() && !m["auto_repair"].empty()) {
      autoRepair = make_shared<bool>(boost::any_cast<bool>(m["auto_repair"]));
    }
    if (m.find("auto_repair_policy") != m.end() && !m["auto_repair_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_repair_policy"].type()) {
        ModifyClusterNodePoolRequestManagementAutoRepairPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_repair_policy"]));
        autoRepairPolicy = make_shared<ModifyClusterNodePoolRequestManagementAutoRepairPolicy>(model1);
      }
    }
    if (m.find("auto_upgrade") != m.end() && !m["auto_upgrade"].empty()) {
      autoUpgrade = make_shared<bool>(boost::any_cast<bool>(m["auto_upgrade"]));
    }
    if (m.find("auto_upgrade_policy") != m.end() && !m["auto_upgrade_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_upgrade_policy"].type()) {
        ModifyClusterNodePoolRequestManagementAutoUpgradePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_upgrade_policy"]));
        autoUpgradePolicy = make_shared<ModifyClusterNodePoolRequestManagementAutoUpgradePolicy>(model1);
      }
    }
    if (m.find("auto_vul_fix") != m.end() && !m["auto_vul_fix"].empty()) {
      autoVulFix = make_shared<bool>(boost::any_cast<bool>(m["auto_vul_fix"]));
    }
    if (m.find("auto_vul_fix_policy") != m.end() && !m["auto_vul_fix_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_vul_fix_policy"].type()) {
        ModifyClusterNodePoolRequestManagementAutoVulFixPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_vul_fix_policy"]));
        autoVulFixPolicy = make_shared<ModifyClusterNodePoolRequestManagementAutoVulFixPolicy>(model1);
      }
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("upgrade_config") != m.end() && !m["upgrade_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_config"].type()) {
        ModifyClusterNodePoolRequestManagementUpgradeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_config"]));
        upgradeConfig = make_shared<ModifyClusterNodePoolRequestManagementUpgradeConfig>(model1);
      }
    }
  }


  virtual ~ModifyClusterNodePoolRequestManagement() = default;
};
class ModifyClusterNodePoolRequestNodepoolInfo : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};

  ModifyClusterNodePoolRequestNodepoolInfo() {}

  explicit ModifyClusterNodePoolRequestNodepoolInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["resource_group_id"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("resource_group_id") != m.end() && !m["resource_group_id"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resource_group_id"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequestNodepoolInfo() = default;
};
class ModifyClusterNodePoolRequestScalingGroupPrivatePoolOptions : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> matchCriteria{};

  ModifyClusterNodePoolRequestScalingGroupPrivatePoolOptions() {}

  explicit ModifyClusterNodePoolRequestScalingGroupPrivatePoolOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (matchCriteria) {
      res["match_criteria"] = boost::any(*matchCriteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("match_criteria") != m.end() && !m["match_criteria"].empty()) {
      matchCriteria = make_shared<string>(boost::any_cast<string>(m["match_criteria"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequestScalingGroupPrivatePoolOptions() = default;
};
class ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<string> priceLimit{};

  ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit() {}

  explicit ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["instance_type"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["price_limit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instance_type") != m.end() && !m["instance_type"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instance_type"]));
    }
    if (m.find("price_limit") != m.end() && !m["price_limit"].empty()) {
      priceLimit = make_shared<string>(boost::any_cast<string>(m["price_limit"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit() = default;
};
class ModifyClusterNodePoolRequestScalingGroup : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<bool> compensateWithOnDemand{};
  shared_ptr<vector<DataDisk>> dataDisks{};
  shared_ptr<string> deploymentsetId{};
  shared_ptr<long> desiredSize{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<vector<InstancePatterns>> instancePatterns{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> keyPair{};
  shared_ptr<string> loginPassword{};
  shared_ptr<string> multiAzPolicy{};
  shared_ptr<long> onDemandBaseCapacity{};
  shared_ptr<long> onDemandPercentageAboveBaseCapacity{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> platform{};
  shared_ptr<ModifyClusterNodePoolRequestScalingGroupPrivatePoolOptions> privatePoolOptions{};
  shared_ptr<vector<string>> rdsInstances{};
  shared_ptr<string> scalingPolicy{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<long> spotInstancePools{};
  shared_ptr<bool> spotInstanceRemedy{};
  shared_ptr<vector<ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit>> spotPriceLimit{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<bool> systemDiskBurstingEnabled{};
  shared_ptr<vector<string>> systemDiskCategories{};
  shared_ptr<string> systemDiskCategory{};
  shared_ptr<string> systemDiskEncryptAlgorithm{};
  shared_ptr<bool> systemDiskEncrypted{};
  shared_ptr<string> systemDiskKmsKeyId{};
  shared_ptr<string> systemDiskPerformanceLevel{};
  shared_ptr<long> systemDiskProvisionedIops{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<vector<string>> vswitchIds{};

  ModifyClusterNodePoolRequestScalingGroup() {}

  explicit ModifyClusterNodePoolRequestScalingGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["auto_renew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["auto_renew_period"] = boost::any(*autoRenewPeriod);
    }
    if (compensateWithOnDemand) {
      res["compensate_with_on_demand"] = boost::any(*compensateWithOnDemand);
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_disks"] = boost::any(temp1);
    }
    if (deploymentsetId) {
      res["deploymentset_id"] = boost::any(*deploymentsetId);
    }
    if (desiredSize) {
      res["desired_size"] = boost::any(*desiredSize);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (imageType) {
      res["image_type"] = boost::any(*imageType);
    }
    if (instanceChargeType) {
      res["instance_charge_type"] = boost::any(*instanceChargeType);
    }
    if (instancePatterns) {
      vector<boost::any> temp1;
      for(auto item1:*instancePatterns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["instance_patterns"] = boost::any(temp1);
    }
    if (instanceTypes) {
      res["instance_types"] = boost::any(*instanceTypes);
    }
    if (internetChargeType) {
      res["internet_charge_type"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["internet_max_bandwidth_out"] = boost::any(*internetMaxBandwidthOut);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (loginPassword) {
      res["login_password"] = boost::any(*loginPassword);
    }
    if (multiAzPolicy) {
      res["multi_az_policy"] = boost::any(*multiAzPolicy);
    }
    if (onDemandBaseCapacity) {
      res["on_demand_base_capacity"] = boost::any(*onDemandBaseCapacity);
    }
    if (onDemandPercentageAboveBaseCapacity) {
      res["on_demand_percentage_above_base_capacity"] = boost::any(*onDemandPercentageAboveBaseCapacity);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["period_unit"] = boost::any(*periodUnit);
    }
    if (platform) {
      res["platform"] = boost::any(*platform);
    }
    if (privatePoolOptions) {
      res["private_pool_options"] = privatePoolOptions ? boost::any(privatePoolOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rdsInstances) {
      res["rds_instances"] = boost::any(*rdsInstances);
    }
    if (scalingPolicy) {
      res["scaling_policy"] = boost::any(*scalingPolicy);
    }
    if (securityGroupIds) {
      res["security_group_ids"] = boost::any(*securityGroupIds);
    }
    if (spotInstancePools) {
      res["spot_instance_pools"] = boost::any(*spotInstancePools);
    }
    if (spotInstanceRemedy) {
      res["spot_instance_remedy"] = boost::any(*spotInstanceRemedy);
    }
    if (spotPriceLimit) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["spot_price_limit"] = boost::any(temp1);
    }
    if (spotStrategy) {
      res["spot_strategy"] = boost::any(*spotStrategy);
    }
    if (systemDiskBurstingEnabled) {
      res["system_disk_bursting_enabled"] = boost::any(*systemDiskBurstingEnabled);
    }
    if (systemDiskCategories) {
      res["system_disk_categories"] = boost::any(*systemDiskCategories);
    }
    if (systemDiskCategory) {
      res["system_disk_category"] = boost::any(*systemDiskCategory);
    }
    if (systemDiskEncryptAlgorithm) {
      res["system_disk_encrypt_algorithm"] = boost::any(*systemDiskEncryptAlgorithm);
    }
    if (systemDiskEncrypted) {
      res["system_disk_encrypted"] = boost::any(*systemDiskEncrypted);
    }
    if (systemDiskKmsKeyId) {
      res["system_disk_kms_key_id"] = boost::any(*systemDiskKmsKeyId);
    }
    if (systemDiskPerformanceLevel) {
      res["system_disk_performance_level"] = boost::any(*systemDiskPerformanceLevel);
    }
    if (systemDiskProvisionedIops) {
      res["system_disk_provisioned_iops"] = boost::any(*systemDiskProvisionedIops);
    }
    if (systemDiskSize) {
      res["system_disk_size"] = boost::any(*systemDiskSize);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_renew") != m.end() && !m["auto_renew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["auto_renew"]));
    }
    if (m.find("auto_renew_period") != m.end() && !m["auto_renew_period"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["auto_renew_period"]));
    }
    if (m.find("compensate_with_on_demand") != m.end() && !m["compensate_with_on_demand"].empty()) {
      compensateWithOnDemand = make_shared<bool>(boost::any_cast<bool>(m["compensate_with_on_demand"]));
    }
    if (m.find("data_disks") != m.end() && !m["data_disks"].empty()) {
      if (typeid(vector<boost::any>) == m["data_disks"].type()) {
        vector<DataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DataDisk>>(expect1);
      }
    }
    if (m.find("deploymentset_id") != m.end() && !m["deploymentset_id"].empty()) {
      deploymentsetId = make_shared<string>(boost::any_cast<string>(m["deploymentset_id"]));
    }
    if (m.find("desired_size") != m.end() && !m["desired_size"].empty()) {
      desiredSize = make_shared<long>(boost::any_cast<long>(m["desired_size"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("image_type") != m.end() && !m["image_type"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["image_type"]));
    }
    if (m.find("instance_charge_type") != m.end() && !m["instance_charge_type"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["instance_charge_type"]));
    }
    if (m.find("instance_patterns") != m.end() && !m["instance_patterns"].empty()) {
      if (typeid(vector<boost::any>) == m["instance_patterns"].type()) {
        vector<InstancePatterns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["instance_patterns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstancePatterns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instancePatterns = make_shared<vector<InstancePatterns>>(expect1);
      }
    }
    if (m.find("instance_types") != m.end() && !m["instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("internet_charge_type") != m.end() && !m["internet_charge_type"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["internet_charge_type"]));
    }
    if (m.find("internet_max_bandwidth_out") != m.end() && !m["internet_max_bandwidth_out"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["internet_max_bandwidth_out"]));
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("login_password") != m.end() && !m["login_password"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["login_password"]));
    }
    if (m.find("multi_az_policy") != m.end() && !m["multi_az_policy"].empty()) {
      multiAzPolicy = make_shared<string>(boost::any_cast<string>(m["multi_az_policy"]));
    }
    if (m.find("on_demand_base_capacity") != m.end() && !m["on_demand_base_capacity"].empty()) {
      onDemandBaseCapacity = make_shared<long>(boost::any_cast<long>(m["on_demand_base_capacity"]));
    }
    if (m.find("on_demand_percentage_above_base_capacity") != m.end() && !m["on_demand_percentage_above_base_capacity"].empty()) {
      onDemandPercentageAboveBaseCapacity = make_shared<long>(boost::any_cast<long>(m["on_demand_percentage_above_base_capacity"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("period_unit") != m.end() && !m["period_unit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["period_unit"]));
    }
    if (m.find("platform") != m.end() && !m["platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["platform"]));
    }
    if (m.find("private_pool_options") != m.end() && !m["private_pool_options"].empty()) {
      if (typeid(map<string, boost::any>) == m["private_pool_options"].type()) {
        ModifyClusterNodePoolRequestScalingGroupPrivatePoolOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["private_pool_options"]));
        privatePoolOptions = make_shared<ModifyClusterNodePoolRequestScalingGroupPrivatePoolOptions>(model1);
      }
    }
    if (m.find("rds_instances") != m.end() && !m["rds_instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["rds_instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["rds_instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rdsInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("scaling_policy") != m.end() && !m["scaling_policy"].empty()) {
      scalingPolicy = make_shared<string>(boost::any_cast<string>(m["scaling_policy"]));
    }
    if (m.find("security_group_ids") != m.end() && !m["security_group_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["security_group_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["security_group_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("spot_instance_pools") != m.end() && !m["spot_instance_pools"].empty()) {
      spotInstancePools = make_shared<long>(boost::any_cast<long>(m["spot_instance_pools"]));
    }
    if (m.find("spot_instance_remedy") != m.end() && !m["spot_instance_remedy"].empty()) {
      spotInstanceRemedy = make_shared<bool>(boost::any_cast<bool>(m["spot_instance_remedy"]));
    }
    if (m.find("spot_price_limit") != m.end() && !m["spot_price_limit"].empty()) {
      if (typeid(vector<boost::any>) == m["spot_price_limit"].type()) {
        vector<ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["spot_price_limit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimit = make_shared<vector<ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit>>(expect1);
      }
    }
    if (m.find("spot_strategy") != m.end() && !m["spot_strategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["spot_strategy"]));
    }
    if (m.find("system_disk_bursting_enabled") != m.end() && !m["system_disk_bursting_enabled"].empty()) {
      systemDiskBurstingEnabled = make_shared<bool>(boost::any_cast<bool>(m["system_disk_bursting_enabled"]));
    }
    if (m.find("system_disk_categories") != m.end() && !m["system_disk_categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["system_disk_categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["system_disk_categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskCategories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("system_disk_category") != m.end() && !m["system_disk_category"].empty()) {
      systemDiskCategory = make_shared<string>(boost::any_cast<string>(m["system_disk_category"]));
    }
    if (m.find("system_disk_encrypt_algorithm") != m.end() && !m["system_disk_encrypt_algorithm"].empty()) {
      systemDiskEncryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["system_disk_encrypt_algorithm"]));
    }
    if (m.find("system_disk_encrypted") != m.end() && !m["system_disk_encrypted"].empty()) {
      systemDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["system_disk_encrypted"]));
    }
    if (m.find("system_disk_kms_key_id") != m.end() && !m["system_disk_kms_key_id"].empty()) {
      systemDiskKmsKeyId = make_shared<string>(boost::any_cast<string>(m["system_disk_kms_key_id"]));
    }
    if (m.find("system_disk_performance_level") != m.end() && !m["system_disk_performance_level"].empty()) {
      systemDiskPerformanceLevel = make_shared<string>(boost::any_cast<string>(m["system_disk_performance_level"]));
    }
    if (m.find("system_disk_provisioned_iops") != m.end() && !m["system_disk_provisioned_iops"].empty()) {
      systemDiskProvisionedIops = make_shared<long>(boost::any_cast<long>(m["system_disk_provisioned_iops"]));
    }
    if (m.find("system_disk_size") != m.end() && !m["system_disk_size"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["system_disk_size"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyClusterNodePoolRequestScalingGroup() = default;
};
class ModifyClusterNodePoolRequestTeeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> teeEnable{};

  ModifyClusterNodePoolRequestTeeConfig() {}

  explicit ModifyClusterNodePoolRequestTeeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (teeEnable) {
      res["tee_enable"] = boost::any(*teeEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tee_enable") != m.end() && !m["tee_enable"].empty()) {
      teeEnable = make_shared<bool>(boost::any_cast<bool>(m["tee_enable"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequestTeeConfig() = default;
};
class ModifyClusterNodePoolRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyClusterNodePoolRequestAutoScaling> autoScaling{};
  shared_ptr<bool> concurrency{};
  shared_ptr<ModifyClusterNodePoolRequestKubernetesConfig> kubernetesConfig{};
  shared_ptr<ModifyClusterNodePoolRequestManagement> management{};
  shared_ptr<ModifyClusterNodePoolRequestNodepoolInfo> nodepoolInfo{};
  shared_ptr<ModifyClusterNodePoolRequestScalingGroup> scalingGroup{};
  shared_ptr<ModifyClusterNodePoolRequestTeeConfig> teeConfig{};
  shared_ptr<bool> updateNodes{};

  ModifyClusterNodePoolRequest() {}

  explicit ModifyClusterNodePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoScaling) {
      res["auto_scaling"] = autoScaling ? boost::any(autoScaling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (concurrency) {
      res["concurrency"] = boost::any(*concurrency);
    }
    if (kubernetesConfig) {
      res["kubernetes_config"] = kubernetesConfig ? boost::any(kubernetesConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (management) {
      res["management"] = management ? boost::any(management->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodepoolInfo) {
      res["nodepool_info"] = nodepoolInfo ? boost::any(nodepoolInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scalingGroup) {
      res["scaling_group"] = scalingGroup ? boost::any(scalingGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (teeConfig) {
      res["tee_config"] = teeConfig ? boost::any(teeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateNodes) {
      res["update_nodes"] = boost::any(*updateNodes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_scaling") != m.end() && !m["auto_scaling"].empty()) {
      if (typeid(map<string, boost::any>) == m["auto_scaling"].type()) {
        ModifyClusterNodePoolRequestAutoScaling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["auto_scaling"]));
        autoScaling = make_shared<ModifyClusterNodePoolRequestAutoScaling>(model1);
      }
    }
    if (m.find("concurrency") != m.end() && !m["concurrency"].empty()) {
      concurrency = make_shared<bool>(boost::any_cast<bool>(m["concurrency"]));
    }
    if (m.find("kubernetes_config") != m.end() && !m["kubernetes_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["kubernetes_config"].type()) {
        ModifyClusterNodePoolRequestKubernetesConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kubernetes_config"]));
        kubernetesConfig = make_shared<ModifyClusterNodePoolRequestKubernetesConfig>(model1);
      }
    }
    if (m.find("management") != m.end() && !m["management"].empty()) {
      if (typeid(map<string, boost::any>) == m["management"].type()) {
        ModifyClusterNodePoolRequestManagement model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["management"]));
        management = make_shared<ModifyClusterNodePoolRequestManagement>(model1);
      }
    }
    if (m.find("nodepool_info") != m.end() && !m["nodepool_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodepool_info"].type()) {
        ModifyClusterNodePoolRequestNodepoolInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodepool_info"]));
        nodepoolInfo = make_shared<ModifyClusterNodePoolRequestNodepoolInfo>(model1);
      }
    }
    if (m.find("scaling_group") != m.end() && !m["scaling_group"].empty()) {
      if (typeid(map<string, boost::any>) == m["scaling_group"].type()) {
        ModifyClusterNodePoolRequestScalingGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["scaling_group"]));
        scalingGroup = make_shared<ModifyClusterNodePoolRequestScalingGroup>(model1);
      }
    }
    if (m.find("tee_config") != m.end() && !m["tee_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["tee_config"].type()) {
        ModifyClusterNodePoolRequestTeeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tee_config"]));
        teeConfig = make_shared<ModifyClusterNodePoolRequestTeeConfig>(model1);
      }
    }
    if (m.find("update_nodes") != m.end() && !m["update_nodes"].empty()) {
      updateNodes = make_shared<bool>(boost::any_cast<bool>(m["update_nodes"]));
    }
  }


  virtual ~ModifyClusterNodePoolRequest() = default;
};
class ModifyClusterNodePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  ModifyClusterNodePoolResponseBody() {}

  explicit ModifyClusterNodePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~ModifyClusterNodePoolResponseBody() = default;
};
class ModifyClusterNodePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyClusterNodePoolResponseBody> body{};

  ModifyClusterNodePoolResponse() {}

  explicit ModifyClusterNodePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClusterNodePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClusterNodePoolResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClusterNodePoolResponse() = default;
};
class ModifyClusterTagsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<Tag>> body{};

  ModifyClusterTagsRequest() {}

  explicit ModifyClusterTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~ModifyClusterTagsRequest() = default;
};
class ModifyClusterTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  ModifyClusterTagsResponse() {}

  explicit ModifyClusterTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~ModifyClusterTagsResponse() = default;
};
class ModifyNodePoolNodeConfigRequestOsConfig : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> sysctl{};

  ModifyNodePoolNodeConfigRequestOsConfig() {}

  explicit ModifyNodePoolNodeConfigRequestOsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sysctl) {
      res["sysctl"] = boost::any(*sysctl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("sysctl") != m.end() && !m["sysctl"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["sysctl"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      sysctl = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ModifyNodePoolNodeConfigRequestOsConfig() = default;
};
class ModifyNodePoolNodeConfigRequestRollingPolicy : public Darabonba::Model {
public:
  shared_ptr<long> maxParallelism{};

  ModifyNodePoolNodeConfigRequestRollingPolicy() {}

  explicit ModifyNodePoolNodeConfigRequestRollingPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxParallelism) {
      res["max_parallelism"] = boost::any(*maxParallelism);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("max_parallelism") != m.end() && !m["max_parallelism"].empty()) {
      maxParallelism = make_shared<long>(boost::any_cast<long>(m["max_parallelism"]));
    }
  }


  virtual ~ModifyNodePoolNodeConfigRequestRollingPolicy() = default;
};
class ModifyNodePoolNodeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<ContainerdConfig> containerdConfig{};
  shared_ptr<KubeletConfig> kubeletConfig{};
  shared_ptr<ModifyNodePoolNodeConfigRequestOsConfig> osConfig{};
  shared_ptr<ModifyNodePoolNodeConfigRequestRollingPolicy> rollingPolicy{};

  ModifyNodePoolNodeConfigRequest() {}

  explicit ModifyNodePoolNodeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerdConfig) {
      res["containerd_config"] = containerdConfig ? boost::any(containerdConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (kubeletConfig) {
      res["kubelet_config"] = kubeletConfig ? boost::any(kubeletConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (osConfig) {
      res["os_config"] = osConfig ? boost::any(osConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rollingPolicy) {
      res["rolling_policy"] = rollingPolicy ? boost::any(rollingPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("containerd_config") != m.end() && !m["containerd_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["containerd_config"].type()) {
        ContainerdConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["containerd_config"]));
        containerdConfig = make_shared<ContainerdConfig>(model1);
      }
    }
    if (m.find("kubelet_config") != m.end() && !m["kubelet_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["kubelet_config"].type()) {
        KubeletConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kubelet_config"]));
        kubeletConfig = make_shared<KubeletConfig>(model1);
      }
    }
    if (m.find("os_config") != m.end() && !m["os_config"].empty()) {
      if (typeid(map<string, boost::any>) == m["os_config"].type()) {
        ModifyNodePoolNodeConfigRequestOsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["os_config"]));
        osConfig = make_shared<ModifyNodePoolNodeConfigRequestOsConfig>(model1);
      }
    }
    if (m.find("rolling_policy") != m.end() && !m["rolling_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["rolling_policy"].type()) {
        ModifyNodePoolNodeConfigRequestRollingPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["rolling_policy"]));
        rollingPolicy = make_shared<ModifyNodePoolNodeConfigRequestRollingPolicy>(model1);
      }
    }
  }


  virtual ~ModifyNodePoolNodeConfigRequest() = default;
};
class ModifyNodePoolNodeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nodepoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  ModifyNodePoolNodeConfigResponseBody() {}

  explicit ModifyNodePoolNodeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodepoolId) {
      res["nodepool_id"] = boost::any(*nodepoolId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nodepool_id") != m.end() && !m["nodepool_id"].empty()) {
      nodepoolId = make_shared<string>(boost::any_cast<string>(m["nodepool_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~ModifyNodePoolNodeConfigResponseBody() = default;
};
class ModifyNodePoolNodeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNodePoolNodeConfigResponseBody> body{};

  ModifyNodePoolNodeConfigResponse() {}

  explicit ModifyNodePoolNodeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNodePoolNodeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNodePoolNodeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNodePoolNodeConfigResponse() = default;
};
class ModifyPolicyInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> instanceName{};
  shared_ptr<vector<string>> namespaces{};
  shared_ptr<map<string, boost::any>> parameters{};

  ModifyPolicyInstanceRequest() {}

  explicit ModifyPolicyInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (instanceName) {
      res["instance_name"] = boost::any(*instanceName);
    }
    if (namespaces) {
      res["namespaces"] = boost::any(*namespaces);
    }
    if (parameters) {
      res["parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("instance_name") != m.end() && !m["instance_name"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["instance_name"]));
    }
    if (m.find("namespaces") != m.end() && !m["namespaces"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["namespaces"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["namespaces"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      namespaces = make_shared<vector<string>>(toVec1);
    }
    if (m.find("parameters") != m.end() && !m["parameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["parameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      parameters = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ModifyPolicyInstanceRequest() = default;
};
class ModifyPolicyInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instances{};

  ModifyPolicyInstanceResponseBody() {}

  explicit ModifyPolicyInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["instances"] = boost::any(*instances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instances") != m.end() && !m["instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instances = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyPolicyInstanceResponseBody() = default;
};
class ModifyPolicyInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPolicyInstanceResponseBody> body{};

  ModifyPolicyInstanceResponse() {}

  explicit ModifyPolicyInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPolicyInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPolicyInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPolicyInstanceResponse() = default;
};
class OpenAckServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  OpenAckServiceRequest() {}

  explicit OpenAckServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~OpenAckServiceRequest() = default;
};
class OpenAckServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  OpenAckServiceResponseBody() {}

  explicit OpenAckServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
  }


  virtual ~OpenAckServiceResponseBody() = default;
};
class OpenAckServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenAckServiceResponseBody> body{};

  OpenAckServiceResponse() {}

  explicit OpenAckServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenAckServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenAckServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenAckServiceResponse() = default;
};
class PauseClusterUpgradeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  PauseClusterUpgradeResponse() {}

  explicit PauseClusterUpgradeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~PauseClusterUpgradeResponse() = default;
};
class PauseComponentUpgradeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  PauseComponentUpgradeResponse() {}

  explicit PauseComponentUpgradeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~PauseComponentUpgradeResponse() = default;
};
class PauseTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  PauseTaskResponse() {}

  explicit PauseTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~PauseTaskResponse() = default;
};
class RemoveClusterNodesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> drainNode{};
  shared_ptr<vector<string>> nodes{};
  shared_ptr<bool> releaseNode{};

  RemoveClusterNodesRequest() {}

  explicit RemoveClusterNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (drainNode) {
      res["drain_node"] = boost::any(*drainNode);
    }
    if (nodes) {
      res["nodes"] = boost::any(*nodes);
    }
    if (releaseNode) {
      res["release_node"] = boost::any(*releaseNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("drain_node") != m.end() && !m["drain_node"].empty()) {
      drainNode = make_shared<bool>(boost::any_cast<bool>(m["drain_node"]));
    }
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("release_node") != m.end() && !m["release_node"].empty()) {
      releaseNode = make_shared<bool>(boost::any_cast<bool>(m["release_node"]));
    }
  }


  virtual ~RemoveClusterNodesRequest() = default;
};
class RemoveClusterNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  RemoveClusterNodesResponse() {}

  explicit RemoveClusterNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~RemoveClusterNodesResponse() = default;
};
class RemoveNodePoolNodesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> concurrency{};
  shared_ptr<bool> drainNode{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<vector<string>> nodes{};
  shared_ptr<bool> releaseNode{};

  RemoveNodePoolNodesRequest() {}

  explicit RemoveNodePoolNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrency) {
      res["concurrency"] = boost::any(*concurrency);
    }
    if (drainNode) {
      res["drain_node"] = boost::any(*drainNode);
    }
    if (instanceIds) {
      res["instance_ids"] = boost::any(*instanceIds);
    }
    if (nodes) {
      res["nodes"] = boost::any(*nodes);
    }
    if (releaseNode) {
      res["release_node"] = boost::any(*releaseNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("concurrency") != m.end() && !m["concurrency"].empty()) {
      concurrency = make_shared<bool>(boost::any_cast<bool>(m["concurrency"]));
    }
    if (m.find("drain_node") != m.end() && !m["drain_node"].empty()) {
      drainNode = make_shared<bool>(boost::any_cast<bool>(m["drain_node"]));
    }
    if (m.find("instance_ids") != m.end() && !m["instance_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instance_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instance_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("release_node") != m.end() && !m["release_node"].empty()) {
      releaseNode = make_shared<bool>(boost::any_cast<bool>(m["release_node"]));
    }
  }


  virtual ~RemoveNodePoolNodesRequest() = default;
};
class RemoveNodePoolNodesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> concurrency{};
  shared_ptr<bool> drainNode{};
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> nodesShrink{};
  shared_ptr<bool> releaseNode{};

  RemoveNodePoolNodesShrinkRequest() {}

  explicit RemoveNodePoolNodesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrency) {
      res["concurrency"] = boost::any(*concurrency);
    }
    if (drainNode) {
      res["drain_node"] = boost::any(*drainNode);
    }
    if (instanceIdsShrink) {
      res["instance_ids"] = boost::any(*instanceIdsShrink);
    }
    if (nodesShrink) {
      res["nodes"] = boost::any(*nodesShrink);
    }
    if (releaseNode) {
      res["release_node"] = boost::any(*releaseNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("concurrency") != m.end() && !m["concurrency"].empty()) {
      concurrency = make_shared<bool>(boost::any_cast<bool>(m["concurrency"]));
    }
    if (m.find("drain_node") != m.end() && !m["drain_node"].empty()) {
      drainNode = make_shared<bool>(boost::any_cast<bool>(m["drain_node"]));
    }
    if (m.find("instance_ids") != m.end() && !m["instance_ids"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["instance_ids"]));
    }
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      nodesShrink = make_shared<string>(boost::any_cast<string>(m["nodes"]));
    }
    if (m.find("release_node") != m.end() && !m["release_node"].empty()) {
      releaseNode = make_shared<bool>(boost::any_cast<bool>(m["release_node"]));
    }
  }


  virtual ~RemoveNodePoolNodesShrinkRequest() = default;
};
class RemoveNodePoolNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  RemoveNodePoolNodesResponseBody() {}

  explicit RemoveNodePoolNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~RemoveNodePoolNodesResponseBody() = default;
};
class RemoveNodePoolNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveNodePoolNodesResponseBody> body{};

  RemoveNodePoolNodesResponse() {}

  explicit RemoveNodePoolNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveNodePoolNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveNodePoolNodesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveNodePoolNodesResponse() = default;
};
class RepairClusterNodePoolRequestOperations : public Darabonba::Model {
public:
  shared_ptr<vector<string>> args{};
  shared_ptr<string> operationId{};

  RepairClusterNodePoolRequestOperations() {}

  explicit RepairClusterNodePoolRequestOperations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["args"] = boost::any(*args);
    }
    if (operationId) {
      res["operation_id"] = boost::any(*operationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("args") != m.end() && !m["args"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["args"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["args"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      args = make_shared<vector<string>>(toVec1);
    }
    if (m.find("operation_id") != m.end() && !m["operation_id"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["operation_id"]));
    }
  }


  virtual ~RepairClusterNodePoolRequestOperations() = default;
};
class RepairClusterNodePoolRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRestart{};
  shared_ptr<vector<string>> nodes{};
  shared_ptr<vector<RepairClusterNodePoolRequestOperations>> operations{};

  RepairClusterNodePoolRequest() {}

  explicit RepairClusterNodePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRestart) {
      res["auto_restart"] = boost::any(*autoRestart);
    }
    if (nodes) {
      res["nodes"] = boost::any(*nodes);
    }
    if (operations) {
      vector<boost::any> temp1;
      for(auto item1:*operations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["operations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_restart") != m.end() && !m["auto_restart"].empty()) {
      autoRestart = make_shared<bool>(boost::any_cast<bool>(m["auto_restart"]));
    }
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("operations") != m.end() && !m["operations"].empty()) {
      if (typeid(vector<boost::any>) == m["operations"].type()) {
        vector<RepairClusterNodePoolRequestOperations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["operations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RepairClusterNodePoolRequestOperations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operations = make_shared<vector<RepairClusterNodePoolRequestOperations>>(expect1);
      }
    }
  }


  virtual ~RepairClusterNodePoolRequest() = default;
};
class RepairClusterNodePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  RepairClusterNodePoolResponseBody() {}

  explicit RepairClusterNodePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~RepairClusterNodePoolResponseBody() = default;
};
class RepairClusterNodePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RepairClusterNodePoolResponseBody> body{};

  RepairClusterNodePoolResponse() {}

  explicit RepairClusterNodePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RepairClusterNodePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RepairClusterNodePoolResponseBody>(model1);
      }
    }
  }


  virtual ~RepairClusterNodePoolResponse() = default;
};
class ResumeComponentUpgradeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  ResumeComponentUpgradeResponse() {}

  explicit ResumeComponentUpgradeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~ResumeComponentUpgradeResponse() = default;
};
class ResumeTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  ResumeTaskResponse() {}

  explicit ResumeTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~ResumeTaskResponse() = default;
};
class ResumeUpgradeClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  ResumeUpgradeClusterResponse() {}

  explicit ResumeUpgradeClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~ResumeUpgradeClusterResponse() = default;
};
class RevokeK8sClusterKubeConfigResponseBody : public Darabonba::Model {
public:

  RevokeK8sClusterKubeConfigResponseBody() {}

  explicit RevokeK8sClusterKubeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
  }


  virtual ~RevokeK8sClusterKubeConfigResponseBody() = default;
};
class RevokeK8sClusterKubeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeK8sClusterKubeConfigResponseBody> body{};

  RevokeK8sClusterKubeConfigResponse() {}

  explicit RevokeK8sClusterKubeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeK8sClusterKubeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeK8sClusterKubeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeK8sClusterKubeConfigResponse() = default;
};
class RunClusterCheckRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> options{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  RunClusterCheckRequest() {}

  explicit RunClusterCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (options) {
      res["options"] = boost::any(*options);
    }
    if (target) {
      res["target"] = boost::any(*target);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("options") != m.end() && !m["options"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["options"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      options = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("target") != m.end() && !m["target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["target"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~RunClusterCheckRequest() = default;
};
class RunClusterCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> checkId{};
  shared_ptr<string> requestId{};

  RunClusterCheckResponseBody() {}

  explicit RunClusterCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["check_id"] = boost::any(*checkId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_id") != m.end() && !m["check_id"].empty()) {
      checkId = make_shared<string>(boost::any_cast<string>(m["check_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
  }


  virtual ~RunClusterCheckResponseBody() = default;
};
class RunClusterCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunClusterCheckResponseBody> body{};

  RunClusterCheckResponse() {}

  explicit RunClusterCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunClusterCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunClusterCheckResponseBody>(model1);
      }
    }
  }


  virtual ~RunClusterCheckResponse() = default;
};
class RunClusterInspectRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  RunClusterInspectRequest() {}

  explicit RunClusterInspectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~RunClusterInspectRequest() = default;
};
class RunClusterInspectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  RunClusterInspectResponseBody() {}

  explicit RunClusterInspectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["reportId"] = boost::any(*reportId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reportId") != m.end() && !m["reportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["reportId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~RunClusterInspectResponseBody() = default;
};
class RunClusterInspectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunClusterInspectResponseBody> body{};

  RunClusterInspectResponse() {}

  explicit RunClusterInspectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunClusterInspectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunClusterInspectResponseBody>(model1);
      }
    }
  }


  virtual ~RunClusterInspectResponse() = default;
};
class ScaleClusterRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};

  ScaleClusterRequestTags() {}

  explicit ScaleClusterRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
  }


  virtual ~ScaleClusterRequestTags() = default;
};
class ScaleClusterRequestTaints : public Darabonba::Model {
public:
  shared_ptr<string> effect{};
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ScaleClusterRequestTaints() {}

  explicit ScaleClusterRequestTaints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      res["effect"] = boost::any(*effect);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("effect") != m.end() && !m["effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["effect"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ScaleClusterRequestTaints() = default;
};
class ScaleClusterRequestWorkerDataDisks : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> size{};

  ScaleClusterRequestWorkerDataDisks() {}

  explicit ScaleClusterRequestWorkerDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (encrypted) {
      res["encrypted"] = boost::any(*encrypted);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("encrypted") != m.end() && !m["encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["encrypted"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["size"]));
    }
  }


  virtual ~ScaleClusterRequestWorkerDataDisks() = default;
};
class ScaleClusterRequest : public Darabonba::Model {
public:
  shared_ptr<bool> cloudMonitorFlags{};
  shared_ptr<long> count{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<bool> disableRollback{};
  shared_ptr<string> keyPair{};
  shared_ptr<string> loginPassword{};
  shared_ptr<vector<ScaleClusterRequestTags>> tags{};
  shared_ptr<vector<ScaleClusterRequestTaints>> taints{};
  shared_ptr<vector<string>> vswitchIds{};
  shared_ptr<bool> workerAutoRenew{};
  shared_ptr<long> workerAutoRenewPeriod{};
  shared_ptr<bool> workerDataDisk{};
  shared_ptr<vector<ScaleClusterRequestWorkerDataDisks>> workerDataDisks{};
  shared_ptr<string> workerInstanceChargeType{};
  shared_ptr<vector<string>> workerInstanceTypes{};
  shared_ptr<long> workerPeriod{};
  shared_ptr<string> workerPeriodUnit{};
  shared_ptr<string> workerSystemDiskCategory{};
  shared_ptr<long> workerSystemDiskSize{};

  ScaleClusterRequest() {}

  explicit ScaleClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudMonitorFlags) {
      res["cloud_monitor_flags"] = boost::any(*cloudMonitorFlags);
    }
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (disableRollback) {
      res["disable_rollback"] = boost::any(*disableRollback);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (loginPassword) {
      res["login_password"] = boost::any(*loginPassword);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (taints) {
      vector<boost::any> temp1;
      for(auto item1:*taints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["taints"] = boost::any(temp1);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    if (workerAutoRenew) {
      res["worker_auto_renew"] = boost::any(*workerAutoRenew);
    }
    if (workerAutoRenewPeriod) {
      res["worker_auto_renew_period"] = boost::any(*workerAutoRenewPeriod);
    }
    if (workerDataDisk) {
      res["worker_data_disk"] = boost::any(*workerDataDisk);
    }
    if (workerDataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*workerDataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["worker_data_disks"] = boost::any(temp1);
    }
    if (workerInstanceChargeType) {
      res["worker_instance_charge_type"] = boost::any(*workerInstanceChargeType);
    }
    if (workerInstanceTypes) {
      res["worker_instance_types"] = boost::any(*workerInstanceTypes);
    }
    if (workerPeriod) {
      res["worker_period"] = boost::any(*workerPeriod);
    }
    if (workerPeriodUnit) {
      res["worker_period_unit"] = boost::any(*workerPeriodUnit);
    }
    if (workerSystemDiskCategory) {
      res["worker_system_disk_category"] = boost::any(*workerSystemDiskCategory);
    }
    if (workerSystemDiskSize) {
      res["worker_system_disk_size"] = boost::any(*workerSystemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cloud_monitor_flags") != m.end() && !m["cloud_monitor_flags"].empty()) {
      cloudMonitorFlags = make_shared<bool>(boost::any_cast<bool>(m["cloud_monitor_flags"]));
    }
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("disable_rollback") != m.end() && !m["disable_rollback"].empty()) {
      disableRollback = make_shared<bool>(boost::any_cast<bool>(m["disable_rollback"]));
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("login_password") != m.end() && !m["login_password"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["login_password"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<ScaleClusterRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScaleClusterRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ScaleClusterRequestTags>>(expect1);
      }
    }
    if (m.find("taints") != m.end() && !m["taints"].empty()) {
      if (typeid(vector<boost::any>) == m["taints"].type()) {
        vector<ScaleClusterRequestTaints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["taints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScaleClusterRequestTaints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taints = make_shared<vector<ScaleClusterRequestTaints>>(expect1);
      }
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("worker_auto_renew") != m.end() && !m["worker_auto_renew"].empty()) {
      workerAutoRenew = make_shared<bool>(boost::any_cast<bool>(m["worker_auto_renew"]));
    }
    if (m.find("worker_auto_renew_period") != m.end() && !m["worker_auto_renew_period"].empty()) {
      workerAutoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["worker_auto_renew_period"]));
    }
    if (m.find("worker_data_disk") != m.end() && !m["worker_data_disk"].empty()) {
      workerDataDisk = make_shared<bool>(boost::any_cast<bool>(m["worker_data_disk"]));
    }
    if (m.find("worker_data_disks") != m.end() && !m["worker_data_disks"].empty()) {
      if (typeid(vector<boost::any>) == m["worker_data_disks"].type()) {
        vector<ScaleClusterRequestWorkerDataDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["worker_data_disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScaleClusterRequestWorkerDataDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workerDataDisks = make_shared<vector<ScaleClusterRequestWorkerDataDisks>>(expect1);
      }
    }
    if (m.find("worker_instance_charge_type") != m.end() && !m["worker_instance_charge_type"].empty()) {
      workerInstanceChargeType = make_shared<string>(boost::any_cast<string>(m["worker_instance_charge_type"]));
    }
    if (m.find("worker_instance_types") != m.end() && !m["worker_instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["worker_instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["worker_instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workerInstanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("worker_period") != m.end() && !m["worker_period"].empty()) {
      workerPeriod = make_shared<long>(boost::any_cast<long>(m["worker_period"]));
    }
    if (m.find("worker_period_unit") != m.end() && !m["worker_period_unit"].empty()) {
      workerPeriodUnit = make_shared<string>(boost::any_cast<string>(m["worker_period_unit"]));
    }
    if (m.find("worker_system_disk_category") != m.end() && !m["worker_system_disk_category"].empty()) {
      workerSystemDiskCategory = make_shared<string>(boost::any_cast<string>(m["worker_system_disk_category"]));
    }
    if (m.find("worker_system_disk_size") != m.end() && !m["worker_system_disk_size"].empty()) {
      workerSystemDiskSize = make_shared<long>(boost::any_cast<long>(m["worker_system_disk_size"]));
    }
  }


  virtual ~ScaleClusterRequest() = default;
};
class ScaleClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  ScaleClusterResponseBody() {}

  explicit ScaleClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~ScaleClusterResponseBody() = default;
};
class ScaleClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ScaleClusterResponseBody> body{};

  ScaleClusterResponse() {}

  explicit ScaleClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleClusterResponse() = default;
};
class ScaleClusterNodePoolRequest : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  ScaleClusterNodePoolRequest() {}

  explicit ScaleClusterNodePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
  }


  virtual ~ScaleClusterNodePoolRequest() = default;
};
class ScaleClusterNodePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  ScaleClusterNodePoolResponseBody() {}

  explicit ScaleClusterNodePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~ScaleClusterNodePoolResponseBody() = default;
};
class ScaleClusterNodePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ScaleClusterNodePoolResponseBody> body{};

  ScaleClusterNodePoolResponse() {}

  explicit ScaleClusterNodePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleClusterNodePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleClusterNodePoolResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleClusterNodePoolResponse() = default;
};
class ScaleOutClusterRequestWorkerDataDisks : public Darabonba::Model {
public:
  shared_ptr<string> autoSnapshotPolicyId{};
  shared_ptr<string> category{};
  shared_ptr<string> encrypted{};
  shared_ptr<string> size{};

  ScaleOutClusterRequestWorkerDataDisks() {}

  explicit ScaleOutClusterRequestWorkerDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSnapshotPolicyId) {
      res["auto_snapshot_policy_id"] = boost::any(*autoSnapshotPolicyId);
    }
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (encrypted) {
      res["encrypted"] = boost::any(*encrypted);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("auto_snapshot_policy_id") != m.end() && !m["auto_snapshot_policy_id"].empty()) {
      autoSnapshotPolicyId = make_shared<string>(boost::any_cast<string>(m["auto_snapshot_policy_id"]));
    }
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("encrypted") != m.end() && !m["encrypted"].empty()) {
      encrypted = make_shared<string>(boost::any_cast<string>(m["encrypted"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["size"]));
    }
  }


  virtual ~ScaleOutClusterRequestWorkerDataDisks() = default;
};
class ScaleOutClusterRequest : public Darabonba::Model {
public:
  shared_ptr<bool> cloudMonitorFlags{};
  shared_ptr<long> count{};
  shared_ptr<string> cpuPolicy{};
  shared_ptr<string> imageId{};
  shared_ptr<string> keyPair{};
  shared_ptr<string> loginPassword{};
  shared_ptr<vector<string>> rdsInstances{};
  shared_ptr<Runtime> runtime{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<vector<Taint>> taints{};
  shared_ptr<string> userData{};
  shared_ptr<vector<string>> vswitchIds{};
  shared_ptr<bool> workerAutoRenew{};
  shared_ptr<long> workerAutoRenewPeriod{};
  shared_ptr<vector<ScaleOutClusterRequestWorkerDataDisks>> workerDataDisks{};
  shared_ptr<string> workerInstanceChargeType{};
  shared_ptr<vector<string>> workerInstanceTypes{};
  shared_ptr<long> workerPeriod{};
  shared_ptr<string> workerPeriodUnit{};
  shared_ptr<string> workerSystemDiskCategory{};
  shared_ptr<long> workerSystemDiskSize{};

  ScaleOutClusterRequest() {}

  explicit ScaleOutClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudMonitorFlags) {
      res["cloud_monitor_flags"] = boost::any(*cloudMonitorFlags);
    }
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (cpuPolicy) {
      res["cpu_policy"] = boost::any(*cpuPolicy);
    }
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (keyPair) {
      res["key_pair"] = boost::any(*keyPair);
    }
    if (loginPassword) {
      res["login_password"] = boost::any(*loginPassword);
    }
    if (rdsInstances) {
      res["rds_instances"] = boost::any(*rdsInstances);
    }
    if (runtime) {
      res["runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (taints) {
      vector<boost::any> temp1;
      for(auto item1:*taints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["taints"] = boost::any(temp1);
    }
    if (userData) {
      res["user_data"] = boost::any(*userData);
    }
    if (vswitchIds) {
      res["vswitch_ids"] = boost::any(*vswitchIds);
    }
    if (workerAutoRenew) {
      res["worker_auto_renew"] = boost::any(*workerAutoRenew);
    }
    if (workerAutoRenewPeriod) {
      res["worker_auto_renew_period"] = boost::any(*workerAutoRenewPeriod);
    }
    if (workerDataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*workerDataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["worker_data_disks"] = boost::any(temp1);
    }
    if (workerInstanceChargeType) {
      res["worker_instance_charge_type"] = boost::any(*workerInstanceChargeType);
    }
    if (workerInstanceTypes) {
      res["worker_instance_types"] = boost::any(*workerInstanceTypes);
    }
    if (workerPeriod) {
      res["worker_period"] = boost::any(*workerPeriod);
    }
    if (workerPeriodUnit) {
      res["worker_period_unit"] = boost::any(*workerPeriodUnit);
    }
    if (workerSystemDiskCategory) {
      res["worker_system_disk_category"] = boost::any(*workerSystemDiskCategory);
    }
    if (workerSystemDiskSize) {
      res["worker_system_disk_size"] = boost::any(*workerSystemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cloud_monitor_flags") != m.end() && !m["cloud_monitor_flags"].empty()) {
      cloudMonitorFlags = make_shared<bool>(boost::any_cast<bool>(m["cloud_monitor_flags"]));
    }
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("cpu_policy") != m.end() && !m["cpu_policy"].empty()) {
      cpuPolicy = make_shared<string>(boost::any_cast<string>(m["cpu_policy"]));
    }
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("key_pair") != m.end() && !m["key_pair"].empty()) {
      keyPair = make_shared<string>(boost::any_cast<string>(m["key_pair"]));
    }
    if (m.find("login_password") != m.end() && !m["login_password"].empty()) {
      loginPassword = make_shared<string>(boost::any_cast<string>(m["login_password"]));
    }
    if (m.find("rds_instances") != m.end() && !m["rds_instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["rds_instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["rds_instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rdsInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("runtime") != m.end() && !m["runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["runtime"].type()) {
        Runtime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["runtime"]));
        runtime = make_shared<Runtime>(model1);
      }
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("taints") != m.end() && !m["taints"].empty()) {
      if (typeid(vector<boost::any>) == m["taints"].type()) {
        vector<Taint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["taints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Taint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taints = make_shared<vector<Taint>>(expect1);
      }
    }
    if (m.find("user_data") != m.end() && !m["user_data"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["user_data"]));
    }
    if (m.find("vswitch_ids") != m.end() && !m["vswitch_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vswitch_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vswitch_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vswitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("worker_auto_renew") != m.end() && !m["worker_auto_renew"].empty()) {
      workerAutoRenew = make_shared<bool>(boost::any_cast<bool>(m["worker_auto_renew"]));
    }
    if (m.find("worker_auto_renew_period") != m.end() && !m["worker_auto_renew_period"].empty()) {
      workerAutoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["worker_auto_renew_period"]));
    }
    if (m.find("worker_data_disks") != m.end() && !m["worker_data_disks"].empty()) {
      if (typeid(vector<boost::any>) == m["worker_data_disks"].type()) {
        vector<ScaleOutClusterRequestWorkerDataDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["worker_data_disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScaleOutClusterRequestWorkerDataDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workerDataDisks = make_shared<vector<ScaleOutClusterRequestWorkerDataDisks>>(expect1);
      }
    }
    if (m.find("worker_instance_charge_type") != m.end() && !m["worker_instance_charge_type"].empty()) {
      workerInstanceChargeType = make_shared<string>(boost::any_cast<string>(m["worker_instance_charge_type"]));
    }
    if (m.find("worker_instance_types") != m.end() && !m["worker_instance_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["worker_instance_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["worker_instance_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workerInstanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("worker_period") != m.end() && !m["worker_period"].empty()) {
      workerPeriod = make_shared<long>(boost::any_cast<long>(m["worker_period"]));
    }
    if (m.find("worker_period_unit") != m.end() && !m["worker_period_unit"].empty()) {
      workerPeriodUnit = make_shared<string>(boost::any_cast<string>(m["worker_period_unit"]));
    }
    if (m.find("worker_system_disk_category") != m.end() && !m["worker_system_disk_category"].empty()) {
      workerSystemDiskCategory = make_shared<string>(boost::any_cast<string>(m["worker_system_disk_category"]));
    }
    if (m.find("worker_system_disk_size") != m.end() && !m["worker_system_disk_size"].empty()) {
      workerSystemDiskSize = make_shared<long>(boost::any_cast<long>(m["worker_system_disk_size"]));
    }
  }


  virtual ~ScaleOutClusterRequest() = default;
};
class ScaleOutClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  ScaleOutClusterResponseBody() {}

  explicit ScaleOutClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~ScaleOutClusterResponseBody() = default;
};
class ScaleOutClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ScaleOutClusterResponseBody> body{};

  ScaleOutClusterResponse() {}

  explicit ScaleOutClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScaleOutClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScaleOutClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ScaleOutClusterResponse() = default;
};
class ScanClusterVulsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  ScanClusterVulsResponseBody() {}

  explicit ScanClusterVulsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~ScanClusterVulsResponseBody() = default;
};
class ScanClusterVulsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ScanClusterVulsResponseBody> body{};

  ScanClusterVulsResponse() {}

  explicit ScanClusterVulsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScanClusterVulsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScanClusterVulsResponseBody>(model1);
      }
    }
  }


  virtual ~ScanClusterVulsResponse() = default;
};
class StartAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertRuleGroupName{};
  shared_ptr<string> alertRuleName{};

  StartAlertRequest() {}

  explicit StartAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRuleGroupName) {
      res["alert_rule_group_name"] = boost::any(*alertRuleGroupName);
    }
    if (alertRuleName) {
      res["alert_rule_name"] = boost::any(*alertRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alert_rule_group_name") != m.end() && !m["alert_rule_group_name"].empty()) {
      alertRuleGroupName = make_shared<string>(boost::any_cast<string>(m["alert_rule_group_name"]));
    }
    if (m.find("alert_rule_name") != m.end() && !m["alert_rule_name"].empty()) {
      alertRuleName = make_shared<string>(boost::any_cast<string>(m["alert_rule_name"]));
    }
  }


  virtual ~StartAlertRequest() = default;
};
class StartAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> msg{};
  shared_ptr<bool> status{};

  StartAlertResponseBody() {}

  explicit StartAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["status"]));
    }
  }


  virtual ~StartAlertResponseBody() = default;
};
class StartAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartAlertResponseBody> body{};

  StartAlertResponse() {}

  explicit StartAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartAlertResponseBody>(model1);
      }
    }
  }


  virtual ~StartAlertResponse() = default;
};
class StopAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertRuleGroupName{};
  shared_ptr<string> alertRuleName{};

  StopAlertRequest() {}

  explicit StopAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRuleGroupName) {
      res["alert_rule_group_name"] = boost::any(*alertRuleGroupName);
    }
    if (alertRuleName) {
      res["alert_rule_name"] = boost::any(*alertRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alert_rule_group_name") != m.end() && !m["alert_rule_group_name"].empty()) {
      alertRuleGroupName = make_shared<string>(boost::any_cast<string>(m["alert_rule_group_name"]));
    }
    if (m.find("alert_rule_name") != m.end() && !m["alert_rule_name"].empty()) {
      alertRuleName = make_shared<string>(boost::any_cast<string>(m["alert_rule_name"]));
    }
  }


  virtual ~StopAlertRequest() = default;
};
class StopAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> msg{};
  shared_ptr<bool> status{};

  StopAlertResponseBody() {}

  explicit StopAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["status"]));
    }
  }


  virtual ~StopAlertResponseBody() = default;
};
class StopAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopAlertResponseBody> body{};

  StopAlertResponse() {}

  explicit StopAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopAlertResponseBody>(model1);
      }
    }
  }


  virtual ~StopAlertResponse() = default;
};
class SyncClusterNodePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SyncClusterNodePoolResponseBody() {}

  explicit SyncClusterNodePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SyncClusterNodePoolResponseBody() = default;
};
class SyncClusterNodePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncClusterNodePoolResponseBody> body{};

  SyncClusterNodePoolResponse() {}

  explicit SyncClusterNodePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncClusterNodePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncClusterNodePoolResponseBody>(model1);
      }
    }
  }


  virtual ~SyncClusterNodePoolResponse() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<Tag>> tags{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["resource_ids"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_ids") != m.end() && !m["resource_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["resource_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["resource_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UnInstallClusterAddonsRequestAddons : public Darabonba::Model {
public:
  shared_ptr<bool> cleanupCloudResources{};
  shared_ptr<string> name{};

  UnInstallClusterAddonsRequestAddons() {}

  explicit UnInstallClusterAddonsRequestAddons(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cleanupCloudResources) {
      res["cleanup_cloud_resources"] = boost::any(*cleanupCloudResources);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cleanup_cloud_resources") != m.end() && !m["cleanup_cloud_resources"].empty()) {
      cleanupCloudResources = make_shared<bool>(boost::any_cast<bool>(m["cleanup_cloud_resources"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~UnInstallClusterAddonsRequestAddons() = default;
};
class UnInstallClusterAddonsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UnInstallClusterAddonsRequestAddons>> addons{};

  UnInstallClusterAddonsRequest() {}

  explicit UnInstallClusterAddonsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addons) {
      vector<boost::any> temp1;
      for(auto item1:*addons){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["addons"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("addons") != m.end() && !m["addons"].empty()) {
      if (typeid(vector<boost::any>) == m["addons"].type()) {
        vector<UnInstallClusterAddonsRequestAddons> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["addons"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnInstallClusterAddonsRequestAddons model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addons = make_shared<vector<UnInstallClusterAddonsRequestAddons>>(expect1);
      }
    }
  }


  virtual ~UnInstallClusterAddonsRequest() = default;
};
class UnInstallClusterAddonsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  UnInstallClusterAddonsResponseBody() {}

  explicit UnInstallClusterAddonsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~UnInstallClusterAddonsResponseBody() = default;
};
class UnInstallClusterAddonsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnInstallClusterAddonsResponseBody> body{};

  UnInstallClusterAddonsResponse() {}

  explicit UnInstallClusterAddonsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnInstallClusterAddonsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnInstallClusterAddonsResponseBody>(model1);
      }
    }
  }


  virtual ~UnInstallClusterAddonsResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKeys{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["all"] = boost::any(*all);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["resource_ids"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (tagKeys) {
      res["tag_keys"] = boost::any(*tagKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all") != m.end() && !m["all"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["all"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_ids") != m.end() && !m["resource_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["resource_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["resource_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("tag_keys") != m.end() && !m["tag_keys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tag_keys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tag_keys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceIdsShrink{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKeysShrink{};

  UntagResourcesShrinkRequest() {}

  explicit UntagResourcesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["all"] = boost::any(*all);
    }
    if (regionId) {
      res["region_id"] = boost::any(*regionId);
    }
    if (resourceIdsShrink) {
      res["resource_ids"] = boost::any(*resourceIdsShrink);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (tagKeysShrink) {
      res["tag_keys"] = boost::any(*tagKeysShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all") != m.end() && !m["all"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["all"]));
    }
    if (m.find("region_id") != m.end() && !m["region_id"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["region_id"]));
    }
    if (m.find("resource_ids") != m.end() && !m["resource_ids"].empty()) {
      resourceIdsShrink = make_shared<string>(boost::any_cast<string>(m["resource_ids"]));
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("tag_keys") != m.end() && !m["tag_keys"].empty()) {
      tagKeysShrink = make_shared<string>(boost::any_cast<string>(m["tag_keys"]));
    }
  }


  virtual ~UntagResourcesShrinkRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateClusterAuditLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<bool> disable{};
  shared_ptr<string> slsProjectName{};

  UpdateClusterAuditLogConfigRequest() {}

  explicit UpdateClusterAuditLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disable) {
      res["disable"] = boost::any(*disable);
    }
    if (slsProjectName) {
      res["sls_project_name"] = boost::any(*slsProjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disable") != m.end() && !m["disable"].empty()) {
      disable = make_shared<bool>(boost::any_cast<bool>(m["disable"]));
    }
    if (m.find("sls_project_name") != m.end() && !m["sls_project_name"].empty()) {
      slsProjectName = make_shared<string>(boost::any_cast<string>(m["sls_project_name"]));
    }
  }


  virtual ~UpdateClusterAuditLogConfigRequest() = default;
};
class UpdateClusterAuditLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  UpdateClusterAuditLogConfigResponseBody() {}

  explicit UpdateClusterAuditLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~UpdateClusterAuditLogConfigResponseBody() = default;
};
class UpdateClusterAuditLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateClusterAuditLogConfigResponseBody> body{};

  UpdateClusterAuditLogConfigResponse() {}

  explicit UpdateClusterAuditLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateClusterAuditLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateClusterAuditLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateClusterAuditLogConfigResponse() = default;
};
class UpdateClusterInspectConfigRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> disabledCheckItems{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> scheduleTime{};

  UpdateClusterInspectConfigRequest() {}

  explicit UpdateClusterInspectConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disabledCheckItems) {
      res["disabledCheckItems"] = boost::any(*disabledCheckItems);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (scheduleTime) {
      res["scheduleTime"] = boost::any(*scheduleTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disabledCheckItems") != m.end() && !m["disabledCheckItems"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["disabledCheckItems"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["disabledCheckItems"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      disabledCheckItems = make_shared<vector<string>>(toVec1);
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("scheduleTime") != m.end() && !m["scheduleTime"].empty()) {
      scheduleTime = make_shared<string>(boost::any_cast<string>(m["scheduleTime"]));
    }
  }


  virtual ~UpdateClusterInspectConfigRequest() = default;
};
class UpdateClusterInspectConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateClusterInspectConfigResponseBody() {}

  explicit UpdateClusterInspectConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateClusterInspectConfigResponseBody() = default;
};
class UpdateClusterInspectConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateClusterInspectConfigResponseBody> body{};

  UpdateClusterInspectConfigResponse() {}

  explicit UpdateClusterInspectConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateClusterInspectConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateClusterInspectConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateClusterInspectConfigResponse() = default;
};
class UpdateContactGroupForAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertRuleGroupName{};
  shared_ptr<vector<long>> contactGroupIds{};
  shared_ptr<string> crName{};
  shared_ptr<string> namespace_{};

  UpdateContactGroupForAlertRequest() {}

  explicit UpdateContactGroupForAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRuleGroupName) {
      res["alert_rule_group_name"] = boost::any(*alertRuleGroupName);
    }
    if (contactGroupIds) {
      res["contact_group_ids"] = boost::any(*contactGroupIds);
    }
    if (crName) {
      res["cr_name"] = boost::any(*crName);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alert_rule_group_name") != m.end() && !m["alert_rule_group_name"].empty()) {
      alertRuleGroupName = make_shared<string>(boost::any_cast<string>(m["alert_rule_group_name"]));
    }
    if (m.find("contact_group_ids") != m.end() && !m["contact_group_ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["contact_group_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["contact_group_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      contactGroupIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("cr_name") != m.end() && !m["cr_name"].empty()) {
      crName = make_shared<string>(boost::any_cast<string>(m["cr_name"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
  }


  virtual ~UpdateContactGroupForAlertRequest() = default;
};
class UpdateContactGroupForAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> msg{};
  shared_ptr<bool> status{};

  UpdateContactGroupForAlertResponseBody() {}

  explicit UpdateContactGroupForAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["status"]));
    }
  }


  virtual ~UpdateContactGroupForAlertResponseBody() = default;
};
class UpdateContactGroupForAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateContactGroupForAlertResponseBody> body{};

  UpdateContactGroupForAlertResponse() {}

  explicit UpdateContactGroupForAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateContactGroupForAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateContactGroupForAlertResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateContactGroupForAlertResponse() = default;
};
class UpdateControlPlaneLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliuid{};
  shared_ptr<vector<string>> components{};
  shared_ptr<string> logProject{};
  shared_ptr<string> logTtl{};

  UpdateControlPlaneLogRequest() {}

  explicit UpdateControlPlaneLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliuid) {
      res["aliuid"] = boost::any(*aliuid);
    }
    if (components) {
      res["components"] = boost::any(*components);
    }
    if (logProject) {
      res["log_project"] = boost::any(*logProject);
    }
    if (logTtl) {
      res["log_ttl"] = boost::any(*logTtl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliuid") != m.end() && !m["aliuid"].empty()) {
      aliuid = make_shared<string>(boost::any_cast<string>(m["aliuid"]));
    }
    if (m.find("components") != m.end() && !m["components"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["components"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["components"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      components = make_shared<vector<string>>(toVec1);
    }
    if (m.find("log_project") != m.end() && !m["log_project"].empty()) {
      logProject = make_shared<string>(boost::any_cast<string>(m["log_project"]));
    }
    if (m.find("log_ttl") != m.end() && !m["log_ttl"].empty()) {
      logTtl = make_shared<string>(boost::any_cast<string>(m["log_ttl"]));
    }
  }


  virtual ~UpdateControlPlaneLogRequest() = default;
};
class UpdateControlPlaneLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  UpdateControlPlaneLogResponseBody() {}

  explicit UpdateControlPlaneLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~UpdateControlPlaneLogResponseBody() = default;
};
class UpdateControlPlaneLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateControlPlaneLogResponseBody> body{};

  UpdateControlPlaneLogResponse() {}

  explicit UpdateControlPlaneLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateControlPlaneLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateControlPlaneLogResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateControlPlaneLogResponse() = default;
};
class UpdateK8sClusterUserConfigExpireRequest : public Darabonba::Model {
public:
  shared_ptr<long> expireHour{};
  shared_ptr<string> user{};

  UpdateK8sClusterUserConfigExpireRequest() {}

  explicit UpdateK8sClusterUserConfigExpireRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireHour) {
      res["expire_hour"] = boost::any(*expireHour);
    }
    if (user) {
      res["user"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expire_hour") != m.end() && !m["expire_hour"].empty()) {
      expireHour = make_shared<long>(boost::any_cast<long>(m["expire_hour"]));
    }
    if (m.find("user") != m.end() && !m["user"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["user"]));
    }
  }


  virtual ~UpdateK8sClusterUserConfigExpireRequest() = default;
};
class UpdateK8sClusterUserConfigExpireResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  UpdateK8sClusterUserConfigExpireResponse() {}

  explicit UpdateK8sClusterUserConfigExpireResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~UpdateK8sClusterUserConfigExpireResponse() = default;
};
class UpdateResourcesDeleteProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> resources{};

  UpdateResourcesDeleteProtectionRequest() {}

  explicit UpdateResourcesDeleteProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (resources) {
      res["resources"] = boost::any(*resources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("resources") != m.end() && !m["resources"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["resources"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["resources"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resources = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateResourcesDeleteProtectionRequest() = default;
};
class UpdateResourcesDeleteProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<string> protection{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> resources{};

  UpdateResourcesDeleteProtectionResponseBody() {}

  explicit UpdateResourcesDeleteProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (protection) {
      res["protection"] = boost::any(*protection);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resourceType) {
      res["resource_type"] = boost::any(*resourceType);
    }
    if (resources) {
      res["resources"] = boost::any(*resources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("protection") != m.end() && !m["protection"].empty()) {
      protection = make_shared<string>(boost::any_cast<string>(m["protection"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resource_type") != m.end() && !m["resource_type"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resource_type"]));
    }
    if (m.find("resources") != m.end() && !m["resources"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["resources"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["resources"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resources = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateResourcesDeleteProtectionResponseBody() = default;
};
class UpdateResourcesDeleteProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateResourcesDeleteProtectionResponseBody> body{};

  UpdateResourcesDeleteProtectionResponse() {}

  explicit UpdateResourcesDeleteProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateResourcesDeleteProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateResourcesDeleteProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateResourcesDeleteProtectionResponse() = default;
};
class UpdateTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};

  UpdateTemplateRequest() {}

  explicit UpdateTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (template_) {
      res["template"] = boost::any(*template_);
    }
    if (templateType) {
      res["template_type"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["template"]));
    }
    if (m.find("template_type") != m.end() && !m["template_type"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["template_type"]));
    }
  }


  virtual ~UpdateTemplateRequest() = default;
};
class UpdateTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  UpdateTemplateResponse() {}

  explicit UpdateTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~UpdateTemplateResponse() = default;
};
class UpdateUserPermissionsRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> cluster{};
  shared_ptr<bool> isCustom{};
  shared_ptr<bool> isRamRole{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleType{};

  UpdateUserPermissionsRequestBody() {}

  explicit UpdateUserPermissionsRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      res["cluster"] = boost::any(*cluster);
    }
    if (isCustom) {
      res["is_custom"] = boost::any(*isCustom);
    }
    if (isRamRole) {
      res["is_ram_role"] = boost::any(*isRamRole);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (roleName) {
      res["role_name"] = boost::any(*roleName);
    }
    if (roleType) {
      res["role_type"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster") != m.end() && !m["cluster"].empty()) {
      cluster = make_shared<string>(boost::any_cast<string>(m["cluster"]));
    }
    if (m.find("is_custom") != m.end() && !m["is_custom"].empty()) {
      isCustom = make_shared<bool>(boost::any_cast<bool>(m["is_custom"]));
    }
    if (m.find("is_ram_role") != m.end() && !m["is_ram_role"].empty()) {
      isRamRole = make_shared<bool>(boost::any_cast<bool>(m["is_ram_role"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("role_name") != m.end() && !m["role_name"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["role_name"]));
    }
    if (m.find("role_type") != m.end() && !m["role_type"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["role_type"]));
    }
  }


  virtual ~UpdateUserPermissionsRequestBody() = default;
};
class UpdateUserPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateUserPermissionsRequestBody>> body{};
  shared_ptr<string> mode{};

  UpdateUserPermissionsRequest() {}

  explicit UpdateUserPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    if (mode) {
      res["mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<UpdateUserPermissionsRequestBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateUserPermissionsRequestBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<UpdateUserPermissionsRequestBody>>(expect1);
      }
    }
    if (m.find("mode") != m.end() && !m["mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["mode"]));
    }
  }


  virtual ~UpdateUserPermissionsRequest() = default;
};
class UpdateUserPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};

  UpdateUserPermissionsResponse() {}

  explicit UpdateUserPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
  }


  virtual ~UpdateUserPermissionsResponse() = default;
};
class UpgradeClusterRequestRollingPolicy : public Darabonba::Model {
public:
  shared_ptr<long> maxParallelism{};

  UpgradeClusterRequestRollingPolicy() {}

  explicit UpgradeClusterRequestRollingPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxParallelism) {
      res["max_parallelism"] = boost::any(*maxParallelism);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("max_parallelism") != m.end() && !m["max_parallelism"].empty()) {
      maxParallelism = make_shared<long>(boost::any_cast<long>(m["max_parallelism"]));
    }
  }


  virtual ~UpgradeClusterRequestRollingPolicy() = default;
};
class UpgradeClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> componentName{};
  shared_ptr<bool> masterOnly{};
  shared_ptr<string> nextVersion{};
  shared_ptr<UpgradeClusterRequestRollingPolicy> rollingPolicy{};
  shared_ptr<string> version{};

  UpgradeClusterRequest() {}

  explicit UpgradeClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentName) {
      res["component_name"] = boost::any(*componentName);
    }
    if (masterOnly) {
      res["master_only"] = boost::any(*masterOnly);
    }
    if (nextVersion) {
      res["next_version"] = boost::any(*nextVersion);
    }
    if (rollingPolicy) {
      res["rolling_policy"] = rollingPolicy ? boost::any(rollingPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("component_name") != m.end() && !m["component_name"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["component_name"]));
    }
    if (m.find("master_only") != m.end() && !m["master_only"].empty()) {
      masterOnly = make_shared<bool>(boost::any_cast<bool>(m["master_only"]));
    }
    if (m.find("next_version") != m.end() && !m["next_version"].empty()) {
      nextVersion = make_shared<string>(boost::any_cast<string>(m["next_version"]));
    }
    if (m.find("rolling_policy") != m.end() && !m["rolling_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["rolling_policy"].type()) {
        UpgradeClusterRequestRollingPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["rolling_policy"]));
        rollingPolicy = make_shared<UpgradeClusterRequestRollingPolicy>(model1);
      }
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~UpgradeClusterRequest() = default;
};
class UpgradeClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  UpgradeClusterResponseBody() {}

  explicit UpgradeClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~UpgradeClusterResponseBody() = default;
};
class UpgradeClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeClusterResponseBody> body{};

  UpgradeClusterResponse() {}

  explicit UpgradeClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeClusterResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeClusterResponse() = default;
};
class UpgradeClusterAddonsRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> componentName{};
  shared_ptr<string> config{};
  shared_ptr<string> nextVersion{};
  shared_ptr<string> policy{};
  shared_ptr<string> version{};

  UpgradeClusterAddonsRequestBody() {}

  explicit UpgradeClusterAddonsRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentName) {
      res["component_name"] = boost::any(*componentName);
    }
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (nextVersion) {
      res["next_version"] = boost::any(*nextVersion);
    }
    if (policy) {
      res["policy"] = boost::any(*policy);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("component_name") != m.end() && !m["component_name"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["component_name"]));
    }
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
    if (m.find("next_version") != m.end() && !m["next_version"].empty()) {
      nextVersion = make_shared<string>(boost::any_cast<string>(m["next_version"]));
    }
    if (m.find("policy") != m.end() && !m["policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["policy"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~UpgradeClusterAddonsRequestBody() = default;
};
class UpgradeClusterAddonsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpgradeClusterAddonsRequestBody>> body{};

  UpgradeClusterAddonsRequest() {}

  explicit UpgradeClusterAddonsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<UpgradeClusterAddonsRequestBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpgradeClusterAddonsRequestBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<UpgradeClusterAddonsRequestBody>>(expect1);
      }
    }
  }


  virtual ~UpgradeClusterAddonsRequest() = default;
};
class UpgradeClusterAddonsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  UpgradeClusterAddonsResponseBody() {}

  explicit UpgradeClusterAddonsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["cluster_id"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cluster_id") != m.end() && !m["cluster_id"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["cluster_id"]));
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~UpgradeClusterAddonsResponseBody() = default;
};
class UpgradeClusterAddonsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeClusterAddonsResponseBody> body{};

  UpgradeClusterAddonsResponse() {}

  explicit UpgradeClusterAddonsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeClusterAddonsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeClusterAddonsResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeClusterAddonsResponse() = default;
};
class UpgradeClusterNodepoolRequestRollingPolicy : public Darabonba::Model {
public:
  shared_ptr<long> batchInterval{};
  shared_ptr<long> maxParallelism{};
  shared_ptr<string> pausePolicy{};

  UpgradeClusterNodepoolRequestRollingPolicy() {}

  explicit UpgradeClusterNodepoolRequestRollingPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchInterval) {
      res["batch_interval"] = boost::any(*batchInterval);
    }
    if (maxParallelism) {
      res["max_parallelism"] = boost::any(*maxParallelism);
    }
    if (pausePolicy) {
      res["pause_policy"] = boost::any(*pausePolicy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("batch_interval") != m.end() && !m["batch_interval"].empty()) {
      batchInterval = make_shared<long>(boost::any_cast<long>(m["batch_interval"]));
    }
    if (m.find("max_parallelism") != m.end() && !m["max_parallelism"].empty()) {
      maxParallelism = make_shared<long>(boost::any_cast<long>(m["max_parallelism"]));
    }
    if (m.find("pause_policy") != m.end() && !m["pause_policy"].empty()) {
      pausePolicy = make_shared<string>(boost::any_cast<string>(m["pause_policy"]));
    }
  }


  virtual ~UpgradeClusterNodepoolRequestRollingPolicy() = default;
};
class UpgradeClusterNodepoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> kubernetesVersion{};
  shared_ptr<vector<string>> nodeNames{};
  shared_ptr<UpgradeClusterNodepoolRequestRollingPolicy> rollingPolicy{};
  shared_ptr<string> runtimeType{};
  shared_ptr<string> runtimeVersion{};
  shared_ptr<bool> useReplace{};

  UpgradeClusterNodepoolRequest() {}

  explicit UpgradeClusterNodepoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["image_id"] = boost::any(*imageId);
    }
    if (kubernetesVersion) {
      res["kubernetes_version"] = boost::any(*kubernetesVersion);
    }
    if (nodeNames) {
      res["node_names"] = boost::any(*nodeNames);
    }
    if (rollingPolicy) {
      res["rolling_policy"] = rollingPolicy ? boost::any(rollingPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeType) {
      res["runtime_type"] = boost::any(*runtimeType);
    }
    if (runtimeVersion) {
      res["runtime_version"] = boost::any(*runtimeVersion);
    }
    if (useReplace) {
      res["use_replace"] = boost::any(*useReplace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image_id") != m.end() && !m["image_id"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["image_id"]));
    }
    if (m.find("kubernetes_version") != m.end() && !m["kubernetes_version"].empty()) {
      kubernetesVersion = make_shared<string>(boost::any_cast<string>(m["kubernetes_version"]));
    }
    if (m.find("node_names") != m.end() && !m["node_names"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["node_names"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["node_names"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("rolling_policy") != m.end() && !m["rolling_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["rolling_policy"].type()) {
        UpgradeClusterNodepoolRequestRollingPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["rolling_policy"]));
        rollingPolicy = make_shared<UpgradeClusterNodepoolRequestRollingPolicy>(model1);
      }
    }
    if (m.find("runtime_type") != m.end() && !m["runtime_type"].empty()) {
      runtimeType = make_shared<string>(boost::any_cast<string>(m["runtime_type"]));
    }
    if (m.find("runtime_version") != m.end() && !m["runtime_version"].empty()) {
      runtimeVersion = make_shared<string>(boost::any_cast<string>(m["runtime_version"]));
    }
    if (m.find("use_replace") != m.end() && !m["use_replace"].empty()) {
      useReplace = make_shared<bool>(boost::any_cast<bool>(m["use_replace"]));
    }
  }


  virtual ~UpgradeClusterNodepoolRequest() = default;
};
class UpgradeClusterNodepoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  UpgradeClusterNodepoolResponseBody() {}

  explicit UpgradeClusterNodepoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["task_id"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("task_id") != m.end() && !m["task_id"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["task_id"]));
    }
  }


  virtual ~UpgradeClusterNodepoolResponseBody() = default;
};
class UpgradeClusterNodepoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeClusterNodepoolResponseBody> body{};

  UpgradeClusterNodepoolResponse() {}

  explicit UpgradeClusterNodepoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeClusterNodepoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeClusterNodepoolResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeClusterNodepoolResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AttachInstancesResponse attachInstancesWithOptions(shared_ptr<string> ClusterId,
                                                     shared_ptr<AttachInstancesRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachInstancesResponse attachInstances(shared_ptr<string> ClusterId, shared_ptr<AttachInstancesRequest> request);
  AttachInstancesToNodePoolResponse attachInstancesToNodePoolWithOptions(shared_ptr<string> ClusterId,
                                                                         shared_ptr<string> NodepoolId,
                                                                         shared_ptr<AttachInstancesToNodePoolRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachInstancesToNodePoolResponse attachInstancesToNodePool(shared_ptr<string> ClusterId, shared_ptr<string> NodepoolId, shared_ptr<AttachInstancesToNodePoolRequest> request);
  CancelClusterUpgradeResponse cancelClusterUpgradeWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelClusterUpgradeResponse cancelClusterUpgrade(shared_ptr<string> ClusterId);
  CancelComponentUpgradeResponse cancelComponentUpgradeWithOptions(shared_ptr<string> clusterId,
                                                                   shared_ptr<string> componentId,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelComponentUpgradeResponse cancelComponentUpgrade(shared_ptr<string> clusterId, shared_ptr<string> componentId);
  CancelOperationPlanResponse cancelOperationPlanWithOptions(shared_ptr<string> planId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOperationPlanResponse cancelOperationPlan(shared_ptr<string> planId);
  CancelTaskResponse cancelTaskWithOptions(shared_ptr<string> taskId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelTaskResponse cancelTask(shared_ptr<string> taskId);
  CheckControlPlaneLogEnableResponse checkControlPlaneLogEnableWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckControlPlaneLogEnableResponse checkControlPlaneLogEnable(shared_ptr<string> ClusterId);
  CheckServiceRoleResponse checkServiceRoleWithOptions(shared_ptr<CheckServiceRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckServiceRoleResponse checkServiceRole(shared_ptr<CheckServiceRoleRequest> request);
  CleanClusterUserPermissionsResponse cleanClusterUserPermissionsWithOptions(shared_ptr<string> ClusterId,
                                                                             shared_ptr<string> Uid,
                                                                             shared_ptr<CleanClusterUserPermissionsRequest> request,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CleanClusterUserPermissionsResponse cleanClusterUserPermissions(shared_ptr<string> ClusterId, shared_ptr<string> Uid, shared_ptr<CleanClusterUserPermissionsRequest> request);
  CleanUserPermissionsResponse cleanUserPermissionsWithOptions(shared_ptr<string> Uid,
                                                               shared_ptr<CleanUserPermissionsRequest> tmpReq,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CleanUserPermissionsResponse cleanUserPermissions(shared_ptr<string> Uid, shared_ptr<CleanUserPermissionsRequest> request);
  CreateAutoscalingConfigResponse createAutoscalingConfigWithOptions(shared_ptr<string> ClusterId,
                                                                     shared_ptr<CreateAutoscalingConfigRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAutoscalingConfigResponse createAutoscalingConfig(shared_ptr<string> ClusterId, shared_ptr<CreateAutoscalingConfigRequest> request);
  CreateClusterResponse createClusterWithOptions(shared_ptr<CreateClusterRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterResponse createCluster(shared_ptr<CreateClusterRequest> request);
  CreateClusterDiagnosisResponse createClusterDiagnosisWithOptions(shared_ptr<string> clusterId,
                                                                   shared_ptr<CreateClusterDiagnosisRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterDiagnosisResponse createClusterDiagnosis(shared_ptr<string> clusterId, shared_ptr<CreateClusterDiagnosisRequest> request);
  CreateClusterInspectConfigResponse createClusterInspectConfigWithOptions(shared_ptr<string> clusterId,
                                                                           shared_ptr<CreateClusterInspectConfigRequest> request,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterInspectConfigResponse createClusterInspectConfig(shared_ptr<string> clusterId, shared_ptr<CreateClusterInspectConfigRequest> request);
  CreateClusterNodePoolResponse createClusterNodePoolWithOptions(shared_ptr<string> ClusterId,
                                                                 shared_ptr<CreateClusterNodePoolRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterNodePoolResponse createClusterNodePool(shared_ptr<string> ClusterId, shared_ptr<CreateClusterNodePoolRequest> request);
  CreateEdgeMachineResponse createEdgeMachineWithOptions(shared_ptr<CreateEdgeMachineRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeMachineResponse createEdgeMachine(shared_ptr<CreateEdgeMachineRequest> request);
  CreateKubernetesTriggerResponse createKubernetesTriggerWithOptions(shared_ptr<CreateKubernetesTriggerRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateKubernetesTriggerResponse createKubernetesTrigger(shared_ptr<CreateKubernetesTriggerRequest> request);
  CreateTemplateResponse createTemplateWithOptions(shared_ptr<CreateTemplateRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTemplateResponse createTemplate(shared_ptr<CreateTemplateRequest> request);
  CreateTriggerResponse createTriggerWithOptions(shared_ptr<string> clusterId,
                                                 shared_ptr<CreateTriggerRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTriggerResponse createTrigger(shared_ptr<string> clusterId, shared_ptr<CreateTriggerRequest> request);
  DeleteAlertContactResponse deleteAlertContactWithOptions(shared_ptr<DeleteAlertContactRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertContactResponse deleteAlertContact(shared_ptr<DeleteAlertContactRequest> request);
  DeleteAlertContactGroupResponse deleteAlertContactGroupWithOptions(shared_ptr<DeleteAlertContactGroupRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertContactGroupResponse deleteAlertContactGroup(shared_ptr<DeleteAlertContactGroupRequest> request);
  DeleteClusterResponse deleteClusterWithOptions(shared_ptr<string> ClusterId,
                                                 shared_ptr<DeleteClusterRequest> tmpReq,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterResponse deleteCluster(shared_ptr<string> ClusterId, shared_ptr<DeleteClusterRequest> request);
  DeleteClusterInspectConfigResponse deleteClusterInspectConfigWithOptions(shared_ptr<string> clusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterInspectConfigResponse deleteClusterInspectConfig(shared_ptr<string> clusterId);
  DeleteClusterNodepoolResponse deleteClusterNodepoolWithOptions(shared_ptr<string> ClusterId,
                                                                 shared_ptr<string> NodepoolId,
                                                                 shared_ptr<DeleteClusterNodepoolRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterNodepoolResponse deleteClusterNodepool(shared_ptr<string> ClusterId, shared_ptr<string> NodepoolId, shared_ptr<DeleteClusterNodepoolRequest> request);
  DeleteClusterNodesResponse deleteClusterNodesWithOptions(shared_ptr<string> ClusterId,
                                                           shared_ptr<DeleteClusterNodesRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterNodesResponse deleteClusterNodes(shared_ptr<string> ClusterId, shared_ptr<DeleteClusterNodesRequest> request);
  DeleteEdgeMachineResponse deleteEdgeMachineWithOptions(shared_ptr<string> edgeMachineid,
                                                         shared_ptr<DeleteEdgeMachineRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeMachineResponse deleteEdgeMachine(shared_ptr<string> edgeMachineid, shared_ptr<DeleteEdgeMachineRequest> request);
  DeleteKubernetesTriggerResponse deleteKubernetesTriggerWithOptions(shared_ptr<string> Id, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteKubernetesTriggerResponse deleteKubernetesTrigger(shared_ptr<string> Id);
  DeletePolicyInstanceResponse deletePolicyInstanceWithOptions(shared_ptr<string> clusterId,
                                                               shared_ptr<string> policyName,
                                                               shared_ptr<DeletePolicyInstanceRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePolicyInstanceResponse deletePolicyInstance(shared_ptr<string> clusterId, shared_ptr<string> policyName, shared_ptr<DeletePolicyInstanceRequest> request);
  DeleteTemplateResponse deleteTemplateWithOptions(shared_ptr<string> TemplateId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTemplateResponse deleteTemplate(shared_ptr<string> TemplateId);
  DeleteTriggerResponse deleteTriggerWithOptions(shared_ptr<string> clusterId,
                                                 shared_ptr<string> Id,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTriggerResponse deleteTrigger(shared_ptr<string> clusterId, shared_ptr<string> Id);
  DeployPolicyInstanceResponse deployPolicyInstanceWithOptions(shared_ptr<string> clusterId,
                                                               shared_ptr<string> policyName,
                                                               shared_ptr<DeployPolicyInstanceRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployPolicyInstanceResponse deployPolicyInstance(shared_ptr<string> clusterId, shared_ptr<string> policyName, shared_ptr<DeployPolicyInstanceRequest> request);
  DescribeAddonResponse describeAddonWithOptions(shared_ptr<string> addonName,
                                                 shared_ptr<DescribeAddonRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAddonResponse describeAddon(shared_ptr<string> addonName, shared_ptr<DescribeAddonRequest> request);
  DescribeAddonsResponse describeAddonsWithOptions(shared_ptr<DescribeAddonsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAddonsResponse describeAddons(shared_ptr<DescribeAddonsRequest> request);
  DescribeClusterAddonInstanceResponse describeClusterAddonInstanceWithOptions(shared_ptr<string> ClusterID,
                                                                               shared_ptr<string> AddonName,
                                                                               shared_ptr<map<string, string>> headers,
                                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterAddonInstanceResponse describeClusterAddonInstance(shared_ptr<string> ClusterID, shared_ptr<string> AddonName);
  DescribeClusterAddonMetadataResponse describeClusterAddonMetadataWithOptions(shared_ptr<string> clusterId,
                                                                               shared_ptr<string> componentId,
                                                                               shared_ptr<DescribeClusterAddonMetadataRequest> request,
                                                                               shared_ptr<map<string, string>> headers,
                                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterAddonMetadataResponse describeClusterAddonMetadata(shared_ptr<string> clusterId, shared_ptr<string> componentId, shared_ptr<DescribeClusterAddonMetadataRequest> request);
  DescribeClusterAddonUpgradeStatusResponse describeClusterAddonUpgradeStatusWithOptions(shared_ptr<string> ClusterId,
                                                                                         shared_ptr<string> ComponentId,
                                                                                         shared_ptr<map<string, string>> headers,
                                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterAddonUpgradeStatusResponse describeClusterAddonUpgradeStatus(shared_ptr<string> ClusterId, shared_ptr<string> ComponentId);
  DescribeClusterAddonsUpgradeStatusResponse describeClusterAddonsUpgradeStatusWithOptions(shared_ptr<string> ClusterId,
                                                                                           shared_ptr<DescribeClusterAddonsUpgradeStatusRequest> tmpReq,
                                                                                           shared_ptr<map<string, string>> headers,
                                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterAddonsUpgradeStatusResponse describeClusterAddonsUpgradeStatus(shared_ptr<string> ClusterId, shared_ptr<DescribeClusterAddonsUpgradeStatusRequest> request);
  DescribeClusterAddonsVersionResponse describeClusterAddonsVersionWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterAddonsVersionResponse describeClusterAddonsVersion(shared_ptr<string> ClusterId);
  DescribeClusterAttachScriptsResponse describeClusterAttachScriptsWithOptions(shared_ptr<string> ClusterId,
                                                                               shared_ptr<DescribeClusterAttachScriptsRequest> request,
                                                                               shared_ptr<map<string, string>> headers,
                                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterAttachScriptsResponse describeClusterAttachScripts(shared_ptr<string> ClusterId, shared_ptr<DescribeClusterAttachScriptsRequest> request);
  DescribeClusterDetailResponse describeClusterDetailWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterDetailResponse describeClusterDetail(shared_ptr<string> ClusterId);
  DescribeClusterEventsResponse describeClusterEventsWithOptions(shared_ptr<string> ClusterId,
                                                                 shared_ptr<DescribeClusterEventsRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterEventsResponse describeClusterEvents(shared_ptr<string> ClusterId, shared_ptr<DescribeClusterEventsRequest> request);
  DescribeClusterLogsResponse describeClusterLogsWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterLogsResponse describeClusterLogs(shared_ptr<string> ClusterId);
  DescribeClusterNodePoolDetailResponse describeClusterNodePoolDetailWithOptions(shared_ptr<string> ClusterId,
                                                                                 shared_ptr<string> NodepoolId,
                                                                                 shared_ptr<map<string, string>> headers,
                                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterNodePoolDetailResponse describeClusterNodePoolDetail(shared_ptr<string> ClusterId, shared_ptr<string> NodepoolId);
  DescribeClusterNodePoolsResponse describeClusterNodePoolsWithOptions(shared_ptr<string> ClusterId,
                                                                       shared_ptr<DescribeClusterNodePoolsRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterNodePoolsResponse describeClusterNodePools(shared_ptr<string> ClusterId, shared_ptr<DescribeClusterNodePoolsRequest> request);
  DescribeClusterNodesResponse describeClusterNodesWithOptions(shared_ptr<string> ClusterId,
                                                               shared_ptr<DescribeClusterNodesRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterNodesResponse describeClusterNodes(shared_ptr<string> ClusterId, shared_ptr<DescribeClusterNodesRequest> request);
  DescribeClusterResourcesResponse describeClusterResourcesWithOptions(shared_ptr<string> ClusterId,
                                                                       shared_ptr<DescribeClusterResourcesRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterResourcesResponse describeClusterResources(shared_ptr<string> ClusterId, shared_ptr<DescribeClusterResourcesRequest> request);
  DescribeClusterTasksResponse describeClusterTasksWithOptions(shared_ptr<string> clusterId,
                                                               shared_ptr<DescribeClusterTasksRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterTasksResponse describeClusterTasks(shared_ptr<string> clusterId, shared_ptr<DescribeClusterTasksRequest> request);
  DescribeClusterUserKubeconfigResponse describeClusterUserKubeconfigWithOptions(shared_ptr<string> ClusterId,
                                                                                 shared_ptr<DescribeClusterUserKubeconfigRequest> request,
                                                                                 shared_ptr<map<string, string>> headers,
                                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterUserKubeconfigResponse describeClusterUserKubeconfig(shared_ptr<string> ClusterId, shared_ptr<DescribeClusterUserKubeconfigRequest> request);
  DescribeClusterV2UserKubeconfigResponse describeClusterV2UserKubeconfigWithOptions(shared_ptr<string> ClusterId,
                                                                                     shared_ptr<DescribeClusterV2UserKubeconfigRequest> request,
                                                                                     shared_ptr<map<string, string>> headers,
                                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterV2UserKubeconfigResponse describeClusterV2UserKubeconfig(shared_ptr<string> ClusterId, shared_ptr<DescribeClusterV2UserKubeconfigRequest> request);
  DescribeClusterVulsResponse describeClusterVulsWithOptions(shared_ptr<string> clusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterVulsResponse describeClusterVuls(shared_ptr<string> clusterId);
  DescribeClustersResponse describeClustersWithOptions(shared_ptr<DescribeClustersRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClustersResponse describeClusters(shared_ptr<DescribeClustersRequest> request);
  DescribeClustersForRegionResponse describeClustersForRegionWithOptions(shared_ptr<string> regionId,
                                                                         shared_ptr<DescribeClustersForRegionRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClustersForRegionResponse describeClustersForRegion(shared_ptr<string> regionId, shared_ptr<DescribeClustersForRegionRequest> request);
  DescribeClustersV1Response describeClustersV1WithOptions(shared_ptr<DescribeClustersV1Request> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClustersV1Response describeClustersV1(shared_ptr<DescribeClustersV1Request> request);
  DescribeEdgeMachineActiveProcessResponse describeEdgeMachineActiveProcessWithOptions(shared_ptr<string> edgeMachineid, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEdgeMachineActiveProcessResponse describeEdgeMachineActiveProcess(shared_ptr<string> edgeMachineid);
  DescribeEdgeMachineModelsResponse describeEdgeMachineModelsWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEdgeMachineModelsResponse describeEdgeMachineModels();
  DescribeEdgeMachineTunnelConfigDetailResponse describeEdgeMachineTunnelConfigDetailWithOptions(shared_ptr<string> edgeMachineid, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEdgeMachineTunnelConfigDetailResponse describeEdgeMachineTunnelConfigDetail(shared_ptr<string> edgeMachineid);
  DescribeEdgeMachinesResponse describeEdgeMachinesWithOptions(shared_ptr<DescribeEdgeMachinesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEdgeMachinesResponse describeEdgeMachines(shared_ptr<DescribeEdgeMachinesRequest> request);
  DescribeEventsResponse describeEventsWithOptions(shared_ptr<DescribeEventsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventsResponse describeEvents(shared_ptr<DescribeEventsRequest> request);
  DescribeEventsForRegionResponse describeEventsForRegionWithOptions(shared_ptr<string> regionId,
                                                                     shared_ptr<DescribeEventsForRegionRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventsForRegionResponse describeEventsForRegion(shared_ptr<string> regionId, shared_ptr<DescribeEventsForRegionRequest> request);
  DescribeExternalAgentResponse describeExternalAgentWithOptions(shared_ptr<string> ClusterId,
                                                                 shared_ptr<DescribeExternalAgentRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExternalAgentResponse describeExternalAgent(shared_ptr<string> ClusterId, shared_ptr<DescribeExternalAgentRequest> request);
  DescribeKubernetesVersionMetadataResponse describeKubernetesVersionMetadataWithOptions(shared_ptr<DescribeKubernetesVersionMetadataRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeKubernetesVersionMetadataResponse describeKubernetesVersionMetadata(shared_ptr<DescribeKubernetesVersionMetadataRequest> request);
  DescribeNodePoolVulsResponse describeNodePoolVulsWithOptions(shared_ptr<string> clusterId,
                                                               shared_ptr<string> nodepoolId,
                                                               shared_ptr<DescribeNodePoolVulsRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNodePoolVulsResponse describeNodePoolVuls(shared_ptr<string> clusterId, shared_ptr<string> nodepoolId, shared_ptr<DescribeNodePoolVulsRequest> request);
  DescribePoliciesResponse describePoliciesWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePoliciesResponse describePolicies();
  DescribePolicyDetailsResponse describePolicyDetailsWithOptions(shared_ptr<string> policyName, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePolicyDetailsResponse describePolicyDetails(shared_ptr<string> policyName);
  DescribePolicyGovernanceInClusterResponse describePolicyGovernanceInClusterWithOptions(shared_ptr<string> clusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePolicyGovernanceInClusterResponse describePolicyGovernanceInCluster(shared_ptr<string> clusterId);
  DescribePolicyInstancesResponse describePolicyInstancesWithOptions(shared_ptr<string> clusterId,
                                                                     shared_ptr<DescribePolicyInstancesRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePolicyInstancesResponse describePolicyInstances(shared_ptr<string> clusterId, shared_ptr<DescribePolicyInstancesRequest> request);
  DescribePolicyInstancesStatusResponse describePolicyInstancesStatusWithOptions(shared_ptr<string> clusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePolicyInstancesStatusResponse describePolicyInstancesStatus(shared_ptr<string> clusterId);
  DescribeResourcesDeleteProtectionResponse describeResourcesDeleteProtectionWithOptions(shared_ptr<string> ClusterId,
                                                                                         shared_ptr<string> ResourceType,
                                                                                         shared_ptr<DescribeResourcesDeleteProtectionRequest> request,
                                                                                         shared_ptr<map<string, string>> headers,
                                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourcesDeleteProtectionResponse describeResourcesDeleteProtection(shared_ptr<string> ClusterId, shared_ptr<string> ResourceType, shared_ptr<DescribeResourcesDeleteProtectionRequest> request);
  DescribeSubaccountK8sClusterUserConfigResponse describeSubaccountK8sClusterUserConfigWithOptions(shared_ptr<string> ClusterId,
                                                                                                   shared_ptr<string> Uid,
                                                                                                   shared_ptr<DescribeSubaccountK8sClusterUserConfigRequest> request,
                                                                                                   shared_ptr<map<string, string>> headers,
                                                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSubaccountK8sClusterUserConfigResponse describeSubaccountK8sClusterUserConfig(shared_ptr<string> ClusterId, shared_ptr<string> Uid, shared_ptr<DescribeSubaccountK8sClusterUserConfigRequest> request);
  DescribeTaskInfoResponse describeTaskInfoWithOptions(shared_ptr<string> taskId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTaskInfoResponse describeTaskInfo(shared_ptr<string> taskId);
  DescribeTemplateAttributeResponse describeTemplateAttributeWithOptions(shared_ptr<string> TemplateId,
                                                                         shared_ptr<DescribeTemplateAttributeRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplateAttributeResponse describeTemplateAttribute(shared_ptr<string> TemplateId, shared_ptr<DescribeTemplateAttributeRequest> request);
  DescribeTemplatesResponse describeTemplatesWithOptions(shared_ptr<DescribeTemplatesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplatesResponse describeTemplates(shared_ptr<DescribeTemplatesRequest> request);
  DescribeTriggerResponse describeTriggerWithOptions(shared_ptr<string> clusterId,
                                                     shared_ptr<DescribeTriggerRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTriggerResponse describeTrigger(shared_ptr<string> clusterId, shared_ptr<DescribeTriggerRequest> request);
  DescribeUserClusterNamespacesResponse describeUserClusterNamespacesWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserClusterNamespacesResponse describeUserClusterNamespaces(shared_ptr<string> ClusterId);
  DescribeUserPermissionResponse describeUserPermissionWithOptions(shared_ptr<string> uid, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserPermissionResponse describeUserPermission(shared_ptr<string> uid);
  DescribeUserQuotaResponse describeUserQuotaWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserQuotaResponse describeUserQuota();
  EdgeClusterAddEdgeMachineResponse edgeClusterAddEdgeMachineWithOptions(shared_ptr<string> clusterid,
                                                                         shared_ptr<string> edgeMachineid,
                                                                         shared_ptr<EdgeClusterAddEdgeMachineRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EdgeClusterAddEdgeMachineResponse edgeClusterAddEdgeMachine(shared_ptr<string> clusterid, shared_ptr<string> edgeMachineid, shared_ptr<EdgeClusterAddEdgeMachineRequest> request);
  FixNodePoolVulsResponse fixNodePoolVulsWithOptions(shared_ptr<string> clusterId,
                                                     shared_ptr<string> nodepoolId,
                                                     shared_ptr<FixNodePoolVulsRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FixNodePoolVulsResponse fixNodePoolVuls(shared_ptr<string> clusterId, shared_ptr<string> nodepoolId, shared_ptr<FixNodePoolVulsRequest> request);
  GetClusterAddonInstanceResponse getClusterAddonInstanceWithOptions(shared_ptr<string> clusterId,
                                                                     shared_ptr<string> instanceName,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterAddonInstanceResponse getClusterAddonInstance(shared_ptr<string> clusterId, shared_ptr<string> instanceName);
  GetClusterAuditProjectResponse getClusterAuditProjectWithOptions(shared_ptr<string> clusterid, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterAuditProjectResponse getClusterAuditProject(shared_ptr<string> clusterid);
  GetClusterCheckResponse getClusterCheckWithOptions(shared_ptr<string> clusterId,
                                                     shared_ptr<string> checkId,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterCheckResponse getClusterCheck(shared_ptr<string> clusterId, shared_ptr<string> checkId);
  GetClusterDiagnosisCheckItemsResponse getClusterDiagnosisCheckItemsWithOptions(shared_ptr<string> clusterId,
                                                                                 shared_ptr<string> diagnosisId,
                                                                                 shared_ptr<GetClusterDiagnosisCheckItemsRequest> request,
                                                                                 shared_ptr<map<string, string>> headers,
                                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterDiagnosisCheckItemsResponse getClusterDiagnosisCheckItems(shared_ptr<string> clusterId, shared_ptr<string> diagnosisId, shared_ptr<GetClusterDiagnosisCheckItemsRequest> request);
  GetClusterDiagnosisResultResponse getClusterDiagnosisResultWithOptions(shared_ptr<string> clusterId,
                                                                         shared_ptr<string> diagnosisId,
                                                                         shared_ptr<GetClusterDiagnosisResultRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterDiagnosisResultResponse getClusterDiagnosisResult(shared_ptr<string> clusterId, shared_ptr<string> diagnosisId, shared_ptr<GetClusterDiagnosisResultRequest> request);
  GetClusterInspectConfigResponse getClusterInspectConfigWithOptions(shared_ptr<string> clusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterInspectConfigResponse getClusterInspectConfig(shared_ptr<string> clusterId);
  GetClusterInspectReportDetailResponse getClusterInspectReportDetailWithOptions(shared_ptr<string> clusterId,
                                                                                 shared_ptr<string> reportId,
                                                                                 shared_ptr<GetClusterInspectReportDetailRequest> request,
                                                                                 shared_ptr<map<string, string>> headers,
                                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterInspectReportDetailResponse getClusterInspectReportDetail(shared_ptr<string> clusterId, shared_ptr<string> reportId, shared_ptr<GetClusterInspectReportDetailRequest> request);
  GetKubernetesTriggerResponse getKubernetesTriggerWithOptions(shared_ptr<string> ClusterId,
                                                               shared_ptr<GetKubernetesTriggerRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetKubernetesTriggerResponse getKubernetesTrigger(shared_ptr<string> ClusterId, shared_ptr<GetKubernetesTriggerRequest> request);
  GetUpgradeStatusResponse getUpgradeStatusWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUpgradeStatusResponse getUpgradeStatus(shared_ptr<string> ClusterId);
  GrantPermissionsResponse grantPermissionsWithOptions(shared_ptr<string> uid,
                                                       shared_ptr<GrantPermissionsRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantPermissionsResponse grantPermissions(shared_ptr<string> uid, shared_ptr<GrantPermissionsRequest> request);
  InstallClusterAddonsResponse installClusterAddonsWithOptions(shared_ptr<string> ClusterId,
                                                               shared_ptr<InstallClusterAddonsRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallClusterAddonsResponse installClusterAddons(shared_ptr<string> ClusterId, shared_ptr<InstallClusterAddonsRequest> request);
  ListAddonsResponse listAddonsWithOptions(shared_ptr<ListAddonsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAddonsResponse listAddons(shared_ptr<ListAddonsRequest> request);
  ListClusterAddonInstancesResponse listClusterAddonInstancesWithOptions(shared_ptr<string> clusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterAddonInstancesResponse listClusterAddonInstances(shared_ptr<string> clusterId);
  ListClusterChecksResponse listClusterChecksWithOptions(shared_ptr<string> clusterId,
                                                         shared_ptr<ListClusterChecksRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterChecksResponse listClusterChecks(shared_ptr<string> clusterId, shared_ptr<ListClusterChecksRequest> request);
  ListClusterInspectReportsResponse listClusterInspectReportsWithOptions(shared_ptr<string> clusterId,
                                                                         shared_ptr<ListClusterInspectReportsRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterInspectReportsResponse listClusterInspectReports(shared_ptr<string> clusterId, shared_ptr<ListClusterInspectReportsRequest> request);
  ListClusterKubeconfigStatesResponse listClusterKubeconfigStatesWithOptions(shared_ptr<string> ClusterId,
                                                                             shared_ptr<ListClusterKubeconfigStatesRequest> request,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterKubeconfigStatesResponse listClusterKubeconfigStates(shared_ptr<string> ClusterId, shared_ptr<ListClusterKubeconfigStatesRequest> request);
  ListOperationPlansResponse listOperationPlansWithOptions(shared_ptr<ListOperationPlansRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOperationPlansResponse listOperationPlans(shared_ptr<ListOperationPlansRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListUserKubeConfigStatesResponse listUserKubeConfigStatesWithOptions(shared_ptr<string> Uid,
                                                                       shared_ptr<ListUserKubeConfigStatesRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserKubeConfigStatesResponse listUserKubeConfigStates(shared_ptr<string> Uid, shared_ptr<ListUserKubeConfigStatesRequest> request);
  MigrateClusterResponse migrateClusterWithOptions(shared_ptr<string> clusterId,
                                                   shared_ptr<MigrateClusterRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MigrateClusterResponse migrateCluster(shared_ptr<string> clusterId, shared_ptr<MigrateClusterRequest> request);
  ModifyClusterResponse modifyClusterWithOptions(shared_ptr<string> ClusterId,
                                                 shared_ptr<ModifyClusterRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterResponse modifyCluster(shared_ptr<string> ClusterId, shared_ptr<ModifyClusterRequest> request);
  ModifyClusterAddonResponse modifyClusterAddonWithOptions(shared_ptr<string> clusterId,
                                                           shared_ptr<string> componentId,
                                                           shared_ptr<ModifyClusterAddonRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterAddonResponse modifyClusterAddon(shared_ptr<string> clusterId, shared_ptr<string> componentId, shared_ptr<ModifyClusterAddonRequest> request);
  ModifyClusterConfigurationResponse modifyClusterConfigurationWithOptions(shared_ptr<string> ClusterId,
                                                                           shared_ptr<ModifyClusterConfigurationRequest> request,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterConfigurationResponse modifyClusterConfiguration(shared_ptr<string> ClusterId, shared_ptr<ModifyClusterConfigurationRequest> request);
  ModifyClusterNodePoolResponse modifyClusterNodePoolWithOptions(shared_ptr<string> ClusterId,
                                                                 shared_ptr<string> NodepoolId,
                                                                 shared_ptr<ModifyClusterNodePoolRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterNodePoolResponse modifyClusterNodePool(shared_ptr<string> ClusterId, shared_ptr<string> NodepoolId, shared_ptr<ModifyClusterNodePoolRequest> request);
  ModifyClusterTagsResponse modifyClusterTagsWithOptions(shared_ptr<string> ClusterId,
                                                         shared_ptr<ModifyClusterTagsRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterTagsResponse modifyClusterTags(shared_ptr<string> ClusterId, shared_ptr<ModifyClusterTagsRequest> request);
  ModifyNodePoolNodeConfigResponse modifyNodePoolNodeConfigWithOptions(shared_ptr<string> ClusterId,
                                                                       shared_ptr<string> NodepoolId,
                                                                       shared_ptr<ModifyNodePoolNodeConfigRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNodePoolNodeConfigResponse modifyNodePoolNodeConfig(shared_ptr<string> ClusterId, shared_ptr<string> NodepoolId, shared_ptr<ModifyNodePoolNodeConfigRequest> request);
  ModifyPolicyInstanceResponse modifyPolicyInstanceWithOptions(shared_ptr<string> clusterId,
                                                               shared_ptr<string> policyName,
                                                               shared_ptr<ModifyPolicyInstanceRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPolicyInstanceResponse modifyPolicyInstance(shared_ptr<string> clusterId, shared_ptr<string> policyName, shared_ptr<ModifyPolicyInstanceRequest> request);
  OpenAckServiceResponse openAckServiceWithOptions(shared_ptr<OpenAckServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenAckServiceResponse openAckService(shared_ptr<OpenAckServiceRequest> request);
  PauseClusterUpgradeResponse pauseClusterUpgradeWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PauseClusterUpgradeResponse pauseClusterUpgrade(shared_ptr<string> ClusterId);
  PauseComponentUpgradeResponse pauseComponentUpgradeWithOptions(shared_ptr<string> clusterid,
                                                                 shared_ptr<string> componentid,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PauseComponentUpgradeResponse pauseComponentUpgrade(shared_ptr<string> clusterid, shared_ptr<string> componentid);
  PauseTaskResponse pauseTaskWithOptions(shared_ptr<string> taskId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PauseTaskResponse pauseTask(shared_ptr<string> taskId);
  RemoveClusterNodesResponse removeClusterNodesWithOptions(shared_ptr<string> ClusterId,
                                                           shared_ptr<RemoveClusterNodesRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveClusterNodesResponse removeClusterNodes(shared_ptr<string> ClusterId, shared_ptr<RemoveClusterNodesRequest> request);
  RemoveNodePoolNodesResponse removeNodePoolNodesWithOptions(shared_ptr<string> ClusterId,
                                                             shared_ptr<string> NodepoolId,
                                                             shared_ptr<RemoveNodePoolNodesRequest> tmpReq,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveNodePoolNodesResponse removeNodePoolNodes(shared_ptr<string> ClusterId, shared_ptr<string> NodepoolId, shared_ptr<RemoveNodePoolNodesRequest> request);
  RepairClusterNodePoolResponse repairClusterNodePoolWithOptions(shared_ptr<string> clusterId,
                                                                 shared_ptr<string> nodepoolId,
                                                                 shared_ptr<RepairClusterNodePoolRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RepairClusterNodePoolResponse repairClusterNodePool(shared_ptr<string> clusterId, shared_ptr<string> nodepoolId, shared_ptr<RepairClusterNodePoolRequest> request);
  ResumeComponentUpgradeResponse resumeComponentUpgradeWithOptions(shared_ptr<string> clusterid,
                                                                   shared_ptr<string> componentid,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeComponentUpgradeResponse resumeComponentUpgrade(shared_ptr<string> clusterid, shared_ptr<string> componentid);
  ResumeTaskResponse resumeTaskWithOptions(shared_ptr<string> taskId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeTaskResponse resumeTask(shared_ptr<string> taskId);
  ResumeUpgradeClusterResponse resumeUpgradeClusterWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeUpgradeClusterResponse resumeUpgradeCluster(shared_ptr<string> ClusterId);
  RevokeK8sClusterKubeConfigResponse revokeK8sClusterKubeConfigWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeK8sClusterKubeConfigResponse revokeK8sClusterKubeConfig(shared_ptr<string> ClusterId);
  RunClusterCheckResponse runClusterCheckWithOptions(shared_ptr<string> clusterId,
                                                     shared_ptr<RunClusterCheckRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunClusterCheckResponse runClusterCheck(shared_ptr<string> clusterId, shared_ptr<RunClusterCheckRequest> request);
  RunClusterInspectResponse runClusterInspectWithOptions(shared_ptr<string> clusterId,
                                                         shared_ptr<RunClusterInspectRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunClusterInspectResponse runClusterInspect(shared_ptr<string> clusterId, shared_ptr<RunClusterInspectRequest> request);
  ScaleClusterResponse scaleClusterWithOptions(shared_ptr<string> ClusterId,
                                               shared_ptr<ScaleClusterRequest> request,
                                               shared_ptr<map<string, string>> headers,
                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleClusterResponse scaleCluster(shared_ptr<string> ClusterId, shared_ptr<ScaleClusterRequest> request);
  ScaleClusterNodePoolResponse scaleClusterNodePoolWithOptions(shared_ptr<string> ClusterId,
                                                               shared_ptr<string> NodepoolId,
                                                               shared_ptr<ScaleClusterNodePoolRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleClusterNodePoolResponse scaleClusterNodePool(shared_ptr<string> ClusterId, shared_ptr<string> NodepoolId, shared_ptr<ScaleClusterNodePoolRequest> request);
  ScaleOutClusterResponse scaleOutClusterWithOptions(shared_ptr<string> ClusterId,
                                                     shared_ptr<ScaleOutClusterRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScaleOutClusterResponse scaleOutCluster(shared_ptr<string> ClusterId, shared_ptr<ScaleOutClusterRequest> request);
  ScanClusterVulsResponse scanClusterVulsWithOptions(shared_ptr<string> clusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScanClusterVulsResponse scanClusterVuls(shared_ptr<string> clusterId);
  StartAlertResponse startAlertWithOptions(shared_ptr<string> ClusterId,
                                           shared_ptr<StartAlertRequest> request,
                                           shared_ptr<map<string, string>> headers,
                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartAlertResponse startAlert(shared_ptr<string> ClusterId, shared_ptr<StartAlertRequest> request);
  StopAlertResponse stopAlertWithOptions(shared_ptr<string> ClusterId,
                                         shared_ptr<StopAlertRequest> request,
                                         shared_ptr<map<string, string>> headers,
                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopAlertResponse stopAlert(shared_ptr<string> ClusterId, shared_ptr<StopAlertRequest> request);
  SyncClusterNodePoolResponse syncClusterNodePoolWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncClusterNodePoolResponse syncClusterNodePool(shared_ptr<string> ClusterId);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UnInstallClusterAddonsResponse unInstallClusterAddonsWithOptions(shared_ptr<string> ClusterId,
                                                                   shared_ptr<UnInstallClusterAddonsRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnInstallClusterAddonsResponse unInstallClusterAddons(shared_ptr<string> ClusterId, shared_ptr<UnInstallClusterAddonsRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateClusterAuditLogConfigResponse updateClusterAuditLogConfigWithOptions(shared_ptr<string> clusterid,
                                                                             shared_ptr<UpdateClusterAuditLogConfigRequest> request,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateClusterAuditLogConfigResponse updateClusterAuditLogConfig(shared_ptr<string> clusterid, shared_ptr<UpdateClusterAuditLogConfigRequest> request);
  UpdateClusterInspectConfigResponse updateClusterInspectConfigWithOptions(shared_ptr<string> clusterId,
                                                                           shared_ptr<UpdateClusterInspectConfigRequest> request,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateClusterInspectConfigResponse updateClusterInspectConfig(shared_ptr<string> clusterId, shared_ptr<UpdateClusterInspectConfigRequest> request);
  UpdateContactGroupForAlertResponse updateContactGroupForAlertWithOptions(shared_ptr<string> ClusterId,
                                                                           shared_ptr<UpdateContactGroupForAlertRequest> request,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateContactGroupForAlertResponse updateContactGroupForAlert(shared_ptr<string> ClusterId, shared_ptr<UpdateContactGroupForAlertRequest> request);
  UpdateControlPlaneLogResponse updateControlPlaneLogWithOptions(shared_ptr<string> ClusterId,
                                                                 shared_ptr<UpdateControlPlaneLogRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateControlPlaneLogResponse updateControlPlaneLog(shared_ptr<string> ClusterId, shared_ptr<UpdateControlPlaneLogRequest> request);
  UpdateK8sClusterUserConfigExpireResponse updateK8sClusterUserConfigExpireWithOptions(shared_ptr<string> ClusterId,
                                                                                       shared_ptr<UpdateK8sClusterUserConfigExpireRequest> request,
                                                                                       shared_ptr<map<string, string>> headers,
                                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateK8sClusterUserConfigExpireResponse updateK8sClusterUserConfigExpire(shared_ptr<string> ClusterId, shared_ptr<UpdateK8sClusterUserConfigExpireRequest> request);
  UpdateResourcesDeleteProtectionResponse updateResourcesDeleteProtectionWithOptions(shared_ptr<string> ClusterId,
                                                                                     shared_ptr<UpdateResourcesDeleteProtectionRequest> request,
                                                                                     shared_ptr<map<string, string>> headers,
                                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateResourcesDeleteProtectionResponse updateResourcesDeleteProtection(shared_ptr<string> ClusterId, shared_ptr<UpdateResourcesDeleteProtectionRequest> request);
  UpdateTemplateResponse updateTemplateWithOptions(shared_ptr<string> TemplateId,
                                                   shared_ptr<UpdateTemplateRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTemplateResponse updateTemplate(shared_ptr<string> TemplateId, shared_ptr<UpdateTemplateRequest> request);
  UpdateUserPermissionsResponse updateUserPermissionsWithOptions(shared_ptr<string> uid,
                                                                 shared_ptr<UpdateUserPermissionsRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserPermissionsResponse updateUserPermissions(shared_ptr<string> uid, shared_ptr<UpdateUserPermissionsRequest> request);
  UpgradeClusterResponse upgradeClusterWithOptions(shared_ptr<string> ClusterId,
                                                   shared_ptr<UpgradeClusterRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeClusterResponse upgradeCluster(shared_ptr<string> ClusterId, shared_ptr<UpgradeClusterRequest> request);
  UpgradeClusterAddonsResponse upgradeClusterAddonsWithOptions(shared_ptr<string> ClusterId,
                                                               shared_ptr<UpgradeClusterAddonsRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeClusterAddonsResponse upgradeClusterAddons(shared_ptr<string> ClusterId, shared_ptr<UpgradeClusterAddonsRequest> request);
  UpgradeClusterNodepoolResponse upgradeClusterNodepoolWithOptions(shared_ptr<string> ClusterId,
                                                                   shared_ptr<string> NodepoolId,
                                                                   shared_ptr<UpgradeClusterNodepoolRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeClusterNodepoolResponse upgradeClusterNodepool(shared_ptr<string> ClusterId, shared_ptr<string> NodepoolId, shared_ptr<UpgradeClusterNodepoolRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_CS20151215

#endif
