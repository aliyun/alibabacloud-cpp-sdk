// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DDOSCOO20200101_H_
#define ALIBABACLOUD_DDOSCOO20200101_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Ddoscoo20200101 {
class AddAutoCcBlacklistRequest : public Darabonba::Model {
public:
  shared_ptr<string> blacklist{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceId{};

  AddAutoCcBlacklistRequest() {}

  explicit AddAutoCcBlacklistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blacklist) {
      res["Blacklist"] = boost::any(*blacklist);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Blacklist") != m.end() && !m["Blacklist"].empty()) {
      blacklist = make_shared<string>(boost::any_cast<string>(m["Blacklist"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AddAutoCcBlacklistRequest() = default;
};
class AddAutoCcBlacklistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddAutoCcBlacklistResponseBody() {}

  explicit AddAutoCcBlacklistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddAutoCcBlacklistResponseBody() = default;
};
class AddAutoCcBlacklistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAutoCcBlacklistResponseBody> body{};

  AddAutoCcBlacklistResponse() {}

  explicit AddAutoCcBlacklistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAutoCcBlacklistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAutoCcBlacklistResponseBody>(model1);
      }
    }
  }


  virtual ~AddAutoCcBlacklistResponse() = default;
};
class AddAutoCcWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> whitelist{};

  AddAutoCcWhitelistRequest() {}

  explicit AddAutoCcWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (whitelist) {
      res["Whitelist"] = boost::any(*whitelist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Whitelist") != m.end() && !m["Whitelist"].empty()) {
      whitelist = make_shared<string>(boost::any_cast<string>(m["Whitelist"]));
    }
  }


  virtual ~AddAutoCcWhitelistRequest() = default;
};
class AddAutoCcWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddAutoCcWhitelistResponseBody() {}

  explicit AddAutoCcWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddAutoCcWhitelistResponseBody() = default;
};
class AddAutoCcWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAutoCcWhitelistResponseBody> body{};

  AddAutoCcWhitelistResponse() {}

  explicit AddAutoCcWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAutoCcWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAutoCcWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~AddAutoCcWhitelistResponse() = default;
};
class AssociateWebCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> cert{};
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> domain{};
  shared_ptr<string> key{};
  shared_ptr<string> resourceGroupId{};

  AssociateWebCertRequest() {}

  explicit AssociateWebCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      res["Cert"] = boost::any(*cert);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      cert = make_shared<string>(boost::any_cast<string>(m["Cert"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~AssociateWebCertRequest() = default;
};
class AssociateWebCertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateWebCertResponseBody() {}

  explicit AssociateWebCertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateWebCertResponseBody() = default;
};
class AssociateWebCertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateWebCertResponseBody> body{};

  AssociateWebCertResponse() {}

  explicit AssociateWebCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateWebCertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateWebCertResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateWebCertResponse() = default;
};
class AttachSceneDefenseObjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> objectType{};
  shared_ptr<string> objects{};
  shared_ptr<string> policyId{};

  AttachSceneDefenseObjectRequest() {}

  explicit AttachSceneDefenseObjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (objects) {
      res["Objects"] = boost::any(*objects);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Objects") != m.end() && !m["Objects"].empty()) {
      objects = make_shared<string>(boost::any_cast<string>(m["Objects"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
  }


  virtual ~AttachSceneDefenseObjectRequest() = default;
};
class AttachSceneDefenseObjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AttachSceneDefenseObjectResponseBody() {}

  explicit AttachSceneDefenseObjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AttachSceneDefenseObjectResponseBody() = default;
};
class AttachSceneDefenseObjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachSceneDefenseObjectResponseBody> body{};

  AttachSceneDefenseObjectResponse() {}

  explicit AttachSceneDefenseObjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachSceneDefenseObjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachSceneDefenseObjectResponseBody>(model1);
      }
    }
  }


  virtual ~AttachSceneDefenseObjectResponse() = default;
};
class ConfigL7RsPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> policy{};
  shared_ptr<string> resourceGroupId{};

  ConfigL7RsPolicyRequest() {}

  explicit ConfigL7RsPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ConfigL7RsPolicyRequest() = default;
};
class ConfigL7RsPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigL7RsPolicyResponseBody() {}

  explicit ConfigL7RsPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigL7RsPolicyResponseBody() = default;
};
class ConfigL7RsPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigL7RsPolicyResponseBody> body{};

  ConfigL7RsPolicyResponse() {}

  explicit ConfigL7RsPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigL7RsPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigL7RsPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigL7RsPolicyResponse() = default;
};
class ConfigLayer4RemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listeners{};

  ConfigLayer4RemarkRequest() {}

  explicit ConfigLayer4RemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listeners) {
      res["Listeners"] = boost::any(*listeners);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Listeners") != m.end() && !m["Listeners"].empty()) {
      listeners = make_shared<string>(boost::any_cast<string>(m["Listeners"]));
    }
  }


  virtual ~ConfigLayer4RemarkRequest() = default;
};
class ConfigLayer4RemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigLayer4RemarkResponseBody() {}

  explicit ConfigLayer4RemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigLayer4RemarkResponseBody() = default;
};
class ConfigLayer4RemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigLayer4RemarkResponseBody> body{};

  ConfigLayer4RemarkResponse() {}

  explicit ConfigLayer4RemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigLayer4RemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigLayer4RemarkResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigLayer4RemarkResponse() = default;
};
class ConfigLayer4RuleBakModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> bakMode{};
  shared_ptr<string> listeners{};

  ConfigLayer4RuleBakModeRequest() {}

  explicit ConfigLayer4RuleBakModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bakMode) {
      res["BakMode"] = boost::any(*bakMode);
    }
    if (listeners) {
      res["Listeners"] = boost::any(*listeners);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BakMode") != m.end() && !m["BakMode"].empty()) {
      bakMode = make_shared<string>(boost::any_cast<string>(m["BakMode"]));
    }
    if (m.find("Listeners") != m.end() && !m["Listeners"].empty()) {
      listeners = make_shared<string>(boost::any_cast<string>(m["Listeners"]));
    }
  }


  virtual ~ConfigLayer4RuleBakModeRequest() = default;
};
class ConfigLayer4RuleBakModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigLayer4RuleBakModeResponseBody() {}

  explicit ConfigLayer4RuleBakModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigLayer4RuleBakModeResponseBody() = default;
};
class ConfigLayer4RuleBakModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigLayer4RuleBakModeResponseBody> body{};

  ConfigLayer4RuleBakModeResponse() {}

  explicit ConfigLayer4RuleBakModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigLayer4RuleBakModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigLayer4RuleBakModeResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigLayer4RuleBakModeResponse() = default;
};
class ConfigLayer4RulePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> listeners{};

  ConfigLayer4RulePolicyRequest() {}

  explicit ConfigLayer4RulePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listeners) {
      res["Listeners"] = boost::any(*listeners);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Listeners") != m.end() && !m["Listeners"].empty()) {
      listeners = make_shared<string>(boost::any_cast<string>(m["Listeners"]));
    }
  }


  virtual ~ConfigLayer4RulePolicyRequest() = default;
};
class ConfigLayer4RulePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigLayer4RulePolicyResponseBody() {}

  explicit ConfigLayer4RulePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigLayer4RulePolicyResponseBody() = default;
};
class ConfigLayer4RulePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigLayer4RulePolicyResponseBody> body{};

  ConfigLayer4RulePolicyResponse() {}

  explicit ConfigLayer4RulePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigLayer4RulePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigLayer4RulePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigLayer4RulePolicyResponse() = default;
};
class ConfigNetworkRegionBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> instanceId{};

  ConfigNetworkRegionBlockRequest() {}

  explicit ConfigNetworkRegionBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ConfigNetworkRegionBlockRequest() = default;
};
class ConfigNetworkRegionBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigNetworkRegionBlockResponseBody() {}

  explicit ConfigNetworkRegionBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigNetworkRegionBlockResponseBody() = default;
};
class ConfigNetworkRegionBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigNetworkRegionBlockResponseBody> body{};

  ConfigNetworkRegionBlockResponse() {}

  explicit ConfigNetworkRegionBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigNetworkRegionBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigNetworkRegionBlockResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigNetworkRegionBlockResponse() = default;
};
class ConfigNetworkRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkRules{};

  ConfigNetworkRulesRequest() {}

  explicit ConfigNetworkRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkRules) {
      res["NetworkRules"] = boost::any(*networkRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkRules") != m.end() && !m["NetworkRules"].empty()) {
      networkRules = make_shared<string>(boost::any_cast<string>(m["NetworkRules"]));
    }
  }


  virtual ~ConfigNetworkRulesRequest() = default;
};
class ConfigNetworkRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigNetworkRulesResponseBody() {}

  explicit ConfigNetworkRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigNetworkRulesResponseBody() = default;
};
class ConfigNetworkRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigNetworkRulesResponseBody> body{};

  ConfigNetworkRulesResponse() {}

  explicit ConfigNetworkRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigNetworkRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigNetworkRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigNetworkRulesResponse() = default;
};
class ConfigUdpReflectRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  ConfigUdpReflectRequest() {}

  explicit ConfigUdpReflectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ConfigUdpReflectRequest() = default;
};
class ConfigUdpReflectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigUdpReflectResponseBody() {}

  explicit ConfigUdpReflectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigUdpReflectResponseBody() = default;
};
class ConfigUdpReflectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigUdpReflectResponseBody> body{};

  ConfigUdpReflectResponse() {}

  explicit ConfigUdpReflectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigUdpReflectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigUdpReflectResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigUdpReflectResponse() = default;
};
class ConfigWebCCTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> template_{};

  ConfigWebCCTemplateRequest() {}

  explicit ConfigWebCCTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~ConfigWebCCTemplateRequest() = default;
};
class ConfigWebCCTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigWebCCTemplateResponseBody() {}

  explicit ConfigWebCCTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigWebCCTemplateResponseBody() = default;
};
class ConfigWebCCTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigWebCCTemplateResponseBody> body{};

  ConfigWebCCTemplateResponse() {}

  explicit ConfigWebCCTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigWebCCTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigWebCCTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigWebCCTemplateResponse() = default;
};
class ConfigWebIpSetRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> blackList{};
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> whiteList{};

  ConfigWebIpSetRequest() {}

  explicit ConfigWebIpSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackList) {
      res["BlackList"] = boost::any(*blackList);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackList") != m.end() && !m["BlackList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BlackList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BlackList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      blackList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whiteList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ConfigWebIpSetRequest() = default;
};
class ConfigWebIpSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigWebIpSetResponseBody() {}

  explicit ConfigWebIpSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigWebIpSetResponseBody() = default;
};
class ConfigWebIpSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigWebIpSetResponseBody> body{};

  ConfigWebIpSetResponse() {}

  explicit ConfigWebIpSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigWebIpSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigWebIpSetResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigWebIpSetResponse() = default;
};
class CreateAsyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> taskParams{};
  shared_ptr<long> taskType{};

  CreateAsyncTaskRequest() {}

  explicit CreateAsyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (taskParams) {
      res["TaskParams"] = boost::any(*taskParams);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TaskParams") != m.end() && !m["TaskParams"].empty()) {
      taskParams = make_shared<string>(boost::any_cast<string>(m["TaskParams"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
  }


  virtual ~CreateAsyncTaskRequest() = default;
};
class CreateAsyncTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateAsyncTaskResponseBody() {}

  explicit CreateAsyncTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAsyncTaskResponseBody() = default;
};
class CreateAsyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAsyncTaskResponseBody> body{};

  CreateAsyncTaskResponse() {}

  explicit CreateAsyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAsyncTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAsyncTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAsyncTaskResponse() = default;
};
class CreateDomainResourceRequestProxyTypes : public Darabonba::Model {
public:
  shared_ptr<vector<long>> proxyPorts{};
  shared_ptr<string> proxyType{};

  CreateDomainResourceRequestProxyTypes() {}

  explicit CreateDomainResourceRequestProxyTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyPorts) {
      res["ProxyPorts"] = boost::any(*proxyPorts);
    }
    if (proxyType) {
      res["ProxyType"] = boost::any(*proxyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyPorts") != m.end() && !m["ProxyPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ProxyPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProxyPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      proxyPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ProxyType") != m.end() && !m["ProxyType"].empty()) {
      proxyType = make_shared<string>(boost::any_cast<string>(m["ProxyType"]));
    }
  }


  virtual ~CreateDomainResourceRequestProxyTypes() = default;
};
class CreateDomainResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> httpsExt{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<vector<CreateDomainResourceRequestProxyTypes>> proxyTypes{};
  shared_ptr<vector<string>> realServers{};
  shared_ptr<long> rsType{};

  CreateDomainResourceRequest() {}

  explicit CreateDomainResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (httpsExt) {
      res["HttpsExt"] = boost::any(*httpsExt);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (proxyTypes) {
      vector<boost::any> temp1;
      for(auto item1:*proxyTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProxyTypes"] = boost::any(temp1);
    }
    if (realServers) {
      res["RealServers"] = boost::any(*realServers);
    }
    if (rsType) {
      res["RsType"] = boost::any(*rsType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("HttpsExt") != m.end() && !m["HttpsExt"].empty()) {
      httpsExt = make_shared<string>(boost::any_cast<string>(m["HttpsExt"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProxyTypes") != m.end() && !m["ProxyTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["ProxyTypes"].type()) {
        vector<CreateDomainResourceRequestProxyTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProxyTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDomainResourceRequestProxyTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxyTypes = make_shared<vector<CreateDomainResourceRequestProxyTypes>>(expect1);
      }
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RealServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      realServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RsType") != m.end() && !m["RsType"].empty()) {
      rsType = make_shared<long>(boost::any_cast<long>(m["RsType"]));
    }
  }


  virtual ~CreateDomainResourceRequest() = default;
};
class CreateDomainResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDomainResourceResponseBody() {}

  explicit CreateDomainResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDomainResourceResponseBody() = default;
};
class CreateDomainResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDomainResourceResponseBody> body{};

  CreateDomainResourceResponse() {}

  explicit CreateDomainResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDomainResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDomainResourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDomainResourceResponse() = default;
};
class CreateNetworkRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkRules{};

  CreateNetworkRulesRequest() {}

  explicit CreateNetworkRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkRules) {
      res["NetworkRules"] = boost::any(*networkRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkRules") != m.end() && !m["NetworkRules"].empty()) {
      networkRules = make_shared<string>(boost::any_cast<string>(m["NetworkRules"]));
    }
  }


  virtual ~CreateNetworkRulesRequest() = default;
};
class CreateNetworkRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateNetworkRulesResponseBody() {}

  explicit CreateNetworkRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkRulesResponseBody() = default;
};
class CreateNetworkRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkRulesResponseBody> body{};

  CreateNetworkRulesResponse() {}

  explicit CreateNetworkRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkRulesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkRulesResponse() = default;
};
class CreatePortRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendPort{};
  shared_ptr<string> frontendPort{};
  shared_ptr<string> frontendProtocol{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> realServers{};

  CreatePortRequest() {}

  explicit CreatePortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendPort) {
      res["BackendPort"] = boost::any(*backendPort);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (frontendProtocol) {
      res["FrontendProtocol"] = boost::any(*frontendProtocol);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (realServers) {
      res["RealServers"] = boost::any(*realServers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendPort") != m.end() && !m["BackendPort"].empty()) {
      backendPort = make_shared<string>(boost::any_cast<string>(m["BackendPort"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<string>(boost::any_cast<string>(m["FrontendPort"]));
    }
    if (m.find("FrontendProtocol") != m.end() && !m["FrontendProtocol"].empty()) {
      frontendProtocol = make_shared<string>(boost::any_cast<string>(m["FrontendProtocol"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RealServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      realServers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreatePortRequest() = default;
};
class CreatePortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreatePortResponseBody() {}

  explicit CreatePortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePortResponseBody() = default;
};
class CreatePortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePortResponseBody> body{};

  CreatePortResponse() {}

  explicit CreatePortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePortResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePortResponse() = default;
};
class CreateSceneDefensePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> name{};
  shared_ptr<long> startTime{};
  shared_ptr<string> template_{};

  CreateSceneDefensePolicyRequest() {}

  explicit CreateSceneDefensePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~CreateSceneDefensePolicyRequest() = default;
};
class CreateSceneDefensePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSceneDefensePolicyResponseBody() {}

  explicit CreateSceneDefensePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSceneDefensePolicyResponseBody() = default;
};
class CreateSceneDefensePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSceneDefensePolicyResponseBody> body{};

  CreateSceneDefensePolicyResponse() {}

  explicit CreateSceneDefensePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSceneDefensePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSceneDefensePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSceneDefensePolicyResponse() = default;
};
class CreateSchedulerRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> param{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> rules{};

  CreateSchedulerRuleRequest() {}

  explicit CreateSchedulerRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~CreateSchedulerRuleRequest() = default;
};
class CreateSchedulerRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleName{};

  CreateSchedulerRuleResponseBody() {}

  explicit CreateSchedulerRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~CreateSchedulerRuleResponseBody() = default;
};
class CreateSchedulerRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSchedulerRuleResponseBody> body{};

  CreateSchedulerRuleResponse() {}

  explicit CreateSchedulerRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSchedulerRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSchedulerRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSchedulerRuleResponse() = default;
};
class CreateTagResourcesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateTagResourcesRequestTags() {}

  explicit CreateTagResourcesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateTagResourcesRequestTags() = default;
};
class CreateTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<CreateTagResourcesRequestTags>> tags{};

  CreateTagResourcesRequest() {}

  explicit CreateTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateTagResourcesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTagResourcesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateTagResourcesRequestTags>>(expect1);
      }
    }
  }


  virtual ~CreateTagResourcesRequest() = default;
};
class CreateTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateTagResourcesResponseBody() {}

  explicit CreateTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateTagResourcesResponseBody() = default;
};
class CreateTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTagResourcesResponseBody> body{};

  CreateTagResourcesResponse() {}

  explicit CreateTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTagResourcesResponse() = default;
};
class CreateWebCCRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> act{};
  shared_ptr<long> count{};
  shared_ptr<string> domain{};
  shared_ptr<long> interval{};
  shared_ptr<string> mode{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> ttl{};
  shared_ptr<string> uri{};

  CreateWebCCRuleRequest() {}

  explicit CreateWebCCRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (act) {
      res["Act"] = boost::any(*act);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Act") != m.end() && !m["Act"].empty()) {
      act = make_shared<string>(boost::any_cast<string>(m["Act"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~CreateWebCCRuleRequest() = default;
};
class CreateWebCCRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateWebCCRuleResponseBody() {}

  explicit CreateWebCCRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWebCCRuleResponseBody() = default;
};
class CreateWebCCRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWebCCRuleResponseBody> body{};

  CreateWebCCRuleResponse() {}

  explicit CreateWebCCRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWebCCRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWebCCRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWebCCRuleResponse() = default;
};
class CreateWebRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseId{};
  shared_ptr<string> domain{};
  shared_ptr<string> httpsExt{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> rsType{};
  shared_ptr<string> rules{};

  CreateWebRuleRequest() {}

  explicit CreateWebRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseId) {
      res["DefenseId"] = boost::any(*defenseId);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (httpsExt) {
      res["HttpsExt"] = boost::any(*httpsExt);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (rsType) {
      res["RsType"] = boost::any(*rsType);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseId") != m.end() && !m["DefenseId"].empty()) {
      defenseId = make_shared<string>(boost::any_cast<string>(m["DefenseId"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("HttpsExt") != m.end() && !m["HttpsExt"].empty()) {
      httpsExt = make_shared<string>(boost::any_cast<string>(m["HttpsExt"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RsType") != m.end() && !m["RsType"].empty()) {
      rsType = make_shared<long>(boost::any_cast<long>(m["RsType"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~CreateWebRuleRequest() = default;
};
class CreateWebRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateWebRuleResponseBody() {}

  explicit CreateWebRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWebRuleResponseBody() = default;
};
class CreateWebRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWebRuleResponseBody> body{};

  CreateWebRuleResponse() {}

  explicit CreateWebRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWebRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWebRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWebRuleResponse() = default;
};
class DeleteAsyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> taskId{};

  DeleteAsyncTaskRequest() {}

  explicit DeleteAsyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DeleteAsyncTaskRequest() = default;
};
class DeleteAsyncTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAsyncTaskResponseBody() {}

  explicit DeleteAsyncTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAsyncTaskResponseBody() = default;
};
class DeleteAsyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAsyncTaskResponseBody> body{};

  DeleteAsyncTaskResponse() {}

  explicit DeleteAsyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAsyncTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAsyncTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAsyncTaskResponse() = default;
};
class DeleteAutoCcBlacklistRequest : public Darabonba::Model {
public:
  shared_ptr<string> blacklist{};
  shared_ptr<string> instanceId{};

  DeleteAutoCcBlacklistRequest() {}

  explicit DeleteAutoCcBlacklistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blacklist) {
      res["Blacklist"] = boost::any(*blacklist);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Blacklist") != m.end() && !m["Blacklist"].empty()) {
      blacklist = make_shared<string>(boost::any_cast<string>(m["Blacklist"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteAutoCcBlacklistRequest() = default;
};
class DeleteAutoCcBlacklistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAutoCcBlacklistResponseBody() {}

  explicit DeleteAutoCcBlacklistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAutoCcBlacklistResponseBody() = default;
};
class DeleteAutoCcBlacklistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAutoCcBlacklistResponseBody> body{};

  DeleteAutoCcBlacklistResponse() {}

  explicit DeleteAutoCcBlacklistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAutoCcBlacklistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAutoCcBlacklistResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAutoCcBlacklistResponse() = default;
};
class DeleteAutoCcWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> whitelist{};

  DeleteAutoCcWhitelistRequest() {}

  explicit DeleteAutoCcWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (whitelist) {
      res["Whitelist"] = boost::any(*whitelist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Whitelist") != m.end() && !m["Whitelist"].empty()) {
      whitelist = make_shared<string>(boost::any_cast<string>(m["Whitelist"]));
    }
  }


  virtual ~DeleteAutoCcWhitelistRequest() = default;
};
class DeleteAutoCcWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAutoCcWhitelistResponseBody() {}

  explicit DeleteAutoCcWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAutoCcWhitelistResponseBody() = default;
};
class DeleteAutoCcWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAutoCcWhitelistResponseBody> body{};

  DeleteAutoCcWhitelistResponse() {}

  explicit DeleteAutoCcWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAutoCcWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAutoCcWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAutoCcWhitelistResponse() = default;
};
class DeleteDomainResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};

  DeleteDomainResourceRequest() {}

  explicit DeleteDomainResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
  }


  virtual ~DeleteDomainResourceRequest() = default;
};
class DeleteDomainResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainResourceResponseBody() {}

  explicit DeleteDomainResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainResourceResponseBody() = default;
};
class DeleteDomainResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainResourceResponseBody> body{};

  DeleteDomainResourceResponse() {}

  explicit DeleteDomainResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainResourceResponse() = default;
};
class DeleteNetworkRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkRule{};

  DeleteNetworkRuleRequest() {}

  explicit DeleteNetworkRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkRule) {
      res["NetworkRule"] = boost::any(*networkRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkRule") != m.end() && !m["NetworkRule"].empty()) {
      networkRule = make_shared<string>(boost::any_cast<string>(m["NetworkRule"]));
    }
  }


  virtual ~DeleteNetworkRuleRequest() = default;
};
class DeleteNetworkRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkRuleResponseBody() {}

  explicit DeleteNetworkRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkRuleResponseBody() = default;
};
class DeleteNetworkRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkRuleResponseBody> body{};

  DeleteNetworkRuleResponse() {}

  explicit DeleteNetworkRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkRuleResponse() = default;
};
class DeletePortRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendPort{};
  shared_ptr<string> frontendPort{};
  shared_ptr<string> frontendProtocol{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> realServers{};

  DeletePortRequest() {}

  explicit DeletePortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendPort) {
      res["BackendPort"] = boost::any(*backendPort);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (frontendProtocol) {
      res["FrontendProtocol"] = boost::any(*frontendProtocol);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (realServers) {
      res["RealServers"] = boost::any(*realServers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendPort") != m.end() && !m["BackendPort"].empty()) {
      backendPort = make_shared<string>(boost::any_cast<string>(m["BackendPort"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<string>(boost::any_cast<string>(m["FrontendPort"]));
    }
    if (m.find("FrontendProtocol") != m.end() && !m["FrontendProtocol"].empty()) {
      frontendProtocol = make_shared<string>(boost::any_cast<string>(m["FrontendProtocol"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RealServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      realServers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeletePortRequest() = default;
};
class DeletePortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePortResponseBody() {}

  explicit DeletePortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePortResponseBody() = default;
};
class DeletePortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePortResponseBody> body{};

  DeletePortResponse() {}

  explicit DeletePortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePortResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePortResponse() = default;
};
class DeleteSceneDefensePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> policyId{};

  DeleteSceneDefensePolicyRequest() {}

  explicit DeleteSceneDefensePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
  }


  virtual ~DeleteSceneDefensePolicyRequest() = default;
};
class DeleteSceneDefensePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSceneDefensePolicyResponseBody() {}

  explicit DeleteSceneDefensePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSceneDefensePolicyResponseBody() = default;
};
class DeleteSceneDefensePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSceneDefensePolicyResponseBody> body{};

  DeleteSceneDefensePolicyResponse() {}

  explicit DeleteSceneDefensePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSceneDefensePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSceneDefensePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSceneDefensePolicyResponse() = default;
};
class DeleteSchedulerRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> ruleName{};

  DeleteSchedulerRuleRequest() {}

  explicit DeleteSchedulerRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~DeleteSchedulerRuleRequest() = default;
};
class DeleteSchedulerRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSchedulerRuleResponseBody() {}

  explicit DeleteSchedulerRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSchedulerRuleResponseBody() = default;
};
class DeleteSchedulerRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSchedulerRuleResponseBody> body{};

  DeleteSchedulerRuleResponse() {}

  explicit DeleteSchedulerRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSchedulerRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSchedulerRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSchedulerRuleResponse() = default;
};
class DeleteTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  DeleteTagResourcesRequest() {}

  explicit DeleteTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteTagResourcesRequest() = default;
};
class DeleteTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTagResourcesResponseBody() {}

  explicit DeleteTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTagResourcesResponseBody() = default;
};
class DeleteTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTagResourcesResponseBody> body{};

  DeleteTagResourcesResponse() {}

  explicit DeleteTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTagResourcesResponse() = default;
};
class DeleteWebCCRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};

  DeleteWebCCRuleRequest() {}

  explicit DeleteWebCCRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DeleteWebCCRuleRequest() = default;
};
class DeleteWebCCRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWebCCRuleResponseBody() {}

  explicit DeleteWebCCRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWebCCRuleResponseBody() = default;
};
class DeleteWebCCRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWebCCRuleResponseBody> body{};

  DeleteWebCCRuleResponse() {}

  explicit DeleteWebCCRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWebCCRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWebCCRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWebCCRuleResponse() = default;
};
class DeleteWebCacheCustomRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> ruleNames{};

  DeleteWebCacheCustomRuleRequest() {}

  explicit DeleteWebCacheCustomRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ruleNames) {
      res["RuleNames"] = boost::any(*ruleNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RuleNames") != m.end() && !m["RuleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteWebCacheCustomRuleRequest() = default;
};
class DeleteWebCacheCustomRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWebCacheCustomRuleResponseBody() {}

  explicit DeleteWebCacheCustomRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWebCacheCustomRuleResponseBody() = default;
};
class DeleteWebCacheCustomRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWebCacheCustomRuleResponseBody> body{};

  DeleteWebCacheCustomRuleResponse() {}

  explicit DeleteWebCacheCustomRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWebCacheCustomRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWebCacheCustomRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWebCacheCustomRuleResponse() = default;
};
class DeleteWebPreciseAccessRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> ruleNames{};

  DeleteWebPreciseAccessRuleRequest() {}

  explicit DeleteWebPreciseAccessRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ruleNames) {
      res["RuleNames"] = boost::any(*ruleNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RuleNames") != m.end() && !m["RuleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteWebPreciseAccessRuleRequest() = default;
};
class DeleteWebPreciseAccessRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWebPreciseAccessRuleResponseBody() {}

  explicit DeleteWebPreciseAccessRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWebPreciseAccessRuleResponseBody() = default;
};
class DeleteWebPreciseAccessRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWebPreciseAccessRuleResponseBody> body{};

  DeleteWebPreciseAccessRuleResponse() {}

  explicit DeleteWebPreciseAccessRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWebPreciseAccessRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWebPreciseAccessRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWebPreciseAccessRuleResponse() = default;
};
class DeleteWebRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  DeleteWebRuleRequest() {}

  explicit DeleteWebRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DeleteWebRuleRequest() = default;
};
class DeleteWebRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWebRuleResponseBody() {}

  explicit DeleteWebRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWebRuleResponseBody() = default;
};
class DeleteWebRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWebRuleResponseBody> body{};

  DeleteWebRuleResponse() {}

  explicit DeleteWebRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWebRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWebRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWebRuleResponse() = default;
};
class DescribeAsyncTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  DescribeAsyncTasksRequest() {}

  explicit DescribeAsyncTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeAsyncTasksRequest() = default;
};
class DescribeAsyncTasksResponseBodyAsyncTasks : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskParams{};
  shared_ptr<string> taskResult{};
  shared_ptr<long> taskStatus{};
  shared_ptr<long> taskType{};

  DescribeAsyncTasksResponseBodyAsyncTasks() {}

  explicit DescribeAsyncTasksResponseBodyAsyncTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskParams) {
      res["TaskParams"] = boost::any(*taskParams);
    }
    if (taskResult) {
      res["TaskResult"] = boost::any(*taskResult);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskParams") != m.end() && !m["TaskParams"].empty()) {
      taskParams = make_shared<string>(boost::any_cast<string>(m["TaskParams"]));
    }
    if (m.find("TaskResult") != m.end() && !m["TaskResult"].empty()) {
      taskResult = make_shared<string>(boost::any_cast<string>(m["TaskResult"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
  }


  virtual ~DescribeAsyncTasksResponseBodyAsyncTasks() = default;
};
class DescribeAsyncTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAsyncTasksResponseBodyAsyncTasks>> asyncTasks{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAsyncTasksResponseBody() {}

  explicit DescribeAsyncTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTasks) {
      vector<boost::any> temp1;
      for(auto item1:*asyncTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AsyncTasks"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTasks") != m.end() && !m["AsyncTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["AsyncTasks"].type()) {
        vector<DescribeAsyncTasksResponseBodyAsyncTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AsyncTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAsyncTasksResponseBodyAsyncTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        asyncTasks = make_shared<vector<DescribeAsyncTasksResponseBodyAsyncTasks>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAsyncTasksResponseBody() = default;
};
class DescribeAsyncTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAsyncTasksResponseBody> body{};

  DescribeAsyncTasksResponse() {}

  explicit DescribeAsyncTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAsyncTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAsyncTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAsyncTasksResponse() = default;
};
class DescribeAttackAnalysisMaxQpsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  DescribeAttackAnalysisMaxQpsRequest() {}

  explicit DescribeAttackAnalysisMaxQpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeAttackAnalysisMaxQpsRequest() = default;
};
class DescribeAttackAnalysisMaxQpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> qps{};
  shared_ptr<string> requestId{};

  DescribeAttackAnalysisMaxQpsResponseBody() {}

  explicit DescribeAttackAnalysisMaxQpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<long>(boost::any_cast<long>(m["Qps"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAttackAnalysisMaxQpsResponseBody() = default;
};
class DescribeAttackAnalysisMaxQpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAttackAnalysisMaxQpsResponseBody> body{};

  DescribeAttackAnalysisMaxQpsResponse() {}

  explicit DescribeAttackAnalysisMaxQpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAttackAnalysisMaxQpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAttackAnalysisMaxQpsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAttackAnalysisMaxQpsResponse() = default;
};
class DescribeAutoCcBlacklistRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> keyWord{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAutoCcBlacklistRequest() {}

  explicit DescribeAutoCcBlacklistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAutoCcBlacklistRequest() = default;
};
class DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist : public Darabonba::Model {
public:
  shared_ptr<string> destIp{};
  shared_ptr<long> endTime{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist() {}

  explicit DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destIp) {
      res["DestIp"] = boost::any(*destIp);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestIp") != m.end() && !m["DestIp"].empty()) {
      destIp = make_shared<string>(boost::any_cast<string>(m["DestIp"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist() = default;
};
class DescribeAutoCcBlacklistResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist>> autoCcBlacklist{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAutoCcBlacklistResponseBody() {}

  explicit DescribeAutoCcBlacklistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoCcBlacklist) {
      vector<boost::any> temp1;
      for(auto item1:*autoCcBlacklist){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoCcBlacklist"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoCcBlacklist") != m.end() && !m["AutoCcBlacklist"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoCcBlacklist"].type()) {
        vector<DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoCcBlacklist"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoCcBlacklist = make_shared<vector<DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAutoCcBlacklistResponseBody() = default;
};
class DescribeAutoCcBlacklistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAutoCcBlacklistResponseBody> body{};

  DescribeAutoCcBlacklistResponse() {}

  explicit DescribeAutoCcBlacklistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoCcBlacklistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoCcBlacklistResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoCcBlacklistResponse() = default;
};
class DescribeAutoCcListCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> queryType{};

  DescribeAutoCcListCountRequest() {}

  explicit DescribeAutoCcListCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
  }


  virtual ~DescribeAutoCcListCountRequest() = default;
};
class DescribeAutoCcListCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> blackCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> whiteCount{};

  DescribeAutoCcListCountResponseBody() {}

  explicit DescribeAutoCcListCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackCount) {
      res["BlackCount"] = boost::any(*blackCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (whiteCount) {
      res["WhiteCount"] = boost::any(*whiteCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackCount") != m.end() && !m["BlackCount"].empty()) {
      blackCount = make_shared<long>(boost::any_cast<long>(m["BlackCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WhiteCount") != m.end() && !m["WhiteCount"].empty()) {
      whiteCount = make_shared<long>(boost::any_cast<long>(m["WhiteCount"]));
    }
  }


  virtual ~DescribeAutoCcListCountResponseBody() = default;
};
class DescribeAutoCcListCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAutoCcListCountResponseBody> body{};

  DescribeAutoCcListCountResponse() {}

  explicit DescribeAutoCcListCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoCcListCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoCcListCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoCcListCountResponse() = default;
};
class DescribeAutoCcWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> keyWord{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAutoCcWhitelistRequest() {}

  explicit DescribeAutoCcWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAutoCcWhitelistRequest() = default;
};
class DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist : public Darabonba::Model {
public:
  shared_ptr<string> destIp{};
  shared_ptr<long> endTime{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist() {}

  explicit DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destIp) {
      res["DestIp"] = boost::any(*destIp);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestIp") != m.end() && !m["DestIp"].empty()) {
      destIp = make_shared<string>(boost::any_cast<string>(m["DestIp"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist() = default;
};
class DescribeAutoCcWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist>> autoCcWhitelist{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAutoCcWhitelistResponseBody() {}

  explicit DescribeAutoCcWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoCcWhitelist) {
      vector<boost::any> temp1;
      for(auto item1:*autoCcWhitelist){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoCcWhitelist"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoCcWhitelist") != m.end() && !m["AutoCcWhitelist"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoCcWhitelist"].type()) {
        vector<DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoCcWhitelist"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoCcWhitelist = make_shared<vector<DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAutoCcWhitelistResponseBody() = default;
};
class DescribeAutoCcWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAutoCcWhitelistResponseBody> body{};

  DescribeAutoCcWhitelistResponse() {}

  explicit DescribeAutoCcWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoCcWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoCcWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoCcWhitelistResponse() = default;
};
class DescribeBackSourceCidrRequest : public Darabonba::Model {
public:
  shared_ptr<string> line{};
  shared_ptr<string> resourceGroupId{};

  DescribeBackSourceCidrRequest() {}

  explicit DescribeBackSourceCidrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeBackSourceCidrRequest() = default;
};
class DescribeBackSourceCidrResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cidrs{};
  shared_ptr<string> requestId{};

  DescribeBackSourceCidrResponseBody() {}

  explicit DescribeBackSourceCidrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrs) {
      res["Cidrs"] = boost::any(*cidrs);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidrs") != m.end() && !m["Cidrs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Cidrs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Cidrs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cidrs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackSourceCidrResponseBody() = default;
};
class DescribeBackSourceCidrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackSourceCidrResponseBody> body{};

  DescribeBackSourceCidrResponse() {}

  explicit DescribeBackSourceCidrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackSourceCidrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackSourceCidrResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackSourceCidrResponse() = default;
};
class DescribeBlackholeStatusRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  DescribeBlackholeStatusRequest() {}

  explicit DescribeBlackholeStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeBlackholeStatusRequest() = default;
};
class DescribeBlackholeStatusResponseBodyBlackholeStatus : public Darabonba::Model {
public:
  shared_ptr<string> blackStatus{};
  shared_ptr<long> endTime{};
  shared_ptr<string> ip{};
  shared_ptr<long> startTime{};

  DescribeBlackholeStatusResponseBodyBlackholeStatus() {}

  explicit DescribeBlackholeStatusResponseBodyBlackholeStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackStatus) {
      res["BlackStatus"] = boost::any(*blackStatus);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackStatus") != m.end() && !m["BlackStatus"].empty()) {
      blackStatus = make_shared<string>(boost::any_cast<string>(m["BlackStatus"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeBlackholeStatusResponseBodyBlackholeStatus() = default;
};
class DescribeBlackholeStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBlackholeStatusResponseBodyBlackholeStatus>> blackholeStatus{};
  shared_ptr<string> requestId{};

  DescribeBlackholeStatusResponseBody() {}

  explicit DescribeBlackholeStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackholeStatus) {
      vector<boost::any> temp1;
      for(auto item1:*blackholeStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BlackholeStatus"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackholeStatus") != m.end() && !m["BlackholeStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["BlackholeStatus"].type()) {
        vector<DescribeBlackholeStatusResponseBodyBlackholeStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BlackholeStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlackholeStatusResponseBodyBlackholeStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        blackholeStatus = make_shared<vector<DescribeBlackholeStatusResponseBodyBlackholeStatus>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBlackholeStatusResponseBody() = default;
};
class DescribeBlackholeStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlackholeStatusResponseBody> body{};

  DescribeBlackholeStatusResponse() {}

  explicit DescribeBlackholeStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlackholeStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlackholeStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlackholeStatusResponse() = default;
};
class DescribeBlockStatusRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> resourceGroupId{};

  DescribeBlockStatusRequest() {}

  explicit DescribeBlockStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeBlockStatusRequest() = default;
};
class DescribeBlockStatusResponseBodyStatusListBlockStatusList : public Darabonba::Model {
public:
  shared_ptr<string> blockStatus{};
  shared_ptr<long> endTime{};
  shared_ptr<string> line{};
  shared_ptr<long> startTime{};

  DescribeBlockStatusResponseBodyStatusListBlockStatusList() {}

  explicit DescribeBlockStatusResponseBodyStatusListBlockStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockStatus) {
      res["BlockStatus"] = boost::any(*blockStatus);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockStatus") != m.end() && !m["BlockStatus"].empty()) {
      blockStatus = make_shared<string>(boost::any_cast<string>(m["BlockStatus"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeBlockStatusResponseBodyStatusListBlockStatusList() = default;
};
class DescribeBlockStatusResponseBodyStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBlockStatusResponseBodyStatusListBlockStatusList>> blockStatusList{};
  shared_ptr<string> ip{};

  DescribeBlockStatusResponseBodyStatusList() {}

  explicit DescribeBlockStatusResponseBodyStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockStatusList) {
      vector<boost::any> temp1;
      for(auto item1:*blockStatusList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BlockStatusList"] = boost::any(temp1);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockStatusList") != m.end() && !m["BlockStatusList"].empty()) {
      if (typeid(vector<boost::any>) == m["BlockStatusList"].type()) {
        vector<DescribeBlockStatusResponseBodyStatusListBlockStatusList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BlockStatusList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockStatusResponseBodyStatusListBlockStatusList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        blockStatusList = make_shared<vector<DescribeBlockStatusResponseBodyStatusListBlockStatusList>>(expect1);
      }
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~DescribeBlockStatusResponseBodyStatusList() = default;
};
class DescribeBlockStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeBlockStatusResponseBodyStatusList>> statusList{};

  DescribeBlockStatusResponseBody() {}

  explicit DescribeBlockStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusList) {
      vector<boost::any> temp1;
      for(auto item1:*statusList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatusList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<DescribeBlockStatusResponseBodyStatusList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatusList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockStatusResponseBodyStatusList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statusList = make_shared<vector<DescribeBlockStatusResponseBodyStatusList>>(expect1);
      }
    }
  }


  virtual ~DescribeBlockStatusResponseBody() = default;
};
class DescribeBlockStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockStatusResponseBody> body{};

  DescribeBlockStatusResponse() {}

  explicit DescribeBlockStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockStatusResponse() = default;
};
class DescribeCertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  DescribeCertsRequest() {}

  explicit DescribeCertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeCertsRequest() = default;
};
class DescribeCertsResponseBodyCerts : public Darabonba::Model {
public:
  shared_ptr<string> common{};
  shared_ptr<bool> domainRelated{};
  shared_ptr<string> endDate{};
  shared_ptr<long> id{};
  shared_ptr<string> issuer{};
  shared_ptr<string> name{};
  shared_ptr<string> startDate{};

  DescribeCertsResponseBodyCerts() {}

  explicit DescribeCertsResponseBodyCerts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (domainRelated) {
      res["DomainRelated"] = boost::any(*domainRelated);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
    if (m.find("DomainRelated") != m.end() && !m["DomainRelated"].empty()) {
      domainRelated = make_shared<bool>(boost::any_cast<bool>(m["DomainRelated"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribeCertsResponseBodyCerts() = default;
};
class DescribeCertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCertsResponseBodyCerts>> certs{};
  shared_ptr<string> requestId{};

  DescribeCertsResponseBody() {}

  explicit DescribeCertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certs) {
      vector<boost::any> temp1;
      for(auto item1:*certs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certs") != m.end() && !m["Certs"].empty()) {
      if (typeid(vector<boost::any>) == m["Certs"].type()) {
        vector<DescribeCertsResponseBodyCerts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCertsResponseBodyCerts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certs = make_shared<vector<DescribeCertsResponseBodyCerts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCertsResponseBody() = default;
};
class DescribeCertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCertsResponseBody> body{};

  DescribeCertsResponse() {}

  explicit DescribeCertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCertsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCertsResponse() = default;
};
class DescribeCnameReusesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> resourceGroupId{};

  DescribeCnameReusesRequest() {}

  explicit DescribeCnameReusesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeCnameReusesRequest() = default;
};
class DescribeCnameReusesResponseBodyCnameReuses : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> domain{};
  shared_ptr<long> enable{};

  DescribeCnameReusesResponseBodyCnameReuses() {}

  explicit DescribeCnameReusesResponseBodyCnameReuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<long>(boost::any_cast<long>(m["Enable"]));
    }
  }


  virtual ~DescribeCnameReusesResponseBodyCnameReuses() = default;
};
class DescribeCnameReusesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCnameReusesResponseBodyCnameReuses>> cnameReuses{};
  shared_ptr<string> requestId{};

  DescribeCnameReusesResponseBody() {}

  explicit DescribeCnameReusesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cnameReuses) {
      vector<boost::any> temp1;
      for(auto item1:*cnameReuses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CnameReuses"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CnameReuses") != m.end() && !m["CnameReuses"].empty()) {
      if (typeid(vector<boost::any>) == m["CnameReuses"].type()) {
        vector<DescribeCnameReusesResponseBodyCnameReuses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CnameReuses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCnameReusesResponseBodyCnameReuses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cnameReuses = make_shared<vector<DescribeCnameReusesResponseBodyCnameReuses>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCnameReusesResponseBody() = default;
};
class DescribeCnameReusesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCnameReusesResponseBody> body{};

  DescribeCnameReusesResponse() {}

  explicit DescribeCnameReusesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCnameReusesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCnameReusesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCnameReusesResponse() = default;
};
class DescribeDDoSEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDDoSEventsRequest() {}

  explicit DescribeDDoSEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDDoSEventsRequest() = default;
};
class DescribeDDoSEventsResponseBodyDDoSEvents : public Darabonba::Model {
public:
  shared_ptr<long> bps{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<string> ip{};
  shared_ptr<string> port{};
  shared_ptr<long> pps{};
  shared_ptr<string> region{};
  shared_ptr<long> startTime{};

  DescribeDDoSEventsResponseBodyDDoSEvents() {}

  explicit DescribeDDoSEventsResponseBodyDDoSEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (pps) {
      res["Pps"] = boost::any(*pps);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<long>(boost::any_cast<long>(m["Bps"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Pps") != m.end() && !m["Pps"].empty()) {
      pps = make_shared<long>(boost::any_cast<long>(m["Pps"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDDoSEventsResponseBodyDDoSEvents() = default;
};
class DescribeDDoSEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDDoSEventsResponseBodyDDoSEvents>> DDoSEvents{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeDDoSEventsResponseBody() {}

  explicit DescribeDDoSEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DDoSEvents) {
      vector<boost::any> temp1;
      for(auto item1:*DDoSEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DDoSEvents"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DDoSEvents") != m.end() && !m["DDoSEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["DDoSEvents"].type()) {
        vector<DescribeDDoSEventsResponseBodyDDoSEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DDoSEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDDoSEventsResponseBodyDDoSEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DDoSEvents = make_shared<vector<DescribeDDoSEventsResponseBodyDDoSEvents>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeDDoSEventsResponseBody() = default;
};
class DescribeDDoSEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDDoSEventsResponseBody> body{};

  DescribeDDoSEventsResponse() {}

  explicit DescribeDDoSEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDDoSEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDDoSEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDDoSEventsResponse() = default;
};
class DescribeDDosAllEventListRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  DescribeDDosAllEventListRequest() {}

  explicit DescribeDDosAllEventListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDDosAllEventListRequest() = default;
};
class DescribeDDosAllEventListResponseBodyAttackEvents : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<string> ip{};
  shared_ptr<long> mbps{};
  shared_ptr<string> port{};
  shared_ptr<long> pps{};
  shared_ptr<long> startTime{};

  DescribeDDosAllEventListResponseBodyAttackEvents() {}

  explicit DescribeDDosAllEventListResponseBodyAttackEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (mbps) {
      res["Mbps"] = boost::any(*mbps);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (pps) {
      res["Pps"] = boost::any(*pps);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Mbps") != m.end() && !m["Mbps"].empty()) {
      mbps = make_shared<long>(boost::any_cast<long>(m["Mbps"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Pps") != m.end() && !m["Pps"].empty()) {
      pps = make_shared<long>(boost::any_cast<long>(m["Pps"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDDosAllEventListResponseBodyAttackEvents() = default;
};
class DescribeDDosAllEventListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDDosAllEventListResponseBodyAttackEvents>> attackEvents{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeDDosAllEventListResponseBody() {}

  explicit DescribeDDosAllEventListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attackEvents) {
      vector<boost::any> temp1;
      for(auto item1:*attackEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttackEvents"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttackEvents") != m.end() && !m["AttackEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["AttackEvents"].type()) {
        vector<DescribeDDosAllEventListResponseBodyAttackEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttackEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDDosAllEventListResponseBodyAttackEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attackEvents = make_shared<vector<DescribeDDosAllEventListResponseBodyAttackEvents>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeDDosAllEventListResponseBody() = default;
};
class DescribeDDosAllEventListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDDosAllEventListResponseBody> body{};

  DescribeDDosAllEventListResponse() {}

  explicit DescribeDDosAllEventListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDDosAllEventListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDDosAllEventListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDDosAllEventListResponse() = default;
};
class DescribeDDosEventAreaRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventType{};
  shared_ptr<string> ip{};
  shared_ptr<long> startTime{};

  DescribeDDosEventAreaRequest() {}

  explicit DescribeDDosEventAreaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDDosEventAreaRequest() = default;
};
class DescribeDDosEventAreaResponseBodyAreas : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<long> inPkts{};

  DescribeDDosEventAreaResponseBodyAreas() {}

  explicit DescribeDDosEventAreaResponseBodyAreas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (inPkts) {
      res["InPkts"] = boost::any(*inPkts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("InPkts") != m.end() && !m["InPkts"].empty()) {
      inPkts = make_shared<long>(boost::any_cast<long>(m["InPkts"]));
    }
  }


  virtual ~DescribeDDosEventAreaResponseBodyAreas() = default;
};
class DescribeDDosEventAreaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDDosEventAreaResponseBodyAreas>> areas{};
  shared_ptr<string> requestId{};

  DescribeDDosEventAreaResponseBody() {}

  explicit DescribeDDosEventAreaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areas) {
      vector<boost::any> temp1;
      for(auto item1:*areas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Areas"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Areas") != m.end() && !m["Areas"].empty()) {
      if (typeid(vector<boost::any>) == m["Areas"].type()) {
        vector<DescribeDDosEventAreaResponseBodyAreas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Areas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDDosEventAreaResponseBodyAreas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        areas = make_shared<vector<DescribeDDosEventAreaResponseBodyAreas>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDDosEventAreaResponseBody() = default;
};
class DescribeDDosEventAreaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDDosEventAreaResponseBody> body{};

  DescribeDDosEventAreaResponse() {}

  explicit DescribeDDosEventAreaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDDosEventAreaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDDosEventAreaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDDosEventAreaResponse() = default;
};
class DescribeDDosEventAttackTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventType{};
  shared_ptr<string> ip{};
  shared_ptr<long> startTime{};

  DescribeDDosEventAttackTypeRequest() {}

  explicit DescribeDDosEventAttackTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDDosEventAttackTypeRequest() = default;
};
class DescribeDDosEventAttackTypeResponseBodyAttackTypes : public Darabonba::Model {
public:
  shared_ptr<string> attackType{};
  shared_ptr<long> inPkts{};

  DescribeDDosEventAttackTypeResponseBodyAttackTypes() {}

  explicit DescribeDDosEventAttackTypeResponseBodyAttackTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attackType) {
      res["AttackType"] = boost::any(*attackType);
    }
    if (inPkts) {
      res["InPkts"] = boost::any(*inPkts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttackType") != m.end() && !m["AttackType"].empty()) {
      attackType = make_shared<string>(boost::any_cast<string>(m["AttackType"]));
    }
    if (m.find("InPkts") != m.end() && !m["InPkts"].empty()) {
      inPkts = make_shared<long>(boost::any_cast<long>(m["InPkts"]));
    }
  }


  virtual ~DescribeDDosEventAttackTypeResponseBodyAttackTypes() = default;
};
class DescribeDDosEventAttackTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDDosEventAttackTypeResponseBodyAttackTypes>> attackTypes{};
  shared_ptr<string> requestId{};

  DescribeDDosEventAttackTypeResponseBody() {}

  explicit DescribeDDosEventAttackTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attackTypes) {
      vector<boost::any> temp1;
      for(auto item1:*attackTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttackTypes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttackTypes") != m.end() && !m["AttackTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["AttackTypes"].type()) {
        vector<DescribeDDosEventAttackTypeResponseBodyAttackTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttackTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDDosEventAttackTypeResponseBodyAttackTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attackTypes = make_shared<vector<DescribeDDosEventAttackTypeResponseBodyAttackTypes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDDosEventAttackTypeResponseBody() = default;
};
class DescribeDDosEventAttackTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDDosEventAttackTypeResponseBody> body{};

  DescribeDDosEventAttackTypeResponse() {}

  explicit DescribeDDosEventAttackTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDDosEventAttackTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDDosEventAttackTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDDosEventAttackTypeResponse() = default;
};
class DescribeDDosEventIspRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventType{};
  shared_ptr<string> ip{};
  shared_ptr<long> startTime{};

  DescribeDDosEventIspRequest() {}

  explicit DescribeDDosEventIspRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDDosEventIspRequest() = default;
};
class DescribeDDosEventIspResponseBodyIsps : public Darabonba::Model {
public:
  shared_ptr<long> inPkts{};
  shared_ptr<string> isp{};

  DescribeDDosEventIspResponseBodyIsps() {}

  explicit DescribeDDosEventIspResponseBodyIsps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inPkts) {
      res["InPkts"] = boost::any(*inPkts);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InPkts") != m.end() && !m["InPkts"].empty()) {
      inPkts = make_shared<long>(boost::any_cast<long>(m["InPkts"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
  }


  virtual ~DescribeDDosEventIspResponseBodyIsps() = default;
};
class DescribeDDosEventIspResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDDosEventIspResponseBodyIsps>> isps{};
  shared_ptr<string> requestId{};

  DescribeDDosEventIspResponseBody() {}

  explicit DescribeDDosEventIspResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isps) {
      vector<boost::any> temp1;
      for(auto item1:*isps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Isps"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Isps") != m.end() && !m["Isps"].empty()) {
      if (typeid(vector<boost::any>) == m["Isps"].type()) {
        vector<DescribeDDosEventIspResponseBodyIsps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Isps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDDosEventIspResponseBodyIsps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        isps = make_shared<vector<DescribeDDosEventIspResponseBodyIsps>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDDosEventIspResponseBody() = default;
};
class DescribeDDosEventIspResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDDosEventIspResponseBody> body{};

  DescribeDDosEventIspResponse() {}

  explicit DescribeDDosEventIspResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDDosEventIspResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDDosEventIspResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDDosEventIspResponse() = default;
};
class DescribeDDosEventMaxRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  DescribeDDosEventMaxRequest() {}

  explicit DescribeDDosEventMaxRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDDosEventMaxRequest() = default;
};
class DescribeDDosEventMaxResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> cps{};
  shared_ptr<long> mbps{};
  shared_ptr<long> qps{};
  shared_ptr<string> requestId{};

  DescribeDDosEventMaxResponseBody() {}

  explicit DescribeDDosEventMaxResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cps) {
      res["Cps"] = boost::any(*cps);
    }
    if (mbps) {
      res["Mbps"] = boost::any(*mbps);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cps") != m.end() && !m["Cps"].empty()) {
      cps = make_shared<long>(boost::any_cast<long>(m["Cps"]));
    }
    if (m.find("Mbps") != m.end() && !m["Mbps"].empty()) {
      mbps = make_shared<long>(boost::any_cast<long>(m["Mbps"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<long>(boost::any_cast<long>(m["Qps"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDDosEventMaxResponseBody() = default;
};
class DescribeDDosEventMaxResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDDosEventMaxResponseBody> body{};

  DescribeDDosEventMaxResponse() {}

  explicit DescribeDDosEventMaxResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDDosEventMaxResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDDosEventMaxResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDDosEventMaxResponse() = default;
};
class DescribeDDosEventSrcIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventType{};
  shared_ptr<string> ip{};
  shared_ptr<long> range{};
  shared_ptr<long> startTime{};

  DescribeDDosEventSrcIpRequest() {}

  explicit DescribeDDosEventSrcIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (range) {
      res["Range"] = boost::any(*range);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      range = make_shared<long>(boost::any_cast<long>(m["Range"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDDosEventSrcIpRequest() = default;
};
class DescribeDDosEventSrcIpResponseBodyIps : public Darabonba::Model {
public:
  shared_ptr<string> areaId{};
  shared_ptr<string> isp{};
  shared_ptr<string> srcIp{};

  DescribeDDosEventSrcIpResponseBodyIps() {}

  explicit DescribeDDosEventSrcIpResponseBodyIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areaId) {
      res["AreaId"] = boost::any(*areaId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (srcIp) {
      res["SrcIp"] = boost::any(*srcIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AreaId") != m.end() && !m["AreaId"].empty()) {
      areaId = make_shared<string>(boost::any_cast<string>(m["AreaId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("SrcIp") != m.end() && !m["SrcIp"].empty()) {
      srcIp = make_shared<string>(boost::any_cast<string>(m["SrcIp"]));
    }
  }


  virtual ~DescribeDDosEventSrcIpResponseBodyIps() = default;
};
class DescribeDDosEventSrcIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDDosEventSrcIpResponseBodyIps>> ips{};
  shared_ptr<string> requestId{};

  DescribeDDosEventSrcIpResponseBody() {}

  explicit DescribeDDosEventSrcIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ips) {
      vector<boost::any> temp1;
      for(auto item1:*ips){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ips"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<DescribeDDosEventSrcIpResponseBodyIps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ips"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDDosEventSrcIpResponseBodyIps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ips = make_shared<vector<DescribeDDosEventSrcIpResponseBodyIps>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDDosEventSrcIpResponseBody() = default;
};
class DescribeDDosEventSrcIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDDosEventSrcIpResponseBody> body{};

  DescribeDDosEventSrcIpResponse() {}

  explicit DescribeDDosEventSrcIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDDosEventSrcIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDDosEventSrcIpResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDDosEventSrcIpResponse() = default;
};
class DescribeDefenseCountStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  DescribeDefenseCountStatisticsRequest() {}

  explicit DescribeDefenseCountStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeDefenseCountStatisticsRequest() = default;
};
class DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics : public Darabonba::Model {
public:
  shared_ptr<long> defenseCountTotalUsageOfCurrentMonth{};
  shared_ptr<long> flowPackCountRemain{};
  shared_ptr<long> maxUsableDefenseCountCurrentMonth{};
  shared_ptr<long> secHighSpeedCountRemain{};

  DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics() {}

  explicit DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseCountTotalUsageOfCurrentMonth) {
      res["DefenseCountTotalUsageOfCurrentMonth"] = boost::any(*defenseCountTotalUsageOfCurrentMonth);
    }
    if (flowPackCountRemain) {
      res["FlowPackCountRemain"] = boost::any(*flowPackCountRemain);
    }
    if (maxUsableDefenseCountCurrentMonth) {
      res["MaxUsableDefenseCountCurrentMonth"] = boost::any(*maxUsableDefenseCountCurrentMonth);
    }
    if (secHighSpeedCountRemain) {
      res["SecHighSpeedCountRemain"] = boost::any(*secHighSpeedCountRemain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseCountTotalUsageOfCurrentMonth") != m.end() && !m["DefenseCountTotalUsageOfCurrentMonth"].empty()) {
      defenseCountTotalUsageOfCurrentMonth = make_shared<long>(boost::any_cast<long>(m["DefenseCountTotalUsageOfCurrentMonth"]));
    }
    if (m.find("FlowPackCountRemain") != m.end() && !m["FlowPackCountRemain"].empty()) {
      flowPackCountRemain = make_shared<long>(boost::any_cast<long>(m["FlowPackCountRemain"]));
    }
    if (m.find("MaxUsableDefenseCountCurrentMonth") != m.end() && !m["MaxUsableDefenseCountCurrentMonth"].empty()) {
      maxUsableDefenseCountCurrentMonth = make_shared<long>(boost::any_cast<long>(m["MaxUsableDefenseCountCurrentMonth"]));
    }
    if (m.find("SecHighSpeedCountRemain") != m.end() && !m["SecHighSpeedCountRemain"].empty()) {
      secHighSpeedCountRemain = make_shared<long>(boost::any_cast<long>(m["SecHighSpeedCountRemain"]));
    }
  }


  virtual ~DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics() = default;
};
class DescribeDefenseCountStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics> defenseCountStatistics{};
  shared_ptr<string> requestId{};

  DescribeDefenseCountStatisticsResponseBody() {}

  explicit DescribeDefenseCountStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseCountStatistics) {
      res["DefenseCountStatistics"] = defenseCountStatistics ? boost::any(defenseCountStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseCountStatistics") != m.end() && !m["DefenseCountStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefenseCountStatistics"].type()) {
        DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefenseCountStatistics"]));
        defenseCountStatistics = make_shared<DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDefenseCountStatisticsResponseBody() = default;
};
class DescribeDefenseCountStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseCountStatisticsResponseBody> body{};

  DescribeDefenseCountStatisticsResponse() {}

  explicit DescribeDefenseCountStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseCountStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseCountStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseCountStatisticsResponse() = default;
};
class DescribeDefenseRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDefenseRecordsRequest() {}

  explicit DescribeDefenseRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDefenseRecordsRequest() = default;
};
class DescribeDefenseRecordsResponseBodyDefenseRecords : public Darabonba::Model {
public:
  shared_ptr<long> attackPeak{};
  shared_ptr<long> endTime{};
  shared_ptr<long> eventCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> status{};

  DescribeDefenseRecordsResponseBodyDefenseRecords() {}

  explicit DescribeDefenseRecordsResponseBodyDefenseRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attackPeak) {
      res["AttackPeak"] = boost::any(*attackPeak);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventCount) {
      res["EventCount"] = boost::any(*eventCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttackPeak") != m.end() && !m["AttackPeak"].empty()) {
      attackPeak = make_shared<long>(boost::any_cast<long>(m["AttackPeak"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EventCount") != m.end() && !m["EventCount"].empty()) {
      eventCount = make_shared<long>(boost::any_cast<long>(m["EventCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeDefenseRecordsResponseBodyDefenseRecords() = default;
};
class DescribeDefenseRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDefenseRecordsResponseBodyDefenseRecords>> defenseRecords{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDefenseRecordsResponseBody() {}

  explicit DescribeDefenseRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseRecords) {
      vector<boost::any> temp1;
      for(auto item1:*defenseRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DefenseRecords"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseRecords") != m.end() && !m["DefenseRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["DefenseRecords"].type()) {
        vector<DescribeDefenseRecordsResponseBodyDefenseRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DefenseRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDefenseRecordsResponseBodyDefenseRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defenseRecords = make_shared<vector<DescribeDefenseRecordsResponseBodyDefenseRecords>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDefenseRecordsResponseBody() = default;
};
class DescribeDefenseRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseRecordsResponseBody> body{};

  DescribeDefenseRecordsResponse() {}

  explicit DescribeDefenseRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseRecordsResponse() = default;
};
class DescribeDomainAttackEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDomainAttackEventsRequest() {}

  explicit DescribeDomainAttackEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainAttackEventsRequest() = default;
};
class DescribeDomainAttackEventsResponseBodyDomainAttackEvents : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<long> maxQps{};
  shared_ptr<long> startTime{};

  DescribeDomainAttackEventsResponseBodyDomainAttackEvents() {}

  explicit DescribeDomainAttackEventsResponseBodyDomainAttackEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (maxQps) {
      res["MaxQps"] = boost::any(*maxQps);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MaxQps") != m.end() && !m["MaxQps"].empty()) {
      maxQps = make_shared<long>(boost::any_cast<long>(m["MaxQps"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainAttackEventsResponseBodyDomainAttackEvents() = default;
};
class DescribeDomainAttackEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainAttackEventsResponseBodyDomainAttackEvents>> domainAttackEvents{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDomainAttackEventsResponseBody() {}

  explicit DescribeDomainAttackEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainAttackEvents) {
      vector<boost::any> temp1;
      for(auto item1:*domainAttackEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainAttackEvents"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainAttackEvents") != m.end() && !m["DomainAttackEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainAttackEvents"].type()) {
        vector<DescribeDomainAttackEventsResponseBodyDomainAttackEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainAttackEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainAttackEventsResponseBodyDomainAttackEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainAttackEvents = make_shared<vector<DescribeDomainAttackEventsResponseBodyDomainAttackEvents>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDomainAttackEventsResponseBody() = default;
};
class DescribeDomainAttackEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainAttackEventsResponseBody> body{};

  DescribeDomainAttackEventsResponse() {}

  explicit DescribeDomainAttackEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainAttackEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainAttackEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainAttackEventsResponse() = default;
};
class DescribeDomainOverviewRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDomainOverviewRequest() {}

  explicit DescribeDomainOverviewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainOverviewRequest() = default;
};
class DescribeDomainOverviewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxHttp{};
  shared_ptr<long> maxHttps{};
  shared_ptr<string> requestId{};

  DescribeDomainOverviewResponseBody() {}

  explicit DescribeDomainOverviewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxHttp) {
      res["MaxHttp"] = boost::any(*maxHttp);
    }
    if (maxHttps) {
      res["MaxHttps"] = boost::any(*maxHttps);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxHttp") != m.end() && !m["MaxHttp"].empty()) {
      maxHttp = make_shared<long>(boost::any_cast<long>(m["MaxHttp"]));
    }
    if (m.find("MaxHttps") != m.end() && !m["MaxHttps"].empty()) {
      maxHttps = make_shared<long>(boost::any_cast<long>(m["MaxHttps"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainOverviewResponseBody() = default;
};
class DescribeDomainOverviewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainOverviewResponseBody> body{};

  DescribeDomainOverviewResponse() {}

  explicit DescribeDomainOverviewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainOverviewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainOverviewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainOverviewResponse() = default;
};
class DescribeDomainQPSListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<long> interval{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDomainQPSListRequest() {}

  explicit DescribeDomainQPSListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainQPSListRequest() = default;
};
class DescribeDomainQPSListResponseBodyDomainQPSList : public Darabonba::Model {
public:
  shared_ptr<long> attackQps{};
  shared_ptr<long> cacheHits{};
  shared_ptr<long> index{};
  shared_ptr<long> maxAttackQps{};
  shared_ptr<long> maxNormalQps{};
  shared_ptr<long> maxQps{};
  shared_ptr<long> time{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalQps{};

  DescribeDomainQPSListResponseBodyDomainQPSList() {}

  explicit DescribeDomainQPSListResponseBodyDomainQPSList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attackQps) {
      res["AttackQps"] = boost::any(*attackQps);
    }
    if (cacheHits) {
      res["CacheHits"] = boost::any(*cacheHits);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (maxAttackQps) {
      res["MaxAttackQps"] = boost::any(*maxAttackQps);
    }
    if (maxNormalQps) {
      res["MaxNormalQps"] = boost::any(*maxNormalQps);
    }
    if (maxQps) {
      res["MaxQps"] = boost::any(*maxQps);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalQps) {
      res["TotalQps"] = boost::any(*totalQps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttackQps") != m.end() && !m["AttackQps"].empty()) {
      attackQps = make_shared<long>(boost::any_cast<long>(m["AttackQps"]));
    }
    if (m.find("CacheHits") != m.end() && !m["CacheHits"].empty()) {
      cacheHits = make_shared<long>(boost::any_cast<long>(m["CacheHits"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("MaxAttackQps") != m.end() && !m["MaxAttackQps"].empty()) {
      maxAttackQps = make_shared<long>(boost::any_cast<long>(m["MaxAttackQps"]));
    }
    if (m.find("MaxNormalQps") != m.end() && !m["MaxNormalQps"].empty()) {
      maxNormalQps = make_shared<long>(boost::any_cast<long>(m["MaxNormalQps"]));
    }
    if (m.find("MaxQps") != m.end() && !m["MaxQps"].empty()) {
      maxQps = make_shared<long>(boost::any_cast<long>(m["MaxQps"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalQps") != m.end() && !m["TotalQps"].empty()) {
      totalQps = make_shared<long>(boost::any_cast<long>(m["TotalQps"]));
    }
  }


  virtual ~DescribeDomainQPSListResponseBodyDomainQPSList() = default;
};
class DescribeDomainQPSListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainQPSListResponseBodyDomainQPSList>> domainQPSList{};
  shared_ptr<string> requestId{};

  DescribeDomainQPSListResponseBody() {}

  explicit DescribeDomainQPSListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainQPSList) {
      vector<boost::any> temp1;
      for(auto item1:*domainQPSList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainQPSList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainQPSList") != m.end() && !m["DomainQPSList"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainQPSList"].type()) {
        vector<DescribeDomainQPSListResponseBodyDomainQPSList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainQPSList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainQPSListResponseBodyDomainQPSList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainQPSList = make_shared<vector<DescribeDomainQPSListResponseBodyDomainQPSList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainQPSListResponseBody() = default;
};
class DescribeDomainQPSListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainQPSListResponseBody> body{};

  DescribeDomainQPSListResponse() {}

  explicit DescribeDomainQPSListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainQPSListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainQPSListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainQPSListResponse() = default;
};
class DescribeDomainQpsWithCacheRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDomainQpsWithCacheRequest() {}

  explicit DescribeDomainQpsWithCacheRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainQpsWithCacheRequest() = default;
};
class DescribeDomainQpsWithCacheResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> blocks{};
  shared_ptr<vector<string>> cacheHits{};
  shared_ptr<vector<string>> ccBlockQps{};
  shared_ptr<vector<string>> ccJsQps{};
  shared_ptr<long> interval{};
  shared_ptr<vector<string>> ipBlockQps{};
  shared_ptr<vector<string>> preciseBlocks{};
  shared_ptr<vector<string>> preciseJsQps{};
  shared_ptr<vector<string>> regionBlocks{};
  shared_ptr<string> requestId{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<string>> totals{};

  DescribeDomainQpsWithCacheResponseBody() {}

  explicit DescribeDomainQpsWithCacheResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blocks) {
      res["Blocks"] = boost::any(*blocks);
    }
    if (cacheHits) {
      res["CacheHits"] = boost::any(*cacheHits);
    }
    if (ccBlockQps) {
      res["CcBlockQps"] = boost::any(*ccBlockQps);
    }
    if (ccJsQps) {
      res["CcJsQps"] = boost::any(*ccJsQps);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ipBlockQps) {
      res["IpBlockQps"] = boost::any(*ipBlockQps);
    }
    if (preciseBlocks) {
      res["PreciseBlocks"] = boost::any(*preciseBlocks);
    }
    if (preciseJsQps) {
      res["PreciseJsQps"] = boost::any(*preciseJsQps);
    }
    if (regionBlocks) {
      res["RegionBlocks"] = boost::any(*regionBlocks);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totals) {
      res["Totals"] = boost::any(*totals);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Blocks") != m.end() && !m["Blocks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Blocks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Blocks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      blocks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CacheHits") != m.end() && !m["CacheHits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CacheHits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CacheHits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cacheHits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CcBlockQps") != m.end() && !m["CcBlockQps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CcBlockQps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CcBlockQps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ccBlockQps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CcJsQps") != m.end() && !m["CcJsQps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CcJsQps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CcJsQps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ccJsQps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IpBlockQps") != m.end() && !m["IpBlockQps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpBlockQps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpBlockQps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipBlockQps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PreciseBlocks") != m.end() && !m["PreciseBlocks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PreciseBlocks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PreciseBlocks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      preciseBlocks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PreciseJsQps") != m.end() && !m["PreciseJsQps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PreciseJsQps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PreciseJsQps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      preciseJsQps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionBlocks") != m.end() && !m["RegionBlocks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RegionBlocks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RegionBlocks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      regionBlocks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Totals") != m.end() && !m["Totals"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Totals"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Totals"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      totals = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainQpsWithCacheResponseBody() = default;
};
class DescribeDomainQpsWithCacheResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainQpsWithCacheResponseBody> body{};

  DescribeDomainQpsWithCacheResponse() {}

  explicit DescribeDomainQpsWithCacheResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainQpsWithCacheResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainQpsWithCacheResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainQpsWithCacheResponse() = default;
};
class DescribeDomainResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryDomainPattern{};

  DescribeDomainResourceRequest() {}

  explicit DescribeDomainResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryDomainPattern) {
      res["QueryDomainPattern"] = boost::any(*queryDomainPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryDomainPattern") != m.end() && !m["QueryDomainPattern"].empty()) {
      queryDomainPattern = make_shared<string>(boost::any_cast<string>(m["QueryDomainPattern"]));
    }
  }


  virtual ~DescribeDomainResourceRequest() = default;
};
class DescribeDomainResourceResponseBodyWebRulesProxyTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> proxyPorts{};
  shared_ptr<string> proxyType{};

  DescribeDomainResourceResponseBodyWebRulesProxyTypes() {}

  explicit DescribeDomainResourceResponseBodyWebRulesProxyTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyPorts) {
      res["ProxyPorts"] = boost::any(*proxyPorts);
    }
    if (proxyType) {
      res["ProxyType"] = boost::any(*proxyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyPorts") != m.end() && !m["ProxyPorts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProxyPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProxyPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      proxyPorts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProxyType") != m.end() && !m["ProxyType"].empty()) {
      proxyType = make_shared<string>(boost::any_cast<string>(m["ProxyType"]));
    }
  }


  virtual ~DescribeDomainResourceResponseBodyWebRulesProxyTypes() = default;
};
class DescribeDomainResourceResponseBodyWebRules : public Darabonba::Model {
public:
  shared_ptr<vector<string>> blackList{};
  shared_ptr<bool> ccEnabled{};
  shared_ptr<bool> ccRuleEnabled{};
  shared_ptr<string> ccTemplate{};
  shared_ptr<string> certName{};
  shared_ptr<string> cname{};
  shared_ptr<vector<string>> customCiphers{};
  shared_ptr<string> domain{};
  shared_ptr<bool> http2Enable{};
  shared_ptr<bool> http2HttpsEnable{};
  shared_ptr<bool> https2HttpEnable{};
  shared_ptr<string> httpsExt{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> policyMode{};
  shared_ptr<bool> proxyEnabled{};
  shared_ptr<vector<DescribeDomainResourceResponseBodyWebRulesProxyTypes>> proxyTypes{};
  shared_ptr<long> punishReason{};
  shared_ptr<bool> punishStatus{};
  shared_ptr<vector<string>> realServers{};
  shared_ptr<long> rsType{};
  shared_ptr<bool> ssl13Enabled{};
  shared_ptr<string> sslCiphers{};
  shared_ptr<string> sslProtocols{};
  shared_ptr<vector<string>> whiteList{};

  DescribeDomainResourceResponseBodyWebRules() {}

  explicit DescribeDomainResourceResponseBodyWebRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackList) {
      res["BlackList"] = boost::any(*blackList);
    }
    if (ccEnabled) {
      res["CcEnabled"] = boost::any(*ccEnabled);
    }
    if (ccRuleEnabled) {
      res["CcRuleEnabled"] = boost::any(*ccRuleEnabled);
    }
    if (ccTemplate) {
      res["CcTemplate"] = boost::any(*ccTemplate);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (http2Enable) {
      res["Http2Enable"] = boost::any(*http2Enable);
    }
    if (http2HttpsEnable) {
      res["Http2HttpsEnable"] = boost::any(*http2HttpsEnable);
    }
    if (https2HttpEnable) {
      res["Https2HttpEnable"] = boost::any(*https2HttpEnable);
    }
    if (httpsExt) {
      res["HttpsExt"] = boost::any(*httpsExt);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (policyMode) {
      res["PolicyMode"] = boost::any(*policyMode);
    }
    if (proxyEnabled) {
      res["ProxyEnabled"] = boost::any(*proxyEnabled);
    }
    if (proxyTypes) {
      vector<boost::any> temp1;
      for(auto item1:*proxyTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProxyTypes"] = boost::any(temp1);
    }
    if (punishReason) {
      res["PunishReason"] = boost::any(*punishReason);
    }
    if (punishStatus) {
      res["PunishStatus"] = boost::any(*punishStatus);
    }
    if (realServers) {
      res["RealServers"] = boost::any(*realServers);
    }
    if (rsType) {
      res["RsType"] = boost::any(*rsType);
    }
    if (ssl13Enabled) {
      res["Ssl13Enabled"] = boost::any(*ssl13Enabled);
    }
    if (sslCiphers) {
      res["SslCiphers"] = boost::any(*sslCiphers);
    }
    if (sslProtocols) {
      res["SslProtocols"] = boost::any(*sslProtocols);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackList") != m.end() && !m["BlackList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BlackList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BlackList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      blackList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CcEnabled") != m.end() && !m["CcEnabled"].empty()) {
      ccEnabled = make_shared<bool>(boost::any_cast<bool>(m["CcEnabled"]));
    }
    if (m.find("CcRuleEnabled") != m.end() && !m["CcRuleEnabled"].empty()) {
      ccRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["CcRuleEnabled"]));
    }
    if (m.find("CcTemplate") != m.end() && !m["CcTemplate"].empty()) {
      ccTemplate = make_shared<string>(boost::any_cast<string>(m["CcTemplate"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomCiphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomCiphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customCiphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Http2Enable") != m.end() && !m["Http2Enable"].empty()) {
      http2Enable = make_shared<bool>(boost::any_cast<bool>(m["Http2Enable"]));
    }
    if (m.find("Http2HttpsEnable") != m.end() && !m["Http2HttpsEnable"].empty()) {
      http2HttpsEnable = make_shared<bool>(boost::any_cast<bool>(m["Http2HttpsEnable"]));
    }
    if (m.find("Https2HttpEnable") != m.end() && !m["Https2HttpEnable"].empty()) {
      https2HttpEnable = make_shared<bool>(boost::any_cast<bool>(m["Https2HttpEnable"]));
    }
    if (m.find("HttpsExt") != m.end() && !m["HttpsExt"].empty()) {
      httpsExt = make_shared<string>(boost::any_cast<string>(m["HttpsExt"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PolicyMode") != m.end() && !m["PolicyMode"].empty()) {
      policyMode = make_shared<string>(boost::any_cast<string>(m["PolicyMode"]));
    }
    if (m.find("ProxyEnabled") != m.end() && !m["ProxyEnabled"].empty()) {
      proxyEnabled = make_shared<bool>(boost::any_cast<bool>(m["ProxyEnabled"]));
    }
    if (m.find("ProxyTypes") != m.end() && !m["ProxyTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["ProxyTypes"].type()) {
        vector<DescribeDomainResourceResponseBodyWebRulesProxyTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProxyTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainResourceResponseBodyWebRulesProxyTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxyTypes = make_shared<vector<DescribeDomainResourceResponseBodyWebRulesProxyTypes>>(expect1);
      }
    }
    if (m.find("PunishReason") != m.end() && !m["PunishReason"].empty()) {
      punishReason = make_shared<long>(boost::any_cast<long>(m["PunishReason"]));
    }
    if (m.find("PunishStatus") != m.end() && !m["PunishStatus"].empty()) {
      punishStatus = make_shared<bool>(boost::any_cast<bool>(m["PunishStatus"]));
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RealServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      realServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RsType") != m.end() && !m["RsType"].empty()) {
      rsType = make_shared<long>(boost::any_cast<long>(m["RsType"]));
    }
    if (m.find("Ssl13Enabled") != m.end() && !m["Ssl13Enabled"].empty()) {
      ssl13Enabled = make_shared<bool>(boost::any_cast<bool>(m["Ssl13Enabled"]));
    }
    if (m.find("SslCiphers") != m.end() && !m["SslCiphers"].empty()) {
      sslCiphers = make_shared<string>(boost::any_cast<string>(m["SslCiphers"]));
    }
    if (m.find("SslProtocols") != m.end() && !m["SslProtocols"].empty()) {
      sslProtocols = make_shared<string>(boost::any_cast<string>(m["SslProtocols"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whiteList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainResourceResponseBodyWebRules() = default;
};
class DescribeDomainResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeDomainResourceResponseBodyWebRules>> webRules{};

  DescribeDomainResourceResponseBody() {}

  explicit DescribeDomainResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (webRules) {
      vector<boost::any> temp1;
      for(auto item1:*webRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WebRules") != m.end() && !m["WebRules"].empty()) {
      if (typeid(vector<boost::any>) == m["WebRules"].type()) {
        vector<DescribeDomainResourceResponseBodyWebRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainResourceResponseBodyWebRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webRules = make_shared<vector<DescribeDomainResourceResponseBodyWebRules>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainResourceResponseBody() = default;
};
class DescribeDomainResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainResourceResponseBody> body{};

  DescribeDomainResourceResponse() {}

  explicit DescribeDomainResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainResourceResponse() = default;
};
class DescribeDomainStatusCodeCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDomainStatusCodeCountRequest() {}

  explicit DescribeDomainStatusCodeCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainStatusCodeCountRequest() = default;
};
class DescribeDomainStatusCodeCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> status200{};
  shared_ptr<long> status2XX{};
  shared_ptr<long> status3XX{};
  shared_ptr<long> status403{};
  shared_ptr<long> status404{};
  shared_ptr<long> status405{};
  shared_ptr<long> status4XX{};
  shared_ptr<long> status501{};
  shared_ptr<long> status502{};
  shared_ptr<long> status503{};
  shared_ptr<long> status504{};
  shared_ptr<long> status5XX{};

  DescribeDomainStatusCodeCountResponseBody() {}

  explicit DescribeDomainStatusCodeCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status200) {
      res["Status200"] = boost::any(*status200);
    }
    if (status2XX) {
      res["Status2XX"] = boost::any(*status2XX);
    }
    if (status3XX) {
      res["Status3XX"] = boost::any(*status3XX);
    }
    if (status403) {
      res["Status403"] = boost::any(*status403);
    }
    if (status404) {
      res["Status404"] = boost::any(*status404);
    }
    if (status405) {
      res["Status405"] = boost::any(*status405);
    }
    if (status4XX) {
      res["Status4XX"] = boost::any(*status4XX);
    }
    if (status501) {
      res["Status501"] = boost::any(*status501);
    }
    if (status502) {
      res["Status502"] = boost::any(*status502);
    }
    if (status503) {
      res["Status503"] = boost::any(*status503);
    }
    if (status504) {
      res["Status504"] = boost::any(*status504);
    }
    if (status5XX) {
      res["Status5XX"] = boost::any(*status5XX);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status200") != m.end() && !m["Status200"].empty()) {
      status200 = make_shared<long>(boost::any_cast<long>(m["Status200"]));
    }
    if (m.find("Status2XX") != m.end() && !m["Status2XX"].empty()) {
      status2XX = make_shared<long>(boost::any_cast<long>(m["Status2XX"]));
    }
    if (m.find("Status3XX") != m.end() && !m["Status3XX"].empty()) {
      status3XX = make_shared<long>(boost::any_cast<long>(m["Status3XX"]));
    }
    if (m.find("Status403") != m.end() && !m["Status403"].empty()) {
      status403 = make_shared<long>(boost::any_cast<long>(m["Status403"]));
    }
    if (m.find("Status404") != m.end() && !m["Status404"].empty()) {
      status404 = make_shared<long>(boost::any_cast<long>(m["Status404"]));
    }
    if (m.find("Status405") != m.end() && !m["Status405"].empty()) {
      status405 = make_shared<long>(boost::any_cast<long>(m["Status405"]));
    }
    if (m.find("Status4XX") != m.end() && !m["Status4XX"].empty()) {
      status4XX = make_shared<long>(boost::any_cast<long>(m["Status4XX"]));
    }
    if (m.find("Status501") != m.end() && !m["Status501"].empty()) {
      status501 = make_shared<long>(boost::any_cast<long>(m["Status501"]));
    }
    if (m.find("Status502") != m.end() && !m["Status502"].empty()) {
      status502 = make_shared<long>(boost::any_cast<long>(m["Status502"]));
    }
    if (m.find("Status503") != m.end() && !m["Status503"].empty()) {
      status503 = make_shared<long>(boost::any_cast<long>(m["Status503"]));
    }
    if (m.find("Status504") != m.end() && !m["Status504"].empty()) {
      status504 = make_shared<long>(boost::any_cast<long>(m["Status504"]));
    }
    if (m.find("Status5XX") != m.end() && !m["Status5XX"].empty()) {
      status5XX = make_shared<long>(boost::any_cast<long>(m["Status5XX"]));
    }
  }


  virtual ~DescribeDomainStatusCodeCountResponseBody() = default;
};
class DescribeDomainStatusCodeCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainStatusCodeCountResponseBody> body{};

  DescribeDomainStatusCodeCountResponse() {}

  explicit DescribeDomainStatusCodeCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainStatusCodeCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainStatusCodeCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainStatusCodeCountResponse() = default;
};
class DescribeDomainStatusCodeListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<long> interval{};
  shared_ptr<string> queryType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDomainStatusCodeListRequest() {}

  explicit DescribeDomainStatusCodeListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainStatusCodeListRequest() = default;
};
class DescribeDomainStatusCodeListResponseBodyStatusCodeList : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<long> status200{};
  shared_ptr<long> status2XX{};
  shared_ptr<long> status3XX{};
  shared_ptr<long> status403{};
  shared_ptr<long> status404{};
  shared_ptr<long> status405{};
  shared_ptr<long> status4XX{};
  shared_ptr<long> status501{};
  shared_ptr<long> status502{};
  shared_ptr<long> status503{};
  shared_ptr<long> status504{};
  shared_ptr<long> status5XX{};
  shared_ptr<long> time{};

  DescribeDomainStatusCodeListResponseBodyStatusCodeList() {}

  explicit DescribeDomainStatusCodeListResponseBodyStatusCodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (status200) {
      res["Status200"] = boost::any(*status200);
    }
    if (status2XX) {
      res["Status2XX"] = boost::any(*status2XX);
    }
    if (status3XX) {
      res["Status3XX"] = boost::any(*status3XX);
    }
    if (status403) {
      res["Status403"] = boost::any(*status403);
    }
    if (status404) {
      res["Status404"] = boost::any(*status404);
    }
    if (status405) {
      res["Status405"] = boost::any(*status405);
    }
    if (status4XX) {
      res["Status4XX"] = boost::any(*status4XX);
    }
    if (status501) {
      res["Status501"] = boost::any(*status501);
    }
    if (status502) {
      res["Status502"] = boost::any(*status502);
    }
    if (status503) {
      res["Status503"] = boost::any(*status503);
    }
    if (status504) {
      res["Status504"] = boost::any(*status504);
    }
    if (status5XX) {
      res["Status5XX"] = boost::any(*status5XX);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Status200") != m.end() && !m["Status200"].empty()) {
      status200 = make_shared<long>(boost::any_cast<long>(m["Status200"]));
    }
    if (m.find("Status2XX") != m.end() && !m["Status2XX"].empty()) {
      status2XX = make_shared<long>(boost::any_cast<long>(m["Status2XX"]));
    }
    if (m.find("Status3XX") != m.end() && !m["Status3XX"].empty()) {
      status3XX = make_shared<long>(boost::any_cast<long>(m["Status3XX"]));
    }
    if (m.find("Status403") != m.end() && !m["Status403"].empty()) {
      status403 = make_shared<long>(boost::any_cast<long>(m["Status403"]));
    }
    if (m.find("Status404") != m.end() && !m["Status404"].empty()) {
      status404 = make_shared<long>(boost::any_cast<long>(m["Status404"]));
    }
    if (m.find("Status405") != m.end() && !m["Status405"].empty()) {
      status405 = make_shared<long>(boost::any_cast<long>(m["Status405"]));
    }
    if (m.find("Status4XX") != m.end() && !m["Status4XX"].empty()) {
      status4XX = make_shared<long>(boost::any_cast<long>(m["Status4XX"]));
    }
    if (m.find("Status501") != m.end() && !m["Status501"].empty()) {
      status501 = make_shared<long>(boost::any_cast<long>(m["Status501"]));
    }
    if (m.find("Status502") != m.end() && !m["Status502"].empty()) {
      status502 = make_shared<long>(boost::any_cast<long>(m["Status502"]));
    }
    if (m.find("Status503") != m.end() && !m["Status503"].empty()) {
      status503 = make_shared<long>(boost::any_cast<long>(m["Status503"]));
    }
    if (m.find("Status504") != m.end() && !m["Status504"].empty()) {
      status504 = make_shared<long>(boost::any_cast<long>(m["Status504"]));
    }
    if (m.find("Status5XX") != m.end() && !m["Status5XX"].empty()) {
      status5XX = make_shared<long>(boost::any_cast<long>(m["Status5XX"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeDomainStatusCodeListResponseBodyStatusCodeList() = default;
};
class DescribeDomainStatusCodeListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDomainStatusCodeListResponseBodyStatusCodeList>> statusCodeList{};

  DescribeDomainStatusCodeListResponseBody() {}

  explicit DescribeDomainStatusCodeListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCodeList) {
      vector<boost::any> temp1;
      for(auto item1:*statusCodeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatusCodeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCodeList") != m.end() && !m["StatusCodeList"].empty()) {
      if (typeid(vector<boost::any>) == m["StatusCodeList"].type()) {
        vector<DescribeDomainStatusCodeListResponseBodyStatusCodeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatusCodeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainStatusCodeListResponseBodyStatusCodeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statusCodeList = make_shared<vector<DescribeDomainStatusCodeListResponseBodyStatusCodeList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainStatusCodeListResponseBody() = default;
};
class DescribeDomainStatusCodeListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainStatusCodeListResponseBody> body{};

  DescribeDomainStatusCodeListResponse() {}

  explicit DescribeDomainStatusCodeListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainStatusCodeListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainStatusCodeListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainStatusCodeListResponse() = default;
};
class DescribeDomainTopAttackListRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDomainTopAttackListRequest() {}

  explicit DescribeDomainTopAttackListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainTopAttackListRequest() = default;
};
class DescribeDomainTopAttackListResponseBodyAttackList : public Darabonba::Model {
public:
  shared_ptr<long> attack{};
  shared_ptr<long> count{};
  shared_ptr<string> domain{};

  DescribeDomainTopAttackListResponseBodyAttackList() {}

  explicit DescribeDomainTopAttackListResponseBodyAttackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attack) {
      res["Attack"] = boost::any(*attack);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attack") != m.end() && !m["Attack"].empty()) {
      attack = make_shared<long>(boost::any_cast<long>(m["Attack"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
  }


  virtual ~DescribeDomainTopAttackListResponseBodyAttackList() = default;
};
class DescribeDomainTopAttackListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainTopAttackListResponseBodyAttackList>> attackList{};
  shared_ptr<string> requestId{};

  DescribeDomainTopAttackListResponseBody() {}

  explicit DescribeDomainTopAttackListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attackList) {
      vector<boost::any> temp1;
      for(auto item1:*attackList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttackList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttackList") != m.end() && !m["AttackList"].empty()) {
      if (typeid(vector<boost::any>) == m["AttackList"].type()) {
        vector<DescribeDomainTopAttackListResponseBodyAttackList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttackList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainTopAttackListResponseBodyAttackList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attackList = make_shared<vector<DescribeDomainTopAttackListResponseBodyAttackList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainTopAttackListResponseBody() = default;
};
class DescribeDomainTopAttackListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainTopAttackListResponseBody> body{};

  DescribeDomainTopAttackListResponse() {}

  explicit DescribeDomainTopAttackListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainTopAttackListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainTopAttackListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainTopAttackListResponse() = default;
};
class DescribeDomainViewSourceCountriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDomainViewSourceCountriesRequest() {}

  explicit DescribeDomainViewSourceCountriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainViewSourceCountriesRequest() = default;
};
class DescribeDomainViewSourceCountriesResponseBodySourceCountrys : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> countryId{};

  DescribeDomainViewSourceCountriesResponseBodySourceCountrys() {}

  explicit DescribeDomainViewSourceCountriesResponseBodySourceCountrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (countryId) {
      res["CountryId"] = boost::any(*countryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CountryId") != m.end() && !m["CountryId"].empty()) {
      countryId = make_shared<string>(boost::any_cast<string>(m["CountryId"]));
    }
  }


  virtual ~DescribeDomainViewSourceCountriesResponseBodySourceCountrys() = default;
};
class DescribeDomainViewSourceCountriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDomainViewSourceCountriesResponseBodySourceCountrys>> sourceCountrys{};

  DescribeDomainViewSourceCountriesResponseBody() {}

  explicit DescribeDomainViewSourceCountriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceCountrys) {
      vector<boost::any> temp1;
      for(auto item1:*sourceCountrys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceCountrys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceCountrys") != m.end() && !m["SourceCountrys"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceCountrys"].type()) {
        vector<DescribeDomainViewSourceCountriesResponseBodySourceCountrys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceCountrys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainViewSourceCountriesResponseBodySourceCountrys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceCountrys = make_shared<vector<DescribeDomainViewSourceCountriesResponseBodySourceCountrys>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainViewSourceCountriesResponseBody() = default;
};
class DescribeDomainViewSourceCountriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainViewSourceCountriesResponseBody> body{};

  DescribeDomainViewSourceCountriesResponse() {}

  explicit DescribeDomainViewSourceCountriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainViewSourceCountriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainViewSourceCountriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainViewSourceCountriesResponse() = default;
};
class DescribeDomainViewSourceProvincesRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeDomainViewSourceProvincesRequest() {}

  explicit DescribeDomainViewSourceProvincesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainViewSourceProvincesRequest() = default;
};
class DescribeDomainViewSourceProvincesResponseBodySourceProvinces : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> provinceId{};

  DescribeDomainViewSourceProvincesResponseBodySourceProvinces() {}

  explicit DescribeDomainViewSourceProvincesResponseBodySourceProvinces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (provinceId) {
      res["ProvinceId"] = boost::any(*provinceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("ProvinceId") != m.end() && !m["ProvinceId"].empty()) {
      provinceId = make_shared<string>(boost::any_cast<string>(m["ProvinceId"]));
    }
  }


  virtual ~DescribeDomainViewSourceProvincesResponseBodySourceProvinces() = default;
};
class DescribeDomainViewSourceProvincesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDomainViewSourceProvincesResponseBodySourceProvinces>> sourceProvinces{};

  DescribeDomainViewSourceProvincesResponseBody() {}

  explicit DescribeDomainViewSourceProvincesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceProvinces) {
      vector<boost::any> temp1;
      for(auto item1:*sourceProvinces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceProvinces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceProvinces") != m.end() && !m["SourceProvinces"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceProvinces"].type()) {
        vector<DescribeDomainViewSourceProvincesResponseBodySourceProvinces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceProvinces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainViewSourceProvincesResponseBodySourceProvinces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceProvinces = make_shared<vector<DescribeDomainViewSourceProvincesResponseBodySourceProvinces>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainViewSourceProvincesResponseBody() = default;
};
class DescribeDomainViewSourceProvincesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainViewSourceProvincesResponseBody> body{};

  DescribeDomainViewSourceProvincesResponse() {}

  explicit DescribeDomainViewSourceProvincesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainViewSourceProvincesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainViewSourceProvincesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainViewSourceProvincesResponse() = default;
};
class DescribeDomainViewTopCostTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> top{};

  DescribeDomainViewTopCostTimeRequest() {}

  explicit DescribeDomainViewTopCostTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<long>(boost::any_cast<long>(m["Top"]));
    }
  }


  virtual ~DescribeDomainViewTopCostTimeRequest() = default;
};
class DescribeDomainViewTopCostTimeResponseBodyUrlList : public Darabonba::Model {
public:
  shared_ptr<double> costTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> url{};

  DescribeDomainViewTopCostTimeResponseBodyUrlList() {}

  explicit DescribeDomainViewTopCostTimeResponseBodyUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costTime) {
      res["CostTime"] = boost::any(*costTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CostTime") != m.end() && !m["CostTime"].empty()) {
      costTime = make_shared<double>(boost::any_cast<double>(m["CostTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeDomainViewTopCostTimeResponseBodyUrlList() = default;
};
class DescribeDomainViewTopCostTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDomainViewTopCostTimeResponseBodyUrlList>> urlList{};

  DescribeDomainViewTopCostTimeResponseBody() {}

  explicit DescribeDomainViewTopCostTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainViewTopCostTimeResponseBodyUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainViewTopCostTimeResponseBodyUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainViewTopCostTimeResponseBodyUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainViewTopCostTimeResponseBody() = default;
};
class DescribeDomainViewTopCostTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainViewTopCostTimeResponseBody> body{};

  DescribeDomainViewTopCostTimeResponse() {}

  explicit DescribeDomainViewTopCostTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainViewTopCostTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainViewTopCostTimeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainViewTopCostTimeResponse() = default;
};
class DescribeDomainViewTopUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> top{};

  DescribeDomainViewTopUrlRequest() {}

  explicit DescribeDomainViewTopUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<long>(boost::any_cast<long>(m["Top"]));
    }
  }


  virtual ~DescribeDomainViewTopUrlRequest() = default;
};
class DescribeDomainViewTopUrlResponseBodyUrlList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> domain{};
  shared_ptr<string> url{};

  DescribeDomainViewTopUrlResponseBodyUrlList() {}

  explicit DescribeDomainViewTopUrlResponseBodyUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeDomainViewTopUrlResponseBodyUrlList() = default;
};
class DescribeDomainViewTopUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDomainViewTopUrlResponseBodyUrlList>> urlList{};

  DescribeDomainViewTopUrlResponseBody() {}

  explicit DescribeDomainViewTopUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainViewTopUrlResponseBodyUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainViewTopUrlResponseBodyUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainViewTopUrlResponseBodyUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainViewTopUrlResponseBody() = default;
};
class DescribeDomainViewTopUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainViewTopUrlResponseBody> body{};

  DescribeDomainViewTopUrlResponse() {}

  explicit DescribeDomainViewTopUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainViewTopUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainViewTopUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainViewTopUrlResponse() = default;
};
class DescribeDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> resourceGroupId{};

  DescribeDomainsRequest() {}

  explicit DescribeDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeDomainsRequest() = default;
};
class DescribeDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> requestId{};

  DescribeDomainsResponseBody() {}

  explicit DescribeDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainsResponseBody() = default;
};
class DescribeDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainsResponseBody> body{};

  DescribeDomainsResponse() {}

  explicit DescribeDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainsResponse() = default;
};
class DescribeElasticBandwidthSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeElasticBandwidthSpecRequest() {}

  explicit DescribeElasticBandwidthSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeElasticBandwidthSpecRequest() = default;
};
class DescribeElasticBandwidthSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> elasticBandwidthSpec{};
  shared_ptr<string> requestId{};

  DescribeElasticBandwidthSpecResponseBody() {}

  explicit DescribeElasticBandwidthSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elasticBandwidthSpec) {
      res["ElasticBandwidthSpec"] = boost::any(*elasticBandwidthSpec);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ElasticBandwidthSpec") != m.end() && !m["ElasticBandwidthSpec"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ElasticBandwidthSpec"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ElasticBandwidthSpec"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      elasticBandwidthSpec = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeElasticBandwidthSpecResponseBody() = default;
};
class DescribeElasticBandwidthSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeElasticBandwidthSpecResponseBody> body{};

  DescribeElasticBandwidthSpecResponse() {}

  explicit DescribeElasticBandwidthSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeElasticBandwidthSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeElasticBandwidthSpecResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeElasticBandwidthSpecResponse() = default;
};
class DescribeHealthCheckListRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkRules{};

  DescribeHealthCheckListRequest() {}

  explicit DescribeHealthCheckListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkRules) {
      res["NetworkRules"] = boost::any(*networkRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkRules") != m.end() && !m["NetworkRules"].empty()) {
      networkRules = make_shared<string>(boost::any_cast<string>(m["NetworkRules"]));
    }
  }


  virtual ~DescribeHealthCheckListRequest() = default;
};
class DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> down{};
  shared_ptr<long> interval{};
  shared_ptr<long> port{};
  shared_ptr<long> timeout{};
  shared_ptr<string> type{};
  shared_ptr<long> up{};
  shared_ptr<string> uri{};

  DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck() {}

  explicit DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (down) {
      res["Down"] = boost::any(*down);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (up) {
      res["Up"] = boost::any(*up);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Down") != m.end() && !m["Down"].empty()) {
      down = make_shared<long>(boost::any_cast<long>(m["Down"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Up") != m.end() && !m["Up"].empty()) {
      up = make_shared<long>(boost::any_cast<long>(m["Up"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck() = default;
};
class DescribeHealthCheckListResponseBodyHealthCheckList : public Darabonba::Model {
public:
  shared_ptr<long> frontendPort{};
  shared_ptr<DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck> healthCheck{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> protocol{};

  DescribeHealthCheckListResponseBodyHealthCheckList() {}

  explicit DescribeHealthCheckListResponseBodyHealthCheckList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (healthCheck) {
      res["HealthCheck"] = healthCheck ? boost::any(healthCheck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthCheck"].type()) {
        DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthCheck"]));
        healthCheck = make_shared<DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeHealthCheckListResponseBodyHealthCheckList() = default;
};
class DescribeHealthCheckListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHealthCheckListResponseBodyHealthCheckList>> healthCheckList{};
  shared_ptr<string> requestId{};

  DescribeHealthCheckListResponseBody() {}

  explicit DescribeHealthCheckListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthCheckList) {
      vector<boost::any> temp1;
      for(auto item1:*healthCheckList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthCheckList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthCheckList") != m.end() && !m["HealthCheckList"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthCheckList"].type()) {
        vector<DescribeHealthCheckListResponseBodyHealthCheckList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthCheckList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHealthCheckListResponseBodyHealthCheckList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthCheckList = make_shared<vector<DescribeHealthCheckListResponseBodyHealthCheckList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeHealthCheckListResponseBody() = default;
};
class DescribeHealthCheckListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHealthCheckListResponseBody> body{};

  DescribeHealthCheckListResponse() {}

  explicit DescribeHealthCheckListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHealthCheckListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHealthCheckListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHealthCheckListResponse() = default;
};
class DescribeHealthCheckStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkRules{};

  DescribeHealthCheckStatusRequest() {}

  explicit DescribeHealthCheckStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkRules) {
      res["NetworkRules"] = boost::any(*networkRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkRules") != m.end() && !m["NetworkRules"].empty()) {
      networkRules = make_shared<string>(boost::any_cast<string>(m["NetworkRules"]));
    }
  }


  virtual ~DescribeHealthCheckStatusRequest() = default;
};
class DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> status{};

  DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList() {}

  explicit DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList() = default;
};
class DescribeHealthCheckStatusResponseBodyHealthCheckStatus : public Darabonba::Model {
public:
  shared_ptr<long> frontendPort{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> protocol{};
  shared_ptr<vector<DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList>> realServerStatusList{};
  shared_ptr<string> status{};

  DescribeHealthCheckStatusResponseBodyHealthCheckStatus() {}

  explicit DescribeHealthCheckStatusResponseBodyHealthCheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (realServerStatusList) {
      vector<boost::any> temp1;
      for(auto item1:*realServerStatusList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealServerStatusList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RealServerStatusList") != m.end() && !m["RealServerStatusList"].empty()) {
      if (typeid(vector<boost::any>) == m["RealServerStatusList"].type()) {
        vector<DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealServerStatusList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realServerStatusList = make_shared<vector<DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeHealthCheckStatusResponseBodyHealthCheckStatus() = default;
};
class DescribeHealthCheckStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHealthCheckStatusResponseBodyHealthCheckStatus>> healthCheckStatus{};
  shared_ptr<string> requestId{};

  DescribeHealthCheckStatusResponseBody() {}

  explicit DescribeHealthCheckStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthCheckStatus) {
      vector<boost::any> temp1;
      for(auto item1:*healthCheckStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthCheckStatus"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthCheckStatus") != m.end() && !m["HealthCheckStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthCheckStatus"].type()) {
        vector<DescribeHealthCheckStatusResponseBodyHealthCheckStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthCheckStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHealthCheckStatusResponseBodyHealthCheckStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthCheckStatus = make_shared<vector<DescribeHealthCheckStatusResponseBodyHealthCheckStatus>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeHealthCheckStatusResponseBody() = default;
};
class DescribeHealthCheckStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHealthCheckStatusResponseBody> body{};

  DescribeHealthCheckStatusResponse() {}

  explicit DescribeHealthCheckStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHealthCheckStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHealthCheckStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHealthCheckStatusResponse() = default;
};
class DescribeInstanceDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  DescribeInstanceDetailsRequest() {}

  explicit DescribeInstanceDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceDetailsRequest() = default;
};
class DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos : public Darabonba::Model {
public:
  shared_ptr<string> eip{};
  shared_ptr<string> ipMode{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> status{};

  DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos() {}

  explicit DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (ipMode) {
      res["IpMode"] = boost::any(*ipMode);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("IpMode") != m.end() && !m["IpMode"].empty()) {
      ipMode = make_shared<string>(boost::any_cast<string>(m["IpMode"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos() = default;
};
class DescribeInstanceDetailsResponseBodyInstanceDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos>> eipInfos{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> line{};

  DescribeInstanceDetailsResponseBodyInstanceDetails() {}

  explicit DescribeInstanceDetailsResponseBodyInstanceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipInfos) {
      vector<boost::any> temp1;
      for(auto item1:*eipInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipInfos"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipInfos") != m.end() && !m["EipInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["EipInfos"].type()) {
        vector<DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipInfos = make_shared<vector<DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
  }


  virtual ~DescribeInstanceDetailsResponseBodyInstanceDetails() = default;
};
class DescribeInstanceDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceDetailsResponseBodyInstanceDetails>> instanceDetails{};
  shared_ptr<string> requestId{};

  DescribeInstanceDetailsResponseBody() {}

  explicit DescribeInstanceDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*instanceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceDetails"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceDetails") != m.end() && !m["InstanceDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceDetails"].type()) {
        vector<DescribeInstanceDetailsResponseBodyInstanceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceDetailsResponseBodyInstanceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceDetails = make_shared<vector<DescribeInstanceDetailsResponseBodyInstanceDetails>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceDetailsResponseBody() = default;
};
class DescribeInstanceDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceDetailsResponseBody> body{};

  DescribeInstanceDetailsResponse() {}

  explicit DescribeInstanceDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceDetailsResponse() = default;
};
class DescribeInstanceIdsRequest : public Darabonba::Model {
public:
  shared_ptr<long> edition{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> resourceGroupId{};

  DescribeInstanceIdsRequest() {}

  explicit DescribeInstanceIdsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<long>(boost::any_cast<long>(m["Edition"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeInstanceIdsRequest() = default;
};
class DescribeInstanceIdsResponseBodyInstanceIds : public Darabonba::Model {
public:
  shared_ptr<long> edition{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipMode{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> remark{};

  DescribeInstanceIdsResponseBodyInstanceIds() {}

  explicit DescribeInstanceIdsResponseBodyInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipMode) {
      res["IpMode"] = boost::any(*ipMode);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<long>(boost::any_cast<long>(m["Edition"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpMode") != m.end() && !m["IpMode"].empty()) {
      ipMode = make_shared<string>(boost::any_cast<string>(m["IpMode"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~DescribeInstanceIdsResponseBodyInstanceIds() = default;
};
class DescribeInstanceIdsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceIdsResponseBodyInstanceIds>> instanceIds{};
  shared_ptr<string> requestId{};

  DescribeInstanceIdsResponseBody() {}

  explicit DescribeInstanceIdsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      vector<boost::any> temp1;
      for(auto item1:*instanceIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceIds"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<DescribeInstanceIdsResponseBodyInstanceIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceIdsResponseBodyInstanceIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceIds = make_shared<vector<DescribeInstanceIdsResponseBodyInstanceIds>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceIdsResponseBody() = default;
};
class DescribeInstanceIdsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceIdsResponseBody> body{};

  DescribeInstanceIdsResponse() {}

  explicit DescribeInstanceIdsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceIdsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceIdsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceIdsResponse() = default;
};
class DescribeInstanceSpecsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  DescribeInstanceSpecsRequest() {}

  explicit DescribeInstanceSpecsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceSpecsRequest() = default;
};
class DescribeInstanceSpecsResponseBodyInstanceSpecs : public Darabonba::Model {
public:
  shared_ptr<long> bandwidthMbps{};
  shared_ptr<long> baseBandwidth{};
  shared_ptr<long> defenseCount{};
  shared_ptr<long> domainLimit{};
  shared_ptr<long> elasticBandwidth{};
  shared_ptr<long> elasticBw{};
  shared_ptr<string> functionVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> portLimit{};
  shared_ptr<long> qpsLimit{};
  shared_ptr<long> siteLimit{};

  DescribeInstanceSpecsResponseBodyInstanceSpecs() {}

  explicit DescribeInstanceSpecsResponseBodyInstanceSpecs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthMbps) {
      res["BandwidthMbps"] = boost::any(*bandwidthMbps);
    }
    if (baseBandwidth) {
      res["BaseBandwidth"] = boost::any(*baseBandwidth);
    }
    if (defenseCount) {
      res["DefenseCount"] = boost::any(*defenseCount);
    }
    if (domainLimit) {
      res["DomainLimit"] = boost::any(*domainLimit);
    }
    if (elasticBandwidth) {
      res["ElasticBandwidth"] = boost::any(*elasticBandwidth);
    }
    if (elasticBw) {
      res["ElasticBw"] = boost::any(*elasticBw);
    }
    if (functionVersion) {
      res["FunctionVersion"] = boost::any(*functionVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (portLimit) {
      res["PortLimit"] = boost::any(*portLimit);
    }
    if (qpsLimit) {
      res["QpsLimit"] = boost::any(*qpsLimit);
    }
    if (siteLimit) {
      res["SiteLimit"] = boost::any(*siteLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthMbps") != m.end() && !m["BandwidthMbps"].empty()) {
      bandwidthMbps = make_shared<long>(boost::any_cast<long>(m["BandwidthMbps"]));
    }
    if (m.find("BaseBandwidth") != m.end() && !m["BaseBandwidth"].empty()) {
      baseBandwidth = make_shared<long>(boost::any_cast<long>(m["BaseBandwidth"]));
    }
    if (m.find("DefenseCount") != m.end() && !m["DefenseCount"].empty()) {
      defenseCount = make_shared<long>(boost::any_cast<long>(m["DefenseCount"]));
    }
    if (m.find("DomainLimit") != m.end() && !m["DomainLimit"].empty()) {
      domainLimit = make_shared<long>(boost::any_cast<long>(m["DomainLimit"]));
    }
    if (m.find("ElasticBandwidth") != m.end() && !m["ElasticBandwidth"].empty()) {
      elasticBandwidth = make_shared<long>(boost::any_cast<long>(m["ElasticBandwidth"]));
    }
    if (m.find("ElasticBw") != m.end() && !m["ElasticBw"].empty()) {
      elasticBw = make_shared<long>(boost::any_cast<long>(m["ElasticBw"]));
    }
    if (m.find("FunctionVersion") != m.end() && !m["FunctionVersion"].empty()) {
      functionVersion = make_shared<string>(boost::any_cast<string>(m["FunctionVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PortLimit") != m.end() && !m["PortLimit"].empty()) {
      portLimit = make_shared<long>(boost::any_cast<long>(m["PortLimit"]));
    }
    if (m.find("QpsLimit") != m.end() && !m["QpsLimit"].empty()) {
      qpsLimit = make_shared<long>(boost::any_cast<long>(m["QpsLimit"]));
    }
    if (m.find("SiteLimit") != m.end() && !m["SiteLimit"].empty()) {
      siteLimit = make_shared<long>(boost::any_cast<long>(m["SiteLimit"]));
    }
  }


  virtual ~DescribeInstanceSpecsResponseBodyInstanceSpecs() = default;
};
class DescribeInstanceSpecsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceSpecsResponseBodyInstanceSpecs>> instanceSpecs{};
  shared_ptr<string> requestId{};

  DescribeInstanceSpecsResponseBody() {}

  explicit DescribeInstanceSpecsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSpecs) {
      vector<boost::any> temp1;
      for(auto item1:*instanceSpecs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceSpecs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSpecs") != m.end() && !m["InstanceSpecs"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceSpecs"].type()) {
        vector<DescribeInstanceSpecsResponseBodyInstanceSpecs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceSpecs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceSpecsResponseBodyInstanceSpecs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceSpecs = make_shared<vector<DescribeInstanceSpecsResponseBodyInstanceSpecs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceSpecsResponseBody() = default;
};
class DescribeInstanceSpecsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceSpecsResponseBody> body{};

  DescribeInstanceSpecsResponse() {}

  explicit DescribeInstanceSpecsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceSpecsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceSpecsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceSpecsResponse() = default;
};
class DescribeInstanceStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  DescribeInstanceStatisticsRequest() {}

  explicit DescribeInstanceStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceStatisticsRequest() = default;
};
class DescribeInstanceStatisticsResponseBodyInstanceStatistics : public Darabonba::Model {
public:
  shared_ptr<long> defenseCountUsage{};
  shared_ptr<long> domainUsage{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> portUsage{};
  shared_ptr<long> siteUsage{};

  DescribeInstanceStatisticsResponseBodyInstanceStatistics() {}

  explicit DescribeInstanceStatisticsResponseBodyInstanceStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseCountUsage) {
      res["DefenseCountUsage"] = boost::any(*defenseCountUsage);
    }
    if (domainUsage) {
      res["DomainUsage"] = boost::any(*domainUsage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (portUsage) {
      res["PortUsage"] = boost::any(*portUsage);
    }
    if (siteUsage) {
      res["SiteUsage"] = boost::any(*siteUsage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseCountUsage") != m.end() && !m["DefenseCountUsage"].empty()) {
      defenseCountUsage = make_shared<long>(boost::any_cast<long>(m["DefenseCountUsage"]));
    }
    if (m.find("DomainUsage") != m.end() && !m["DomainUsage"].empty()) {
      domainUsage = make_shared<long>(boost::any_cast<long>(m["DomainUsage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PortUsage") != m.end() && !m["PortUsage"].empty()) {
      portUsage = make_shared<long>(boost::any_cast<long>(m["PortUsage"]));
    }
    if (m.find("SiteUsage") != m.end() && !m["SiteUsage"].empty()) {
      siteUsage = make_shared<long>(boost::any_cast<long>(m["SiteUsage"]));
    }
  }


  virtual ~DescribeInstanceStatisticsResponseBodyInstanceStatistics() = default;
};
class DescribeInstanceStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceStatisticsResponseBodyInstanceStatistics>> instanceStatistics{};
  shared_ptr<string> requestId{};

  DescribeInstanceStatisticsResponseBody() {}

  explicit DescribeInstanceStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceStatistics) {
      vector<boost::any> temp1;
      for(auto item1:*instanceStatistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceStatistics"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceStatistics") != m.end() && !m["InstanceStatistics"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceStatistics"].type()) {
        vector<DescribeInstanceStatisticsResponseBodyInstanceStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceStatistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceStatisticsResponseBodyInstanceStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceStatistics = make_shared<vector<DescribeInstanceStatisticsResponseBodyInstanceStatistics>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceStatisticsResponseBody() = default;
};
class DescribeInstanceStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceStatisticsResponseBody> body{};

  DescribeInstanceStatisticsResponse() {}

  explicit DescribeInstanceStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceStatisticsResponse() = default;
};
class DescribeInstanceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> productType{};

  DescribeInstanceStatusRequest() {}

  explicit DescribeInstanceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["ProductType"]));
    }
  }


  virtual ~DescribeInstanceStatusRequest() = default;
};
class DescribeInstanceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> instanceStatus{};
  shared_ptr<string> requestId{};

  DescribeInstanceStatusResponseBody() {}

  explicit DescribeInstanceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<long>(boost::any_cast<long>(m["InstanceStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceStatusResponseBody() = default;
};
class DescribeInstanceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceStatusResponseBody> body{};

  DescribeInstanceStatusResponse() {}

  explicit DescribeInstanceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceStatusResponse() = default;
};
class DescribeInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeInstancesRequestTag() {}

  explicit DescribeInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeInstancesRequestTag() = default;
};
class DescribeInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> edition{};
  shared_ptr<long> enabled{};
  shared_ptr<long> expireEndTime{};
  shared_ptr<long> expireStartTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> ip{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<long>> status{};
  shared_ptr<vector<DescribeInstancesRequestTag>> tag{};

  DescribeInstancesRequest() {}

  explicit DescribeInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (expireEndTime) {
      res["ExpireEndTime"] = boost::any(*expireEndTime);
    }
    if (expireStartTime) {
      res["ExpireStartTime"] = boost::any(*expireStartTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<long>(boost::any_cast<long>(m["Edition"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<long>(boost::any_cast<long>(m["Enabled"]));
    }
    if (m.find("ExpireEndTime") != m.end() && !m["ExpireEndTime"].empty()) {
      expireEndTime = make_shared<long>(boost::any_cast<long>(m["ExpireEndTime"]));
    }
    if (m.find("ExpireStartTime") != m.end() && !m["ExpireStartTime"].empty()) {
      expireStartTime = make_shared<long>(boost::any_cast<long>(m["ExpireStartTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Status"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Status"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      status = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeInstancesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesRequest() = default;
};
class DescribeInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> debtStatus{};
  shared_ptr<long> edition{};
  shared_ptr<long> enabled{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipMode{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> remark{};
  shared_ptr<long> status{};

  DescribeInstancesResponseBodyInstances() {}

  explicit DescribeInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (debtStatus) {
      res["DebtStatus"] = boost::any(*debtStatus);
    }
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipMode) {
      res["IpMode"] = boost::any(*ipMode);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DebtStatus") != m.end() && !m["DebtStatus"].empty()) {
      debtStatus = make_shared<long>(boost::any_cast<long>(m["DebtStatus"]));
    }
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<long>(boost::any_cast<long>(m["Edition"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<long>(boost::any_cast<long>(m["Enabled"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpMode") != m.end() && !m["IpMode"].empty()) {
      ipMode = make_shared<string>(boost::any_cast<string>(m["IpMode"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstances() = default;
};
class DescribeInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstances>> instances{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstancesResponseBody() {}

  explicit DescribeInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeInstancesResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstancesResponseBody() = default;
};
class DescribeInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstancesResponseBody> body{};

  DescribeInstancesResponse() {}

  explicit DescribeInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponse() = default;
};
class DescribeL7RsPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<vector<string>> realServers{};
  shared_ptr<string> resourceGroupId{};

  DescribeL7RsPolicyRequest() {}

  explicit DescribeL7RsPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (realServers) {
      res["RealServers"] = boost::any(*realServers);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RealServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      realServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeL7RsPolicyRequest() = default;
};
class DescribeL7RsPolicyResponseBodyAttributesAttribute : public Darabonba::Model {
public:
  shared_ptr<long> weight{};

  DescribeL7RsPolicyResponseBodyAttributesAttribute() {}

  explicit DescribeL7RsPolicyResponseBodyAttributesAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeL7RsPolicyResponseBodyAttributesAttribute() = default;
};
class DescribeL7RsPolicyResponseBodyAttributes : public Darabonba::Model {
public:
  shared_ptr<DescribeL7RsPolicyResponseBodyAttributesAttribute> attribute{};
  shared_ptr<string> realServer{};
  shared_ptr<long> rsType{};

  DescribeL7RsPolicyResponseBodyAttributes() {}

  explicit DescribeL7RsPolicyResponseBodyAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attribute) {
      res["Attribute"] = attribute ? boost::any(attribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (realServer) {
      res["RealServer"] = boost::any(*realServer);
    }
    if (rsType) {
      res["RsType"] = boost::any(*rsType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attribute") != m.end() && !m["Attribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["Attribute"].type()) {
        DescribeL7RsPolicyResponseBodyAttributesAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Attribute"]));
        attribute = make_shared<DescribeL7RsPolicyResponseBodyAttributesAttribute>(model1);
      }
    }
    if (m.find("RealServer") != m.end() && !m["RealServer"].empty()) {
      realServer = make_shared<string>(boost::any_cast<string>(m["RealServer"]));
    }
    if (m.find("RsType") != m.end() && !m["RsType"].empty()) {
      rsType = make_shared<long>(boost::any_cast<long>(m["RsType"]));
    }
  }


  virtual ~DescribeL7RsPolicyResponseBodyAttributes() = default;
};
class DescribeL7RsPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeL7RsPolicyResponseBodyAttributes>> attributes{};
  shared_ptr<string> proxyMode{};
  shared_ptr<string> requestId{};

  DescribeL7RsPolicyResponseBody() {}

  explicit DescribeL7RsPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributes) {
      vector<boost::any> temp1;
      for(auto item1:*attributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attributes"] = boost::any(temp1);
    }
    if (proxyMode) {
      res["ProxyMode"] = boost::any(*proxyMode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      if (typeid(vector<boost::any>) == m["Attributes"].type()) {
        vector<DescribeL7RsPolicyResponseBodyAttributes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeL7RsPolicyResponseBodyAttributes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributes = make_shared<vector<DescribeL7RsPolicyResponseBodyAttributes>>(expect1);
      }
    }
    if (m.find("ProxyMode") != m.end() && !m["ProxyMode"].empty()) {
      proxyMode = make_shared<string>(boost::any_cast<string>(m["ProxyMode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeL7RsPolicyResponseBody() = default;
};
class DescribeL7RsPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeL7RsPolicyResponseBody> body{};

  DescribeL7RsPolicyResponse() {}

  explicit DescribeL7RsPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeL7RsPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeL7RsPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeL7RsPolicyResponse() = default;
};
class DescribeLayer4RulePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> listeners{};

  DescribeLayer4RulePolicyRequest() {}

  explicit DescribeLayer4RulePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listeners) {
      res["Listeners"] = boost::any(*listeners);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Listeners") != m.end() && !m["Listeners"].empty()) {
      listeners = make_shared<string>(boost::any_cast<string>(m["Listeners"]));
    }
  }


  virtual ~DescribeLayer4RulePolicyRequest() = default;
};
class DescribeLayer4RulePolicyResponseBodyPriRealServers : public Darabonba::Model {
public:
  shared_ptr<long> currentIndex{};
  shared_ptr<string> eip{};
  shared_ptr<long> frontendPort{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> realServer{};

  DescribeLayer4RulePolicyResponseBodyPriRealServers() {}

  explicit DescribeLayer4RulePolicyResponseBodyPriRealServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentIndex) {
      res["CurrentIndex"] = boost::any(*currentIndex);
    }
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (realServer) {
      res["RealServer"] = boost::any(*realServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentIndex") != m.end() && !m["CurrentIndex"].empty()) {
      currentIndex = make_shared<long>(boost::any_cast<long>(m["CurrentIndex"]));
    }
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RealServer") != m.end() && !m["RealServer"].empty()) {
      realServer = make_shared<string>(boost::any_cast<string>(m["RealServer"]));
    }
  }


  virtual ~DescribeLayer4RulePolicyResponseBodyPriRealServers() = default;
};
class DescribeLayer4RulePolicyResponseBodySecRealServers : public Darabonba::Model {
public:
  shared_ptr<long> currentIndex{};
  shared_ptr<string> eip{};
  shared_ptr<long> frontendPort{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> realServer{};

  DescribeLayer4RulePolicyResponseBodySecRealServers() {}

  explicit DescribeLayer4RulePolicyResponseBodySecRealServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentIndex) {
      res["CurrentIndex"] = boost::any(*currentIndex);
    }
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (realServer) {
      res["RealServer"] = boost::any(*realServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentIndex") != m.end() && !m["CurrentIndex"].empty()) {
      currentIndex = make_shared<long>(boost::any_cast<long>(m["CurrentIndex"]));
    }
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RealServer") != m.end() && !m["RealServer"].empty()) {
      realServer = make_shared<string>(boost::any_cast<string>(m["RealServer"]));
    }
  }


  virtual ~DescribeLayer4RulePolicyResponseBodySecRealServers() = default;
};
class DescribeLayer4RulePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> backendPort{};
  shared_ptr<string> bakMode{};
  shared_ptr<long> currentIndex{};
  shared_ptr<string> forwardProtocol{};
  shared_ptr<long> frontendPort{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<DescribeLayer4RulePolicyResponseBodyPriRealServers>> priRealServers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeLayer4RulePolicyResponseBodySecRealServers>> secRealServers{};

  DescribeLayer4RulePolicyResponseBody() {}

  explicit DescribeLayer4RulePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendPort) {
      res["BackendPort"] = boost::any(*backendPort);
    }
    if (bakMode) {
      res["BakMode"] = boost::any(*bakMode);
    }
    if (currentIndex) {
      res["CurrentIndex"] = boost::any(*currentIndex);
    }
    if (forwardProtocol) {
      res["ForwardProtocol"] = boost::any(*forwardProtocol);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (priRealServers) {
      vector<boost::any> temp1;
      for(auto item1:*priRealServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PriRealServers"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (secRealServers) {
      vector<boost::any> temp1;
      for(auto item1:*secRealServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecRealServers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendPort") != m.end() && !m["BackendPort"].empty()) {
      backendPort = make_shared<long>(boost::any_cast<long>(m["BackendPort"]));
    }
    if (m.find("BakMode") != m.end() && !m["BakMode"].empty()) {
      bakMode = make_shared<string>(boost::any_cast<string>(m["BakMode"]));
    }
    if (m.find("CurrentIndex") != m.end() && !m["CurrentIndex"].empty()) {
      currentIndex = make_shared<long>(boost::any_cast<long>(m["CurrentIndex"]));
    }
    if (m.find("ForwardProtocol") != m.end() && !m["ForwardProtocol"].empty()) {
      forwardProtocol = make_shared<string>(boost::any_cast<string>(m["ForwardProtocol"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PriRealServers") != m.end() && !m["PriRealServers"].empty()) {
      if (typeid(vector<boost::any>) == m["PriRealServers"].type()) {
        vector<DescribeLayer4RulePolicyResponseBodyPriRealServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PriRealServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLayer4RulePolicyResponseBodyPriRealServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priRealServers = make_shared<vector<DescribeLayer4RulePolicyResponseBodyPriRealServers>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecRealServers") != m.end() && !m["SecRealServers"].empty()) {
      if (typeid(vector<boost::any>) == m["SecRealServers"].type()) {
        vector<DescribeLayer4RulePolicyResponseBodySecRealServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecRealServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLayer4RulePolicyResponseBodySecRealServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        secRealServers = make_shared<vector<DescribeLayer4RulePolicyResponseBodySecRealServers>>(expect1);
      }
    }
  }


  virtual ~DescribeLayer4RulePolicyResponseBody() = default;
};
class DescribeLayer4RulePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLayer4RulePolicyResponseBody> body{};

  DescribeLayer4RulePolicyResponse() {}

  explicit DescribeLayer4RulePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLayer4RulePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLayer4RulePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLayer4RulePolicyResponse() = default;
};
class DescribeLogStoreExistStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  DescribeLogStoreExistStatusRequest() {}

  explicit DescribeLogStoreExistStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeLogStoreExistStatusRequest() = default;
};
class DescribeLogStoreExistStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> existStatus{};
  shared_ptr<string> requestId{};

  DescribeLogStoreExistStatusResponseBody() {}

  explicit DescribeLogStoreExistStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (existStatus) {
      res["ExistStatus"] = boost::any(*existStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExistStatus") != m.end() && !m["ExistStatus"].empty()) {
      existStatus = make_shared<bool>(boost::any_cast<bool>(m["ExistStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLogStoreExistStatusResponseBody() = default;
};
class DescribeLogStoreExistStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLogStoreExistStatusResponseBody> body{};

  DescribeLogStoreExistStatusResponse() {}

  explicit DescribeLogStoreExistStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogStoreExistStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogStoreExistStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogStoreExistStatusResponse() = default;
};
class DescribeNetworkRegionBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeNetworkRegionBlockRequest() {}

  explicit DescribeNetworkRegionBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeNetworkRegionBlockRequest() = default;
};
class DescribeNetworkRegionBlockResponseBodyConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> countries{};
  shared_ptr<vector<string>> provinces{};
  shared_ptr<string> regionBlockSwitch{};

  DescribeNetworkRegionBlockResponseBodyConfig() {}

  explicit DescribeNetworkRegionBlockResponseBodyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (countries) {
      res["Countries"] = boost::any(*countries);
    }
    if (provinces) {
      res["Provinces"] = boost::any(*provinces);
    }
    if (regionBlockSwitch) {
      res["RegionBlockSwitch"] = boost::any(*regionBlockSwitch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Countries") != m.end() && !m["Countries"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Countries"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Countries"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      countries = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Provinces") != m.end() && !m["Provinces"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Provinces"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Provinces"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      provinces = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionBlockSwitch") != m.end() && !m["RegionBlockSwitch"].empty()) {
      regionBlockSwitch = make_shared<string>(boost::any_cast<string>(m["RegionBlockSwitch"]));
    }
  }


  virtual ~DescribeNetworkRegionBlockResponseBodyConfig() = default;
};
class DescribeNetworkRegionBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkRegionBlockResponseBodyConfig> config{};
  shared_ptr<string> requestId{};

  DescribeNetworkRegionBlockResponseBody() {}

  explicit DescribeNetworkRegionBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        DescribeNetworkRegionBlockResponseBodyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<DescribeNetworkRegionBlockResponseBodyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNetworkRegionBlockResponseBody() = default;
};
class DescribeNetworkRegionBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkRegionBlockResponseBody> body{};

  DescribeNetworkRegionBlockResponse() {}

  explicit DescribeNetworkRegionBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkRegionBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkRegionBlockResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkRegionBlockResponse() = default;
};
class DescribeNetworkRuleAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkRules{};

  DescribeNetworkRuleAttributesRequest() {}

  explicit DescribeNetworkRuleAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkRules) {
      res["NetworkRules"] = boost::any(*networkRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkRules") != m.end() && !m["NetworkRules"].empty()) {
      networkRules = make_shared<string>(boost::any_cast<string>(m["NetworkRules"]));
    }
  }


  virtual ~DescribeNetworkRuleAttributesRequest() = default;
};
class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack : public Darabonba::Model {
public:
  shared_ptr<long> cnt{};
  shared_ptr<long> during{};
  shared_ptr<long> expires{};
  shared_ptr<long> type{};

  DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack() {}

  explicit DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cnt) {
      res["Cnt"] = boost::any(*cnt);
    }
    if (during) {
      res["During"] = boost::any(*during);
    }
    if (expires) {
      res["Expires"] = boost::any(*expires);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cnt") != m.end() && !m["Cnt"].empty()) {
      cnt = make_shared<long>(boost::any_cast<long>(m["Cnt"]));
    }
    if (m.find("During") != m.end() && !m["During"].empty()) {
      during = make_shared<long>(boost::any_cast<long>(m["During"]));
    }
    if (m.find("Expires") != m.end() && !m["Expires"].empty()) {
      expires = make_shared<long>(boost::any_cast<long>(m["Expires"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack() = default;
};
class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack>> sblack{};

  DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc() {}

  explicit DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sblack) {
      vector<boost::any> temp1;
      for(auto item1:*sblack){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sblack"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sblack") != m.end() && !m["Sblack"].empty()) {
      if (typeid(vector<boost::any>) == m["Sblack"].type()) {
        vector<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sblack"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sblack = make_shared<vector<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc() = default;
};
class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen : public Darabonba::Model {
public:
  shared_ptr<long> max{};
  shared_ptr<long> min{};

  DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen() {}

  explicit DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<long>(boost::any_cast<long>(m["Min"]));
    }
  }


  virtual ~DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen() = default;
};
class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla : public Darabonba::Model {
public:
  shared_ptr<long> cps{};
  shared_ptr<long> cpsEnable{};
  shared_ptr<long> maxconn{};
  shared_ptr<long> maxconnEnable{};

  DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla() {}

  explicit DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cps) {
      res["Cps"] = boost::any(*cps);
    }
    if (cpsEnable) {
      res["CpsEnable"] = boost::any(*cpsEnable);
    }
    if (maxconn) {
      res["Maxconn"] = boost::any(*maxconn);
    }
    if (maxconnEnable) {
      res["MaxconnEnable"] = boost::any(*maxconnEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cps") != m.end() && !m["Cps"].empty()) {
      cps = make_shared<long>(boost::any_cast<long>(m["Cps"]));
    }
    if (m.find("CpsEnable") != m.end() && !m["CpsEnable"].empty()) {
      cpsEnable = make_shared<long>(boost::any_cast<long>(m["CpsEnable"]));
    }
    if (m.find("Maxconn") != m.end() && !m["Maxconn"].empty()) {
      maxconn = make_shared<long>(boost::any_cast<long>(m["Maxconn"]));
    }
    if (m.find("MaxconnEnable") != m.end() && !m["MaxconnEnable"].empty()) {
      maxconnEnable = make_shared<long>(boost::any_cast<long>(m["MaxconnEnable"]));
    }
  }


  virtual ~DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla() = default;
};
class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit : public Darabonba::Model {
public:
  shared_ptr<long> bps{};
  shared_ptr<long> cps{};
  shared_ptr<long> cpsEnable{};
  shared_ptr<long> cpsMode{};
  shared_ptr<long> maxconn{};
  shared_ptr<long> maxconnEnable{};
  shared_ptr<long> pps{};

  DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit() {}

  explicit DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (cps) {
      res["Cps"] = boost::any(*cps);
    }
    if (cpsEnable) {
      res["CpsEnable"] = boost::any(*cpsEnable);
    }
    if (cpsMode) {
      res["CpsMode"] = boost::any(*cpsMode);
    }
    if (maxconn) {
      res["Maxconn"] = boost::any(*maxconn);
    }
    if (maxconnEnable) {
      res["MaxconnEnable"] = boost::any(*maxconnEnable);
    }
    if (pps) {
      res["Pps"] = boost::any(*pps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<long>(boost::any_cast<long>(m["Bps"]));
    }
    if (m.find("Cps") != m.end() && !m["Cps"].empty()) {
      cps = make_shared<long>(boost::any_cast<long>(m["Cps"]));
    }
    if (m.find("CpsEnable") != m.end() && !m["CpsEnable"].empty()) {
      cpsEnable = make_shared<long>(boost::any_cast<long>(m["CpsEnable"]));
    }
    if (m.find("CpsMode") != m.end() && !m["CpsMode"].empty()) {
      cpsMode = make_shared<long>(boost::any_cast<long>(m["CpsMode"]));
    }
    if (m.find("Maxconn") != m.end() && !m["Maxconn"].empty()) {
      maxconn = make_shared<long>(boost::any_cast<long>(m["Maxconn"]));
    }
    if (m.find("MaxconnEnable") != m.end() && !m["MaxconnEnable"].empty()) {
      maxconnEnable = make_shared<long>(boost::any_cast<long>(m["MaxconnEnable"]));
    }
    if (m.find("Pps") != m.end() && !m["Pps"].empty()) {
      pps = make_shared<long>(boost::any_cast<long>(m["Pps"]));
    }
  }


  virtual ~DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit() = default;
};
class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc> cc{};
  shared_ptr<string> nodataConn{};
  shared_ptr<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen> payloadLen{};
  shared_ptr<long> persistenceTimeout{};
  shared_ptr<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla> sla{};
  shared_ptr<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit> slimit{};
  shared_ptr<string> synproxy{};

  DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig() {}

  explicit DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cc) {
      res["Cc"] = cc ? boost::any(cc->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodataConn) {
      res["NodataConn"] = boost::any(*nodataConn);
    }
    if (payloadLen) {
      res["PayloadLen"] = payloadLen ? boost::any(payloadLen->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (persistenceTimeout) {
      res["PersistenceTimeout"] = boost::any(*persistenceTimeout);
    }
    if (sla) {
      res["Sla"] = sla ? boost::any(sla->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (slimit) {
      res["Slimit"] = slimit ? boost::any(slimit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (synproxy) {
      res["Synproxy"] = boost::any(*synproxy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cc") != m.end() && !m["Cc"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cc"].type()) {
        DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cc"]));
        cc = make_shared<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc>(model1);
      }
    }
    if (m.find("NodataConn") != m.end() && !m["NodataConn"].empty()) {
      nodataConn = make_shared<string>(boost::any_cast<string>(m["NodataConn"]));
    }
    if (m.find("PayloadLen") != m.end() && !m["PayloadLen"].empty()) {
      if (typeid(map<string, boost::any>) == m["PayloadLen"].type()) {
        DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PayloadLen"]));
        payloadLen = make_shared<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen>(model1);
      }
    }
    if (m.find("PersistenceTimeout") != m.end() && !m["PersistenceTimeout"].empty()) {
      persistenceTimeout = make_shared<long>(boost::any_cast<long>(m["PersistenceTimeout"]));
    }
    if (m.find("Sla") != m.end() && !m["Sla"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sla"].type()) {
        DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sla"]));
        sla = make_shared<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla>(model1);
      }
    }
    if (m.find("Slimit") != m.end() && !m["Slimit"].empty()) {
      if (typeid(map<string, boost::any>) == m["Slimit"].type()) {
        DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Slimit"]));
        slimit = make_shared<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit>(model1);
      }
    }
    if (m.find("Synproxy") != m.end() && !m["Synproxy"].empty()) {
      synproxy = make_shared<string>(boost::any_cast<string>(m["Synproxy"]));
    }
  }


  virtual ~DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig() = default;
};
class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig> config{};
  shared_ptr<long> frontendPort{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> protocol{};

  DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes() {}

  explicit DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig>(model1);
      }
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes() = default;
};
class DescribeNetworkRuleAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes>> networkRuleAttributes{};
  shared_ptr<string> requestId{};

  DescribeNetworkRuleAttributesResponseBody() {}

  explicit DescribeNetworkRuleAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkRuleAttributes) {
      vector<boost::any> temp1;
      for(auto item1:*networkRuleAttributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkRuleAttributes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkRuleAttributes") != m.end() && !m["NetworkRuleAttributes"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkRuleAttributes"].type()) {
        vector<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkRuleAttributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkRuleAttributes = make_shared<vector<DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNetworkRuleAttributesResponseBody() = default;
};
class DescribeNetworkRuleAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkRuleAttributesResponseBody> body{};

  DescribeNetworkRuleAttributesResponse() {}

  explicit DescribeNetworkRuleAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkRuleAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkRuleAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkRuleAttributesResponse() = default;
};
class DescribeNetworkRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> forwardProtocol{};
  shared_ptr<long> frontendPort{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeNetworkRulesRequest() {}

  explicit DescribeNetworkRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardProtocol) {
      res["ForwardProtocol"] = boost::any(*forwardProtocol);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardProtocol") != m.end() && !m["ForwardProtocol"].empty()) {
      forwardProtocol = make_shared<string>(boost::any_cast<string>(m["ForwardProtocol"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeNetworkRulesRequest() = default;
};
class DescribeNetworkRulesResponseBodyNetworkRules : public Darabonba::Model {
public:
  shared_ptr<long> backendPort{};
  shared_ptr<long> frontendPort{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isAutoCreate{};
  shared_ptr<string> protocol{};
  shared_ptr<vector<string>> realServers{};

  DescribeNetworkRulesResponseBodyNetworkRules() {}

  explicit DescribeNetworkRulesResponseBodyNetworkRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendPort) {
      res["BackendPort"] = boost::any(*backendPort);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isAutoCreate) {
      res["IsAutoCreate"] = boost::any(*isAutoCreate);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (realServers) {
      res["RealServers"] = boost::any(*realServers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendPort") != m.end() && !m["BackendPort"].empty()) {
      backendPort = make_shared<long>(boost::any_cast<long>(m["BackendPort"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsAutoCreate") != m.end() && !m["IsAutoCreate"].empty()) {
      isAutoCreate = make_shared<bool>(boost::any_cast<bool>(m["IsAutoCreate"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RealServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      realServers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkRulesResponseBodyNetworkRules() = default;
};
class DescribeNetworkRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkRulesResponseBodyNetworkRules>> networkRules{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeNetworkRulesResponseBody() {}

  explicit DescribeNetworkRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkRules) {
      vector<boost::any> temp1;
      for(auto item1:*networkRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkRules") != m.end() && !m["NetworkRules"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkRules"].type()) {
        vector<DescribeNetworkRulesResponseBodyNetworkRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkRulesResponseBodyNetworkRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkRules = make_shared<vector<DescribeNetworkRulesResponseBodyNetworkRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNetworkRulesResponseBody() = default;
};
class DescribeNetworkRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkRulesResponseBody> body{};

  DescribeNetworkRulesResponse() {}

  explicit DescribeNetworkRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkRulesResponse() = default;
};
class DescribeOpEntitiesRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> entityObject{};
  shared_ptr<long> entityType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeOpEntitiesRequest() {}

  explicit DescribeOpEntitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (entityObject) {
      res["EntityObject"] = boost::any(*entityObject);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EntityObject") != m.end() && !m["EntityObject"].empty()) {
      entityObject = make_shared<string>(boost::any_cast<string>(m["EntityObject"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<long>(boost::any_cast<long>(m["EntityType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeOpEntitiesRequest() = default;
};
class DescribeOpEntitiesResponseBodyOpEntities : public Darabonba::Model {
public:
  shared_ptr<string> entityObject{};
  shared_ptr<long> entityType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> opAccount{};
  shared_ptr<long> opAction{};
  shared_ptr<string> opDesc{};

  DescribeOpEntitiesResponseBodyOpEntities() {}

  explicit DescribeOpEntitiesResponseBodyOpEntities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityObject) {
      res["EntityObject"] = boost::any(*entityObject);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (opAccount) {
      res["OpAccount"] = boost::any(*opAccount);
    }
    if (opAction) {
      res["OpAction"] = boost::any(*opAction);
    }
    if (opDesc) {
      res["OpDesc"] = boost::any(*opDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityObject") != m.end() && !m["EntityObject"].empty()) {
      entityObject = make_shared<string>(boost::any_cast<string>(m["EntityObject"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<long>(boost::any_cast<long>(m["EntityType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("OpAccount") != m.end() && !m["OpAccount"].empty()) {
      opAccount = make_shared<string>(boost::any_cast<string>(m["OpAccount"]));
    }
    if (m.find("OpAction") != m.end() && !m["OpAction"].empty()) {
      opAction = make_shared<long>(boost::any_cast<long>(m["OpAction"]));
    }
    if (m.find("OpDesc") != m.end() && !m["OpDesc"].empty()) {
      opDesc = make_shared<string>(boost::any_cast<string>(m["OpDesc"]));
    }
  }


  virtual ~DescribeOpEntitiesResponseBodyOpEntities() = default;
};
class DescribeOpEntitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOpEntitiesResponseBodyOpEntities>> opEntities{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeOpEntitiesResponseBody() {}

  explicit DescribeOpEntitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opEntities) {
      vector<boost::any> temp1;
      for(auto item1:*opEntities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OpEntities"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpEntities") != m.end() && !m["OpEntities"].empty()) {
      if (typeid(vector<boost::any>) == m["OpEntities"].type()) {
        vector<DescribeOpEntitiesResponseBodyOpEntities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OpEntities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOpEntitiesResponseBodyOpEntities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opEntities = make_shared<vector<DescribeOpEntitiesResponseBodyOpEntities>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeOpEntitiesResponseBody() = default;
};
class DescribeOpEntitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOpEntitiesResponseBody> body{};

  DescribeOpEntitiesResponse() {}

  explicit DescribeOpEntitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOpEntitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOpEntitiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOpEntitiesResponse() = default;
};
class DescribePortRequest : public Darabonba::Model {
public:
  shared_ptr<long> frontendPort{};
  shared_ptr<string> frontendProtocol{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribePortRequest() {}

  explicit DescribePortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (frontendProtocol) {
      res["FrontendProtocol"] = boost::any(*frontendProtocol);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("FrontendProtocol") != m.end() && !m["FrontendProtocol"].empty()) {
      frontendProtocol = make_shared<string>(boost::any_cast<string>(m["FrontendProtocol"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePortRequest() = default;
};
class DescribePortResponseBodyNetworkRules : public Darabonba::Model {
public:
  shared_ptr<long> backendPort{};
  shared_ptr<long> frontendPort{};
  shared_ptr<string> frontendProtocol{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isAutoCreate{};
  shared_ptr<vector<string>> realServers{};

  DescribePortResponseBodyNetworkRules() {}

  explicit DescribePortResponseBodyNetworkRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendPort) {
      res["BackendPort"] = boost::any(*backendPort);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (frontendProtocol) {
      res["FrontendProtocol"] = boost::any(*frontendProtocol);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isAutoCreate) {
      res["IsAutoCreate"] = boost::any(*isAutoCreate);
    }
    if (realServers) {
      res["RealServers"] = boost::any(*realServers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendPort") != m.end() && !m["BackendPort"].empty()) {
      backendPort = make_shared<long>(boost::any_cast<long>(m["BackendPort"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("FrontendProtocol") != m.end() && !m["FrontendProtocol"].empty()) {
      frontendProtocol = make_shared<string>(boost::any_cast<string>(m["FrontendProtocol"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsAutoCreate") != m.end() && !m["IsAutoCreate"].empty()) {
      isAutoCreate = make_shared<bool>(boost::any_cast<bool>(m["IsAutoCreate"]));
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RealServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      realServers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribePortResponseBodyNetworkRules() = default;
};
class DescribePortResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePortResponseBodyNetworkRules>> networkRules{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePortResponseBody() {}

  explicit DescribePortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkRules) {
      vector<boost::any> temp1;
      for(auto item1:*networkRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkRules") != m.end() && !m["NetworkRules"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkRules"].type()) {
        vector<DescribePortResponseBodyNetworkRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePortResponseBodyNetworkRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkRules = make_shared<vector<DescribePortResponseBodyNetworkRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePortResponseBody() = default;
};
class DescribePortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePortResponseBody> body{};

  DescribePortResponse() {}

  explicit DescribePortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePortResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePortResponse() = default;
};
class DescribePortAttackMaxFlowRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribePortAttackMaxFlowRequest() {}

  explicit DescribePortAttackMaxFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribePortAttackMaxFlowRequest() = default;
};
class DescribePortAttackMaxFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> bps{};
  shared_ptr<long> pps{};
  shared_ptr<string> requestId{};

  DescribePortAttackMaxFlowResponseBody() {}

  explicit DescribePortAttackMaxFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (pps) {
      res["Pps"] = boost::any(*pps);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<long>(boost::any_cast<long>(m["Bps"]));
    }
    if (m.find("Pps") != m.end() && !m["Pps"].empty()) {
      pps = make_shared<long>(boost::any_cast<long>(m["Pps"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePortAttackMaxFlowResponseBody() = default;
};
class DescribePortAttackMaxFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePortAttackMaxFlowResponseBody> body{};

  DescribePortAttackMaxFlowResponse() {}

  explicit DescribePortAttackMaxFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePortAttackMaxFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePortAttackMaxFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePortAttackMaxFlowResponse() = default;
};
class DescribePortAutoCcStatusRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  DescribePortAutoCcStatusRequest() {}

  explicit DescribePortAutoCcStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribePortAutoCcStatusRequest() = default;
};
class DescribePortAutoCcStatusResponseBodyPortAutoCcStatus : public Darabonba::Model {
public:
  shared_ptr<string> mode{};
  shared_ptr<string> switch_{};
  shared_ptr<string> webMode{};
  shared_ptr<string> webSwitch{};

  DescribePortAutoCcStatusResponseBodyPortAutoCcStatus() {}

  explicit DescribePortAutoCcStatusResponseBodyPortAutoCcStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (switch_) {
      res["Switch"] = boost::any(*switch_);
    }
    if (webMode) {
      res["WebMode"] = boost::any(*webMode);
    }
    if (webSwitch) {
      res["WebSwitch"] = boost::any(*webSwitch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Switch") != m.end() && !m["Switch"].empty()) {
      switch_ = make_shared<string>(boost::any_cast<string>(m["Switch"]));
    }
    if (m.find("WebMode") != m.end() && !m["WebMode"].empty()) {
      webMode = make_shared<string>(boost::any_cast<string>(m["WebMode"]));
    }
    if (m.find("WebSwitch") != m.end() && !m["WebSwitch"].empty()) {
      webSwitch = make_shared<string>(boost::any_cast<string>(m["WebSwitch"]));
    }
  }


  virtual ~DescribePortAutoCcStatusResponseBodyPortAutoCcStatus() = default;
};
class DescribePortAutoCcStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePortAutoCcStatusResponseBodyPortAutoCcStatus>> portAutoCcStatus{};
  shared_ptr<string> requestId{};

  DescribePortAutoCcStatusResponseBody() {}

  explicit DescribePortAutoCcStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (portAutoCcStatus) {
      vector<boost::any> temp1;
      for(auto item1:*portAutoCcStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortAutoCcStatus"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PortAutoCcStatus") != m.end() && !m["PortAutoCcStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["PortAutoCcStatus"].type()) {
        vector<DescribePortAutoCcStatusResponseBodyPortAutoCcStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortAutoCcStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePortAutoCcStatusResponseBodyPortAutoCcStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portAutoCcStatus = make_shared<vector<DescribePortAutoCcStatusResponseBodyPortAutoCcStatus>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePortAutoCcStatusResponseBody() = default;
};
class DescribePortAutoCcStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePortAutoCcStatusResponseBody> body{};

  DescribePortAutoCcStatusResponse() {}

  explicit DescribePortAutoCcStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePortAutoCcStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePortAutoCcStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePortAutoCcStatusResponse() = default;
};
class DescribePortConnsCountRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> port{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribePortConnsCountRequest() {}

  explicit DescribePortConnsCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribePortConnsCountRequest() = default;
};
class DescribePortConnsCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> actConns{};
  shared_ptr<long> conns{};
  shared_ptr<long> cps{};
  shared_ptr<long> inActConns{};
  shared_ptr<string> requestId{};

  DescribePortConnsCountResponseBody() {}

  explicit DescribePortConnsCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actConns) {
      res["ActConns"] = boost::any(*actConns);
    }
    if (conns) {
      res["Conns"] = boost::any(*conns);
    }
    if (cps) {
      res["Cps"] = boost::any(*cps);
    }
    if (inActConns) {
      res["InActConns"] = boost::any(*inActConns);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActConns") != m.end() && !m["ActConns"].empty()) {
      actConns = make_shared<long>(boost::any_cast<long>(m["ActConns"]));
    }
    if (m.find("Conns") != m.end() && !m["Conns"].empty()) {
      conns = make_shared<long>(boost::any_cast<long>(m["Conns"]));
    }
    if (m.find("Cps") != m.end() && !m["Cps"].empty()) {
      cps = make_shared<long>(boost::any_cast<long>(m["Cps"]));
    }
    if (m.find("InActConns") != m.end() && !m["InActConns"].empty()) {
      inActConns = make_shared<long>(boost::any_cast<long>(m["InActConns"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePortConnsCountResponseBody() = default;
};
class DescribePortConnsCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePortConnsCountResponseBody> body{};

  DescribePortConnsCountResponse() {}

  explicit DescribePortConnsCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePortConnsCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePortConnsCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePortConnsCountResponse() = default;
};
class DescribePortConnsListRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> interval{};
  shared_ptr<string> port{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribePortConnsListRequest() {}

  explicit DescribePortConnsListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribePortConnsListRequest() = default;
};
class DescribePortConnsListResponseBodyConnsList : public Darabonba::Model {
public:
  shared_ptr<long> actConns{};
  shared_ptr<long> conns{};
  shared_ptr<long> cps{};
  shared_ptr<long> inActConns{};
  shared_ptr<long> index{};

  DescribePortConnsListResponseBodyConnsList() {}

  explicit DescribePortConnsListResponseBodyConnsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actConns) {
      res["ActConns"] = boost::any(*actConns);
    }
    if (conns) {
      res["Conns"] = boost::any(*conns);
    }
    if (cps) {
      res["Cps"] = boost::any(*cps);
    }
    if (inActConns) {
      res["InActConns"] = boost::any(*inActConns);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActConns") != m.end() && !m["ActConns"].empty()) {
      actConns = make_shared<long>(boost::any_cast<long>(m["ActConns"]));
    }
    if (m.find("Conns") != m.end() && !m["Conns"].empty()) {
      conns = make_shared<long>(boost::any_cast<long>(m["Conns"]));
    }
    if (m.find("Cps") != m.end() && !m["Cps"].empty()) {
      cps = make_shared<long>(boost::any_cast<long>(m["Cps"]));
    }
    if (m.find("InActConns") != m.end() && !m["InActConns"].empty()) {
      inActConns = make_shared<long>(boost::any_cast<long>(m["InActConns"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
  }


  virtual ~DescribePortConnsListResponseBodyConnsList() = default;
};
class DescribePortConnsListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePortConnsListResponseBodyConnsList>> connsList{};
  shared_ptr<string> requestId{};

  DescribePortConnsListResponseBody() {}

  explicit DescribePortConnsListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connsList) {
      vector<boost::any> temp1;
      for(auto item1:*connsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConnsList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnsList") != m.end() && !m["ConnsList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConnsList"].type()) {
        vector<DescribePortConnsListResponseBodyConnsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConnsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePortConnsListResponseBodyConnsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        connsList = make_shared<vector<DescribePortConnsListResponseBodyConnsList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePortConnsListResponseBody() = default;
};
class DescribePortConnsListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePortConnsListResponseBody> body{};

  DescribePortConnsListResponse() {}

  explicit DescribePortConnsListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePortConnsListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePortConnsListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePortConnsListResponse() = default;
};
class DescribePortFlowListRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> interval{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribePortFlowListRequest() {}

  explicit DescribePortFlowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribePortFlowListRequest() = default;
};
class DescribePortFlowListResponseBodyPortFlowList : public Darabonba::Model {
public:
  shared_ptr<long> attackBps{};
  shared_ptr<long> attackPps{};
  shared_ptr<long> inBps{};
  shared_ptr<long> inPps{};
  shared_ptr<long> index{};
  shared_ptr<long> outBps{};
  shared_ptr<long> outPps{};
  shared_ptr<string> region{};
  shared_ptr<long> time{};

  DescribePortFlowListResponseBodyPortFlowList() {}

  explicit DescribePortFlowListResponseBodyPortFlowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attackBps) {
      res["AttackBps"] = boost::any(*attackBps);
    }
    if (attackPps) {
      res["AttackPps"] = boost::any(*attackPps);
    }
    if (inBps) {
      res["InBps"] = boost::any(*inBps);
    }
    if (inPps) {
      res["InPps"] = boost::any(*inPps);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (outBps) {
      res["OutBps"] = boost::any(*outBps);
    }
    if (outPps) {
      res["OutPps"] = boost::any(*outPps);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttackBps") != m.end() && !m["AttackBps"].empty()) {
      attackBps = make_shared<long>(boost::any_cast<long>(m["AttackBps"]));
    }
    if (m.find("AttackPps") != m.end() && !m["AttackPps"].empty()) {
      attackPps = make_shared<long>(boost::any_cast<long>(m["AttackPps"]));
    }
    if (m.find("InBps") != m.end() && !m["InBps"].empty()) {
      inBps = make_shared<long>(boost::any_cast<long>(m["InBps"]));
    }
    if (m.find("InPps") != m.end() && !m["InPps"].empty()) {
      inPps = make_shared<long>(boost::any_cast<long>(m["InPps"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("OutBps") != m.end() && !m["OutBps"].empty()) {
      outBps = make_shared<long>(boost::any_cast<long>(m["OutBps"]));
    }
    if (m.find("OutPps") != m.end() && !m["OutPps"].empty()) {
      outPps = make_shared<long>(boost::any_cast<long>(m["OutPps"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribePortFlowListResponseBodyPortFlowList() = default;
};
class DescribePortFlowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePortFlowListResponseBodyPortFlowList>> portFlowList{};
  shared_ptr<string> requestId{};

  DescribePortFlowListResponseBody() {}

  explicit DescribePortFlowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (portFlowList) {
      vector<boost::any> temp1;
      for(auto item1:*portFlowList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortFlowList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PortFlowList") != m.end() && !m["PortFlowList"].empty()) {
      if (typeid(vector<boost::any>) == m["PortFlowList"].type()) {
        vector<DescribePortFlowListResponseBodyPortFlowList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortFlowList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePortFlowListResponseBodyPortFlowList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portFlowList = make_shared<vector<DescribePortFlowListResponseBodyPortFlowList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePortFlowListResponseBody() = default;
};
class DescribePortFlowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePortFlowListResponseBody> body{};

  DescribePortFlowListResponse() {}

  explicit DescribePortFlowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePortFlowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePortFlowListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePortFlowListResponse() = default;
};
class DescribePortMaxConnsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribePortMaxConnsRequest() {}

  explicit DescribePortMaxConnsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribePortMaxConnsRequest() = default;
};
class DescribePortMaxConnsResponseBodyPortMaxConns : public Darabonba::Model {
public:
  shared_ptr<long> cps{};
  shared_ptr<string> ip{};
  shared_ptr<string> port{};

  DescribePortMaxConnsResponseBodyPortMaxConns() {}

  explicit DescribePortMaxConnsResponseBodyPortMaxConns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cps) {
      res["Cps"] = boost::any(*cps);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cps") != m.end() && !m["Cps"].empty()) {
      cps = make_shared<long>(boost::any_cast<long>(m["Cps"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
  }


  virtual ~DescribePortMaxConnsResponseBodyPortMaxConns() = default;
};
class DescribePortMaxConnsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePortMaxConnsResponseBodyPortMaxConns>> portMaxConns{};
  shared_ptr<string> requestId{};

  DescribePortMaxConnsResponseBody() {}

  explicit DescribePortMaxConnsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (portMaxConns) {
      vector<boost::any> temp1;
      for(auto item1:*portMaxConns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortMaxConns"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PortMaxConns") != m.end() && !m["PortMaxConns"].empty()) {
      if (typeid(vector<boost::any>) == m["PortMaxConns"].type()) {
        vector<DescribePortMaxConnsResponseBodyPortMaxConns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortMaxConns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePortMaxConnsResponseBodyPortMaxConns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portMaxConns = make_shared<vector<DescribePortMaxConnsResponseBodyPortMaxConns>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePortMaxConnsResponseBody() = default;
};
class DescribePortMaxConnsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePortMaxConnsResponseBody> body{};

  DescribePortMaxConnsResponse() {}

  explicit DescribePortMaxConnsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePortMaxConnsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePortMaxConnsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePortMaxConnsResponse() = default;
};
class DescribePortViewSourceCountriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribePortViewSourceCountriesRequest() {}

  explicit DescribePortViewSourceCountriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribePortViewSourceCountriesRequest() = default;
};
class DescribePortViewSourceCountriesResponseBodySourceCountrys : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> countryId{};

  DescribePortViewSourceCountriesResponseBodySourceCountrys() {}

  explicit DescribePortViewSourceCountriesResponseBodySourceCountrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (countryId) {
      res["CountryId"] = boost::any(*countryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CountryId") != m.end() && !m["CountryId"].empty()) {
      countryId = make_shared<string>(boost::any_cast<string>(m["CountryId"]));
    }
  }


  virtual ~DescribePortViewSourceCountriesResponseBodySourceCountrys() = default;
};
class DescribePortViewSourceCountriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribePortViewSourceCountriesResponseBodySourceCountrys>> sourceCountrys{};

  DescribePortViewSourceCountriesResponseBody() {}

  explicit DescribePortViewSourceCountriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceCountrys) {
      vector<boost::any> temp1;
      for(auto item1:*sourceCountrys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceCountrys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceCountrys") != m.end() && !m["SourceCountrys"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceCountrys"].type()) {
        vector<DescribePortViewSourceCountriesResponseBodySourceCountrys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceCountrys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePortViewSourceCountriesResponseBodySourceCountrys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceCountrys = make_shared<vector<DescribePortViewSourceCountriesResponseBodySourceCountrys>>(expect1);
      }
    }
  }


  virtual ~DescribePortViewSourceCountriesResponseBody() = default;
};
class DescribePortViewSourceCountriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePortViewSourceCountriesResponseBody> body{};

  DescribePortViewSourceCountriesResponse() {}

  explicit DescribePortViewSourceCountriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePortViewSourceCountriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePortViewSourceCountriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePortViewSourceCountriesResponse() = default;
};
class DescribePortViewSourceIspsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribePortViewSourceIspsRequest() {}

  explicit DescribePortViewSourceIspsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribePortViewSourceIspsRequest() = default;
};
class DescribePortViewSourceIspsResponseBodyIsps : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> ispId{};

  DescribePortViewSourceIspsResponseBodyIsps() {}

  explicit DescribePortViewSourceIspsResponseBodyIsps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (ispId) {
      res["IspId"] = boost::any(*ispId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("IspId") != m.end() && !m["IspId"].empty()) {
      ispId = make_shared<string>(boost::any_cast<string>(m["IspId"]));
    }
  }


  virtual ~DescribePortViewSourceIspsResponseBodyIsps() = default;
};
class DescribePortViewSourceIspsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePortViewSourceIspsResponseBodyIsps>> isps{};
  shared_ptr<string> requestId{};

  DescribePortViewSourceIspsResponseBody() {}

  explicit DescribePortViewSourceIspsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isps) {
      vector<boost::any> temp1;
      for(auto item1:*isps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Isps"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Isps") != m.end() && !m["Isps"].empty()) {
      if (typeid(vector<boost::any>) == m["Isps"].type()) {
        vector<DescribePortViewSourceIspsResponseBodyIsps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Isps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePortViewSourceIspsResponseBodyIsps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        isps = make_shared<vector<DescribePortViewSourceIspsResponseBodyIsps>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePortViewSourceIspsResponseBody() = default;
};
class DescribePortViewSourceIspsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePortViewSourceIspsResponseBody> body{};

  DescribePortViewSourceIspsResponse() {}

  explicit DescribePortViewSourceIspsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePortViewSourceIspsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePortViewSourceIspsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePortViewSourceIspsResponse() = default;
};
class DescribePortViewSourceProvincesRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};

  DescribePortViewSourceProvincesRequest() {}

  explicit DescribePortViewSourceProvincesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribePortViewSourceProvincesRequest() = default;
};
class DescribePortViewSourceProvincesResponseBodySourceProvinces : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> provinceId{};

  DescribePortViewSourceProvincesResponseBodySourceProvinces() {}

  explicit DescribePortViewSourceProvincesResponseBodySourceProvinces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (provinceId) {
      res["ProvinceId"] = boost::any(*provinceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("ProvinceId") != m.end() && !m["ProvinceId"].empty()) {
      provinceId = make_shared<string>(boost::any_cast<string>(m["ProvinceId"]));
    }
  }


  virtual ~DescribePortViewSourceProvincesResponseBodySourceProvinces() = default;
};
class DescribePortViewSourceProvincesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribePortViewSourceProvincesResponseBodySourceProvinces>> sourceProvinces{};

  DescribePortViewSourceProvincesResponseBody() {}

  explicit DescribePortViewSourceProvincesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceProvinces) {
      vector<boost::any> temp1;
      for(auto item1:*sourceProvinces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceProvinces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceProvinces") != m.end() && !m["SourceProvinces"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceProvinces"].type()) {
        vector<DescribePortViewSourceProvincesResponseBodySourceProvinces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceProvinces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePortViewSourceProvincesResponseBodySourceProvinces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceProvinces = make_shared<vector<DescribePortViewSourceProvincesResponseBodySourceProvinces>>(expect1);
      }
    }
  }


  virtual ~DescribePortViewSourceProvincesResponseBody() = default;
};
class DescribePortViewSourceProvincesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePortViewSourceProvincesResponseBody> body{};

  DescribePortViewSourceProvincesResponse() {}

  explicit DescribePortViewSourceProvincesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePortViewSourceProvincesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePortViewSourceProvincesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePortViewSourceProvincesResponse() = default;
};
class DescribeSceneDefenseObjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> policyId{};
  shared_ptr<string> resourceGroupId{};

  DescribeSceneDefenseObjectsRequest() {}

  explicit DescribeSceneDefenseObjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeSceneDefenseObjectsRequest() = default;
};
class DescribeSceneDefenseObjectsResponseBodyObjects : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> policyId{};
  shared_ptr<string> vip{};

  DescribeSceneDefenseObjectsResponseBodyObjects() {}

  explicit DescribeSceneDefenseObjectsResponseBodyObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (vip) {
      res["Vip"] = boost::any(*vip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("Vip") != m.end() && !m["Vip"].empty()) {
      vip = make_shared<string>(boost::any_cast<string>(m["Vip"]));
    }
  }


  virtual ~DescribeSceneDefenseObjectsResponseBodyObjects() = default;
};
class DescribeSceneDefenseObjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSceneDefenseObjectsResponseBodyObjects>> objects{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeSceneDefenseObjectsResponseBody() {}

  explicit DescribeSceneDefenseObjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objects) {
      vector<boost::any> temp1;
      for(auto item1:*objects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Objects"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Objects") != m.end() && !m["Objects"].empty()) {
      if (typeid(vector<boost::any>) == m["Objects"].type()) {
        vector<DescribeSceneDefenseObjectsResponseBodyObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Objects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSceneDefenseObjectsResponseBodyObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        objects = make_shared<vector<DescribeSceneDefenseObjectsResponseBodyObjects>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSceneDefenseObjectsResponseBody() = default;
};
class DescribeSceneDefenseObjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSceneDefenseObjectsResponseBody> body{};

  DescribeSceneDefenseObjectsResponse() {}

  explicit DescribeSceneDefenseObjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSceneDefenseObjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSceneDefenseObjectsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSceneDefenseObjectsResponse() = default;
};
class DescribeSceneDefensePoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> template_{};

  DescribeSceneDefensePoliciesRequest() {}

  explicit DescribeSceneDefensePoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~DescribeSceneDefensePoliciesRequest() = default;
};
class DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies : public Darabonba::Model {
public:
  shared_ptr<string> newValue{};
  shared_ptr<long> policyType{};
  shared_ptr<long> status{};
  shared_ptr<string> oldValue{};

  DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies() {}

  explicit DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newValue) {
      res["NewValue"] = boost::any(*newValue);
    }
    if (policyType) {
      res["PolicyType"] = boost::any(*policyType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (oldValue) {
      res["oldValue"] = boost::any(*oldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewValue") != m.end() && !m["NewValue"].empty()) {
      newValue = make_shared<string>(boost::any_cast<string>(m["NewValue"]));
    }
    if (m.find("PolicyType") != m.end() && !m["PolicyType"].empty()) {
      policyType = make_shared<long>(boost::any_cast<long>(m["PolicyType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("oldValue") != m.end() && !m["oldValue"].empty()) {
      oldValue = make_shared<string>(boost::any_cast<string>(m["oldValue"]));
    }
  }


  virtual ~DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies() = default;
};
class DescribeSceneDefensePoliciesResponseBodyPolicies : public Darabonba::Model {
public:
  shared_ptr<long> done{};
  shared_ptr<long> endTime{};
  shared_ptr<string> name{};
  shared_ptr<long> objectCount{};
  shared_ptr<string> policyId{};
  shared_ptr<vector<DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies>> runtimePolicies{};
  shared_ptr<long> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> template_{};

  DescribeSceneDefensePoliciesResponseBodyPolicies() {}

  explicit DescribeSceneDefensePoliciesResponseBodyPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (done) {
      res["Done"] = boost::any(*done);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objectCount) {
      res["ObjectCount"] = boost::any(*objectCount);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (runtimePolicies) {
      vector<boost::any> temp1;
      for(auto item1:*runtimePolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuntimePolicies"] = boost::any(temp1);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Done") != m.end() && !m["Done"].empty()) {
      done = make_shared<long>(boost::any_cast<long>(m["Done"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ObjectCount") != m.end() && !m["ObjectCount"].empty()) {
      objectCount = make_shared<long>(boost::any_cast<long>(m["ObjectCount"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RuntimePolicies") != m.end() && !m["RuntimePolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["RuntimePolicies"].type()) {
        vector<DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuntimePolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runtimePolicies = make_shared<vector<DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies>>(expect1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~DescribeSceneDefensePoliciesResponseBodyPolicies() = default;
};
class DescribeSceneDefensePoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSceneDefensePoliciesResponseBodyPolicies>> policies{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeSceneDefensePoliciesResponseBody() {}

  explicit DescribeSceneDefensePoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<DescribeSceneDefensePoliciesResponseBodyPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSceneDefensePoliciesResponseBodyPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<DescribeSceneDefensePoliciesResponseBodyPolicies>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSceneDefensePoliciesResponseBody() = default;
};
class DescribeSceneDefensePoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSceneDefensePoliciesResponseBody> body{};

  DescribeSceneDefensePoliciesResponse() {}

  explicit DescribeSceneDefensePoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSceneDefensePoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSceneDefensePoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSceneDefensePoliciesResponse() = default;
};
class DescribeSchedulerRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> ruleName{};

  DescribeSchedulerRulesRequest() {}

  explicit DescribeSchedulerRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~DescribeSchedulerRulesRequest() = default;
};
class DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData : public Darabonba::Model {
public:
  shared_ptr<string> cloudInstanceId{};

  DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData() {}

  explicit DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudInstanceId) {
      res["CloudInstanceId"] = boost::any(*cloudInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudInstanceId") != m.end() && !m["CloudInstanceId"].empty()) {
      cloudInstanceId = make_shared<string>(boost::any_cast<string>(m["CloudInstanceId"]));
    }
  }


  virtual ~DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData() = default;
};
class DescribeSchedulerRulesResponseBodySchedulerRulesParam : public Darabonba::Model {
public:
  shared_ptr<DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData> paramData{};
  shared_ptr<string> paramType{};

  DescribeSchedulerRulesResponseBodySchedulerRulesParam() {}

  explicit DescribeSchedulerRulesResponseBodySchedulerRulesParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramData) {
      res["ParamData"] = paramData ? boost::any(paramData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamData") != m.end() && !m["ParamData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParamData"].type()) {
        DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParamData"]));
        paramData = make_shared<DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData>(model1);
      }
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
  }


  virtual ~DescribeSchedulerRulesResponseBodySchedulerRulesParam() = default;
};
class DescribeSchedulerRulesResponseBodySchedulerRulesRules : public Darabonba::Model {
public:
  shared_ptr<long> priority{};
  shared_ptr<string> regionId{};
  shared_ptr<long> restoreDelay{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<long> valueType{};

  DescribeSchedulerRulesResponseBodySchedulerRulesRules() {}

  explicit DescribeSchedulerRulesResponseBodySchedulerRulesRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (restoreDelay) {
      res["RestoreDelay"] = boost::any(*restoreDelay);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RestoreDelay") != m.end() && !m["RestoreDelay"].empty()) {
      restoreDelay = make_shared<long>(boost::any_cast<long>(m["RestoreDelay"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<long>(boost::any_cast<long>(m["ValueType"]));
    }
  }


  virtual ~DescribeSchedulerRulesResponseBodySchedulerRulesRules() = default;
};
class DescribeSchedulerRulesResponseBodySchedulerRules : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<DescribeSchedulerRulesResponseBodySchedulerRulesParam> param{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleType{};
  shared_ptr<vector<DescribeSchedulerRulesResponseBodySchedulerRulesRules>> rules{};

  DescribeSchedulerRulesResponseBodySchedulerRules() {}

  explicit DescribeSchedulerRulesResponseBodySchedulerRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        DescribeSchedulerRulesResponseBodySchedulerRulesParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<DescribeSchedulerRulesResponseBodySchedulerRulesParam>(model1);
      }
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeSchedulerRulesResponseBodySchedulerRulesRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSchedulerRulesResponseBodySchedulerRulesRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeSchedulerRulesResponseBodySchedulerRulesRules>>(expect1);
      }
    }
  }


  virtual ~DescribeSchedulerRulesResponseBodySchedulerRules() = default;
};
class DescribeSchedulerRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSchedulerRulesResponseBodySchedulerRules>> schedulerRules{};
  shared_ptr<string> totalCount{};

  DescribeSchedulerRulesResponseBody() {}

  explicit DescribeSchedulerRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schedulerRules) {
      vector<boost::any> temp1;
      for(auto item1:*schedulerRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SchedulerRules"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchedulerRules") != m.end() && !m["SchedulerRules"].empty()) {
      if (typeid(vector<boost::any>) == m["SchedulerRules"].type()) {
        vector<DescribeSchedulerRulesResponseBodySchedulerRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SchedulerRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSchedulerRulesResponseBodySchedulerRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulerRules = make_shared<vector<DescribeSchedulerRulesResponseBodySchedulerRules>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSchedulerRulesResponseBody() = default;
};
class DescribeSchedulerRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSchedulerRulesResponseBody> body{};

  DescribeSchedulerRulesResponse() {}

  explicit DescribeSchedulerRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSchedulerRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSchedulerRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSchedulerRulesResponse() = default;
};
class DescribeSlsAuthStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  DescribeSlsAuthStatusRequest() {}

  explicit DescribeSlsAuthStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeSlsAuthStatusRequest() = default;
};
class DescribeSlsAuthStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> slsAuthStatus{};

  DescribeSlsAuthStatusResponseBody() {}

  explicit DescribeSlsAuthStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slsAuthStatus) {
      res["SlsAuthStatus"] = boost::any(*slsAuthStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlsAuthStatus") != m.end() && !m["SlsAuthStatus"].empty()) {
      slsAuthStatus = make_shared<bool>(boost::any_cast<bool>(m["SlsAuthStatus"]));
    }
  }


  virtual ~DescribeSlsAuthStatusResponseBody() = default;
};
class DescribeSlsAuthStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSlsAuthStatusResponseBody> body{};

  DescribeSlsAuthStatusResponse() {}

  explicit DescribeSlsAuthStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlsAuthStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlsAuthStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlsAuthStatusResponse() = default;
};
class DescribeSlsLogstoreInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  DescribeSlsLogstoreInfoRequest() {}

  explicit DescribeSlsLogstoreInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeSlsLogstoreInfoRequest() = default;
};
class DescribeSlsLogstoreInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> logStore{};
  shared_ptr<string> project{};
  shared_ptr<long> quota{};
  shared_ptr<string> requestId{};
  shared_ptr<long> ttl{};
  shared_ptr<long> used{};

  DescribeSlsLogstoreInfoResponseBody() {}

  explicit DescribeSlsLogstoreInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["Quota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
  }


  virtual ~DescribeSlsLogstoreInfoResponseBody() = default;
};
class DescribeSlsLogstoreInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSlsLogstoreInfoResponseBody> body{};

  DescribeSlsLogstoreInfoResponse() {}

  explicit DescribeSlsLogstoreInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlsLogstoreInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlsLogstoreInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlsLogstoreInfoResponse() = default;
};
class DescribeSlsOpenStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  DescribeSlsOpenStatusRequest() {}

  explicit DescribeSlsOpenStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeSlsOpenStatusRequest() = default;
};
class DescribeSlsOpenStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> slsOpenStatus{};

  DescribeSlsOpenStatusResponseBody() {}

  explicit DescribeSlsOpenStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slsOpenStatus) {
      res["SlsOpenStatus"] = boost::any(*slsOpenStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlsOpenStatus") != m.end() && !m["SlsOpenStatus"].empty()) {
      slsOpenStatus = make_shared<bool>(boost::any_cast<bool>(m["SlsOpenStatus"]));
    }
  }


  virtual ~DescribeSlsOpenStatusResponseBody() = default;
};
class DescribeSlsOpenStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSlsOpenStatusResponseBody> body{};

  DescribeSlsOpenStatusResponse() {}

  explicit DescribeSlsOpenStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlsOpenStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlsOpenStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlsOpenStatusResponse() = default;
};
class DescribeStsGrantStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> role{};

  DescribeStsGrantStatusRequest() {}

  explicit DescribeStsGrantStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~DescribeStsGrantStatusRequest() = default;
};
class DescribeStsGrantStatusResponseBodyStsGrant : public Darabonba::Model {
public:
  shared_ptr<long> status{};

  DescribeStsGrantStatusResponseBodyStsGrant() {}

  explicit DescribeStsGrantStatusResponseBodyStsGrant(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeStsGrantStatusResponseBodyStsGrant() = default;
};
class DescribeStsGrantStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeStsGrantStatusResponseBodyStsGrant> stsGrant{};

  DescribeStsGrantStatusResponseBody() {}

  explicit DescribeStsGrantStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stsGrant) {
      res["StsGrant"] = stsGrant ? boost::any(stsGrant->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StsGrant") != m.end() && !m["StsGrant"].empty()) {
      if (typeid(map<string, boost::any>) == m["StsGrant"].type()) {
        DescribeStsGrantStatusResponseBodyStsGrant model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StsGrant"]));
        stsGrant = make_shared<DescribeStsGrantStatusResponseBodyStsGrant>(model1);
      }
    }
  }


  virtual ~DescribeStsGrantStatusResponseBody() = default;
};
class DescribeStsGrantStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStsGrantStatusResponseBody> body{};

  DescribeStsGrantStatusResponse() {}

  explicit DescribeStsGrantStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStsGrantStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStsGrantStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStsGrantStatusResponse() = default;
};
class DescribeSystemLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> entityObject{};
  shared_ptr<long> entityType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  DescribeSystemLogRequest() {}

  explicit DescribeSystemLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (entityObject) {
      res["EntityObject"] = boost::any(*entityObject);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EntityObject") != m.end() && !m["EntityObject"].empty()) {
      entityObject = make_shared<string>(boost::any_cast<string>(m["EntityObject"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<long>(boost::any_cast<long>(m["EntityType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSystemLogRequest() = default;
};
class DescribeSystemLogResponseBodySystemLog : public Darabonba::Model {
public:
  shared_ptr<string> entityObject{};
  shared_ptr<long> entityType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> opAccount{};
  shared_ptr<long> opAction{};
  shared_ptr<string> opDesc{};
  shared_ptr<long> status{};

  DescribeSystemLogResponseBodySystemLog() {}

  explicit DescribeSystemLogResponseBodySystemLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityObject) {
      res["EntityObject"] = boost::any(*entityObject);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (opAccount) {
      res["OpAccount"] = boost::any(*opAccount);
    }
    if (opAction) {
      res["OpAction"] = boost::any(*opAction);
    }
    if (opDesc) {
      res["OpDesc"] = boost::any(*opDesc);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityObject") != m.end() && !m["EntityObject"].empty()) {
      entityObject = make_shared<string>(boost::any_cast<string>(m["EntityObject"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<long>(boost::any_cast<long>(m["EntityType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("OpAccount") != m.end() && !m["OpAccount"].empty()) {
      opAccount = make_shared<string>(boost::any_cast<string>(m["OpAccount"]));
    }
    if (m.find("OpAction") != m.end() && !m["OpAction"].empty()) {
      opAction = make_shared<long>(boost::any_cast<long>(m["OpAction"]));
    }
    if (m.find("OpDesc") != m.end() && !m["OpDesc"].empty()) {
      opDesc = make_shared<string>(boost::any_cast<string>(m["OpDesc"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeSystemLogResponseBodySystemLog() = default;
};
class DescribeSystemLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSystemLogResponseBodySystemLog>> systemLog{};
  shared_ptr<long> total{};

  DescribeSystemLogResponseBody() {}

  explicit DescribeSystemLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemLog) {
      vector<boost::any> temp1;
      for(auto item1:*systemLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemLog"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemLog") != m.end() && !m["SystemLog"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemLog"].type()) {
        vector<DescribeSystemLogResponseBodySystemLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSystemLogResponseBodySystemLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemLog = make_shared<vector<DescribeSystemLogResponseBodySystemLog>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeSystemLogResponseBody() = default;
};
class DescribeSystemLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSystemLogResponseBody> body{};

  DescribeSystemLogResponse() {}

  explicit DescribeSystemLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSystemLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSystemLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSystemLogResponse() = default;
};
class DescribeTagKeysRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};

  DescribeTagKeysRequest() {}

  explicit DescribeTagKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeTagKeysRequest() = default;
};
class DescribeTagKeysResponseBodyTagKeys : public Darabonba::Model {
public:
  shared_ptr<long> tagCount{};
  shared_ptr<string> tagKey{};

  DescribeTagKeysResponseBodyTagKeys() {}

  explicit DescribeTagKeysResponseBodyTagKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagCount) {
      res["TagCount"] = boost::any(*tagCount);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagCount") != m.end() && !m["TagCount"].empty()) {
      tagCount = make_shared<long>(boost::any_cast<long>(m["TagCount"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeTagKeysResponseBodyTagKeys() = default;
};
class DescribeTagKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTagKeysResponseBodyTagKeys>> tagKeys{};
  shared_ptr<long> totalCount{};

  DescribeTagKeysResponseBody() {}

  explicit DescribeTagKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagKeys) {
      vector<boost::any> temp1;
      for(auto item1:*tagKeys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagKeys"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      if (typeid(vector<boost::any>) == m["TagKeys"].type()) {
        vector<DescribeTagKeysResponseBodyTagKeys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagKeys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagKeysResponseBodyTagKeys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagKeys = make_shared<vector<DescribeTagKeysResponseBodyTagKeys>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTagKeysResponseBody() = default;
};
class DescribeTagKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagKeysResponseBody> body{};

  DescribeTagKeysResponse() {}

  explicit DescribeTagKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagKeysResponse() = default;
};
class DescribeTagResourcesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeTagResourcesRequestTags() {}

  explicit DescribeTagResourcesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeTagResourcesRequestTags() = default;
};
class DescribeTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeTagResourcesRequestTags>> tags{};

  DescribeTagResourcesRequest() {}

  explicit DescribeTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeTagResourcesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagResourcesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeTagResourcesRequestTags>>(expect1);
      }
    }
  }


  virtual ~DescribeTagResourcesRequest() = default;
};
class DescribeTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit DescribeTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class DescribeTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  DescribeTagResourcesResponseBodyTagResources() {}

  explicit DescribeTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<DescribeTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<DescribeTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~DescribeTagResourcesResponseBodyTagResources() = default;
};
class DescribeTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTagResourcesResponseBodyTagResources> tagResources{};

  DescribeTagResourcesResponseBody() {}

  explicit DescribeTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        DescribeTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<DescribeTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~DescribeTagResourcesResponseBody() = default;
};
class DescribeTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagResourcesResponseBody> body{};

  DescribeTagResourcesResponse() {}

  explicit DescribeTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagResourcesResponse() = default;
};
class DescribeUdpReflectRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DescribeUdpReflectRequest() {}

  explicit DescribeUdpReflectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeUdpReflectRequest() = default;
};
class DescribeUdpReflectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> udpSports{};

  DescribeUdpReflectResponseBody() {}

  explicit DescribeUdpReflectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (udpSports) {
      res["UdpSports"] = boost::any(*udpSports);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UdpSports") != m.end() && !m["UdpSports"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UdpSports"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UdpSports"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      udpSports = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeUdpReflectResponseBody() = default;
};
class DescribeUdpReflectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUdpReflectResponseBody> body{};

  DescribeUdpReflectResponse() {}

  explicit DescribeUdpReflectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUdpReflectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUdpReflectResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUdpReflectResponse() = default;
};
class DescribeUnBlackholeCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  DescribeUnBlackholeCountRequest() {}

  explicit DescribeUnBlackholeCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeUnBlackholeCountRequest() = default;
};
class DescribeUnBlackholeCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> remainCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeUnBlackholeCountResponseBody() {}

  explicit DescribeUnBlackholeCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remainCount) {
      res["RemainCount"] = boost::any(*remainCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemainCount") != m.end() && !m["RemainCount"].empty()) {
      remainCount = make_shared<long>(boost::any_cast<long>(m["RemainCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeUnBlackholeCountResponseBody() = default;
};
class DescribeUnBlackholeCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUnBlackholeCountResponseBody> body{};

  DescribeUnBlackholeCountResponse() {}

  explicit DescribeUnBlackholeCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUnBlackholeCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUnBlackholeCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUnBlackholeCountResponse() = default;
};
class DescribeUnBlockCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  DescribeUnBlockCountRequest() {}

  explicit DescribeUnBlockCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeUnBlockCountRequest() = default;
};
class DescribeUnBlockCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> remainCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeUnBlockCountResponseBody() {}

  explicit DescribeUnBlockCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remainCount) {
      res["RemainCount"] = boost::any(*remainCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemainCount") != m.end() && !m["RemainCount"].empty()) {
      remainCount = make_shared<long>(boost::any_cast<long>(m["RemainCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeUnBlockCountResponseBody() = default;
};
class DescribeUnBlockCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUnBlockCountResponseBody> body{};

  DescribeUnBlockCountResponse() {}

  explicit DescribeUnBlockCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUnBlockCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUnBlockCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUnBlockCountResponse() = default;
};
class DescribeWebAccessLogDispatchStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  DescribeWebAccessLogDispatchStatusRequest() {}

  explicit DescribeWebAccessLogDispatchStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebAccessLogDispatchStatusRequest() = default;
};
class DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<bool> enable{};

  DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus() {}

  explicit DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
  }


  virtual ~DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus() = default;
};
class DescribeWebAccessLogDispatchStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus>> slsConfigStatus{};
  shared_ptr<long> totalCount{};

  DescribeWebAccessLogDispatchStatusResponseBody() {}

  explicit DescribeWebAccessLogDispatchStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slsConfigStatus) {
      vector<boost::any> temp1;
      for(auto item1:*slsConfigStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlsConfigStatus"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlsConfigStatus") != m.end() && !m["SlsConfigStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["SlsConfigStatus"].type()) {
        vector<DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlsConfigStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slsConfigStatus = make_shared<vector<DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebAccessLogDispatchStatusResponseBody() = default;
};
class DescribeWebAccessLogDispatchStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebAccessLogDispatchStatusResponseBody> body{};

  DescribeWebAccessLogDispatchStatusResponse() {}

  explicit DescribeWebAccessLogDispatchStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebAccessLogDispatchStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebAccessLogDispatchStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebAccessLogDispatchStatusResponse() = default;
};
class DescribeWebAccessLogEmptyCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  DescribeWebAccessLogEmptyCountRequest() {}

  explicit DescribeWebAccessLogEmptyCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebAccessLogEmptyCountRequest() = default;
};
class DescribeWebAccessLogEmptyCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> availableCount{};
  shared_ptr<string> requestId{};

  DescribeWebAccessLogEmptyCountResponseBody() {}

  explicit DescribeWebAccessLogEmptyCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableCount) {
      res["AvailableCount"] = boost::any(*availableCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableCount") != m.end() && !m["AvailableCount"].empty()) {
      availableCount = make_shared<long>(boost::any_cast<long>(m["AvailableCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeWebAccessLogEmptyCountResponseBody() = default;
};
class DescribeWebAccessLogEmptyCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebAccessLogEmptyCountResponseBody> body{};

  DescribeWebAccessLogEmptyCountResponse() {}

  explicit DescribeWebAccessLogEmptyCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebAccessLogEmptyCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebAccessLogEmptyCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebAccessLogEmptyCountResponse() = default;
};
class DescribeWebAccessLogStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  DescribeWebAccessLogStatusRequest() {}

  explicit DescribeWebAccessLogStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebAccessLogStatusRequest() = default;
};
class DescribeWebAccessLogStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> slsLogstore{};
  shared_ptr<string> slsProject{};
  shared_ptr<bool> slsStatus{};

  DescribeWebAccessLogStatusResponseBody() {}

  explicit DescribeWebAccessLogStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slsLogstore) {
      res["SlsLogstore"] = boost::any(*slsLogstore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    if (slsStatus) {
      res["SlsStatus"] = boost::any(*slsStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlsLogstore") != m.end() && !m["SlsLogstore"].empty()) {
      slsLogstore = make_shared<string>(boost::any_cast<string>(m["SlsLogstore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
    if (m.find("SlsStatus") != m.end() && !m["SlsStatus"].empty()) {
      slsStatus = make_shared<bool>(boost::any_cast<bool>(m["SlsStatus"]));
    }
  }


  virtual ~DescribeWebAccessLogStatusResponseBody() = default;
};
class DescribeWebAccessLogStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebAccessLogStatusResponseBody> body{};

  DescribeWebAccessLogStatusResponse() {}

  explicit DescribeWebAccessLogStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebAccessLogStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebAccessLogStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebAccessLogStatusResponse() = default;
};
class DescribeWebAccessModeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};

  DescribeWebAccessModeRequest() {}

  explicit DescribeWebAccessModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeWebAccessModeRequest() = default;
};
class DescribeWebAccessModeResponseBodyDomainModes : public Darabonba::Model {
public:
  shared_ptr<long> accessMode{};
  shared_ptr<string> domain{};

  DescribeWebAccessModeResponseBodyDomainModes() {}

  explicit DescribeWebAccessModeResponseBodyDomainModes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<long>(boost::any_cast<long>(m["AccessMode"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
  }


  virtual ~DescribeWebAccessModeResponseBodyDomainModes() = default;
};
class DescribeWebAccessModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebAccessModeResponseBodyDomainModes>> domainModes{};
  shared_ptr<string> requestId{};

  DescribeWebAccessModeResponseBody() {}

  explicit DescribeWebAccessModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainModes) {
      vector<boost::any> temp1;
      for(auto item1:*domainModes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainModes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainModes") != m.end() && !m["DomainModes"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainModes"].type()) {
        vector<DescribeWebAccessModeResponseBodyDomainModes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainModes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebAccessModeResponseBodyDomainModes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainModes = make_shared<vector<DescribeWebAccessModeResponseBodyDomainModes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeWebAccessModeResponseBody() = default;
};
class DescribeWebAccessModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebAccessModeResponseBody> body{};

  DescribeWebAccessModeResponse() {}

  explicit DescribeWebAccessModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebAccessModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebAccessModeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebAccessModeResponse() = default;
};
class DescribeWebAreaBlockConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> resourceGroupId{};

  DescribeWebAreaBlockConfigsRequest() {}

  explicit DescribeWebAreaBlockConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebAreaBlockConfigsRequest() = default;
};
class DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList : public Darabonba::Model {
public:
  shared_ptr<long> block{};
  shared_ptr<string> region{};

  DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList() {}

  explicit DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (block) {
      res["Block"] = boost::any(*block);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Block") != m.end() && !m["Block"].empty()) {
      block = make_shared<long>(boost::any_cast<long>(m["Block"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList() = default;
};
class DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<vector<DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList>> regionList{};

  DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs() {}

  explicit DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (regionList) {
      vector<boost::any> temp1;
      for(auto item1:*regionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RegionList") != m.end() && !m["RegionList"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionList"].type()) {
        vector<DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionList = make_shared<vector<DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList>>(expect1);
      }
    }
  }


  virtual ~DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs() = default;
};
class DescribeWebAreaBlockConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs>> areaBlockConfigs{};
  shared_ptr<string> requestId{};

  DescribeWebAreaBlockConfigsResponseBody() {}

  explicit DescribeWebAreaBlockConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areaBlockConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*areaBlockConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AreaBlockConfigs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AreaBlockConfigs") != m.end() && !m["AreaBlockConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["AreaBlockConfigs"].type()) {
        vector<DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AreaBlockConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        areaBlockConfigs = make_shared<vector<DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeWebAreaBlockConfigsResponseBody() = default;
};
class DescribeWebAreaBlockConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebAreaBlockConfigsResponseBody> body{};

  DescribeWebAreaBlockConfigsResponse() {}

  explicit DescribeWebAreaBlockConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebAreaBlockConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebAreaBlockConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebAreaBlockConfigsResponse() = default;
};
class DescribeWebCCRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> resourceGroupId{};

  DescribeWebCCRulesRequest() {}

  explicit DescribeWebCCRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebCCRulesRequest() = default;
};
class DescribeWebCCRulesResponseBodyWebCCRules : public Darabonba::Model {
public:
  shared_ptr<string> act{};
  shared_ptr<long> count{};
  shared_ptr<long> interval{};
  shared_ptr<string> mode{};
  shared_ptr<string> name{};
  shared_ptr<long> ttl{};
  shared_ptr<string> uri{};

  DescribeWebCCRulesResponseBodyWebCCRules() {}

  explicit DescribeWebCCRulesResponseBodyWebCCRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (act) {
      res["Act"] = boost::any(*act);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Act") != m.end() && !m["Act"].empty()) {
      act = make_shared<string>(boost::any_cast<string>(m["Act"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~DescribeWebCCRulesResponseBodyWebCCRules() = default;
};
class DescribeWebCCRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeWebCCRulesResponseBodyWebCCRules>> webCCRules{};

  DescribeWebCCRulesResponseBody() {}

  explicit DescribeWebCCRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (webCCRules) {
      vector<boost::any> temp1;
      for(auto item1:*webCCRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebCCRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WebCCRules") != m.end() && !m["WebCCRules"].empty()) {
      if (typeid(vector<boost::any>) == m["WebCCRules"].type()) {
        vector<DescribeWebCCRulesResponseBodyWebCCRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebCCRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebCCRulesResponseBodyWebCCRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webCCRules = make_shared<vector<DescribeWebCCRulesResponseBodyWebCCRules>>(expect1);
      }
    }
  }


  virtual ~DescribeWebCCRulesResponseBody() = default;
};
class DescribeWebCCRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebCCRulesResponseBody> body{};

  DescribeWebCCRulesResponse() {}

  explicit DescribeWebCCRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebCCRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebCCRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebCCRulesResponse() = default;
};
class DescribeWebCacheConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> resourceGroupId{};

  DescribeWebCacheConfigsRequest() {}

  explicit DescribeWebCacheConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebCacheConfigsRequest() = default;
};
class DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules : public Darabonba::Model {
public:
  shared_ptr<long> cacheTtl{};
  shared_ptr<string> mode{};
  shared_ptr<string> name{};
  shared_ptr<string> uri{};

  DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules() {}

  explicit DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheTtl) {
      res["CacheTtl"] = boost::any(*cacheTtl);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CacheTtl") != m.end() && !m["CacheTtl"].empty()) {
      cacheTtl = make_shared<long>(boost::any_cast<long>(m["CacheTtl"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules() = default;
};
class DescribeWebCacheConfigsResponseBodyDomainCacheConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules>> customRules{};
  shared_ptr<string> domain{};
  shared_ptr<long> enable{};
  shared_ptr<string> mode{};

  DescribeWebCacheConfigsResponseBodyDomainCacheConfigs() {}

  explicit DescribeWebCacheConfigsResponseBodyDomainCacheConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customRules) {
      vector<boost::any> temp1;
      for(auto item1:*customRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomRules"] = boost::any(temp1);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomRules") != m.end() && !m["CustomRules"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomRules"].type()) {
        vector<DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customRules = make_shared<vector<DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules>>(expect1);
      }
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<long>(boost::any_cast<long>(m["Enable"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~DescribeWebCacheConfigsResponseBodyDomainCacheConfigs() = default;
};
class DescribeWebCacheConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebCacheConfigsResponseBodyDomainCacheConfigs>> domainCacheConfigs{};
  shared_ptr<string> requestId{};

  DescribeWebCacheConfigsResponseBody() {}

  explicit DescribeWebCacheConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCacheConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*domainCacheConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainCacheConfigs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCacheConfigs") != m.end() && !m["DomainCacheConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainCacheConfigs"].type()) {
        vector<DescribeWebCacheConfigsResponseBodyDomainCacheConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainCacheConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebCacheConfigsResponseBodyDomainCacheConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainCacheConfigs = make_shared<vector<DescribeWebCacheConfigsResponseBodyDomainCacheConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeWebCacheConfigsResponseBody() = default;
};
class DescribeWebCacheConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebCacheConfigsResponseBody> body{};

  DescribeWebCacheConfigsResponse() {}

  explicit DescribeWebCacheConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebCacheConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebCacheConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebCacheConfigsResponse() = default;
};
class DescribeWebCcProtectSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> resourceGroupId{};

  DescribeWebCcProtectSwitchRequest() {}

  explicit DescribeWebCcProtectSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebCcProtectSwitchRequest() = default;
};
class DescribeWebCcProtectSwitchResponseBodyProtectSwitchList : public Darabonba::Model {
public:
  shared_ptr<string> aiMode{};
  shared_ptr<long> aiRuleEnable{};
  shared_ptr<string> aiTemplate{};
  shared_ptr<long> blackWhiteListEnable{};
  shared_ptr<long> ccCustomRuleEnable{};
  shared_ptr<long> ccEnable{};
  shared_ptr<string> ccTemplate{};
  shared_ptr<string> domain{};
  shared_ptr<long> preciseRuleEnable{};
  shared_ptr<long> regionBlockEnable{};

  DescribeWebCcProtectSwitchResponseBodyProtectSwitchList() {}

  explicit DescribeWebCcProtectSwitchResponseBodyProtectSwitchList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiMode) {
      res["AiMode"] = boost::any(*aiMode);
    }
    if (aiRuleEnable) {
      res["AiRuleEnable"] = boost::any(*aiRuleEnable);
    }
    if (aiTemplate) {
      res["AiTemplate"] = boost::any(*aiTemplate);
    }
    if (blackWhiteListEnable) {
      res["BlackWhiteListEnable"] = boost::any(*blackWhiteListEnable);
    }
    if (ccCustomRuleEnable) {
      res["CcCustomRuleEnable"] = boost::any(*ccCustomRuleEnable);
    }
    if (ccEnable) {
      res["CcEnable"] = boost::any(*ccEnable);
    }
    if (ccTemplate) {
      res["CcTemplate"] = boost::any(*ccTemplate);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (preciseRuleEnable) {
      res["PreciseRuleEnable"] = boost::any(*preciseRuleEnable);
    }
    if (regionBlockEnable) {
      res["RegionBlockEnable"] = boost::any(*regionBlockEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiMode") != m.end() && !m["AiMode"].empty()) {
      aiMode = make_shared<string>(boost::any_cast<string>(m["AiMode"]));
    }
    if (m.find("AiRuleEnable") != m.end() && !m["AiRuleEnable"].empty()) {
      aiRuleEnable = make_shared<long>(boost::any_cast<long>(m["AiRuleEnable"]));
    }
    if (m.find("AiTemplate") != m.end() && !m["AiTemplate"].empty()) {
      aiTemplate = make_shared<string>(boost::any_cast<string>(m["AiTemplate"]));
    }
    if (m.find("BlackWhiteListEnable") != m.end() && !m["BlackWhiteListEnable"].empty()) {
      blackWhiteListEnable = make_shared<long>(boost::any_cast<long>(m["BlackWhiteListEnable"]));
    }
    if (m.find("CcCustomRuleEnable") != m.end() && !m["CcCustomRuleEnable"].empty()) {
      ccCustomRuleEnable = make_shared<long>(boost::any_cast<long>(m["CcCustomRuleEnable"]));
    }
    if (m.find("CcEnable") != m.end() && !m["CcEnable"].empty()) {
      ccEnable = make_shared<long>(boost::any_cast<long>(m["CcEnable"]));
    }
    if (m.find("CcTemplate") != m.end() && !m["CcTemplate"].empty()) {
      ccTemplate = make_shared<string>(boost::any_cast<string>(m["CcTemplate"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("PreciseRuleEnable") != m.end() && !m["PreciseRuleEnable"].empty()) {
      preciseRuleEnable = make_shared<long>(boost::any_cast<long>(m["PreciseRuleEnable"]));
    }
    if (m.find("RegionBlockEnable") != m.end() && !m["RegionBlockEnable"].empty()) {
      regionBlockEnable = make_shared<long>(boost::any_cast<long>(m["RegionBlockEnable"]));
    }
  }


  virtual ~DescribeWebCcProtectSwitchResponseBodyProtectSwitchList() = default;
};
class DescribeWebCcProtectSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebCcProtectSwitchResponseBodyProtectSwitchList>> protectSwitchList{};
  shared_ptr<string> requestId{};

  DescribeWebCcProtectSwitchResponseBody() {}

  explicit DescribeWebCcProtectSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (protectSwitchList) {
      vector<boost::any> temp1;
      for(auto item1:*protectSwitchList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProtectSwitchList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProtectSwitchList") != m.end() && !m["ProtectSwitchList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProtectSwitchList"].type()) {
        vector<DescribeWebCcProtectSwitchResponseBodyProtectSwitchList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProtectSwitchList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebCcProtectSwitchResponseBodyProtectSwitchList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        protectSwitchList = make_shared<vector<DescribeWebCcProtectSwitchResponseBodyProtectSwitchList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeWebCcProtectSwitchResponseBody() = default;
};
class DescribeWebCcProtectSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebCcProtectSwitchResponseBody> body{};

  DescribeWebCcProtectSwitchResponse() {}

  explicit DescribeWebCcProtectSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebCcProtectSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebCcProtectSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebCcProtectSwitchResponse() = default;
};
class DescribeWebCustomPortsRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  DescribeWebCustomPortsRequest() {}

  explicit DescribeWebCustomPortsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebCustomPortsRequest() = default;
};
class DescribeWebCustomPortsResponseBodyWebCustomPorts : public Darabonba::Model {
public:
  shared_ptr<vector<string>> proxyPorts{};
  shared_ptr<string> proxyType{};

  DescribeWebCustomPortsResponseBodyWebCustomPorts() {}

  explicit DescribeWebCustomPortsResponseBodyWebCustomPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyPorts) {
      res["ProxyPorts"] = boost::any(*proxyPorts);
    }
    if (proxyType) {
      res["ProxyType"] = boost::any(*proxyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyPorts") != m.end() && !m["ProxyPorts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProxyPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProxyPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      proxyPorts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProxyType") != m.end() && !m["ProxyType"].empty()) {
      proxyType = make_shared<string>(boost::any_cast<string>(m["ProxyType"]));
    }
  }


  virtual ~DescribeWebCustomPortsResponseBodyWebCustomPorts() = default;
};
class DescribeWebCustomPortsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeWebCustomPortsResponseBodyWebCustomPorts>> webCustomPorts{};

  DescribeWebCustomPortsResponseBody() {}

  explicit DescribeWebCustomPortsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (webCustomPorts) {
      vector<boost::any> temp1;
      for(auto item1:*webCustomPorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebCustomPorts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WebCustomPorts") != m.end() && !m["WebCustomPorts"].empty()) {
      if (typeid(vector<boost::any>) == m["WebCustomPorts"].type()) {
        vector<DescribeWebCustomPortsResponseBodyWebCustomPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebCustomPorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebCustomPortsResponseBodyWebCustomPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webCustomPorts = make_shared<vector<DescribeWebCustomPortsResponseBodyWebCustomPorts>>(expect1);
      }
    }
  }


  virtual ~DescribeWebCustomPortsResponseBody() = default;
};
class DescribeWebCustomPortsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebCustomPortsResponseBody> body{};

  DescribeWebCustomPortsResponse() {}

  explicit DescribeWebCustomPortsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebCustomPortsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebCustomPortsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebCustomPortsResponse() = default;
};
class DescribeWebInstanceRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> resourceGroupId{};

  DescribeWebInstanceRelationsRequest() {}

  explicit DescribeWebInstanceRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebInstanceRelationsRequest() = default;
};
class DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails : public Darabonba::Model {
public:
  shared_ptr<vector<string>> eipList{};
  shared_ptr<string> functionVersion{};
  shared_ptr<string> instanceId{};

  DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails() {}

  explicit DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipList) {
      res["EipList"] = boost::any(*eipList);
    }
    if (functionVersion) {
      res["FunctionVersion"] = boost::any(*functionVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipList") != m.end() && !m["EipList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EipList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EipList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eipList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FunctionVersion") != m.end() && !m["FunctionVersion"].empty()) {
      functionVersion = make_shared<string>(boost::any_cast<string>(m["FunctionVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails() = default;
};
class DescribeWebInstanceRelationsResponseBodyWebInstanceRelations : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<vector<DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails>> instanceDetails{};

  DescribeWebInstanceRelationsResponseBodyWebInstanceRelations() {}

  explicit DescribeWebInstanceRelationsResponseBodyWebInstanceRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*instanceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceDetails") != m.end() && !m["InstanceDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceDetails"].type()) {
        vector<DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceDetails = make_shared<vector<DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails>>(expect1);
      }
    }
  }


  virtual ~DescribeWebInstanceRelationsResponseBodyWebInstanceRelations() = default;
};
class DescribeWebInstanceRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeWebInstanceRelationsResponseBodyWebInstanceRelations>> webInstanceRelations{};

  DescribeWebInstanceRelationsResponseBody() {}

  explicit DescribeWebInstanceRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (webInstanceRelations) {
      vector<boost::any> temp1;
      for(auto item1:*webInstanceRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebInstanceRelations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WebInstanceRelations") != m.end() && !m["WebInstanceRelations"].empty()) {
      if (typeid(vector<boost::any>) == m["WebInstanceRelations"].type()) {
        vector<DescribeWebInstanceRelationsResponseBodyWebInstanceRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebInstanceRelations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebInstanceRelationsResponseBodyWebInstanceRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webInstanceRelations = make_shared<vector<DescribeWebInstanceRelationsResponseBodyWebInstanceRelations>>(expect1);
      }
    }
  }


  virtual ~DescribeWebInstanceRelationsResponseBody() = default;
};
class DescribeWebInstanceRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebInstanceRelationsResponseBody> body{};

  DescribeWebInstanceRelationsResponse() {}

  explicit DescribeWebInstanceRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebInstanceRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebInstanceRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebInstanceRelationsResponse() = default;
};
class DescribeWebPreciseAccessRuleRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> resourceGroupId{};

  DescribeWebPreciseAccessRuleRequest() {}

  explicit DescribeWebPreciseAccessRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebPreciseAccessRuleRequest() = default;
};
class DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> field{};
  shared_ptr<string> headerName{};
  shared_ptr<string> matchMethod{};

  DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList() {}

  explicit DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (headerName) {
      res["HeaderName"] = boost::any(*headerName);
    }
    if (matchMethod) {
      res["MatchMethod"] = boost::any(*matchMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("HeaderName") != m.end() && !m["HeaderName"].empty()) {
      headerName = make_shared<string>(boost::any_cast<string>(m["HeaderName"]));
    }
    if (m.find("MatchMethod") != m.end() && !m["MatchMethod"].empty()) {
      matchMethod = make_shared<string>(boost::any_cast<string>(m["MatchMethod"]));
    }
  }


  virtual ~DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList() = default;
};
class DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<vector<DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList>> conditionList{};
  shared_ptr<long> expires{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};

  DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList() {}

  explicit DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (conditionList) {
      vector<boost::any> temp1;
      for(auto item1:*conditionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionList"] = boost::any(temp1);
    }
    if (expires) {
      res["Expires"] = boost::any(*expires);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("ConditionList") != m.end() && !m["ConditionList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionList"].type()) {
        vector<DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionList = make_shared<vector<DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList>>(expect1);
      }
    }
    if (m.find("Expires") != m.end() && !m["Expires"].empty()) {
      expires = make_shared<long>(boost::any_cast<long>(m["Expires"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
  }


  virtual ~DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList() = default;
};
class DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<vector<DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList>> ruleList{};

  DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList() {}

  explicit DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList>>(expect1);
      }
    }
  }


  virtual ~DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList() = default;
};
class DescribeWebPreciseAccessRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList>> preciseAccessConfigList{};
  shared_ptr<string> requestId{};

  DescribeWebPreciseAccessRuleResponseBody() {}

  explicit DescribeWebPreciseAccessRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preciseAccessConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*preciseAccessConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreciseAccessConfigList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreciseAccessConfigList") != m.end() && !m["PreciseAccessConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["PreciseAccessConfigList"].type()) {
        vector<DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreciseAccessConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preciseAccessConfigList = make_shared<vector<DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeWebPreciseAccessRuleResponseBody() = default;
};
class DescribeWebPreciseAccessRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebPreciseAccessRuleResponseBody> body{};

  DescribeWebPreciseAccessRuleResponse() {}

  explicit DescribeWebPreciseAccessRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebPreciseAccessRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebPreciseAccessRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebPreciseAccessRuleResponse() = default;
};
class DescribeWebRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> domain{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryDomainPattern{};
  shared_ptr<string> resourceGroupId{};

  DescribeWebRulesRequest() {}

  explicit DescribeWebRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryDomainPattern) {
      res["QueryDomainPattern"] = boost::any(*queryDomainPattern);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryDomainPattern") != m.end() && !m["QueryDomainPattern"].empty()) {
      queryDomainPattern = make_shared<string>(boost::any_cast<string>(m["QueryDomainPattern"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeWebRulesRequest() = default;
};
class DescribeWebRulesResponseBodyWebRulesGmCert : public Darabonba::Model {
public:
  shared_ptr<string> certId{};
  shared_ptr<long> gmEnable{};
  shared_ptr<long> gmOnly{};

  DescribeWebRulesResponseBodyWebRulesGmCert() {}

  explicit DescribeWebRulesResponseBodyWebRulesGmCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (gmEnable) {
      res["GmEnable"] = boost::any(*gmEnable);
    }
    if (gmOnly) {
      res["GmOnly"] = boost::any(*gmOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("GmEnable") != m.end() && !m["GmEnable"].empty()) {
      gmEnable = make_shared<long>(boost::any_cast<long>(m["GmEnable"]));
    }
    if (m.find("GmOnly") != m.end() && !m["GmOnly"].empty()) {
      gmOnly = make_shared<long>(boost::any_cast<long>(m["GmOnly"]));
    }
  }


  virtual ~DescribeWebRulesResponseBodyWebRulesGmCert() = default;
};
class DescribeWebRulesResponseBodyWebRulesProxyTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> proxyPorts{};
  shared_ptr<string> proxyType{};

  DescribeWebRulesResponseBodyWebRulesProxyTypes() {}

  explicit DescribeWebRulesResponseBodyWebRulesProxyTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyPorts) {
      res["ProxyPorts"] = boost::any(*proxyPorts);
    }
    if (proxyType) {
      res["ProxyType"] = boost::any(*proxyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyPorts") != m.end() && !m["ProxyPorts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProxyPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProxyPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      proxyPorts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProxyType") != m.end() && !m["ProxyType"].empty()) {
      proxyType = make_shared<string>(boost::any_cast<string>(m["ProxyType"]));
    }
  }


  virtual ~DescribeWebRulesResponseBodyWebRulesProxyTypes() = default;
};
class DescribeWebRulesResponseBodyWebRulesRealServers : public Darabonba::Model {
public:
  shared_ptr<string> realServer{};
  shared_ptr<long> rsType{};

  DescribeWebRulesResponseBodyWebRulesRealServers() {}

  explicit DescribeWebRulesResponseBodyWebRulesRealServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realServer) {
      res["RealServer"] = boost::any(*realServer);
    }
    if (rsType) {
      res["RsType"] = boost::any(*rsType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealServer") != m.end() && !m["RealServer"].empty()) {
      realServer = make_shared<string>(boost::any_cast<string>(m["RealServer"]));
    }
    if (m.find("RsType") != m.end() && !m["RsType"].empty()) {
      rsType = make_shared<long>(boost::any_cast<long>(m["RsType"]));
    }
  }


  virtual ~DescribeWebRulesResponseBodyWebRulesRealServers() = default;
};
class DescribeWebRulesResponseBodyWebRules : public Darabonba::Model {
public:
  shared_ptr<vector<string>> blackList{};
  shared_ptr<bool> ccEnabled{};
  shared_ptr<bool> ccRuleEnabled{};
  shared_ptr<string> ccTemplate{};
  shared_ptr<string> certName{};
  shared_ptr<string> cname{};
  shared_ptr<vector<string>> customCiphers{};
  shared_ptr<string> domain{};
  shared_ptr<DescribeWebRulesResponseBodyWebRulesGmCert> gmCert{};
  shared_ptr<bool> http2Enable{};
  shared_ptr<bool> http2HttpsEnable{};
  shared_ptr<bool> https2HttpEnable{};
  shared_ptr<bool> ocspEnabled{};
  shared_ptr<string> policyMode{};
  shared_ptr<bool> proxyEnabled{};
  shared_ptr<vector<DescribeWebRulesResponseBodyWebRulesProxyTypes>> proxyTypes{};
  shared_ptr<long> punishReason{};
  shared_ptr<bool> punishStatus{};
  shared_ptr<vector<DescribeWebRulesResponseBodyWebRulesRealServers>> realServers{};
  shared_ptr<bool> ssl13Enabled{};
  shared_ptr<string> sslCiphers{};
  shared_ptr<string> sslProtocols{};
  shared_ptr<vector<string>> whiteList{};

  DescribeWebRulesResponseBodyWebRules() {}

  explicit DescribeWebRulesResponseBodyWebRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackList) {
      res["BlackList"] = boost::any(*blackList);
    }
    if (ccEnabled) {
      res["CcEnabled"] = boost::any(*ccEnabled);
    }
    if (ccRuleEnabled) {
      res["CcRuleEnabled"] = boost::any(*ccRuleEnabled);
    }
    if (ccTemplate) {
      res["CcTemplate"] = boost::any(*ccTemplate);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (gmCert) {
      res["GmCert"] = gmCert ? boost::any(gmCert->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (http2Enable) {
      res["Http2Enable"] = boost::any(*http2Enable);
    }
    if (http2HttpsEnable) {
      res["Http2HttpsEnable"] = boost::any(*http2HttpsEnable);
    }
    if (https2HttpEnable) {
      res["Https2HttpEnable"] = boost::any(*https2HttpEnable);
    }
    if (ocspEnabled) {
      res["OcspEnabled"] = boost::any(*ocspEnabled);
    }
    if (policyMode) {
      res["PolicyMode"] = boost::any(*policyMode);
    }
    if (proxyEnabled) {
      res["ProxyEnabled"] = boost::any(*proxyEnabled);
    }
    if (proxyTypes) {
      vector<boost::any> temp1;
      for(auto item1:*proxyTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProxyTypes"] = boost::any(temp1);
    }
    if (punishReason) {
      res["PunishReason"] = boost::any(*punishReason);
    }
    if (punishStatus) {
      res["PunishStatus"] = boost::any(*punishStatus);
    }
    if (realServers) {
      vector<boost::any> temp1;
      for(auto item1:*realServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealServers"] = boost::any(temp1);
    }
    if (ssl13Enabled) {
      res["Ssl13Enabled"] = boost::any(*ssl13Enabled);
    }
    if (sslCiphers) {
      res["SslCiphers"] = boost::any(*sslCiphers);
    }
    if (sslProtocols) {
      res["SslProtocols"] = boost::any(*sslProtocols);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackList") != m.end() && !m["BlackList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BlackList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BlackList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      blackList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CcEnabled") != m.end() && !m["CcEnabled"].empty()) {
      ccEnabled = make_shared<bool>(boost::any_cast<bool>(m["CcEnabled"]));
    }
    if (m.find("CcRuleEnabled") != m.end() && !m["CcRuleEnabled"].empty()) {
      ccRuleEnabled = make_shared<bool>(boost::any_cast<bool>(m["CcRuleEnabled"]));
    }
    if (m.find("CcTemplate") != m.end() && !m["CcTemplate"].empty()) {
      ccTemplate = make_shared<string>(boost::any_cast<string>(m["CcTemplate"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomCiphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomCiphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customCiphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("GmCert") != m.end() && !m["GmCert"].empty()) {
      if (typeid(map<string, boost::any>) == m["GmCert"].type()) {
        DescribeWebRulesResponseBodyWebRulesGmCert model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GmCert"]));
        gmCert = make_shared<DescribeWebRulesResponseBodyWebRulesGmCert>(model1);
      }
    }
    if (m.find("Http2Enable") != m.end() && !m["Http2Enable"].empty()) {
      http2Enable = make_shared<bool>(boost::any_cast<bool>(m["Http2Enable"]));
    }
    if (m.find("Http2HttpsEnable") != m.end() && !m["Http2HttpsEnable"].empty()) {
      http2HttpsEnable = make_shared<bool>(boost::any_cast<bool>(m["Http2HttpsEnable"]));
    }
    if (m.find("Https2HttpEnable") != m.end() && !m["Https2HttpEnable"].empty()) {
      https2HttpEnable = make_shared<bool>(boost::any_cast<bool>(m["Https2HttpEnable"]));
    }
    if (m.find("OcspEnabled") != m.end() && !m["OcspEnabled"].empty()) {
      ocspEnabled = make_shared<bool>(boost::any_cast<bool>(m["OcspEnabled"]));
    }
    if (m.find("PolicyMode") != m.end() && !m["PolicyMode"].empty()) {
      policyMode = make_shared<string>(boost::any_cast<string>(m["PolicyMode"]));
    }
    if (m.find("ProxyEnabled") != m.end() && !m["ProxyEnabled"].empty()) {
      proxyEnabled = make_shared<bool>(boost::any_cast<bool>(m["ProxyEnabled"]));
    }
    if (m.find("ProxyTypes") != m.end() && !m["ProxyTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["ProxyTypes"].type()) {
        vector<DescribeWebRulesResponseBodyWebRulesProxyTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProxyTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebRulesResponseBodyWebRulesProxyTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxyTypes = make_shared<vector<DescribeWebRulesResponseBodyWebRulesProxyTypes>>(expect1);
      }
    }
    if (m.find("PunishReason") != m.end() && !m["PunishReason"].empty()) {
      punishReason = make_shared<long>(boost::any_cast<long>(m["PunishReason"]));
    }
    if (m.find("PunishStatus") != m.end() && !m["PunishStatus"].empty()) {
      punishStatus = make_shared<bool>(boost::any_cast<bool>(m["PunishStatus"]));
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<DescribeWebRulesResponseBodyWebRulesRealServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebRulesResponseBodyWebRulesRealServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realServers = make_shared<vector<DescribeWebRulesResponseBodyWebRulesRealServers>>(expect1);
      }
    }
    if (m.find("Ssl13Enabled") != m.end() && !m["Ssl13Enabled"].empty()) {
      ssl13Enabled = make_shared<bool>(boost::any_cast<bool>(m["Ssl13Enabled"]));
    }
    if (m.find("SslCiphers") != m.end() && !m["SslCiphers"].empty()) {
      sslCiphers = make_shared<string>(boost::any_cast<string>(m["SslCiphers"]));
    }
    if (m.find("SslProtocols") != m.end() && !m["SslProtocols"].empty()) {
      sslProtocols = make_shared<string>(boost::any_cast<string>(m["SslProtocols"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whiteList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeWebRulesResponseBodyWebRules() = default;
};
class DescribeWebRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeWebRulesResponseBodyWebRules>> webRules{};

  DescribeWebRulesResponseBody() {}

  explicit DescribeWebRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (webRules) {
      vector<boost::any> temp1;
      for(auto item1:*webRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebRules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WebRules") != m.end() && !m["WebRules"].empty()) {
      if (typeid(vector<boost::any>) == m["WebRules"].type()) {
        vector<DescribeWebRulesResponseBodyWebRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebRulesResponseBodyWebRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webRules = make_shared<vector<DescribeWebRulesResponseBodyWebRules>>(expect1);
      }
    }
  }


  virtual ~DescribeWebRulesResponseBody() = default;
};
class DescribeWebRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebRulesResponseBody> body{};

  DescribeWebRulesResponse() {}

  explicit DescribeWebRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebRulesResponse() = default;
};
class DetachSceneDefenseObjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> objectType{};
  shared_ptr<string> objects{};
  shared_ptr<string> policyId{};

  DetachSceneDefenseObjectRequest() {}

  explicit DetachSceneDefenseObjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (objects) {
      res["Objects"] = boost::any(*objects);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Objects") != m.end() && !m["Objects"].empty()) {
      objects = make_shared<string>(boost::any_cast<string>(m["Objects"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
  }


  virtual ~DetachSceneDefenseObjectRequest() = default;
};
class DetachSceneDefenseObjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DetachSceneDefenseObjectResponseBody() {}

  explicit DetachSceneDefenseObjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DetachSceneDefenseObjectResponseBody() = default;
};
class DetachSceneDefenseObjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachSceneDefenseObjectResponseBody> body{};

  DetachSceneDefenseObjectResponse() {}

  explicit DetachSceneDefenseObjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachSceneDefenseObjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachSceneDefenseObjectResponseBody>(model1);
      }
    }
  }


  virtual ~DetachSceneDefenseObjectResponse() = default;
};
class DisableSceneDefensePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> policyId{};

  DisableSceneDefensePolicyRequest() {}

  explicit DisableSceneDefensePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
  }


  virtual ~DisableSceneDefensePolicyRequest() = default;
};
class DisableSceneDefensePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableSceneDefensePolicyResponseBody() {}

  explicit DisableSceneDefensePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableSceneDefensePolicyResponseBody() = default;
};
class DisableSceneDefensePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableSceneDefensePolicyResponseBody> body{};

  DisableSceneDefensePolicyResponse() {}

  explicit DisableSceneDefensePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableSceneDefensePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableSceneDefensePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DisableSceneDefensePolicyResponse() = default;
};
class DisableWebAccessLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  DisableWebAccessLogConfigRequest() {}

  explicit DisableWebAccessLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DisableWebAccessLogConfigRequest() = default;
};
class DisableWebAccessLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableWebAccessLogConfigResponseBody() {}

  explicit DisableWebAccessLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableWebAccessLogConfigResponseBody() = default;
};
class DisableWebAccessLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableWebAccessLogConfigResponseBody> body{};

  DisableWebAccessLogConfigResponse() {}

  explicit DisableWebAccessLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableWebAccessLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableWebAccessLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DisableWebAccessLogConfigResponse() = default;
};
class DisableWebCCRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  DisableWebCCRequest() {}

  explicit DisableWebCCRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DisableWebCCRequest() = default;
};
class DisableWebCCResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableWebCCResponseBody() {}

  explicit DisableWebCCResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableWebCCResponseBody() = default;
};
class DisableWebCCResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableWebCCResponseBody> body{};

  DisableWebCCResponse() {}

  explicit DisableWebCCResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableWebCCResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableWebCCResponseBody>(model1);
      }
    }
  }


  virtual ~DisableWebCCResponse() = default;
};
class DisableWebCCRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  DisableWebCCRuleRequest() {}

  explicit DisableWebCCRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DisableWebCCRuleRequest() = default;
};
class DisableWebCCRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableWebCCRuleResponseBody() {}

  explicit DisableWebCCRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableWebCCRuleResponseBody() = default;
};
class DisableWebCCRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableWebCCRuleResponseBody> body{};

  DisableWebCCRuleResponse() {}

  explicit DisableWebCCRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableWebCCRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableWebCCRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DisableWebCCRuleResponse() = default;
};
class EmptyAutoCcBlacklistRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  EmptyAutoCcBlacklistRequest() {}

  explicit EmptyAutoCcBlacklistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~EmptyAutoCcBlacklistRequest() = default;
};
class EmptyAutoCcBlacklistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EmptyAutoCcBlacklistResponseBody() {}

  explicit EmptyAutoCcBlacklistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EmptyAutoCcBlacklistResponseBody() = default;
};
class EmptyAutoCcBlacklistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EmptyAutoCcBlacklistResponseBody> body{};

  EmptyAutoCcBlacklistResponse() {}

  explicit EmptyAutoCcBlacklistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EmptyAutoCcBlacklistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EmptyAutoCcBlacklistResponseBody>(model1);
      }
    }
  }


  virtual ~EmptyAutoCcBlacklistResponse() = default;
};
class EmptyAutoCcWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  EmptyAutoCcWhitelistRequest() {}

  explicit EmptyAutoCcWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~EmptyAutoCcWhitelistRequest() = default;
};
class EmptyAutoCcWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EmptyAutoCcWhitelistResponseBody() {}

  explicit EmptyAutoCcWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EmptyAutoCcWhitelistResponseBody() = default;
};
class EmptyAutoCcWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EmptyAutoCcWhitelistResponseBody> body{};

  EmptyAutoCcWhitelistResponse() {}

  explicit EmptyAutoCcWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EmptyAutoCcWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EmptyAutoCcWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~EmptyAutoCcWhitelistResponse() = default;
};
class EmptySlsLogstoreRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};

  EmptySlsLogstoreRequest() {}

  explicit EmptySlsLogstoreRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~EmptySlsLogstoreRequest() = default;
};
class EmptySlsLogstoreResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EmptySlsLogstoreResponseBody() {}

  explicit EmptySlsLogstoreResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EmptySlsLogstoreResponseBody() = default;
};
class EmptySlsLogstoreResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EmptySlsLogstoreResponseBody> body{};

  EmptySlsLogstoreResponse() {}

  explicit EmptySlsLogstoreResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EmptySlsLogstoreResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EmptySlsLogstoreResponseBody>(model1);
      }
    }
  }


  virtual ~EmptySlsLogstoreResponse() = default;
};
class EnableSceneDefensePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> policyId{};

  EnableSceneDefensePolicyRequest() {}

  explicit EnableSceneDefensePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
  }


  virtual ~EnableSceneDefensePolicyRequest() = default;
};
class EnableSceneDefensePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableSceneDefensePolicyResponseBody() {}

  explicit EnableSceneDefensePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableSceneDefensePolicyResponseBody() = default;
};
class EnableSceneDefensePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableSceneDefensePolicyResponseBody> body{};

  EnableSceneDefensePolicyResponse() {}

  explicit EnableSceneDefensePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableSceneDefensePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableSceneDefensePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~EnableSceneDefensePolicyResponse() = default;
};
class EnableWebAccessLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  EnableWebAccessLogConfigRequest() {}

  explicit EnableWebAccessLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~EnableWebAccessLogConfigRequest() = default;
};
class EnableWebAccessLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableWebAccessLogConfigResponseBody() {}

  explicit EnableWebAccessLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableWebAccessLogConfigResponseBody() = default;
};
class EnableWebAccessLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableWebAccessLogConfigResponseBody> body{};

  EnableWebAccessLogConfigResponse() {}

  explicit EnableWebAccessLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableWebAccessLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableWebAccessLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~EnableWebAccessLogConfigResponse() = default;
};
class EnableWebCCRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  EnableWebCCRequest() {}

  explicit EnableWebCCRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~EnableWebCCRequest() = default;
};
class EnableWebCCResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableWebCCResponseBody() {}

  explicit EnableWebCCResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableWebCCResponseBody() = default;
};
class EnableWebCCResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableWebCCResponseBody> body{};

  EnableWebCCResponse() {}

  explicit EnableWebCCResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableWebCCResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableWebCCResponseBody>(model1);
      }
    }
  }


  virtual ~EnableWebCCResponse() = default;
};
class EnableWebCCRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  EnableWebCCRuleRequest() {}

  explicit EnableWebCCRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~EnableWebCCRuleRequest() = default;
};
class EnableWebCCRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableWebCCRuleResponseBody() {}

  explicit EnableWebCCRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableWebCCRuleResponseBody() = default;
};
class EnableWebCCRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableWebCCRuleResponseBody> body{};

  EnableWebCCRuleResponse() {}

  explicit EnableWebCCRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableWebCCRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableWebCCRuleResponseBody>(model1);
      }
    }
  }


  virtual ~EnableWebCCRuleResponse() = default;
};
class ModifyBlackholeStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> blackholeStatus{};
  shared_ptr<string> instanceId{};

  ModifyBlackholeStatusRequest() {}

  explicit ModifyBlackholeStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackholeStatus) {
      res["BlackholeStatus"] = boost::any(*blackholeStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackholeStatus") != m.end() && !m["BlackholeStatus"].empty()) {
      blackholeStatus = make_shared<string>(boost::any_cast<string>(m["BlackholeStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyBlackholeStatusRequest() = default;
};
class ModifyBlackholeStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBlackholeStatusResponseBody() {}

  explicit ModifyBlackholeStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBlackholeStatusResponseBody() = default;
};
class ModifyBlackholeStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBlackholeStatusResponseBody> body{};

  ModifyBlackholeStatusResponse() {}

  explicit ModifyBlackholeStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBlackholeStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBlackholeStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBlackholeStatusResponse() = default;
};
class ModifyBlockStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> lines{};
  shared_ptr<string> status{};

  ModifyBlockStatusRequest() {}

  explicit ModifyBlockStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Lines"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Lines"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lines = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyBlockStatusRequest() = default;
};
class ModifyBlockStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBlockStatusResponseBody() {}

  explicit ModifyBlockStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBlockStatusResponseBody() = default;
};
class ModifyBlockStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBlockStatusResponseBody> body{};

  ModifyBlockStatusResponse() {}

  explicit ModifyBlockStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBlockStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBlockStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBlockStatusResponse() = default;
};
class ModifyCnameReuseRequest : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> domain{};
  shared_ptr<long> enable{};
  shared_ptr<string> resourceGroupId{};

  ModifyCnameReuseRequest() {}

  explicit ModifyCnameReuseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<long>(boost::any_cast<long>(m["Enable"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyCnameReuseRequest() = default;
};
class ModifyCnameReuseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCnameReuseResponseBody() {}

  explicit ModifyCnameReuseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCnameReuseResponseBody() = default;
};
class ModifyCnameReuseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCnameReuseResponseBody> body{};

  ModifyCnameReuseResponse() {}

  explicit ModifyCnameReuseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCnameReuseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCnameReuseResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCnameReuseResponse() = default;
};
class ModifyDomainResourceRequestProxyTypes : public Darabonba::Model {
public:
  shared_ptr<vector<long>> proxyPorts{};
  shared_ptr<string> proxyType{};

  ModifyDomainResourceRequestProxyTypes() {}

  explicit ModifyDomainResourceRequestProxyTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyPorts) {
      res["ProxyPorts"] = boost::any(*proxyPorts);
    }
    if (proxyType) {
      res["ProxyType"] = boost::any(*proxyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyPorts") != m.end() && !m["ProxyPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ProxyPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProxyPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      proxyPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ProxyType") != m.end() && !m["ProxyType"].empty()) {
      proxyType = make_shared<string>(boost::any_cast<string>(m["ProxyType"]));
    }
  }


  virtual ~ModifyDomainResourceRequestProxyTypes() = default;
};
class ModifyDomainResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> httpsExt{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<vector<ModifyDomainResourceRequestProxyTypes>> proxyTypes{};
  shared_ptr<vector<string>> realServers{};
  shared_ptr<long> rsType{};

  ModifyDomainResourceRequest() {}

  explicit ModifyDomainResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (httpsExt) {
      res["HttpsExt"] = boost::any(*httpsExt);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (proxyTypes) {
      vector<boost::any> temp1;
      for(auto item1:*proxyTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProxyTypes"] = boost::any(temp1);
    }
    if (realServers) {
      res["RealServers"] = boost::any(*realServers);
    }
    if (rsType) {
      res["RsType"] = boost::any(*rsType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("HttpsExt") != m.end() && !m["HttpsExt"].empty()) {
      httpsExt = make_shared<string>(boost::any_cast<string>(m["HttpsExt"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProxyTypes") != m.end() && !m["ProxyTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["ProxyTypes"].type()) {
        vector<ModifyDomainResourceRequestProxyTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProxyTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyDomainResourceRequestProxyTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxyTypes = make_shared<vector<ModifyDomainResourceRequestProxyTypes>>(expect1);
      }
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RealServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      realServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RsType") != m.end() && !m["RsType"].empty()) {
      rsType = make_shared<long>(boost::any_cast<long>(m["RsType"]));
    }
  }


  virtual ~ModifyDomainResourceRequest() = default;
};
class ModifyDomainResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDomainResourceResponseBody() {}

  explicit ModifyDomainResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDomainResourceResponseBody() = default;
};
class ModifyDomainResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDomainResourceResponseBody> body{};

  ModifyDomainResourceResponse() {}

  explicit ModifyDomainResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDomainResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDomainResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDomainResourceResponse() = default;
};
class ModifyElasticBandWidthRequest : public Darabonba::Model {
public:
  shared_ptr<long> elasticBandwidth{};
  shared_ptr<string> instanceId{};

  ModifyElasticBandWidthRequest() {}

  explicit ModifyElasticBandWidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elasticBandwidth) {
      res["ElasticBandwidth"] = boost::any(*elasticBandwidth);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ElasticBandwidth") != m.end() && !m["ElasticBandwidth"].empty()) {
      elasticBandwidth = make_shared<long>(boost::any_cast<long>(m["ElasticBandwidth"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyElasticBandWidthRequest() = default;
};
class ModifyElasticBandWidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyElasticBandWidthResponseBody() {}

  explicit ModifyElasticBandWidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyElasticBandWidthResponseBody() = default;
};
class ModifyElasticBandWidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyElasticBandWidthResponseBody> body{};

  ModifyElasticBandWidthResponse() {}

  explicit ModifyElasticBandWidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyElasticBandWidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyElasticBandWidthResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyElasticBandWidthResponse() = default;
};
class ModifyFullLogTtlRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> ttl{};

  ModifyFullLogTtlRequest() {}

  explicit ModifyFullLogTtlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
  }


  virtual ~ModifyFullLogTtlRequest() = default;
};
class ModifyFullLogTtlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyFullLogTtlResponseBody() {}

  explicit ModifyFullLogTtlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFullLogTtlResponseBody() = default;
};
class ModifyFullLogTtlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyFullLogTtlResponseBody> body{};

  ModifyFullLogTtlResponse() {}

  explicit ModifyFullLogTtlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFullLogTtlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFullLogTtlResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFullLogTtlResponse() = default;
};
class ModifyHealthCheckConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> forwardProtocol{};
  shared_ptr<long> frontendPort{};
  shared_ptr<string> healthCheck{};
  shared_ptr<string> instanceId{};

  ModifyHealthCheckConfigRequest() {}

  explicit ModifyHealthCheckConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardProtocol) {
      res["ForwardProtocol"] = boost::any(*forwardProtocol);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardProtocol") != m.end() && !m["ForwardProtocol"].empty()) {
      forwardProtocol = make_shared<string>(boost::any_cast<string>(m["ForwardProtocol"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyHealthCheckConfigRequest() = default;
};
class ModifyHealthCheckConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHealthCheckConfigResponseBody() {}

  explicit ModifyHealthCheckConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHealthCheckConfigResponseBody() = default;
};
class ModifyHealthCheckConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHealthCheckConfigResponseBody> body{};

  ModifyHealthCheckConfigResponse() {}

  explicit ModifyHealthCheckConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHealthCheckConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHealthCheckConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHealthCheckConfigResponse() = default;
};
class ModifyHttp2EnableRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> enable{};
  shared_ptr<string> resourceGroupId{};

  ModifyHttp2EnableRequest() {}

  explicit ModifyHttp2EnableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<long>(boost::any_cast<long>(m["Enable"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyHttp2EnableRequest() = default;
};
class ModifyHttp2EnableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHttp2EnableResponseBody() {}

  explicit ModifyHttp2EnableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHttp2EnableResponseBody() = default;
};
class ModifyHttp2EnableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHttp2EnableResponseBody> body{};

  ModifyHttp2EnableResponse() {}

  explicit ModifyHttp2EnableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHttp2EnableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHttp2EnableResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHttp2EnableResponse() = default;
};
class ModifyInstanceRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> remark{};

  ModifyInstanceRemarkRequest() {}

  explicit ModifyInstanceRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~ModifyInstanceRemarkRequest() = default;
};
class ModifyInstanceRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceRemarkResponseBody() {}

  explicit ModifyInstanceRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceRemarkResponseBody() = default;
};
class ModifyInstanceRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceRemarkResponseBody> body{};

  ModifyInstanceRemarkResponse() {}

  explicit ModifyInstanceRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceRemarkResponse() = default;
};
class ModifyNetworkRuleAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> forwardProtocol{};
  shared_ptr<long> frontendPort{};
  shared_ptr<string> instanceId{};

  ModifyNetworkRuleAttributeRequest() {}

  explicit ModifyNetworkRuleAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (forwardProtocol) {
      res["ForwardProtocol"] = boost::any(*forwardProtocol);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("ForwardProtocol") != m.end() && !m["ForwardProtocol"].empty()) {
      forwardProtocol = make_shared<string>(boost::any_cast<string>(m["ForwardProtocol"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<long>(boost::any_cast<long>(m["FrontendPort"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyNetworkRuleAttributeRequest() = default;
};
class ModifyNetworkRuleAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNetworkRuleAttributeResponseBody() {}

  explicit ModifyNetworkRuleAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNetworkRuleAttributeResponseBody() = default;
};
class ModifyNetworkRuleAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNetworkRuleAttributeResponseBody> body{};

  ModifyNetworkRuleAttributeResponse() {}

  explicit ModifyNetworkRuleAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNetworkRuleAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNetworkRuleAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNetworkRuleAttributeResponse() = default;
};
class ModifyPortRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendPort{};
  shared_ptr<string> frontendPort{};
  shared_ptr<string> frontendProtocol{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> realServers{};

  ModifyPortRequest() {}

  explicit ModifyPortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendPort) {
      res["BackendPort"] = boost::any(*backendPort);
    }
    if (frontendPort) {
      res["FrontendPort"] = boost::any(*frontendPort);
    }
    if (frontendProtocol) {
      res["FrontendProtocol"] = boost::any(*frontendProtocol);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (realServers) {
      res["RealServers"] = boost::any(*realServers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendPort") != m.end() && !m["BackendPort"].empty()) {
      backendPort = make_shared<string>(boost::any_cast<string>(m["BackendPort"]));
    }
    if (m.find("FrontendPort") != m.end() && !m["FrontendPort"].empty()) {
      frontendPort = make_shared<string>(boost::any_cast<string>(m["FrontendPort"]));
    }
    if (m.find("FrontendProtocol") != m.end() && !m["FrontendProtocol"].empty()) {
      frontendProtocol = make_shared<string>(boost::any_cast<string>(m["FrontendProtocol"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RealServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      realServers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyPortRequest() = default;
};
class ModifyPortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPortResponseBody() {}

  explicit ModifyPortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPortResponseBody() = default;
};
class ModifyPortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPortResponseBody> body{};

  ModifyPortResponse() {}

  explicit ModifyPortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPortResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPortResponse() = default;
};
class ModifyPortAutoCcStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> mode{};
  shared_ptr<string> switch_{};

  ModifyPortAutoCcStatusRequest() {}

  explicit ModifyPortAutoCcStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (switch_) {
      res["Switch"] = boost::any(*switch_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Switch") != m.end() && !m["Switch"].empty()) {
      switch_ = make_shared<string>(boost::any_cast<string>(m["Switch"]));
    }
  }


  virtual ~ModifyPortAutoCcStatusRequest() = default;
};
class ModifyPortAutoCcStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPortAutoCcStatusResponseBody() {}

  explicit ModifyPortAutoCcStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPortAutoCcStatusResponseBody() = default;
};
class ModifyPortAutoCcStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPortAutoCcStatusResponseBody> body{};

  ModifyPortAutoCcStatusResponse() {}

  explicit ModifyPortAutoCcStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPortAutoCcStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPortAutoCcStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPortAutoCcStatusResponse() = default;
};
class ModifySceneDefensePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> name{};
  shared_ptr<string> policyId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> template_{};

  ModifySceneDefensePolicyRequest() {}

  explicit ModifySceneDefensePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~ModifySceneDefensePolicyRequest() = default;
};
class ModifySceneDefensePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifySceneDefensePolicyResponseBody() {}

  explicit ModifySceneDefensePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifySceneDefensePolicyResponseBody() = default;
};
class ModifySceneDefensePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySceneDefensePolicyResponseBody> body{};

  ModifySceneDefensePolicyResponse() {}

  explicit ModifySceneDefensePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySceneDefensePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySceneDefensePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySceneDefensePolicyResponse() = default;
};
class ModifySchedulerRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> param{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> rules{};

  ModifySchedulerRuleRequest() {}

  explicit ModifySchedulerRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~ModifySchedulerRuleRequest() = default;
};
class ModifySchedulerRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleName{};

  ModifySchedulerRuleResponseBody() {}

  explicit ModifySchedulerRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~ModifySchedulerRuleResponseBody() = default;
};
class ModifySchedulerRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySchedulerRuleResponseBody> body{};

  ModifySchedulerRuleResponse() {}

  explicit ModifySchedulerRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySchedulerRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySchedulerRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySchedulerRuleResponse() = default;
};
class ModifyTlsConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  ModifyTlsConfigRequest() {}

  explicit ModifyTlsConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyTlsConfigRequest() = default;
};
class ModifyTlsConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyTlsConfigResponseBody() {}

  explicit ModifyTlsConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTlsConfigResponseBody() = default;
};
class ModifyTlsConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTlsConfigResponseBody> body{};

  ModifyTlsConfigResponse() {}

  explicit ModifyTlsConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTlsConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTlsConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTlsConfigResponse() = default;
};
class ModifyWebAIProtectModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  ModifyWebAIProtectModeRequest() {}

  explicit ModifyWebAIProtectModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyWebAIProtectModeRequest() = default;
};
class ModifyWebAIProtectModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebAIProtectModeResponseBody() {}

  explicit ModifyWebAIProtectModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebAIProtectModeResponseBody() = default;
};
class ModifyWebAIProtectModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebAIProtectModeResponseBody> body{};

  ModifyWebAIProtectModeResponse() {}

  explicit ModifyWebAIProtectModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebAIProtectModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebAIProtectModeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebAIProtectModeResponse() = default;
};
class ModifyWebAIProtectSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  ModifyWebAIProtectSwitchRequest() {}

  explicit ModifyWebAIProtectSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyWebAIProtectSwitchRequest() = default;
};
class ModifyWebAIProtectSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebAIProtectSwitchResponseBody() {}

  explicit ModifyWebAIProtectSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebAIProtectSwitchResponseBody() = default;
};
class ModifyWebAIProtectSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebAIProtectSwitchResponseBody> body{};

  ModifyWebAIProtectSwitchResponse() {}

  explicit ModifyWebAIProtectSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebAIProtectSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebAIProtectSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebAIProtectSwitchResponse() = default;
};
class ModifyWebAccessModeRequest : public Darabonba::Model {
public:
  shared_ptr<long> accessMode{};
  shared_ptr<string> domain{};

  ModifyWebAccessModeRequest() {}

  explicit ModifyWebAccessModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<long>(boost::any_cast<long>(m["AccessMode"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
  }


  virtual ~ModifyWebAccessModeRequest() = default;
};
class ModifyWebAccessModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebAccessModeResponseBody() {}

  explicit ModifyWebAccessModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebAccessModeResponseBody() = default;
};
class ModifyWebAccessModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebAccessModeResponseBody> body{};

  ModifyWebAccessModeResponse() {}

  explicit ModifyWebAccessModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebAccessModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebAccessModeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebAccessModeResponse() = default;
};
class ModifyWebAreaBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<vector<string>> regions{};
  shared_ptr<string> resourceGroupId{};

  ModifyWebAreaBlockRequest() {}

  explicit ModifyWebAreaBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (regions) {
      res["Regions"] = boost::any(*regions);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Regions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      regions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyWebAreaBlockRequest() = default;
};
class ModifyWebAreaBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebAreaBlockResponseBody() {}

  explicit ModifyWebAreaBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebAreaBlockResponseBody() = default;
};
class ModifyWebAreaBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebAreaBlockResponseBody> body{};

  ModifyWebAreaBlockResponse() {}

  explicit ModifyWebAreaBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebAreaBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebAreaBlockResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebAreaBlockResponse() = default;
};
class ModifyWebAreaBlockSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  ModifyWebAreaBlockSwitchRequest() {}

  explicit ModifyWebAreaBlockSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyWebAreaBlockSwitchRequest() = default;
};
class ModifyWebAreaBlockSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebAreaBlockSwitchResponseBody() {}

  explicit ModifyWebAreaBlockSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebAreaBlockSwitchResponseBody() = default;
};
class ModifyWebAreaBlockSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebAreaBlockSwitchResponseBody> body{};

  ModifyWebAreaBlockSwitchResponse() {}

  explicit ModifyWebAreaBlockSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebAreaBlockSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebAreaBlockSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebAreaBlockSwitchResponse() = default;
};
class ModifyWebCCRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> act{};
  shared_ptr<long> count{};
  shared_ptr<string> domain{};
  shared_ptr<long> interval{};
  shared_ptr<string> mode{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> ttl{};
  shared_ptr<string> uri{};

  ModifyWebCCRuleRequest() {}

  explicit ModifyWebCCRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (act) {
      res["Act"] = boost::any(*act);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Act") != m.end() && !m["Act"].empty()) {
      act = make_shared<string>(boost::any_cast<string>(m["Act"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~ModifyWebCCRuleRequest() = default;
};
class ModifyWebCCRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebCCRuleResponseBody() {}

  explicit ModifyWebCCRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebCCRuleResponseBody() = default;
};
class ModifyWebCCRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebCCRuleResponseBody> body{};

  ModifyWebCCRuleResponse() {}

  explicit ModifyWebCCRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebCCRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebCCRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebCCRuleResponse() = default;
};
class ModifyWebCacheCustomRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> rules{};

  ModifyWebCacheCustomRuleRequest() {}

  explicit ModifyWebCacheCustomRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~ModifyWebCacheCustomRuleRequest() = default;
};
class ModifyWebCacheCustomRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebCacheCustomRuleResponseBody() {}

  explicit ModifyWebCacheCustomRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebCacheCustomRuleResponseBody() = default;
};
class ModifyWebCacheCustomRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebCacheCustomRuleResponseBody> body{};

  ModifyWebCacheCustomRuleResponse() {}

  explicit ModifyWebCacheCustomRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebCacheCustomRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebCacheCustomRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebCacheCustomRuleResponse() = default;
};
class ModifyWebCacheModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> mode{};
  shared_ptr<string> resourceGroupId{};

  ModifyWebCacheModeRequest() {}

  explicit ModifyWebCacheModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyWebCacheModeRequest() = default;
};
class ModifyWebCacheModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebCacheModeResponseBody() {}

  explicit ModifyWebCacheModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebCacheModeResponseBody() = default;
};
class ModifyWebCacheModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebCacheModeResponseBody> body{};

  ModifyWebCacheModeResponse() {}

  explicit ModifyWebCacheModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebCacheModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebCacheModeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebCacheModeResponse() = default;
};
class ModifyWebCacheSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> enable{};
  shared_ptr<string> resourceGroupId{};

  ModifyWebCacheSwitchRequest() {}

  explicit ModifyWebCacheSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<long>(boost::any_cast<long>(m["Enable"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyWebCacheSwitchRequest() = default;
};
class ModifyWebCacheSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebCacheSwitchResponseBody() {}

  explicit ModifyWebCacheSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebCacheSwitchResponseBody() = default;
};
class ModifyWebCacheSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebCacheSwitchResponseBody> body{};

  ModifyWebCacheSwitchResponse() {}

  explicit ModifyWebCacheSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebCacheSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebCacheSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebCacheSwitchResponse() = default;
};
class ModifyWebIpSetSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  ModifyWebIpSetSwitchRequest() {}

  explicit ModifyWebIpSetSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyWebIpSetSwitchRequest() = default;
};
class ModifyWebIpSetSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebIpSetSwitchResponseBody() {}

  explicit ModifyWebIpSetSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebIpSetSwitchResponseBody() = default;
};
class ModifyWebIpSetSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebIpSetSwitchResponseBody> body{};

  ModifyWebIpSetSwitchResponse() {}

  explicit ModifyWebIpSetSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebIpSetSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebIpSetSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebIpSetSwitchResponse() = default;
};
class ModifyWebPreciseAccessRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> expires{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> rules{};

  ModifyWebPreciseAccessRuleRequest() {}

  explicit ModifyWebPreciseAccessRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (expires) {
      res["Expires"] = boost::any(*expires);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Expires") != m.end() && !m["Expires"].empty()) {
      expires = make_shared<long>(boost::any_cast<long>(m["Expires"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~ModifyWebPreciseAccessRuleRequest() = default;
};
class ModifyWebPreciseAccessRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebPreciseAccessRuleResponseBody() {}

  explicit ModifyWebPreciseAccessRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebPreciseAccessRuleResponseBody() = default;
};
class ModifyWebPreciseAccessRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebPreciseAccessRuleResponseBody> body{};

  ModifyWebPreciseAccessRuleResponse() {}

  explicit ModifyWebPreciseAccessRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebPreciseAccessRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebPreciseAccessRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebPreciseAccessRuleResponse() = default;
};
class ModifyWebPreciseAccessSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> domain{};
  shared_ptr<string> resourceGroupId{};

  ModifyWebPreciseAccessSwitchRequest() {}

  explicit ModifyWebPreciseAccessSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyWebPreciseAccessSwitchRequest() = default;
};
class ModifyWebPreciseAccessSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebPreciseAccessSwitchResponseBody() {}

  explicit ModifyWebPreciseAccessSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebPreciseAccessSwitchResponseBody() = default;
};
class ModifyWebPreciseAccessSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebPreciseAccessSwitchResponseBody> body{};

  ModifyWebPreciseAccessSwitchResponse() {}

  explicit ModifyWebPreciseAccessSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebPreciseAccessSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebPreciseAccessSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebPreciseAccessSwitchResponse() = default;
};
class ModifyWebRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> httpsExt{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> proxyTypes{};
  shared_ptr<vector<string>> realServers{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> rsType{};

  ModifyWebRuleRequest() {}

  explicit ModifyWebRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (httpsExt) {
      res["HttpsExt"] = boost::any(*httpsExt);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (proxyTypes) {
      res["ProxyTypes"] = boost::any(*proxyTypes);
    }
    if (realServers) {
      res["RealServers"] = boost::any(*realServers);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (rsType) {
      res["RsType"] = boost::any(*rsType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("HttpsExt") != m.end() && !m["HttpsExt"].empty()) {
      httpsExt = make_shared<string>(boost::any_cast<string>(m["HttpsExt"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProxyTypes") != m.end() && !m["ProxyTypes"].empty()) {
      proxyTypes = make_shared<string>(boost::any_cast<string>(m["ProxyTypes"]));
    }
    if (m.find("RealServers") != m.end() && !m["RealServers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RealServers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RealServers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      realServers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RsType") != m.end() && !m["RsType"].empty()) {
      rsType = make_shared<long>(boost::any_cast<long>(m["RsType"]));
    }
  }


  virtual ~ModifyWebRuleRequest() = default;
};
class ModifyWebRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebRuleResponseBody() {}

  explicit ModifyWebRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebRuleResponseBody() = default;
};
class ModifyWebRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebRuleResponseBody> body{};

  ModifyWebRuleResponse() {}

  explicit ModifyWebRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebRuleResponse() = default;
};
class ReleaseInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ReleaseInstanceRequest() {}

  explicit ReleaseInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ReleaseInstanceRequest() = default;
};
class ReleaseInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseInstanceResponseBody() {}

  explicit ReleaseInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseInstanceResponseBody() = default;
};
class ReleaseInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseInstanceResponseBody> body{};

  ReleaseInstanceResponse() {}

  explicit ReleaseInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseInstanceResponse() = default;
};
class SwitchSchedulerRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> switchData{};

  SwitchSchedulerRuleRequest() {}

  explicit SwitchSchedulerRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (switchData) {
      res["SwitchData"] = boost::any(*switchData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("SwitchData") != m.end() && !m["SwitchData"].empty()) {
      switchData = make_shared<string>(boost::any_cast<string>(m["SwitchData"]));
    }
  }


  virtual ~SwitchSchedulerRuleRequest() = default;
};
class SwitchSchedulerRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SwitchSchedulerRuleResponseBody() {}

  explicit SwitchSchedulerRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchSchedulerRuleResponseBody() = default;
};
class SwitchSchedulerRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchSchedulerRuleResponseBody> body{};

  SwitchSchedulerRuleResponse() {}

  explicit SwitchSchedulerRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchSchedulerRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchSchedulerRuleResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchSchedulerRuleResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddAutoCcBlacklistResponse addAutoCcBlacklistWithOptions(shared_ptr<AddAutoCcBlacklistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAutoCcBlacklistResponse addAutoCcBlacklist(shared_ptr<AddAutoCcBlacklistRequest> request);
  AddAutoCcWhitelistResponse addAutoCcWhitelistWithOptions(shared_ptr<AddAutoCcWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAutoCcWhitelistResponse addAutoCcWhitelist(shared_ptr<AddAutoCcWhitelistRequest> request);
  AssociateWebCertResponse associateWebCertWithOptions(shared_ptr<AssociateWebCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateWebCertResponse associateWebCert(shared_ptr<AssociateWebCertRequest> request);
  AttachSceneDefenseObjectResponse attachSceneDefenseObjectWithOptions(shared_ptr<AttachSceneDefenseObjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachSceneDefenseObjectResponse attachSceneDefenseObject(shared_ptr<AttachSceneDefenseObjectRequest> request);
  ConfigL7RsPolicyResponse configL7RsPolicyWithOptions(shared_ptr<ConfigL7RsPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigL7RsPolicyResponse configL7RsPolicy(shared_ptr<ConfigL7RsPolicyRequest> request);
  ConfigLayer4RemarkResponse configLayer4RemarkWithOptions(shared_ptr<ConfigLayer4RemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigLayer4RemarkResponse configLayer4Remark(shared_ptr<ConfigLayer4RemarkRequest> request);
  ConfigLayer4RuleBakModeResponse configLayer4RuleBakModeWithOptions(shared_ptr<ConfigLayer4RuleBakModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigLayer4RuleBakModeResponse configLayer4RuleBakMode(shared_ptr<ConfigLayer4RuleBakModeRequest> request);
  ConfigLayer4RulePolicyResponse configLayer4RulePolicyWithOptions(shared_ptr<ConfigLayer4RulePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigLayer4RulePolicyResponse configLayer4RulePolicy(shared_ptr<ConfigLayer4RulePolicyRequest> request);
  ConfigNetworkRegionBlockResponse configNetworkRegionBlockWithOptions(shared_ptr<ConfigNetworkRegionBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigNetworkRegionBlockResponse configNetworkRegionBlock(shared_ptr<ConfigNetworkRegionBlockRequest> request);
  ConfigNetworkRulesResponse configNetworkRulesWithOptions(shared_ptr<ConfigNetworkRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigNetworkRulesResponse configNetworkRules(shared_ptr<ConfigNetworkRulesRequest> request);
  ConfigUdpReflectResponse configUdpReflectWithOptions(shared_ptr<ConfigUdpReflectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigUdpReflectResponse configUdpReflect(shared_ptr<ConfigUdpReflectRequest> request);
  ConfigWebCCTemplateResponse configWebCCTemplateWithOptions(shared_ptr<ConfigWebCCTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigWebCCTemplateResponse configWebCCTemplate(shared_ptr<ConfigWebCCTemplateRequest> request);
  ConfigWebIpSetResponse configWebIpSetWithOptions(shared_ptr<ConfigWebIpSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigWebIpSetResponse configWebIpSet(shared_ptr<ConfigWebIpSetRequest> request);
  CreateAsyncTaskResponse createAsyncTaskWithOptions(shared_ptr<CreateAsyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAsyncTaskResponse createAsyncTask(shared_ptr<CreateAsyncTaskRequest> request);
  CreateDomainResourceResponse createDomainResourceWithOptions(shared_ptr<CreateDomainResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDomainResourceResponse createDomainResource(shared_ptr<CreateDomainResourceRequest> request);
  CreateNetworkRulesResponse createNetworkRulesWithOptions(shared_ptr<CreateNetworkRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkRulesResponse createNetworkRules(shared_ptr<CreateNetworkRulesRequest> request);
  CreatePortResponse createPortWithOptions(shared_ptr<CreatePortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePortResponse createPort(shared_ptr<CreatePortRequest> request);
  CreateSceneDefensePolicyResponse createSceneDefensePolicyWithOptions(shared_ptr<CreateSceneDefensePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSceneDefensePolicyResponse createSceneDefensePolicy(shared_ptr<CreateSceneDefensePolicyRequest> request);
  CreateSchedulerRuleResponse createSchedulerRuleWithOptions(shared_ptr<CreateSchedulerRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSchedulerRuleResponse createSchedulerRule(shared_ptr<CreateSchedulerRuleRequest> request);
  CreateTagResourcesResponse createTagResourcesWithOptions(shared_ptr<CreateTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTagResourcesResponse createTagResources(shared_ptr<CreateTagResourcesRequest> request);
  CreateWebCCRuleResponse createWebCCRuleWithOptions(shared_ptr<CreateWebCCRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWebCCRuleResponse createWebCCRule(shared_ptr<CreateWebCCRuleRequest> request);
  CreateWebRuleResponse createWebRuleWithOptions(shared_ptr<CreateWebRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWebRuleResponse createWebRule(shared_ptr<CreateWebRuleRequest> request);
  DeleteAsyncTaskResponse deleteAsyncTaskWithOptions(shared_ptr<DeleteAsyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAsyncTaskResponse deleteAsyncTask(shared_ptr<DeleteAsyncTaskRequest> request);
  DeleteAutoCcBlacklistResponse deleteAutoCcBlacklistWithOptions(shared_ptr<DeleteAutoCcBlacklistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAutoCcBlacklistResponse deleteAutoCcBlacklist(shared_ptr<DeleteAutoCcBlacklistRequest> request);
  DeleteAutoCcWhitelistResponse deleteAutoCcWhitelistWithOptions(shared_ptr<DeleteAutoCcWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAutoCcWhitelistResponse deleteAutoCcWhitelist(shared_ptr<DeleteAutoCcWhitelistRequest> request);
  DeleteDomainResourceResponse deleteDomainResourceWithOptions(shared_ptr<DeleteDomainResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainResourceResponse deleteDomainResource(shared_ptr<DeleteDomainResourceRequest> request);
  DeleteNetworkRuleResponse deleteNetworkRuleWithOptions(shared_ptr<DeleteNetworkRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkRuleResponse deleteNetworkRule(shared_ptr<DeleteNetworkRuleRequest> request);
  DeletePortResponse deletePortWithOptions(shared_ptr<DeletePortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePortResponse deletePort(shared_ptr<DeletePortRequest> request);
  DeleteSceneDefensePolicyResponse deleteSceneDefensePolicyWithOptions(shared_ptr<DeleteSceneDefensePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSceneDefensePolicyResponse deleteSceneDefensePolicy(shared_ptr<DeleteSceneDefensePolicyRequest> request);
  DeleteSchedulerRuleResponse deleteSchedulerRuleWithOptions(shared_ptr<DeleteSchedulerRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSchedulerRuleResponse deleteSchedulerRule(shared_ptr<DeleteSchedulerRuleRequest> request);
  DeleteTagResourcesResponse deleteTagResourcesWithOptions(shared_ptr<DeleteTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTagResourcesResponse deleteTagResources(shared_ptr<DeleteTagResourcesRequest> request);
  DeleteWebCCRuleResponse deleteWebCCRuleWithOptions(shared_ptr<DeleteWebCCRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWebCCRuleResponse deleteWebCCRule(shared_ptr<DeleteWebCCRuleRequest> request);
  DeleteWebCacheCustomRuleResponse deleteWebCacheCustomRuleWithOptions(shared_ptr<DeleteWebCacheCustomRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWebCacheCustomRuleResponse deleteWebCacheCustomRule(shared_ptr<DeleteWebCacheCustomRuleRequest> request);
  DeleteWebPreciseAccessRuleResponse deleteWebPreciseAccessRuleWithOptions(shared_ptr<DeleteWebPreciseAccessRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWebPreciseAccessRuleResponse deleteWebPreciseAccessRule(shared_ptr<DeleteWebPreciseAccessRuleRequest> request);
  DeleteWebRuleResponse deleteWebRuleWithOptions(shared_ptr<DeleteWebRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWebRuleResponse deleteWebRule(shared_ptr<DeleteWebRuleRequest> request);
  DescribeAsyncTasksResponse describeAsyncTasksWithOptions(shared_ptr<DescribeAsyncTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAsyncTasksResponse describeAsyncTasks(shared_ptr<DescribeAsyncTasksRequest> request);
  DescribeAttackAnalysisMaxQpsResponse describeAttackAnalysisMaxQpsWithOptions(shared_ptr<DescribeAttackAnalysisMaxQpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAttackAnalysisMaxQpsResponse describeAttackAnalysisMaxQps(shared_ptr<DescribeAttackAnalysisMaxQpsRequest> request);
  DescribeAutoCcBlacklistResponse describeAutoCcBlacklistWithOptions(shared_ptr<DescribeAutoCcBlacklistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoCcBlacklistResponse describeAutoCcBlacklist(shared_ptr<DescribeAutoCcBlacklistRequest> request);
  DescribeAutoCcListCountResponse describeAutoCcListCountWithOptions(shared_ptr<DescribeAutoCcListCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoCcListCountResponse describeAutoCcListCount(shared_ptr<DescribeAutoCcListCountRequest> request);
  DescribeAutoCcWhitelistResponse describeAutoCcWhitelistWithOptions(shared_ptr<DescribeAutoCcWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoCcWhitelistResponse describeAutoCcWhitelist(shared_ptr<DescribeAutoCcWhitelistRequest> request);
  DescribeBackSourceCidrResponse describeBackSourceCidrWithOptions(shared_ptr<DescribeBackSourceCidrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackSourceCidrResponse describeBackSourceCidr(shared_ptr<DescribeBackSourceCidrRequest> request);
  DescribeBlackholeStatusResponse describeBlackholeStatusWithOptions(shared_ptr<DescribeBlackholeStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlackholeStatusResponse describeBlackholeStatus(shared_ptr<DescribeBlackholeStatusRequest> request);
  DescribeBlockStatusResponse describeBlockStatusWithOptions(shared_ptr<DescribeBlockStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockStatusResponse describeBlockStatus(shared_ptr<DescribeBlockStatusRequest> request);
  DescribeCertsResponse describeCertsWithOptions(shared_ptr<DescribeCertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCertsResponse describeCerts(shared_ptr<DescribeCertsRequest> request);
  DescribeCnameReusesResponse describeCnameReusesWithOptions(shared_ptr<DescribeCnameReusesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCnameReusesResponse describeCnameReuses(shared_ptr<DescribeCnameReusesRequest> request);
  DescribeDDoSEventsResponse describeDDoSEventsWithOptions(shared_ptr<DescribeDDoSEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDDoSEventsResponse describeDDoSEvents(shared_ptr<DescribeDDoSEventsRequest> request);
  DescribeDDosAllEventListResponse describeDDosAllEventListWithOptions(shared_ptr<DescribeDDosAllEventListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDDosAllEventListResponse describeDDosAllEventList(shared_ptr<DescribeDDosAllEventListRequest> request);
  DescribeDDosEventAreaResponse describeDDosEventAreaWithOptions(shared_ptr<DescribeDDosEventAreaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDDosEventAreaResponse describeDDosEventArea(shared_ptr<DescribeDDosEventAreaRequest> request);
  DescribeDDosEventAttackTypeResponse describeDDosEventAttackTypeWithOptions(shared_ptr<DescribeDDosEventAttackTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDDosEventAttackTypeResponse describeDDosEventAttackType(shared_ptr<DescribeDDosEventAttackTypeRequest> request);
  DescribeDDosEventIspResponse describeDDosEventIspWithOptions(shared_ptr<DescribeDDosEventIspRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDDosEventIspResponse describeDDosEventIsp(shared_ptr<DescribeDDosEventIspRequest> request);
  DescribeDDosEventMaxResponse describeDDosEventMaxWithOptions(shared_ptr<DescribeDDosEventMaxRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDDosEventMaxResponse describeDDosEventMax(shared_ptr<DescribeDDosEventMaxRequest> request);
  DescribeDDosEventSrcIpResponse describeDDosEventSrcIpWithOptions(shared_ptr<DescribeDDosEventSrcIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDDosEventSrcIpResponse describeDDosEventSrcIp(shared_ptr<DescribeDDosEventSrcIpRequest> request);
  DescribeDefenseCountStatisticsResponse describeDefenseCountStatisticsWithOptions(shared_ptr<DescribeDefenseCountStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseCountStatisticsResponse describeDefenseCountStatistics(shared_ptr<DescribeDefenseCountStatisticsRequest> request);
  DescribeDefenseRecordsResponse describeDefenseRecordsWithOptions(shared_ptr<DescribeDefenseRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseRecordsResponse describeDefenseRecords(shared_ptr<DescribeDefenseRecordsRequest> request);
  DescribeDomainAttackEventsResponse describeDomainAttackEventsWithOptions(shared_ptr<DescribeDomainAttackEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainAttackEventsResponse describeDomainAttackEvents(shared_ptr<DescribeDomainAttackEventsRequest> request);
  DescribeDomainOverviewResponse describeDomainOverviewWithOptions(shared_ptr<DescribeDomainOverviewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainOverviewResponse describeDomainOverview(shared_ptr<DescribeDomainOverviewRequest> request);
  DescribeDomainQPSListResponse describeDomainQPSListWithOptions(shared_ptr<DescribeDomainQPSListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainQPSListResponse describeDomainQPSList(shared_ptr<DescribeDomainQPSListRequest> request);
  DescribeDomainQpsWithCacheResponse describeDomainQpsWithCacheWithOptions(shared_ptr<DescribeDomainQpsWithCacheRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainQpsWithCacheResponse describeDomainQpsWithCache(shared_ptr<DescribeDomainQpsWithCacheRequest> request);
  DescribeDomainResourceResponse describeDomainResourceWithOptions(shared_ptr<DescribeDomainResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainResourceResponse describeDomainResource(shared_ptr<DescribeDomainResourceRequest> request);
  DescribeDomainStatusCodeCountResponse describeDomainStatusCodeCountWithOptions(shared_ptr<DescribeDomainStatusCodeCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainStatusCodeCountResponse describeDomainStatusCodeCount(shared_ptr<DescribeDomainStatusCodeCountRequest> request);
  DescribeDomainStatusCodeListResponse describeDomainStatusCodeListWithOptions(shared_ptr<DescribeDomainStatusCodeListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainStatusCodeListResponse describeDomainStatusCodeList(shared_ptr<DescribeDomainStatusCodeListRequest> request);
  DescribeDomainTopAttackListResponse describeDomainTopAttackListWithOptions(shared_ptr<DescribeDomainTopAttackListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainTopAttackListResponse describeDomainTopAttackList(shared_ptr<DescribeDomainTopAttackListRequest> request);
  DescribeDomainViewSourceCountriesResponse describeDomainViewSourceCountriesWithOptions(shared_ptr<DescribeDomainViewSourceCountriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainViewSourceCountriesResponse describeDomainViewSourceCountries(shared_ptr<DescribeDomainViewSourceCountriesRequest> request);
  DescribeDomainViewSourceProvincesResponse describeDomainViewSourceProvincesWithOptions(shared_ptr<DescribeDomainViewSourceProvincesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainViewSourceProvincesResponse describeDomainViewSourceProvinces(shared_ptr<DescribeDomainViewSourceProvincesRequest> request);
  DescribeDomainViewTopCostTimeResponse describeDomainViewTopCostTimeWithOptions(shared_ptr<DescribeDomainViewTopCostTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainViewTopCostTimeResponse describeDomainViewTopCostTime(shared_ptr<DescribeDomainViewTopCostTimeRequest> request);
  DescribeDomainViewTopUrlResponse describeDomainViewTopUrlWithOptions(shared_ptr<DescribeDomainViewTopUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainViewTopUrlResponse describeDomainViewTopUrl(shared_ptr<DescribeDomainViewTopUrlRequest> request);
  DescribeDomainsResponse describeDomainsWithOptions(shared_ptr<DescribeDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainsResponse describeDomains(shared_ptr<DescribeDomainsRequest> request);
  DescribeElasticBandwidthSpecResponse describeElasticBandwidthSpecWithOptions(shared_ptr<DescribeElasticBandwidthSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeElasticBandwidthSpecResponse describeElasticBandwidthSpec(shared_ptr<DescribeElasticBandwidthSpecRequest> request);
  DescribeHealthCheckListResponse describeHealthCheckListWithOptions(shared_ptr<DescribeHealthCheckListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHealthCheckListResponse describeHealthCheckList(shared_ptr<DescribeHealthCheckListRequest> request);
  DescribeHealthCheckStatusResponse describeHealthCheckStatusWithOptions(shared_ptr<DescribeHealthCheckStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHealthCheckStatusResponse describeHealthCheckStatus(shared_ptr<DescribeHealthCheckStatusRequest> request);
  DescribeInstanceDetailsResponse describeInstanceDetailsWithOptions(shared_ptr<DescribeInstanceDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceDetailsResponse describeInstanceDetails(shared_ptr<DescribeInstanceDetailsRequest> request);
  DescribeInstanceIdsResponse describeInstanceIdsWithOptions(shared_ptr<DescribeInstanceIdsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceIdsResponse describeInstanceIds(shared_ptr<DescribeInstanceIdsRequest> request);
  DescribeInstanceSpecsResponse describeInstanceSpecsWithOptions(shared_ptr<DescribeInstanceSpecsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceSpecsResponse describeInstanceSpecs(shared_ptr<DescribeInstanceSpecsRequest> request);
  DescribeInstanceStatisticsResponse describeInstanceStatisticsWithOptions(shared_ptr<DescribeInstanceStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceStatisticsResponse describeInstanceStatistics(shared_ptr<DescribeInstanceStatisticsRequest> request);
  DescribeInstanceStatusResponse describeInstanceStatusWithOptions(shared_ptr<DescribeInstanceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceStatusResponse describeInstanceStatus(shared_ptr<DescribeInstanceStatusRequest> request);
  DescribeInstancesResponse describeInstancesWithOptions(shared_ptr<DescribeInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstancesResponse describeInstances(shared_ptr<DescribeInstancesRequest> request);
  DescribeL7RsPolicyResponse describeL7RsPolicyWithOptions(shared_ptr<DescribeL7RsPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeL7RsPolicyResponse describeL7RsPolicy(shared_ptr<DescribeL7RsPolicyRequest> request);
  DescribeLayer4RulePolicyResponse describeLayer4RulePolicyWithOptions(shared_ptr<DescribeLayer4RulePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLayer4RulePolicyResponse describeLayer4RulePolicy(shared_ptr<DescribeLayer4RulePolicyRequest> request);
  DescribeLogStoreExistStatusResponse describeLogStoreExistStatusWithOptions(shared_ptr<DescribeLogStoreExistStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogStoreExistStatusResponse describeLogStoreExistStatus(shared_ptr<DescribeLogStoreExistStatusRequest> request);
  DescribeNetworkRegionBlockResponse describeNetworkRegionBlockWithOptions(shared_ptr<DescribeNetworkRegionBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkRegionBlockResponse describeNetworkRegionBlock(shared_ptr<DescribeNetworkRegionBlockRequest> request);
  DescribeNetworkRuleAttributesResponse describeNetworkRuleAttributesWithOptions(shared_ptr<DescribeNetworkRuleAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkRuleAttributesResponse describeNetworkRuleAttributes(shared_ptr<DescribeNetworkRuleAttributesRequest> request);
  DescribeNetworkRulesResponse describeNetworkRulesWithOptions(shared_ptr<DescribeNetworkRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkRulesResponse describeNetworkRules(shared_ptr<DescribeNetworkRulesRequest> request);
  DescribeOpEntitiesResponse describeOpEntitiesWithOptions(shared_ptr<DescribeOpEntitiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOpEntitiesResponse describeOpEntities(shared_ptr<DescribeOpEntitiesRequest> request);
  DescribePortResponse describePortWithOptions(shared_ptr<DescribePortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePortResponse describePort(shared_ptr<DescribePortRequest> request);
  DescribePortAttackMaxFlowResponse describePortAttackMaxFlowWithOptions(shared_ptr<DescribePortAttackMaxFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePortAttackMaxFlowResponse describePortAttackMaxFlow(shared_ptr<DescribePortAttackMaxFlowRequest> request);
  DescribePortAutoCcStatusResponse describePortAutoCcStatusWithOptions(shared_ptr<DescribePortAutoCcStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePortAutoCcStatusResponse describePortAutoCcStatus(shared_ptr<DescribePortAutoCcStatusRequest> request);
  DescribePortConnsCountResponse describePortConnsCountWithOptions(shared_ptr<DescribePortConnsCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePortConnsCountResponse describePortConnsCount(shared_ptr<DescribePortConnsCountRequest> request);
  DescribePortConnsListResponse describePortConnsListWithOptions(shared_ptr<DescribePortConnsListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePortConnsListResponse describePortConnsList(shared_ptr<DescribePortConnsListRequest> request);
  DescribePortFlowListResponse describePortFlowListWithOptions(shared_ptr<DescribePortFlowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePortFlowListResponse describePortFlowList(shared_ptr<DescribePortFlowListRequest> request);
  DescribePortMaxConnsResponse describePortMaxConnsWithOptions(shared_ptr<DescribePortMaxConnsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePortMaxConnsResponse describePortMaxConns(shared_ptr<DescribePortMaxConnsRequest> request);
  DescribePortViewSourceCountriesResponse describePortViewSourceCountriesWithOptions(shared_ptr<DescribePortViewSourceCountriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePortViewSourceCountriesResponse describePortViewSourceCountries(shared_ptr<DescribePortViewSourceCountriesRequest> request);
  DescribePortViewSourceIspsResponse describePortViewSourceIspsWithOptions(shared_ptr<DescribePortViewSourceIspsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePortViewSourceIspsResponse describePortViewSourceIsps(shared_ptr<DescribePortViewSourceIspsRequest> request);
  DescribePortViewSourceProvincesResponse describePortViewSourceProvincesWithOptions(shared_ptr<DescribePortViewSourceProvincesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePortViewSourceProvincesResponse describePortViewSourceProvinces(shared_ptr<DescribePortViewSourceProvincesRequest> request);
  DescribeSceneDefenseObjectsResponse describeSceneDefenseObjectsWithOptions(shared_ptr<DescribeSceneDefenseObjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSceneDefenseObjectsResponse describeSceneDefenseObjects(shared_ptr<DescribeSceneDefenseObjectsRequest> request);
  DescribeSceneDefensePoliciesResponse describeSceneDefensePoliciesWithOptions(shared_ptr<DescribeSceneDefensePoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSceneDefensePoliciesResponse describeSceneDefensePolicies(shared_ptr<DescribeSceneDefensePoliciesRequest> request);
  DescribeSchedulerRulesResponse describeSchedulerRulesWithOptions(shared_ptr<DescribeSchedulerRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSchedulerRulesResponse describeSchedulerRules(shared_ptr<DescribeSchedulerRulesRequest> request);
  DescribeSlsAuthStatusResponse describeSlsAuthStatusWithOptions(shared_ptr<DescribeSlsAuthStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlsAuthStatusResponse describeSlsAuthStatus(shared_ptr<DescribeSlsAuthStatusRequest> request);
  DescribeSlsLogstoreInfoResponse describeSlsLogstoreInfoWithOptions(shared_ptr<DescribeSlsLogstoreInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlsLogstoreInfoResponse describeSlsLogstoreInfo(shared_ptr<DescribeSlsLogstoreInfoRequest> request);
  DescribeSlsOpenStatusResponse describeSlsOpenStatusWithOptions(shared_ptr<DescribeSlsOpenStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlsOpenStatusResponse describeSlsOpenStatus(shared_ptr<DescribeSlsOpenStatusRequest> request);
  DescribeStsGrantStatusResponse describeStsGrantStatusWithOptions(shared_ptr<DescribeStsGrantStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStsGrantStatusResponse describeStsGrantStatus(shared_ptr<DescribeStsGrantStatusRequest> request);
  DescribeSystemLogResponse describeSystemLogWithOptions(shared_ptr<DescribeSystemLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSystemLogResponse describeSystemLog(shared_ptr<DescribeSystemLogRequest> request);
  DescribeTagKeysResponse describeTagKeysWithOptions(shared_ptr<DescribeTagKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagKeysResponse describeTagKeys(shared_ptr<DescribeTagKeysRequest> request);
  DescribeTagResourcesResponse describeTagResourcesWithOptions(shared_ptr<DescribeTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagResourcesResponse describeTagResources(shared_ptr<DescribeTagResourcesRequest> request);
  DescribeUdpReflectResponse describeUdpReflectWithOptions(shared_ptr<DescribeUdpReflectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUdpReflectResponse describeUdpReflect(shared_ptr<DescribeUdpReflectRequest> request);
  DescribeUnBlackholeCountResponse describeUnBlackholeCountWithOptions(shared_ptr<DescribeUnBlackholeCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUnBlackholeCountResponse describeUnBlackholeCount(shared_ptr<DescribeUnBlackholeCountRequest> request);
  DescribeUnBlockCountResponse describeUnBlockCountWithOptions(shared_ptr<DescribeUnBlockCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUnBlockCountResponse describeUnBlockCount(shared_ptr<DescribeUnBlockCountRequest> request);
  DescribeWebAccessLogDispatchStatusResponse describeWebAccessLogDispatchStatusWithOptions(shared_ptr<DescribeWebAccessLogDispatchStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebAccessLogDispatchStatusResponse describeWebAccessLogDispatchStatus(shared_ptr<DescribeWebAccessLogDispatchStatusRequest> request);
  DescribeWebAccessLogEmptyCountResponse describeWebAccessLogEmptyCountWithOptions(shared_ptr<DescribeWebAccessLogEmptyCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebAccessLogEmptyCountResponse describeWebAccessLogEmptyCount(shared_ptr<DescribeWebAccessLogEmptyCountRequest> request);
  DescribeWebAccessLogStatusResponse describeWebAccessLogStatusWithOptions(shared_ptr<DescribeWebAccessLogStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebAccessLogStatusResponse describeWebAccessLogStatus(shared_ptr<DescribeWebAccessLogStatusRequest> request);
  DescribeWebAccessModeResponse describeWebAccessModeWithOptions(shared_ptr<DescribeWebAccessModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebAccessModeResponse describeWebAccessMode(shared_ptr<DescribeWebAccessModeRequest> request);
  DescribeWebAreaBlockConfigsResponse describeWebAreaBlockConfigsWithOptions(shared_ptr<DescribeWebAreaBlockConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebAreaBlockConfigsResponse describeWebAreaBlockConfigs(shared_ptr<DescribeWebAreaBlockConfigsRequest> request);
  DescribeWebCCRulesResponse describeWebCCRulesWithOptions(shared_ptr<DescribeWebCCRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebCCRulesResponse describeWebCCRules(shared_ptr<DescribeWebCCRulesRequest> request);
  DescribeWebCacheConfigsResponse describeWebCacheConfigsWithOptions(shared_ptr<DescribeWebCacheConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebCacheConfigsResponse describeWebCacheConfigs(shared_ptr<DescribeWebCacheConfigsRequest> request);
  DescribeWebCcProtectSwitchResponse describeWebCcProtectSwitchWithOptions(shared_ptr<DescribeWebCcProtectSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebCcProtectSwitchResponse describeWebCcProtectSwitch(shared_ptr<DescribeWebCcProtectSwitchRequest> request);
  DescribeWebCustomPortsResponse describeWebCustomPortsWithOptions(shared_ptr<DescribeWebCustomPortsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebCustomPortsResponse describeWebCustomPorts(shared_ptr<DescribeWebCustomPortsRequest> request);
  DescribeWebInstanceRelationsResponse describeWebInstanceRelationsWithOptions(shared_ptr<DescribeWebInstanceRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebInstanceRelationsResponse describeWebInstanceRelations(shared_ptr<DescribeWebInstanceRelationsRequest> request);
  DescribeWebPreciseAccessRuleResponse describeWebPreciseAccessRuleWithOptions(shared_ptr<DescribeWebPreciseAccessRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebPreciseAccessRuleResponse describeWebPreciseAccessRule(shared_ptr<DescribeWebPreciseAccessRuleRequest> request);
  DescribeWebRulesResponse describeWebRulesWithOptions(shared_ptr<DescribeWebRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebRulesResponse describeWebRules(shared_ptr<DescribeWebRulesRequest> request);
  DetachSceneDefenseObjectResponse detachSceneDefenseObjectWithOptions(shared_ptr<DetachSceneDefenseObjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachSceneDefenseObjectResponse detachSceneDefenseObject(shared_ptr<DetachSceneDefenseObjectRequest> request);
  DisableSceneDefensePolicyResponse disableSceneDefensePolicyWithOptions(shared_ptr<DisableSceneDefensePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableSceneDefensePolicyResponse disableSceneDefensePolicy(shared_ptr<DisableSceneDefensePolicyRequest> request);
  DisableWebAccessLogConfigResponse disableWebAccessLogConfigWithOptions(shared_ptr<DisableWebAccessLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableWebAccessLogConfigResponse disableWebAccessLogConfig(shared_ptr<DisableWebAccessLogConfigRequest> request);
  DisableWebCCResponse disableWebCCWithOptions(shared_ptr<DisableWebCCRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableWebCCResponse disableWebCC(shared_ptr<DisableWebCCRequest> request);
  DisableWebCCRuleResponse disableWebCCRuleWithOptions(shared_ptr<DisableWebCCRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableWebCCRuleResponse disableWebCCRule(shared_ptr<DisableWebCCRuleRequest> request);
  EmptyAutoCcBlacklistResponse emptyAutoCcBlacklistWithOptions(shared_ptr<EmptyAutoCcBlacklistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EmptyAutoCcBlacklistResponse emptyAutoCcBlacklist(shared_ptr<EmptyAutoCcBlacklistRequest> request);
  EmptyAutoCcWhitelistResponse emptyAutoCcWhitelistWithOptions(shared_ptr<EmptyAutoCcWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EmptyAutoCcWhitelistResponse emptyAutoCcWhitelist(shared_ptr<EmptyAutoCcWhitelistRequest> request);
  EmptySlsLogstoreResponse emptySlsLogstoreWithOptions(shared_ptr<EmptySlsLogstoreRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EmptySlsLogstoreResponse emptySlsLogstore(shared_ptr<EmptySlsLogstoreRequest> request);
  EnableSceneDefensePolicyResponse enableSceneDefensePolicyWithOptions(shared_ptr<EnableSceneDefensePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableSceneDefensePolicyResponse enableSceneDefensePolicy(shared_ptr<EnableSceneDefensePolicyRequest> request);
  EnableWebAccessLogConfigResponse enableWebAccessLogConfigWithOptions(shared_ptr<EnableWebAccessLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableWebAccessLogConfigResponse enableWebAccessLogConfig(shared_ptr<EnableWebAccessLogConfigRequest> request);
  EnableWebCCResponse enableWebCCWithOptions(shared_ptr<EnableWebCCRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableWebCCResponse enableWebCC(shared_ptr<EnableWebCCRequest> request);
  EnableWebCCRuleResponse enableWebCCRuleWithOptions(shared_ptr<EnableWebCCRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableWebCCRuleResponse enableWebCCRule(shared_ptr<EnableWebCCRuleRequest> request);
  ModifyBlackholeStatusResponse modifyBlackholeStatusWithOptions(shared_ptr<ModifyBlackholeStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBlackholeStatusResponse modifyBlackholeStatus(shared_ptr<ModifyBlackholeStatusRequest> request);
  ModifyBlockStatusResponse modifyBlockStatusWithOptions(shared_ptr<ModifyBlockStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBlockStatusResponse modifyBlockStatus(shared_ptr<ModifyBlockStatusRequest> request);
  ModifyCnameReuseResponse modifyCnameReuseWithOptions(shared_ptr<ModifyCnameReuseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCnameReuseResponse modifyCnameReuse(shared_ptr<ModifyCnameReuseRequest> request);
  ModifyDomainResourceResponse modifyDomainResourceWithOptions(shared_ptr<ModifyDomainResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDomainResourceResponse modifyDomainResource(shared_ptr<ModifyDomainResourceRequest> request);
  ModifyElasticBandWidthResponse modifyElasticBandWidthWithOptions(shared_ptr<ModifyElasticBandWidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyElasticBandWidthResponse modifyElasticBandWidth(shared_ptr<ModifyElasticBandWidthRequest> request);
  ModifyFullLogTtlResponse modifyFullLogTtlWithOptions(shared_ptr<ModifyFullLogTtlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFullLogTtlResponse modifyFullLogTtl(shared_ptr<ModifyFullLogTtlRequest> request);
  ModifyHealthCheckConfigResponse modifyHealthCheckConfigWithOptions(shared_ptr<ModifyHealthCheckConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHealthCheckConfigResponse modifyHealthCheckConfig(shared_ptr<ModifyHealthCheckConfigRequest> request);
  ModifyHttp2EnableResponse modifyHttp2EnableWithOptions(shared_ptr<ModifyHttp2EnableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHttp2EnableResponse modifyHttp2Enable(shared_ptr<ModifyHttp2EnableRequest> request);
  ModifyInstanceRemarkResponse modifyInstanceRemarkWithOptions(shared_ptr<ModifyInstanceRemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceRemarkResponse modifyInstanceRemark(shared_ptr<ModifyInstanceRemarkRequest> request);
  ModifyNetworkRuleAttributeResponse modifyNetworkRuleAttributeWithOptions(shared_ptr<ModifyNetworkRuleAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNetworkRuleAttributeResponse modifyNetworkRuleAttribute(shared_ptr<ModifyNetworkRuleAttributeRequest> request);
  ModifyPortResponse modifyPortWithOptions(shared_ptr<ModifyPortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPortResponse modifyPort(shared_ptr<ModifyPortRequest> request);
  ModifyPortAutoCcStatusResponse modifyPortAutoCcStatusWithOptions(shared_ptr<ModifyPortAutoCcStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPortAutoCcStatusResponse modifyPortAutoCcStatus(shared_ptr<ModifyPortAutoCcStatusRequest> request);
  ModifySceneDefensePolicyResponse modifySceneDefensePolicyWithOptions(shared_ptr<ModifySceneDefensePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySceneDefensePolicyResponse modifySceneDefensePolicy(shared_ptr<ModifySceneDefensePolicyRequest> request);
  ModifySchedulerRuleResponse modifySchedulerRuleWithOptions(shared_ptr<ModifySchedulerRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySchedulerRuleResponse modifySchedulerRule(shared_ptr<ModifySchedulerRuleRequest> request);
  ModifyTlsConfigResponse modifyTlsConfigWithOptions(shared_ptr<ModifyTlsConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTlsConfigResponse modifyTlsConfig(shared_ptr<ModifyTlsConfigRequest> request);
  ModifyWebAIProtectModeResponse modifyWebAIProtectModeWithOptions(shared_ptr<ModifyWebAIProtectModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebAIProtectModeResponse modifyWebAIProtectMode(shared_ptr<ModifyWebAIProtectModeRequest> request);
  ModifyWebAIProtectSwitchResponse modifyWebAIProtectSwitchWithOptions(shared_ptr<ModifyWebAIProtectSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebAIProtectSwitchResponse modifyWebAIProtectSwitch(shared_ptr<ModifyWebAIProtectSwitchRequest> request);
  ModifyWebAccessModeResponse modifyWebAccessModeWithOptions(shared_ptr<ModifyWebAccessModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebAccessModeResponse modifyWebAccessMode(shared_ptr<ModifyWebAccessModeRequest> request);
  ModifyWebAreaBlockResponse modifyWebAreaBlockWithOptions(shared_ptr<ModifyWebAreaBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebAreaBlockResponse modifyWebAreaBlock(shared_ptr<ModifyWebAreaBlockRequest> request);
  ModifyWebAreaBlockSwitchResponse modifyWebAreaBlockSwitchWithOptions(shared_ptr<ModifyWebAreaBlockSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebAreaBlockSwitchResponse modifyWebAreaBlockSwitch(shared_ptr<ModifyWebAreaBlockSwitchRequest> request);
  ModifyWebCCRuleResponse modifyWebCCRuleWithOptions(shared_ptr<ModifyWebCCRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebCCRuleResponse modifyWebCCRule(shared_ptr<ModifyWebCCRuleRequest> request);
  ModifyWebCacheCustomRuleResponse modifyWebCacheCustomRuleWithOptions(shared_ptr<ModifyWebCacheCustomRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebCacheCustomRuleResponse modifyWebCacheCustomRule(shared_ptr<ModifyWebCacheCustomRuleRequest> request);
  ModifyWebCacheModeResponse modifyWebCacheModeWithOptions(shared_ptr<ModifyWebCacheModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebCacheModeResponse modifyWebCacheMode(shared_ptr<ModifyWebCacheModeRequest> request);
  ModifyWebCacheSwitchResponse modifyWebCacheSwitchWithOptions(shared_ptr<ModifyWebCacheSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebCacheSwitchResponse modifyWebCacheSwitch(shared_ptr<ModifyWebCacheSwitchRequest> request);
  ModifyWebIpSetSwitchResponse modifyWebIpSetSwitchWithOptions(shared_ptr<ModifyWebIpSetSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebIpSetSwitchResponse modifyWebIpSetSwitch(shared_ptr<ModifyWebIpSetSwitchRequest> request);
  ModifyWebPreciseAccessRuleResponse modifyWebPreciseAccessRuleWithOptions(shared_ptr<ModifyWebPreciseAccessRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebPreciseAccessRuleResponse modifyWebPreciseAccessRule(shared_ptr<ModifyWebPreciseAccessRuleRequest> request);
  ModifyWebPreciseAccessSwitchResponse modifyWebPreciseAccessSwitchWithOptions(shared_ptr<ModifyWebPreciseAccessSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebPreciseAccessSwitchResponse modifyWebPreciseAccessSwitch(shared_ptr<ModifyWebPreciseAccessSwitchRequest> request);
  ModifyWebRuleResponse modifyWebRuleWithOptions(shared_ptr<ModifyWebRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebRuleResponse modifyWebRule(shared_ptr<ModifyWebRuleRequest> request);
  ReleaseInstanceResponse releaseInstanceWithOptions(shared_ptr<ReleaseInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseInstanceResponse releaseInstance(shared_ptr<ReleaseInstanceRequest> request);
  SwitchSchedulerRuleResponse switchSchedulerRuleWithOptions(shared_ptr<SwitchSchedulerRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchSchedulerRuleResponse switchSchedulerRule(shared_ptr<SwitchSchedulerRuleRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Ddoscoo20200101

#endif
