// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ARMS20190808_H_
#define ALIBABACLOUD_ARMS20190808_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_ARMS20190808 {
class CallChainInfo : public Darabonba::Model {
public:
  shared_ptr<string> additionalInfo{};
  shared_ptr<string> appName{};
  shared_ptr<string> appType{};
  shared_ptr<vector<CallChainInfo>> children{};
  shared_ptr<bool> haveSpan{};
  shared_ptr<map<string, map<string, boost::any>>> logMap{};
  shared_ptr<long> logTime{};
  shared_ptr<string> parentSpanId{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> rpc{};
  shared_ptr<string> rpcId{};
  shared_ptr<long> rpcType{};
  shared_ptr<string> serverIp{};
  shared_ptr<long> span{};
  shared_ptr<string> spanId{};
  shared_ptr<map<string, string>> tagMap{};
  shared_ptr<string> traceId{};

  CallChainInfo() {}

  explicit CallChainInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalInfo) {
      res["AdditionalInfo"] = boost::any(*additionalInfo);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Children"] = boost::any(temp1);
    }
    if (haveSpan) {
      res["HaveSpan"] = boost::any(*haveSpan);
    }
    if (logMap) {
      res["LogMap"] = boost::any(*logMap);
    }
    if (logTime) {
      res["LogTime"] = boost::any(*logTime);
    }
    if (parentSpanId) {
      res["ParentSpanId"] = boost::any(*parentSpanId);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (rpc) {
      res["Rpc"] = boost::any(*rpc);
    }
    if (rpcId) {
      res["RpcId"] = boost::any(*rpcId);
    }
    if (rpcType) {
      res["RpcType"] = boost::any(*rpcType);
    }
    if (serverIp) {
      res["ServerIp"] = boost::any(*serverIp);
    }
    if (span) {
      res["Span"] = boost::any(*span);
    }
    if (spanId) {
      res["SpanId"] = boost::any(*spanId);
    }
    if (tagMap) {
      res["TagMap"] = boost::any(*tagMap);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalInfo") != m.end() && !m["AdditionalInfo"].empty()) {
      additionalInfo = make_shared<string>(boost::any_cast<string>(m["AdditionalInfo"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<CallChainInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CallChainInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<CallChainInfo>>(expect1);
      }
    }
    if (m.find("HaveSpan") != m.end() && !m["HaveSpan"].empty()) {
      haveSpan = make_shared<bool>(boost::any_cast<bool>(m["HaveSpan"]));
    }
    if (m.find("LogMap") != m.end() && !m["LogMap"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["LogMap"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      logMap = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
    if (m.find("LogTime") != m.end() && !m["LogTime"].empty()) {
      logTime = make_shared<long>(boost::any_cast<long>(m["LogTime"]));
    }
    if (m.find("ParentSpanId") != m.end() && !m["ParentSpanId"].empty()) {
      parentSpanId = make_shared<string>(boost::any_cast<string>(m["ParentSpanId"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("Rpc") != m.end() && !m["Rpc"].empty()) {
      rpc = make_shared<string>(boost::any_cast<string>(m["Rpc"]));
    }
    if (m.find("RpcId") != m.end() && !m["RpcId"].empty()) {
      rpcId = make_shared<string>(boost::any_cast<string>(m["RpcId"]));
    }
    if (m.find("RpcType") != m.end() && !m["RpcType"].empty()) {
      rpcType = make_shared<long>(boost::any_cast<long>(m["RpcType"]));
    }
    if (m.find("ServerIp") != m.end() && !m["ServerIp"].empty()) {
      serverIp = make_shared<string>(boost::any_cast<string>(m["ServerIp"]));
    }
    if (m.find("Span") != m.end() && !m["Span"].empty()) {
      span = make_shared<long>(boost::any_cast<long>(m["Span"]));
    }
    if (m.find("SpanId") != m.end() && !m["SpanId"].empty()) {
      spanId = make_shared<string>(boost::any_cast<string>(m["SpanId"]));
    }
    if (m.find("TagMap") != m.end() && !m["TagMap"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["TagMap"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tagMap = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CallChainInfo() = default;
};
class GrafanaWorkspaceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GrafanaWorkspaceTags() {}

  explicit GrafanaWorkspaceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GrafanaWorkspaceTags() = default;
};
class GrafanaWorkspace : public Darabonba::Model {
public:
  shared_ptr<bool> commercial{};
  shared_ptr<string> deployType{};
  shared_ptr<string> description{};
  shared_ptr<double> endTime{};
  shared_ptr<double> gmtCreate{};
  shared_ptr<string> grafanaVersion{};
  shared_ptr<string> grafanaWorkspaceDomain{};
  shared_ptr<string> grafanaWorkspaceDomainStatus{};
  shared_ptr<string> grafanaWorkspaceEdition{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<string> grafanaWorkspaceIp{};
  shared_ptr<string> grafanaWorkspaceName{};
  shared_ptr<string> maxAccount{};
  shared_ptr<string> ntmId{};
  shared_ptr<string> personalDomain{};
  shared_ptr<string> personalDomainPrefix{};
  shared_ptr<string> privateDomain{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> shareSynced{};
  shared_ptr<string> snatIp{};
  shared_ptr<string> status{};
  shared_ptr<vector<GrafanaWorkspaceTags>> tags{};
  shared_ptr<vector<string>> upgradeVersion{};
  shared_ptr<string> userId{};

  GrafanaWorkspace() {}

  explicit GrafanaWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commercial) {
      res["commercial"] = boost::any(*commercial);
    }
    if (deployType) {
      res["deployType"] = boost::any(*deployType);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (grafanaVersion) {
      res["grafanaVersion"] = boost::any(*grafanaVersion);
    }
    if (grafanaWorkspaceDomain) {
      res["grafanaWorkspaceDomain"] = boost::any(*grafanaWorkspaceDomain);
    }
    if (grafanaWorkspaceDomainStatus) {
      res["grafanaWorkspaceDomainStatus"] = boost::any(*grafanaWorkspaceDomainStatus);
    }
    if (grafanaWorkspaceEdition) {
      res["grafanaWorkspaceEdition"] = boost::any(*grafanaWorkspaceEdition);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (grafanaWorkspaceIp) {
      res["grafanaWorkspaceIp"] = boost::any(*grafanaWorkspaceIp);
    }
    if (grafanaWorkspaceName) {
      res["grafanaWorkspaceName"] = boost::any(*grafanaWorkspaceName);
    }
    if (maxAccount) {
      res["maxAccount"] = boost::any(*maxAccount);
    }
    if (ntmId) {
      res["ntmId"] = boost::any(*ntmId);
    }
    if (personalDomain) {
      res["personalDomain"] = boost::any(*personalDomain);
    }
    if (personalDomainPrefix) {
      res["personalDomainPrefix"] = boost::any(*personalDomainPrefix);
    }
    if (privateDomain) {
      res["privateDomain"] = boost::any(*privateDomain);
    }
    if (privateIp) {
      res["privateIp"] = boost::any(*privateIp);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["resourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (shareSynced) {
      res["shareSynced"] = boost::any(*shareSynced);
    }
    if (snatIp) {
      res["snatIp"] = boost::any(*snatIp);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (upgradeVersion) {
      res["upgradeVersion"] = boost::any(*upgradeVersion);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commercial") != m.end() && !m["commercial"].empty()) {
      commercial = make_shared<bool>(boost::any_cast<bool>(m["commercial"]));
    }
    if (m.find("deployType") != m.end() && !m["deployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["deployType"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<double>(boost::any_cast<double>(m["endTime"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<double>(boost::any_cast<double>(m["gmtCreate"]));
    }
    if (m.find("grafanaVersion") != m.end() && !m["grafanaVersion"].empty()) {
      grafanaVersion = make_shared<string>(boost::any_cast<string>(m["grafanaVersion"]));
    }
    if (m.find("grafanaWorkspaceDomain") != m.end() && !m["grafanaWorkspaceDomain"].empty()) {
      grafanaWorkspaceDomain = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceDomain"]));
    }
    if (m.find("grafanaWorkspaceDomainStatus") != m.end() && !m["grafanaWorkspaceDomainStatus"].empty()) {
      grafanaWorkspaceDomainStatus = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceDomainStatus"]));
    }
    if (m.find("grafanaWorkspaceEdition") != m.end() && !m["grafanaWorkspaceEdition"].empty()) {
      grafanaWorkspaceEdition = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceEdition"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("grafanaWorkspaceIp") != m.end() && !m["grafanaWorkspaceIp"].empty()) {
      grafanaWorkspaceIp = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceIp"]));
    }
    if (m.find("grafanaWorkspaceName") != m.end() && !m["grafanaWorkspaceName"].empty()) {
      grafanaWorkspaceName = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceName"]));
    }
    if (m.find("maxAccount") != m.end() && !m["maxAccount"].empty()) {
      maxAccount = make_shared<string>(boost::any_cast<string>(m["maxAccount"]));
    }
    if (m.find("ntmId") != m.end() && !m["ntmId"].empty()) {
      ntmId = make_shared<string>(boost::any_cast<string>(m["ntmId"]));
    }
    if (m.find("personalDomain") != m.end() && !m["personalDomain"].empty()) {
      personalDomain = make_shared<string>(boost::any_cast<string>(m["personalDomain"]));
    }
    if (m.find("personalDomainPrefix") != m.end() && !m["personalDomainPrefix"].empty()) {
      personalDomainPrefix = make_shared<string>(boost::any_cast<string>(m["personalDomainPrefix"]));
    }
    if (m.find("privateDomain") != m.end() && !m["privateDomain"].empty()) {
      privateDomain = make_shared<string>(boost::any_cast<string>(m["privateDomain"]));
    }
    if (m.find("privateIp") != m.end() && !m["privateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["privateIp"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("resourceGroupId") != m.end() && !m["resourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resourceGroupId"]));
    }
    if (m.find("shareSynced") != m.end() && !m["shareSynced"].empty()) {
      shareSynced = make_shared<bool>(boost::any_cast<bool>(m["shareSynced"]));
    }
    if (m.find("snatIp") != m.end() && !m["snatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["snatIp"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<GrafanaWorkspaceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GrafanaWorkspaceTags>>(expect1);
      }
    }
    if (m.find("upgradeVersion") != m.end() && !m["upgradeVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["upgradeVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["upgradeVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      upgradeVersion = make_shared<vector<string>>(toVec1);
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspace() = default;
};
class GrafanaWorkspaceUserOrg : public Darabonba::Model {
public:
  shared_ptr<long> orgId{};
  shared_ptr<string> orgName{};
  shared_ptr<string> role{};

  GrafanaWorkspaceUserOrg() {}

  explicit GrafanaWorkspaceUserOrg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (orgName) {
      res["orgName"] = boost::any(*orgName);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("orgName") != m.end() && !m["orgName"].empty()) {
      orgName = make_shared<string>(boost::any_cast<string>(m["orgName"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
  }


  virtual ~GrafanaWorkspaceUserOrg() = default;
};
class GrafanaWorkspaceAccount : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> accountNotes{};
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> aliyunUserName{};
  shared_ptr<double> gmtCreate{};
  shared_ptr<vector<GrafanaWorkspaceUserOrg>> orgs{};
  shared_ptr<string> type{};

  GrafanaWorkspaceAccount() {}

  explicit GrafanaWorkspaceAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (accountNotes) {
      res["accountNotes"] = boost::any(*accountNotes);
    }
    if (aliyunUid) {
      res["aliyunUid"] = boost::any(*aliyunUid);
    }
    if (aliyunUserName) {
      res["aliyunUserName"] = boost::any(*aliyunUserName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (orgs) {
      vector<boost::any> temp1;
      for(auto item1:*orgs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["orgs"] = boost::any(temp1);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["accountId"]));
    }
    if (m.find("accountNotes") != m.end() && !m["accountNotes"].empty()) {
      accountNotes = make_shared<string>(boost::any_cast<string>(m["accountNotes"]));
    }
    if (m.find("aliyunUid") != m.end() && !m["aliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["aliyunUid"]));
    }
    if (m.find("aliyunUserName") != m.end() && !m["aliyunUserName"].empty()) {
      aliyunUserName = make_shared<string>(boost::any_cast<string>(m["aliyunUserName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<double>(boost::any_cast<double>(m["gmtCreate"]));
    }
    if (m.find("orgs") != m.end() && !m["orgs"].empty()) {
      if (typeid(vector<boost::any>) == m["orgs"].type()) {
        vector<GrafanaWorkspaceUserOrg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["orgs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceUserOrg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        orgs = make_shared<vector<GrafanaWorkspaceUserOrg>>(expect1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GrafanaWorkspaceAccount() = default;
};
class GrafanaWorkspaceAlertNotification : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<bool> isArms{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> name{};
  shared_ptr<bool> sendReminder{};
  shared_ptr<string> settings{};
  shared_ptr<string> type{};
  shared_ptr<string> uid{};

  GrafanaWorkspaceAlertNotification() {}

  explicit GrafanaWorkspaceAlertNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isArms) {
      res["isArms"] = boost::any(*isArms);
    }
    if (isDefault) {
      res["isDefault"] = boost::any(*isDefault);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sendReminder) {
      res["sendReminder"] = boost::any(*sendReminder);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (uid) {
      res["uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("isArms") != m.end() && !m["isArms"].empty()) {
      isArms = make_shared<bool>(boost::any_cast<bool>(m["isArms"]));
    }
    if (m.find("isDefault") != m.end() && !m["isDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["isDefault"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sendReminder") != m.end() && !m["sendReminder"].empty()) {
      sendReminder = make_shared<bool>(boost::any_cast<bool>(m["sendReminder"]));
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      settings = make_shared<string>(boost::any_cast<string>(m["settings"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("uid") != m.end() && !m["uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["uid"]));
    }
  }


  virtual ~GrafanaWorkspaceAlertNotification() = default;
};
class GrafanaWorkspaceArmsAlertConfig : public Darabonba::Model {
public:
  shared_ptr<string> armsAlertsEnable{};
  shared_ptr<string> armsAlertsWebhookUrl{};

  GrafanaWorkspaceArmsAlertConfig() {}

  explicit GrafanaWorkspaceArmsAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsAlertsEnable) {
      res["armsAlertsEnable"] = boost::any(*armsAlertsEnable);
    }
    if (armsAlertsWebhookUrl) {
      res["armsAlertsWebhookUrl"] = boost::any(*armsAlertsWebhookUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("armsAlertsEnable") != m.end() && !m["armsAlertsEnable"].empty()) {
      armsAlertsEnable = make_shared<string>(boost::any_cast<string>(m["armsAlertsEnable"]));
    }
    if (m.find("armsAlertsWebhookUrl") != m.end() && !m["armsAlertsWebhookUrl"].empty()) {
      armsAlertsWebhookUrl = make_shared<string>(boost::any_cast<string>(m["armsAlertsWebhookUrl"]));
    }
  }


  virtual ~GrafanaWorkspaceArmsAlertConfig() = default;
};
class GrafanaWorkspaceCustomDomain : public Darabonba::Model {
public:
  shared_ptr<string> cert{};
  shared_ptr<long> date{};
  shared_ptr<string> domain{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> key{};
  shared_ptr<string> privateZone{};
  shared_ptr<string> protocol{};
  shared_ptr<string> status{};
  shared_ptr<string> uri{};

  GrafanaWorkspaceCustomDomain() {}

  explicit GrafanaWorkspaceCustomDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      res["cert"] = boost::any(*cert);
    }
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (domain) {
      res["domain"] = boost::any(*domain);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (privateZone) {
      res["privateZone"] = boost::any(*privateZone);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (uri) {
      res["uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cert") != m.end() && !m["cert"].empty()) {
      cert = make_shared<string>(boost::any_cast<string>(m["cert"]));
    }
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["date"]));
    }
    if (m.find("domain") != m.end() && !m["domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["domain"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("privateZone") != m.end() && !m["privateZone"].empty()) {
      privateZone = make_shared<string>(boost::any_cast<string>(m["privateZone"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("uri") != m.end() && !m["uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["uri"]));
    }
  }


  virtual ~GrafanaWorkspaceCustomDomain() = default;
};
class GrafanaWorkspaceDashboardReport : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<long> lastSendTime{};
  shared_ptr<string> msg{};
  shared_ptr<string> name{};
  shared_ptr<string> reportChannelTarget{};
  shared_ptr<string> reportChannelType{};
  shared_ptr<string> reportStyle{};
  shared_ptr<string> reportType{};
  shared_ptr<string> status{};
  shared_ptr<string> triggerDay{};
  shared_ptr<string> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<string> url{};
  shared_ptr<string> userId{};

  GrafanaWorkspaceDashboardReport() {}

  explicit GrafanaWorkspaceDashboardReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastSendTime) {
      res["lastSendTime"] = boost::any(*lastSendTime);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (reportChannelTarget) {
      res["reportChannelTarget"] = boost::any(*reportChannelTarget);
    }
    if (reportChannelType) {
      res["reportChannelType"] = boost::any(*reportChannelType);
    }
    if (reportStyle) {
      res["reportStyle"] = boost::any(*reportStyle);
    }
    if (reportType) {
      res["reportType"] = boost::any(*reportType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (triggerDay) {
      res["triggerDay"] = boost::any(*triggerDay);
    }
    if (triggerTime) {
      res["triggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["triggerType"] = boost::any(*triggerType);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastSendTime") != m.end() && !m["lastSendTime"].empty()) {
      lastSendTime = make_shared<long>(boost::any_cast<long>(m["lastSendTime"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("reportChannelTarget") != m.end() && !m["reportChannelTarget"].empty()) {
      reportChannelTarget = make_shared<string>(boost::any_cast<string>(m["reportChannelTarget"]));
    }
    if (m.find("reportChannelType") != m.end() && !m["reportChannelType"].empty()) {
      reportChannelType = make_shared<string>(boost::any_cast<string>(m["reportChannelType"]));
    }
    if (m.find("reportStyle") != m.end() && !m["reportStyle"].empty()) {
      reportStyle = make_shared<string>(boost::any_cast<string>(m["reportStyle"]));
    }
    if (m.find("reportType") != m.end() && !m["reportType"].empty()) {
      reportType = make_shared<string>(boost::any_cast<string>(m["reportType"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("triggerDay") != m.end() && !m["triggerDay"].empty()) {
      triggerDay = make_shared<string>(boost::any_cast<string>(m["triggerDay"]));
    }
    if (m.find("triggerTime") != m.end() && !m["triggerTime"].empty()) {
      triggerTime = make_shared<string>(boost::any_cast<string>(m["triggerTime"]));
    }
    if (m.find("triggerType") != m.end() && !m["triggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["triggerType"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspaceDashboardReport() = default;
};
class GrafanaWorkspaceDashboardSync : public Darabonba::Model {
public:
  shared_ptr<string> dashboardTitle{};
  shared_ptr<string> dashboardURL{};
  shared_ptr<string> dashboardUid{};
  shared_ptr<string> folderId{};
  shared_ptr<string> folderTitle{};
  shared_ptr<string> folderURL{};
  shared_ptr<string> folderUid{};
  shared_ptr<string> orgId{};
  shared_ptr<string> orgName{};
  shared_ptr<string> type{};

  GrafanaWorkspaceDashboardSync() {}

  explicit GrafanaWorkspaceDashboardSync(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboardTitle) {
      res["dashboardTitle"] = boost::any(*dashboardTitle);
    }
    if (dashboardURL) {
      res["dashboardURL"] = boost::any(*dashboardURL);
    }
    if (dashboardUid) {
      res["dashboardUid"] = boost::any(*dashboardUid);
    }
    if (folderId) {
      res["folderId"] = boost::any(*folderId);
    }
    if (folderTitle) {
      res["folderTitle"] = boost::any(*folderTitle);
    }
    if (folderURL) {
      res["folderURL"] = boost::any(*folderURL);
    }
    if (folderUid) {
      res["folderUid"] = boost::any(*folderUid);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (orgName) {
      res["orgName"] = boost::any(*orgName);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dashboardTitle") != m.end() && !m["dashboardTitle"].empty()) {
      dashboardTitle = make_shared<string>(boost::any_cast<string>(m["dashboardTitle"]));
    }
    if (m.find("dashboardURL") != m.end() && !m["dashboardURL"].empty()) {
      dashboardURL = make_shared<string>(boost::any_cast<string>(m["dashboardURL"]));
    }
    if (m.find("dashboardUid") != m.end() && !m["dashboardUid"].empty()) {
      dashboardUid = make_shared<string>(boost::any_cast<string>(m["dashboardUid"]));
    }
    if (m.find("folderId") != m.end() && !m["folderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["folderId"]));
    }
    if (m.find("folderTitle") != m.end() && !m["folderTitle"].empty()) {
      folderTitle = make_shared<string>(boost::any_cast<string>(m["folderTitle"]));
    }
    if (m.find("folderURL") != m.end() && !m["folderURL"].empty()) {
      folderURL = make_shared<string>(boost::any_cast<string>(m["folderURL"]));
    }
    if (m.find("folderUid") != m.end() && !m["folderUid"].empty()) {
      folderUid = make_shared<string>(boost::any_cast<string>(m["folderUid"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<string>(boost::any_cast<string>(m["orgId"]));
    }
    if (m.find("orgName") != m.end() && !m["orgName"].empty()) {
      orgName = make_shared<string>(boost::any_cast<string>(m["orgName"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GrafanaWorkspaceDashboardSync() = default;
};
class GrafanaWorkspaceDataBackup : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> msg{};
  shared_ptr<string> processName{};
  shared_ptr<string> processStatus{};
  shared_ptr<string> subType{};
  shared_ptr<string> userId{};

  GrafanaWorkspaceDataBackup() {}

  explicit GrafanaWorkspaceDataBackup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (processName) {
      res["processName"] = boost::any(*processName);
    }
    if (processStatus) {
      res["processStatus"] = boost::any(*processStatus);
    }
    if (subType) {
      res["subType"] = boost::any(*subType);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("processName") != m.end() && !m["processName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["processName"]));
    }
    if (m.find("processStatus") != m.end() && !m["processStatus"].empty()) {
      processStatus = make_shared<string>(boost::any_cast<string>(m["processStatus"]));
    }
    if (m.find("subType") != m.end() && !m["subType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["subType"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspaceDataBackup() = default;
};
class GrafanaWorkspaceIniBackup : public Darabonba::Model {
public:
  shared_ptr<string> ext{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> msg{};
  shared_ptr<string> processName{};
  shared_ptr<string> processStatus{};
  shared_ptr<string> subType{};
  shared_ptr<string> userId{};

  GrafanaWorkspaceIniBackup() {}

  explicit GrafanaWorkspaceIniBackup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ext) {
      res["ext"] = boost::any(*ext);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (processName) {
      res["processName"] = boost::any(*processName);
    }
    if (processStatus) {
      res["processStatus"] = boost::any(*processStatus);
    }
    if (subType) {
      res["subType"] = boost::any(*subType);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ext") != m.end() && !m["ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["ext"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("processName") != m.end() && !m["processName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["processName"]));
    }
    if (m.find("processStatus") != m.end() && !m["processStatus"].empty()) {
      processStatus = make_shared<string>(boost::any_cast<string>(m["processStatus"]));
    }
    if (m.find("subType") != m.end() && !m["subType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["subType"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspaceIniBackup() = default;
};
class GrafanaWorkspaceIniProperty : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<string> example{};
  shared_ptr<string> key{};
  shared_ptr<bool> secret{};
  shared_ptr<string> value{};

  GrafanaWorkspaceIniProperty() {}

  explicit GrafanaWorkspaceIniProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["defaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (example) {
      res["example"] = boost::any(*example);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (secret) {
      res["secret"] = boost::any(*secret);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("defaultValue") != m.end() && !m["defaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["defaultValue"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("example") != m.end() && !m["example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["example"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("secret") != m.end() && !m["secret"].empty()) {
      secret = make_shared<bool>(boost::any_cast<bool>(m["secret"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GrafanaWorkspaceIniProperty() = default;
};
class GrafanaWorkspaceIniSection : public Darabonba::Model {
public:
  shared_ptr<vector<GrafanaWorkspaceIniProperty>> propertys{};
  shared_ptr<string> section{};

  GrafanaWorkspaceIniSection() {}

  explicit GrafanaWorkspaceIniSection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["propertys"] = boost::any(temp1);
    }
    if (section) {
      res["section"] = boost::any(*section);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("propertys") != m.end() && !m["propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["propertys"].type()) {
        vector<GrafanaWorkspaceIniProperty> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceIniProperty model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<GrafanaWorkspaceIniProperty>>(expect1);
      }
    }
    if (m.find("section") != m.end() && !m["section"].empty()) {
      section = make_shared<string>(boost::any_cast<string>(m["section"]));
    }
  }


  virtual ~GrafanaWorkspaceIniSection() = default;
};
class GrafanaWorkspaceIntegrationPreview : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> image{};
  shared_ptr<string> name{};
  shared_ptr<string> thumbnail{};

  GrafanaWorkspaceIntegrationPreview() {}

  explicit GrafanaWorkspaceIntegrationPreview(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (thumbnail) {
      res["thumbnail"] = boost::any(*thumbnail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("thumbnail") != m.end() && !m["thumbnail"].empty()) {
      thumbnail = make_shared<string>(boost::any_cast<string>(m["thumbnail"]));
    }
  }


  virtual ~GrafanaWorkspaceIntegrationPreview() = default;
};
class GrafanaWorkspaceIntegration : public Darabonba::Model {
public:
  shared_ptr<long> datasourceAmount{};
  shared_ptr<string> integrationId{};
  shared_ptr<string> integrationName{};
  shared_ptr<vector<GrafanaWorkspaceIntegrationPreview>> previews{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> supportRegions{};

  GrafanaWorkspaceIntegration() {}

  explicit GrafanaWorkspaceIntegration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasourceAmount) {
      res["datasourceAmount"] = boost::any(*datasourceAmount);
    }
    if (integrationId) {
      res["integrationId"] = boost::any(*integrationId);
    }
    if (integrationName) {
      res["integrationName"] = boost::any(*integrationName);
    }
    if (previews) {
      vector<boost::any> temp1;
      for(auto item1:*previews){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["previews"] = boost::any(temp1);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (supportRegions) {
      res["supportRegions"] = boost::any(*supportRegions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("datasourceAmount") != m.end() && !m["datasourceAmount"].empty()) {
      datasourceAmount = make_shared<long>(boost::any_cast<long>(m["datasourceAmount"]));
    }
    if (m.find("integrationId") != m.end() && !m["integrationId"].empty()) {
      integrationId = make_shared<string>(boost::any_cast<string>(m["integrationId"]));
    }
    if (m.find("integrationName") != m.end() && !m["integrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["integrationName"]));
    }
    if (m.find("previews") != m.end() && !m["previews"].empty()) {
      if (typeid(vector<boost::any>) == m["previews"].type()) {
        vector<GrafanaWorkspaceIntegrationPreview> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["previews"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceIntegrationPreview model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        previews = make_shared<vector<GrafanaWorkspaceIntegrationPreview>>(expect1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("supportRegions") != m.end() && !m["supportRegions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportRegions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportRegions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportRegions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GrafanaWorkspaceIntegration() = default;
};
class GrafanaWorkspaceIntegrationDataSource : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> datasourceId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<string> datasourceUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> exploreUrl{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<string> folderUrl{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GrafanaWorkspaceIntegrationDataSource() {}

  explicit GrafanaWorkspaceIntegrationDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["clusterType"] = boost::any(*clusterType);
    }
    if (datasourceId) {
      res["datasourceId"] = boost::any(*datasourceId);
    }
    if (datasourceName) {
      res["datasourceName"] = boost::any(*datasourceName);
    }
    if (datasourceUrl) {
      res["datasourceUrl"] = boost::any(*datasourceUrl);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (exploreUrl) {
      res["exploreUrl"] = boost::any(*exploreUrl);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (folderUrl) {
      res["folderUrl"] = boost::any(*folderUrl);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusterType") != m.end() && !m["clusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["clusterType"]));
    }
    if (m.find("datasourceId") != m.end() && !m["datasourceId"].empty()) {
      datasourceId = make_shared<string>(boost::any_cast<string>(m["datasourceId"]));
    }
    if (m.find("datasourceName") != m.end() && !m["datasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["datasourceName"]));
    }
    if (m.find("datasourceUrl") != m.end() && !m["datasourceUrl"].empty()) {
      datasourceUrl = make_shared<string>(boost::any_cast<string>(m["datasourceUrl"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("exploreUrl") != m.end() && !m["exploreUrl"].empty()) {
      exploreUrl = make_shared<string>(boost::any_cast<string>(m["exploreUrl"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("folderUrl") != m.end() && !m["folderUrl"].empty()) {
      folderUrl = make_shared<string>(boost::any_cast<string>(m["folderUrl"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GrafanaWorkspaceIntegrationDataSource() = default;
};
class GrafanaWorkspaceIntegrationDetail : public Darabonba::Model {
public:
  shared_ptr<vector<GrafanaWorkspaceIntegrationDataSource>> dataSources{};
  shared_ptr<string> integrationId{};
  shared_ptr<string> status{};

  GrafanaWorkspaceIntegrationDetail() {}

  explicit GrafanaWorkspaceIntegrationDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSources) {
      vector<boost::any> temp1;
      for(auto item1:*dataSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dataSources"] = boost::any(temp1);
    }
    if (integrationId) {
      res["integrationId"] = boost::any(*integrationId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataSources") != m.end() && !m["dataSources"].empty()) {
      if (typeid(vector<boost::any>) == m["dataSources"].type()) {
        vector<GrafanaWorkspaceIntegrationDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dataSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceIntegrationDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSources = make_shared<vector<GrafanaWorkspaceIntegrationDataSource>>(expect1);
      }
    }
    if (m.find("integrationId") != m.end() && !m["integrationId"].empty()) {
      integrationId = make_shared<string>(boost::any_cast<string>(m["integrationId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~GrafanaWorkspaceIntegrationDetail() = default;
};
class GrafanaWorkspaceMoveProcess : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> msg{};
  shared_ptr<string> processName{};
  shared_ptr<string> processStatus{};
  shared_ptr<string> subType{};
  shared_ptr<string> userId{};

  GrafanaWorkspaceMoveProcess() {}

  explicit GrafanaWorkspaceMoveProcess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (processName) {
      res["processName"] = boost::any(*processName);
    }
    if (processStatus) {
      res["processStatus"] = boost::any(*processStatus);
    }
    if (subType) {
      res["subType"] = boost::any(*subType);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("processName") != m.end() && !m["processName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["processName"]));
    }
    if (m.find("processStatus") != m.end() && !m["processStatus"].empty()) {
      processStatus = make_shared<string>(boost::any_cast<string>(m["processStatus"]));
    }
    if (m.find("subType") != m.end() && !m["subType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["subType"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspaceMoveProcess() = default;
};
class GrafanaWorkspaceNews : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<string> description{};
  shared_ptr<string> image{};
  shared_ptr<string> link{};
  shared_ptr<string> title{};

  GrafanaWorkspaceNews() {}

  explicit GrafanaWorkspaceNews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (link) {
      res["link"] = boost::any(*link);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["date"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("link") != m.end() && !m["link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["link"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~GrafanaWorkspaceNews() = default;
};
class GrafanaWorkspaceOperateLog : public Darabonba::Model {
public:
  shared_ptr<double> date{};
  shared_ptr<string> detail{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> operatorId{};

  GrafanaWorkspaceOperateLog() {}

  explicit GrafanaWorkspaceOperateLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (detail) {
      res["detail"] = boost::any(*detail);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<double>(boost::any_cast<double>(m["date"]));
    }
    if (m.find("detail") != m.end() && !m["detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["detail"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
  }


  virtual ~GrafanaWorkspaceOperateLog() = default;
};
class GrafanaWorkspaceOrg : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GrafanaWorkspaceOrg() {}

  explicit GrafanaWorkspaceOrg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GrafanaWorkspaceOrg() = default;
};
class GrafanaWorkspaceTransDetail : public Darabonba::Model {
public:
  shared_ptr<long> dashboardAmount{};
  shared_ptr<long> dataSourceAmount{};
  shared_ptr<long> original{};
  shared_ptr<string> originalName{};
  shared_ptr<long> target{};
  shared_ptr<string> targetName{};

  GrafanaWorkspaceTransDetail() {}

  explicit GrafanaWorkspaceTransDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboardAmount) {
      res["dashboardAmount"] = boost::any(*dashboardAmount);
    }
    if (dataSourceAmount) {
      res["dataSourceAmount"] = boost::any(*dataSourceAmount);
    }
    if (original) {
      res["original"] = boost::any(*original);
    }
    if (originalName) {
      res["originalName"] = boost::any(*originalName);
    }
    if (target) {
      res["target"] = boost::any(*target);
    }
    if (targetName) {
      res["targetName"] = boost::any(*targetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dashboardAmount") != m.end() && !m["dashboardAmount"].empty()) {
      dashboardAmount = make_shared<long>(boost::any_cast<long>(m["dashboardAmount"]));
    }
    if (m.find("dataSourceAmount") != m.end() && !m["dataSourceAmount"].empty()) {
      dataSourceAmount = make_shared<long>(boost::any_cast<long>(m["dataSourceAmount"]));
    }
    if (m.find("original") != m.end() && !m["original"].empty()) {
      original = make_shared<long>(boost::any_cast<long>(m["original"]));
    }
    if (m.find("originalName") != m.end() && !m["originalName"].empty()) {
      originalName = make_shared<string>(boost::any_cast<string>(m["originalName"]));
    }
    if (m.find("target") != m.end() && !m["target"].empty()) {
      target = make_shared<long>(boost::any_cast<long>(m["target"]));
    }
    if (m.find("targetName") != m.end() && !m["targetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["targetName"]));
    }
  }


  virtual ~GrafanaWorkspaceTransDetail() = default;
};
class GrafanaWorkspaceTrans : public Darabonba::Model {
public:
  shared_ptr<string> apiUrl{};
  shared_ptr<string> authType{};
  shared_ptr<double> gmtCreate{};
  shared_ptr<double> gmtModified{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> msg{};
  shared_ptr<string> processStatus{};
  shared_ptr<vector<GrafanaWorkspaceTransDetail>> transDetails{};
  shared_ptr<string> userId{};

  GrafanaWorkspaceTrans() {}

  explicit GrafanaWorkspaceTrans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUrl) {
      res["apiUrl"] = boost::any(*apiUrl);
    }
    if (authType) {
      res["authType"] = boost::any(*authType);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (processStatus) {
      res["processStatus"] = boost::any(*processStatus);
    }
    if (transDetails) {
      vector<boost::any> temp1;
      for(auto item1:*transDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["transDetails"] = boost::any(temp1);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apiUrl") != m.end() && !m["apiUrl"].empty()) {
      apiUrl = make_shared<string>(boost::any_cast<string>(m["apiUrl"]));
    }
    if (m.find("authType") != m.end() && !m["authType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["authType"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<double>(boost::any_cast<double>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<double>(boost::any_cast<double>(m["gmtModified"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("processStatus") != m.end() && !m["processStatus"].empty()) {
      processStatus = make_shared<string>(boost::any_cast<string>(m["processStatus"]));
    }
    if (m.find("transDetails") != m.end() && !m["transDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["transDetails"].type()) {
        vector<GrafanaWorkspaceTransDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["transDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceTransDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transDetails = make_shared<vector<GrafanaWorkspaceTransDetail>>(expect1);
      }
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspaceTrans() = default;
};
class GrafanaWorkspaceUserCert : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GrafanaWorkspaceUserCert() {}

  explicit GrafanaWorkspaceUserCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GrafanaWorkspaceUserCert() = default;
};
class GrafanaWorkspaceVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> fcConfig{};
  shared_ptr<long> id{};
  shared_ptr<string> installMsg{};
  shared_ptr<string> installStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  GrafanaWorkspaceVpcConfig() {}

  explicit GrafanaWorkspaceVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcConfig) {
      res["fcConfig"] = boost::any(*fcConfig);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (installMsg) {
      res["installMsg"] = boost::any(*installMsg);
    }
    if (installStatus) {
      res["installStatus"] = boost::any(*installStatus);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["securityGroupId"] = boost::any(*securityGroupId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["vSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fcConfig") != m.end() && !m["fcConfig"].empty()) {
      fcConfig = make_shared<string>(boost::any_cast<string>(m["fcConfig"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("installMsg") != m.end() && !m["installMsg"].empty()) {
      installMsg = make_shared<string>(boost::any_cast<string>(m["installMsg"]));
    }
    if (m.find("installStatus") != m.end() && !m["installStatus"].empty()) {
      installStatus = make_shared<string>(boost::any_cast<string>(m["installStatus"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("securityGroupId") != m.end() && !m["securityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["securityGroupId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
    if (m.find("vSwitchId") != m.end() && !m["vSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["vSwitchId"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~GrafanaWorkspaceVpcConfig() = default;
};
class GrafanaWorkspaceVpcRegion : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};

  GrafanaWorkspaceVpcRegion() {}

  explicit GrafanaWorkspaceVpcRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["regionName"] = boost::any(*regionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("regionName") != m.end() && !m["regionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["regionName"]));
    }
  }


  virtual ~GrafanaWorkspaceVpcRegion() = default;
};
class GrafanaWorkspaceVpcRegionDetail : public Darabonba::Model {
public:
  shared_ptr<string> fcConfig{};
  shared_ptr<long> id{};
  shared_ptr<string> installStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vpcId{};

  GrafanaWorkspaceVpcRegionDetail() {}

  explicit GrafanaWorkspaceVpcRegionDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcConfig) {
      res["fcConfig"] = boost::any(*fcConfig);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (installStatus) {
      res["installStatus"] = boost::any(*installStatus);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["securityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["securityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["vSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchIds) {
      res["vSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fcConfig") != m.end() && !m["fcConfig"].empty()) {
      fcConfig = make_shared<string>(boost::any_cast<string>(m["fcConfig"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("installStatus") != m.end() && !m["installStatus"].empty()) {
      installStatus = make_shared<string>(boost::any_cast<string>(m["installStatus"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("securityGroupId") != m.end() && !m["securityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["securityGroupId"]));
    }
    if (m.find("securityGroupIds") != m.end() && !m["securityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["securityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["securityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
    if (m.find("vSwitchId") != m.end() && !m["vSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["vSwitchId"]));
    }
    if (m.find("vSwitchIds") != m.end() && !m["vSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~GrafanaWorkspaceVpcRegionDetail() = default;
};
class QueryDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> results{};

  QueryDataResponse() {}

  explicit QueryDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (results) {
      res["results"] = boost::any(*results);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("results") != m.end() && !m["results"].empty()) {
      results = make_shared<string>(boost::any_cast<string>(m["results"]));
    }
  }


  virtual ~QueryDataResponse() = default;
};
class DataBonreeSDKConfigModuleConfigDefaultConfigValue : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};

  DataBonreeSDKConfigModuleConfigDefaultConfigValue() {}

  explicit DataBonreeSDKConfigModuleConfigDefaultConfigValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
  }


  virtual ~DataBonreeSDKConfigModuleConfigDefaultConfigValue() = default;
};
class DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};

  DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue() {}

  explicit DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
  }


  virtual ~DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue() = default;
};
class DataBonreeSDKConfigModuleConfigVersionConfigsValue : public Darabonba::Model {
public:
  shared_ptr<bool> useCustom{};
  shared_ptr<map<string, DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue>> customConfig{};
  shared_ptr<string> description{};
  shared_ptr<long> updateTime{};

  DataBonreeSDKConfigModuleConfigVersionConfigsValue() {}

  explicit DataBonreeSDKConfigModuleConfigVersionConfigsValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (useCustom) {
      res["useCustom"] = boost::any(*useCustom);
    }
    if (customConfig) {
      map<string, boost::any> temp1;
      for(auto item1:*customConfig){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["customConfig"] = boost::any(temp1);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("useCustom") != m.end() && !m["useCustom"].empty()) {
      useCustom = make_shared<bool>(boost::any_cast<bool>(m["useCustom"]));
    }
    if (m.find("customConfig") != m.end() && !m["customConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["customConfig"].type()) {
        map<string, DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["customConfig"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        customConfig = make_shared<map<string, DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue>>(expect1);
      }
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
  }


  virtual ~DataBonreeSDKConfigModuleConfigVersionConfigsValue() = default;
};
class AddAliClusterIdsToPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterIds{};
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};

  AddAliClusterIdsToPrometheusGlobalViewRequest() {}

  explicit AddAliClusterIdsToPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      clusterIds = make_shared<string>(boost::any_cast<string>(m["ClusterIds"]));
    }
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddAliClusterIdsToPrometheusGlobalViewRequest() = default;
};
class AddAliClusterIdsToPrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  AddAliClusterIdsToPrometheusGlobalViewResponseBodyData() {}

  explicit AddAliClusterIdsToPrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddAliClusterIdsToPrometheusGlobalViewResponseBodyData() = default;
};
class AddAliClusterIdsToPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AddAliClusterIdsToPrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddAliClusterIdsToPrometheusGlobalViewResponseBody() {}

  explicit AddAliClusterIdsToPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddAliClusterIdsToPrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddAliClusterIdsToPrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddAliClusterIdsToPrometheusGlobalViewResponseBody() = default;
};
class AddAliClusterIdsToPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAliClusterIdsToPrometheusGlobalViewResponseBody> body{};

  AddAliClusterIdsToPrometheusGlobalViewResponse() {}

  explicit AddAliClusterIdsToPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAliClusterIdsToPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAliClusterIdsToPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~AddAliClusterIdsToPrometheusGlobalViewResponse() = default;
};
class AddGrafanaRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integration{};
  shared_ptr<string> regionId{};

  AddGrafanaRequest() {}

  explicit AddGrafanaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integration) {
      res["Integration"] = boost::any(*integration);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      integration = make_shared<string>(boost::any_cast<string>(m["Integration"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddGrafanaRequest() = default;
};
class AddGrafanaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  AddGrafanaResponseBody() {}

  explicit AddGrafanaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddGrafanaResponseBody() = default;
};
class AddGrafanaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGrafanaResponseBody> body{};

  AddGrafanaResponse() {}

  explicit AddGrafanaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGrafanaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGrafanaResponseBody>(model1);
      }
    }
  }


  virtual ~AddGrafanaResponse() = default;
};
class AddIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integration{};
  shared_ptr<string> regionId{};

  AddIntegrationRequest() {}

  explicit AddIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integration) {
      res["Integration"] = boost::any(*integration);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      integration = make_shared<string>(boost::any_cast<string>(m["Integration"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddIntegrationRequest() = default;
};
class AddIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddIntegrationResponseBody() {}

  explicit AddIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddIntegrationResponseBody() = default;
};
class AddIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddIntegrationResponseBody> body{};

  AddIntegrationResponse() {}

  explicit AddIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~AddIntegrationResponse() = default;
};
class AddPrometheusGlobalViewRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddPrometheusGlobalViewRequestTag() {}

  explicit AddPrometheusGlobalViewRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddPrometheusGlobalViewRequestTag() = default;
};
class AddPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusters{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<AddPrometheusGlobalViewRequestTag>> tag{};

  AddPrometheusGlobalViewRequest() {}

  explicit AddPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      res["Clusters"] = boost::any(*clusters);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      clusters = make_shared<string>(boost::any_cast<string>(m["Clusters"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddPrometheusGlobalViewRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddPrometheusGlobalViewRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddPrometheusGlobalViewRequestTag>>(expect1);
      }
    }
  }


  virtual ~AddPrometheusGlobalViewRequest() = default;
};
class AddPrometheusGlobalViewResponseBodyDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> failedInstances{};
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> regionId{};

  AddPrometheusGlobalViewResponseBodyDataInfo() {}

  explicit AddPrometheusGlobalViewResponseBodyDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedInstances) {
      res["FailedInstances"] = boost::any(*failedInstances);
    }
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedInstances") != m.end() && !m["FailedInstances"].empty()) {
      failedInstances = make_shared<string>(boost::any_cast<string>(m["FailedInstances"]));
    }
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddPrometheusGlobalViewResponseBodyDataInfo() = default;
};
class AddPrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<AddPrometheusGlobalViewResponseBodyDataInfo> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  AddPrometheusGlobalViewResponseBodyData() {}

  explicit AddPrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        AddPrometheusGlobalViewResponseBodyDataInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<AddPrometheusGlobalViewResponseBodyDataInfo>(model1);
      }
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddPrometheusGlobalViewResponseBodyData() = default;
};
class AddPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AddPrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPrometheusGlobalViewResponseBody() {}

  explicit AddPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddPrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddPrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPrometheusGlobalViewResponseBody() = default;
};
class AddPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPrometheusGlobalViewResponseBody> body{};

  AddPrometheusGlobalViewResponse() {}

  explicit AddPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~AddPrometheusGlobalViewResponse() = default;
};
class AddPrometheusGlobalViewByAliClusterIdsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterIds{};
  shared_ptr<string> groupName{};
  shared_ptr<string> productCode{};
  shared_ptr<string> regionId{};

  AddPrometheusGlobalViewByAliClusterIdsRequest() {}

  explicit AddPrometheusGlobalViewByAliClusterIdsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      clusterIds = make_shared<string>(boost::any_cast<string>(m["ClusterIds"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddPrometheusGlobalViewByAliClusterIdsRequest() = default;
};
class AddPrometheusGlobalViewByAliClusterIdsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  AddPrometheusGlobalViewByAliClusterIdsResponseBodyData() {}

  explicit AddPrometheusGlobalViewByAliClusterIdsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddPrometheusGlobalViewByAliClusterIdsResponseBodyData() = default;
};
class AddPrometheusGlobalViewByAliClusterIdsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AddPrometheusGlobalViewByAliClusterIdsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPrometheusGlobalViewByAliClusterIdsResponseBody() {}

  explicit AddPrometheusGlobalViewByAliClusterIdsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddPrometheusGlobalViewByAliClusterIdsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddPrometheusGlobalViewByAliClusterIdsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPrometheusGlobalViewByAliClusterIdsResponseBody() = default;
};
class AddPrometheusGlobalViewByAliClusterIdsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPrometheusGlobalViewByAliClusterIdsResponseBody> body{};

  AddPrometheusGlobalViewByAliClusterIdsResponse() {}

  explicit AddPrometheusGlobalViewByAliClusterIdsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPrometheusGlobalViewByAliClusterIdsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPrometheusGlobalViewByAliClusterIdsResponseBody>(model1);
      }
    }
  }


  virtual ~AddPrometheusGlobalViewByAliClusterIdsResponse() = default;
};
class AddPrometheusInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  AddPrometheusInstanceRequest() {}

  explicit AddPrometheusInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddPrometheusInstanceRequest() = default;
};
class AddPrometheusInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddPrometheusInstanceResponseBody() {}

  explicit AddPrometheusInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddPrometheusInstanceResponseBody() = default;
};
class AddPrometheusInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPrometheusInstanceResponseBody> body{};

  AddPrometheusInstanceResponse() {}

  explicit AddPrometheusInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPrometheusInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPrometheusInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~AddPrometheusInstanceResponse() = default;
};
class AddPrometheusIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> param{};
  shared_ptr<string> regionId{};

  AddPrometheusIntegrationRequest() {}

  explicit AddPrometheusIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddPrometheusIntegrationRequest() = default;
};
class AddPrometheusIntegrationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};

  AddPrometheusIntegrationResponseBodyData() {}

  explicit AddPrometheusIntegrationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~AddPrometheusIntegrationResponseBodyData() = default;
};
class AddPrometheusIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AddPrometheusIntegrationResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPrometheusIntegrationResponseBody() {}

  explicit AddPrometheusIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddPrometheusIntegrationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddPrometheusIntegrationResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPrometheusIntegrationResponseBody() = default;
};
class AddPrometheusIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPrometheusIntegrationResponseBody> body{};

  AddPrometheusIntegrationResponse() {}

  explicit AddPrometheusIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPrometheusIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPrometheusIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~AddPrometheusIntegrationResponse() = default;
};
class AddRecordingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleYaml{};

  AddRecordingRuleRequest() {}

  explicit AddRecordingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleYaml) {
      res["RuleYaml"] = boost::any(*ruleYaml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleYaml") != m.end() && !m["RuleYaml"].empty()) {
      ruleYaml = make_shared<string>(boost::any_cast<string>(m["RuleYaml"]));
    }
  }


  virtual ~AddRecordingRuleRequest() = default;
};
class AddRecordingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddRecordingRuleResponseBody() {}

  explicit AddRecordingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddRecordingRuleResponseBody() = default;
};
class AddRecordingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddRecordingRuleResponseBody> body{};

  AddRecordingRuleResponse() {}

  explicit AddRecordingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddRecordingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddRecordingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddRecordingRuleResponse() = default;
};
class AddTagToFlinkClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> flinkWorkSpaceId{};
  shared_ptr<string> flinkWorkSpaceName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> targetUserId{};

  AddTagToFlinkClusterRequest() {}

  explicit AddTagToFlinkClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (flinkWorkSpaceId) {
      res["FlinkWorkSpaceId"] = boost::any(*flinkWorkSpaceId);
    }
    if (flinkWorkSpaceName) {
      res["FlinkWorkSpaceName"] = boost::any(*flinkWorkSpaceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("FlinkWorkSpaceId") != m.end() && !m["FlinkWorkSpaceId"].empty()) {
      flinkWorkSpaceId = make_shared<string>(boost::any_cast<string>(m["FlinkWorkSpaceId"]));
    }
    if (m.find("FlinkWorkSpaceName") != m.end() && !m["FlinkWorkSpaceName"].empty()) {
      flinkWorkSpaceName = make_shared<string>(boost::any_cast<string>(m["FlinkWorkSpaceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
  }


  virtual ~AddTagToFlinkClusterRequest() = default;
};
class AddTagToFlinkClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddTagToFlinkClusterResponseBody() {}

  explicit AddTagToFlinkClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddTagToFlinkClusterResponseBody() = default;
};
class AddTagToFlinkClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTagToFlinkClusterResponseBody> body{};

  AddTagToFlinkClusterResponse() {}

  explicit AddTagToFlinkClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTagToFlinkClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTagToFlinkClusterResponseBody>(model1);
      }
    }
  }


  virtual ~AddTagToFlinkClusterResponse() = default;
};
class AppendInstancesToPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusters{};
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};

  AppendInstancesToPrometheusGlobalViewRequest() {}

  explicit AppendInstancesToPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      res["Clusters"] = boost::any(*clusters);
    }
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      clusters = make_shared<string>(boost::any_cast<string>(m["Clusters"]));
    }
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AppendInstancesToPrometheusGlobalViewRequest() = default;
};
class AppendInstancesToPrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  AppendInstancesToPrometheusGlobalViewResponseBodyData() {}

  explicit AppendInstancesToPrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AppendInstancesToPrometheusGlobalViewResponseBodyData() = default;
};
class AppendInstancesToPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AppendInstancesToPrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AppendInstancesToPrometheusGlobalViewResponseBody() {}

  explicit AppendInstancesToPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AppendInstancesToPrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AppendInstancesToPrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AppendInstancesToPrometheusGlobalViewResponseBody() = default;
};
class AppendInstancesToPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AppendInstancesToPrometheusGlobalViewResponseBody> body{};

  AppendInstancesToPrometheusGlobalViewResponse() {}

  explicit AppendInstancesToPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AppendInstancesToPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AppendInstancesToPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~AppendInstancesToPrometheusGlobalViewResponse() = default;
};
class ApplyScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<map<string, boost::any>> config{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scenario{};
  shared_ptr<string> sign{};
  shared_ptr<bool> snDump{};
  shared_ptr<bool> snForce{};
  shared_ptr<bool> snStat{};
  shared_ptr<bool> snTransfer{};
  shared_ptr<bool> updateOption{};

  ApplyScenarioRequest() {}

  explicit ApplyScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    if (snDump) {
      res["SnDump"] = boost::any(*snDump);
    }
    if (snForce) {
      res["SnForce"] = boost::any(*snForce);
    }
    if (snStat) {
      res["SnStat"] = boost::any(*snStat);
    }
    if (snTransfer) {
      res["SnTransfer"] = boost::any(*snTransfer);
    }
    if (updateOption) {
      res["UpdateOption"] = boost::any(*updateOption);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Config"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      config = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
    if (m.find("SnDump") != m.end() && !m["SnDump"].empty()) {
      snDump = make_shared<bool>(boost::any_cast<bool>(m["SnDump"]));
    }
    if (m.find("SnForce") != m.end() && !m["SnForce"].empty()) {
      snForce = make_shared<bool>(boost::any_cast<bool>(m["SnForce"]));
    }
    if (m.find("SnStat") != m.end() && !m["SnStat"].empty()) {
      snStat = make_shared<bool>(boost::any_cast<bool>(m["SnStat"]));
    }
    if (m.find("SnTransfer") != m.end() && !m["SnTransfer"].empty()) {
      snTransfer = make_shared<bool>(boost::any_cast<bool>(m["SnTransfer"]));
    }
    if (m.find("UpdateOption") != m.end() && !m["UpdateOption"].empty()) {
      updateOption = make_shared<bool>(boost::any_cast<bool>(m["UpdateOption"]));
    }
  }


  virtual ~ApplyScenarioRequest() = default;
};
class ApplyScenarioShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> configShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scenario{};
  shared_ptr<string> sign{};
  shared_ptr<bool> snDump{};
  shared_ptr<bool> snForce{};
  shared_ptr<bool> snStat{};
  shared_ptr<bool> snTransfer{};
  shared_ptr<bool> updateOption{};

  ApplyScenarioShrinkRequest() {}

  explicit ApplyScenarioShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (configShrink) {
      res["Config"] = boost::any(*configShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    if (snDump) {
      res["SnDump"] = boost::any(*snDump);
    }
    if (snForce) {
      res["SnForce"] = boost::any(*snForce);
    }
    if (snStat) {
      res["SnStat"] = boost::any(*snStat);
    }
    if (snTransfer) {
      res["SnTransfer"] = boost::any(*snTransfer);
    }
    if (updateOption) {
      res["UpdateOption"] = boost::any(*updateOption);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      configShrink = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
    if (m.find("SnDump") != m.end() && !m["SnDump"].empty()) {
      snDump = make_shared<bool>(boost::any_cast<bool>(m["SnDump"]));
    }
    if (m.find("SnForce") != m.end() && !m["SnForce"].empty()) {
      snForce = make_shared<bool>(boost::any_cast<bool>(m["SnForce"]));
    }
    if (m.find("SnStat") != m.end() && !m["SnStat"].empty()) {
      snStat = make_shared<bool>(boost::any_cast<bool>(m["SnStat"]));
    }
    if (m.find("SnTransfer") != m.end() && !m["SnTransfer"].empty()) {
      snTransfer = make_shared<bool>(boost::any_cast<bool>(m["SnTransfer"]));
    }
    if (m.find("UpdateOption") != m.end() && !m["UpdateOption"].empty()) {
      updateOption = make_shared<bool>(boost::any_cast<bool>(m["UpdateOption"]));
    }
  }


  virtual ~ApplyScenarioShrinkRequest() = default;
};
class ApplyScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ApplyScenarioResponseBody() {}

  explicit ApplyScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ApplyScenarioResponseBody() = default;
};
class ApplyScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyScenarioResponseBody> body{};

  ApplyScenarioResponse() {}

  explicit ApplyScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyScenarioResponse() = default;
};
class BindPrometheusGrafanaInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> grafanaInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  BindPrometheusGrafanaInstanceRequest() {}

  explicit BindPrometheusGrafanaInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (grafanaInstanceId) {
      res["GrafanaInstanceId"] = boost::any(*grafanaInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("GrafanaInstanceId") != m.end() && !m["GrafanaInstanceId"].empty()) {
      grafanaInstanceId = make_shared<string>(boost::any_cast<string>(m["GrafanaInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~BindPrometheusGrafanaInstanceRequest() = default;
};
class BindPrometheusGrafanaInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  BindPrometheusGrafanaInstanceResponseBody() {}

  explicit BindPrometheusGrafanaInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindPrometheusGrafanaInstanceResponseBody() = default;
};
class BindPrometheusGrafanaInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindPrometheusGrafanaInstanceResponseBody> body{};

  BindPrometheusGrafanaInstanceResponse() {}

  explicit BindPrometheusGrafanaInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindPrometheusGrafanaInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindPrometheusGrafanaInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindPrometheusGrafanaInstanceResponse() = default;
};
class BlockAlarmNotificationRequest : public Darabonba::Model {
public:
  shared_ptr<long> alarmId{};
  shared_ptr<long> handlerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> timeout{};

  BlockAlarmNotificationRequest() {}

  explicit BlockAlarmNotificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmId) {
      res["AlarmId"] = boost::any(*alarmId);
    }
    if (handlerId) {
      res["HandlerId"] = boost::any(*handlerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmId") != m.end() && !m["AlarmId"].empty()) {
      alarmId = make_shared<long>(boost::any_cast<long>(m["AlarmId"]));
    }
    if (m.find("HandlerId") != m.end() && !m["HandlerId"].empty()) {
      handlerId = make_shared<long>(boost::any_cast<long>(m["HandlerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~BlockAlarmNotificationRequest() = default;
};
class BlockAlarmNotificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  BlockAlarmNotificationResponseBody() {}

  explicit BlockAlarmNotificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BlockAlarmNotificationResponseBody() = default;
};
class BlockAlarmNotificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BlockAlarmNotificationResponseBody> body{};

  BlockAlarmNotificationResponse() {}

  explicit BlockAlarmNotificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BlockAlarmNotificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BlockAlarmNotificationResponseBody>(model1);
      }
    }
  }


  virtual ~BlockAlarmNotificationResponse() = default;
};
class ChangeAlarmSeverityRequest : public Darabonba::Model {
public:
  shared_ptr<long> alarmId{};
  shared_ptr<long> handlerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> severity{};

  ChangeAlarmSeverityRequest() {}

  explicit ChangeAlarmSeverityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmId) {
      res["AlarmId"] = boost::any(*alarmId);
    }
    if (handlerId) {
      res["HandlerId"] = boost::any(*handlerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmId") != m.end() && !m["AlarmId"].empty()) {
      alarmId = make_shared<long>(boost::any_cast<long>(m["AlarmId"]));
    }
    if (m.find("HandlerId") != m.end() && !m["HandlerId"].empty()) {
      handlerId = make_shared<long>(boost::any_cast<long>(m["HandlerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
  }


  virtual ~ChangeAlarmSeverityRequest() = default;
};
class ChangeAlarmSeverityResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  ChangeAlarmSeverityResponseBody() {}

  explicit ChangeAlarmSeverityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ChangeAlarmSeverityResponseBody() = default;
};
class ChangeAlarmSeverityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeAlarmSeverityResponseBody> body{};

  ChangeAlarmSeverityResponse() {}

  explicit ChangeAlarmSeverityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeAlarmSeverityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeAlarmSeverityResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeAlarmSeverityResponse() = default;
};
class ChangeResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  ChangeResourceGroupRequest() {}

  explicit ChangeResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ChangeResourceGroupRequest() = default;
};
class ChangeResourceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};

  ChangeResourceGroupResponseBodyData() {}

  explicit ChangeResourceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ChangeResourceGroupResponseBodyData() = default;
};
class ChangeResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ChangeResourceGroupResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ChangeResourceGroupResponseBody() {}

  explicit ChangeResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ChangeResourceGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ChangeResourceGroupResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeResourceGroupResponseBody() = default;
};
class ChangeResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeResourceGroupResponseBody> body{};

  ChangeResourceGroupResponse() {}

  explicit ChangeResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeResourceGroupResponse() = default;
};
class CheckCommercialStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> service{};

  CheckCommercialStatusRequest() {}

  explicit CheckCommercialStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["Service"]));
    }
  }


  virtual ~CheckCommercialStatusRequest() = default;
};
class CheckCommercialStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  CheckCommercialStatusResponseBody() {}

  explicit CheckCommercialStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckCommercialStatusResponseBody() = default;
};
class CheckCommercialStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckCommercialStatusResponseBody> body{};

  CheckCommercialStatusResponse() {}

  explicit CheckCommercialStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckCommercialStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckCommercialStatusResponseBody>(model1);
      }
    }
  }


  virtual ~CheckCommercialStatusResponse() = default;
};
class CheckServiceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> svcCode{};

  CheckServiceStatusRequest() {}

  explicit CheckServiceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (svcCode) {
      res["SvcCode"] = boost::any(*svcCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SvcCode") != m.end() && !m["SvcCode"].empty()) {
      svcCode = make_shared<string>(boost::any_cast<string>(m["SvcCode"]));
    }
  }


  virtual ~CheckServiceStatusRequest() = default;
};
class CheckServiceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  CheckServiceStatusResponseBody() {}

  explicit CheckServiceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckServiceStatusResponseBody() = default;
};
class CheckServiceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckServiceStatusResponseBody> body{};

  CheckServiceStatusResponse() {}

  explicit CheckServiceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckServiceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckServiceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~CheckServiceStatusResponse() = default;
};
class ClaimAlarmRequest : public Darabonba::Model {
public:
  shared_ptr<long> alarmId{};
  shared_ptr<long> handlerId{};
  shared_ptr<string> regionId{};

  ClaimAlarmRequest() {}

  explicit ClaimAlarmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmId) {
      res["AlarmId"] = boost::any(*alarmId);
    }
    if (handlerId) {
      res["HandlerId"] = boost::any(*handlerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmId") != m.end() && !m["AlarmId"].empty()) {
      alarmId = make_shared<long>(boost::any_cast<long>(m["AlarmId"]));
    }
    if (m.find("HandlerId") != m.end() && !m["HandlerId"].empty()) {
      handlerId = make_shared<long>(boost::any_cast<long>(m["HandlerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ClaimAlarmRequest() = default;
};
class ClaimAlarmResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  ClaimAlarmResponseBody() {}

  explicit ClaimAlarmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ClaimAlarmResponseBody() = default;
};
class ClaimAlarmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClaimAlarmResponseBody> body{};

  ClaimAlarmResponse() {}

  explicit ClaimAlarmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClaimAlarmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClaimAlarmResponseBody>(model1);
      }
    }
  }


  virtual ~ClaimAlarmResponse() = default;
};
class CloseAlarmRequest : public Darabonba::Model {
public:
  shared_ptr<long> alarmId{};
  shared_ptr<long> handlerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> solution{};

  CloseAlarmRequest() {}

  explicit CloseAlarmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmId) {
      res["AlarmId"] = boost::any(*alarmId);
    }
    if (handlerId) {
      res["HandlerId"] = boost::any(*handlerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (solution) {
      res["Solution"] = boost::any(*solution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmId") != m.end() && !m["AlarmId"].empty()) {
      alarmId = make_shared<long>(boost::any_cast<long>(m["AlarmId"]));
    }
    if (m.find("HandlerId") != m.end() && !m["HandlerId"].empty()) {
      handlerId = make_shared<long>(boost::any_cast<long>(m["HandlerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Solution") != m.end() && !m["Solution"].empty()) {
      solution = make_shared<string>(boost::any_cast<string>(m["Solution"]));
    }
  }


  virtual ~CloseAlarmRequest() = default;
};
class CloseAlarmResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  CloseAlarmResponseBody() {}

  explicit CloseAlarmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CloseAlarmResponseBody() = default;
};
class CloseAlarmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseAlarmResponseBody> body{};

  CloseAlarmResponse() {}

  explicit CloseAlarmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseAlarmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseAlarmResponseBody>(model1);
      }
    }
  }


  virtual ~CloseAlarmResponse() = default;
};
class ConfigAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};
  shared_ptr<string> enable{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  ConfigAppRequest() {}

  explicit ConfigAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ConfigAppRequest() = default;
};
class ConfigAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  ConfigAppResponseBody() {}

  explicit ConfigAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigAppResponseBody() = default;
};
class ConfigAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigAppResponseBody> body{};

  ConfigAppResponse() {}

  explicit ConfigAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigAppResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigAppResponse() = default;
};
class CreateAlertContactRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactName{};
  shared_ptr<string> dingRobotWebhookUrl{};
  shared_ptr<string> email{};
  shared_ptr<string> phoneNum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> systemNoc{};

  CreateAlertContactRequest() {}

  explicit CreateAlertContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (dingRobotWebhookUrl) {
      res["DingRobotWebhookUrl"] = boost::any(*dingRobotWebhookUrl);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (systemNoc) {
      res["SystemNoc"] = boost::any(*systemNoc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("DingRobotWebhookUrl") != m.end() && !m["DingRobotWebhookUrl"].empty()) {
      dingRobotWebhookUrl = make_shared<string>(boost::any_cast<string>(m["DingRobotWebhookUrl"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SystemNoc") != m.end() && !m["SystemNoc"].empty()) {
      systemNoc = make_shared<bool>(boost::any_cast<bool>(m["SystemNoc"]));
    }
  }


  virtual ~CreateAlertContactRequest() = default;
};
class CreateAlertContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> requestId{};

  CreateAlertContactResponseBody() {}

  explicit CreateAlertContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAlertContactResponseBody() = default;
};
class CreateAlertContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAlertContactResponseBody> body{};

  CreateAlertContactResponse() {}

  explicit CreateAlertContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAlertContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAlertContactResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAlertContactResponse() = default;
};
class CreateAlertContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> contactIds{};
  shared_ptr<string> regionId{};

  CreateAlertContactGroupRequest() {}

  explicit CreateAlertContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateAlertContactGroupRequest() = default;
};
class CreateAlertContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupId{};
  shared_ptr<string> requestId{};

  CreateAlertContactGroupResponseBody() {}

  explicit CreateAlertContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<string>(boost::any_cast<string>(m["ContactGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAlertContactGroupResponseBody() = default;
};
class CreateAlertContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAlertContactGroupResponseBody> body{};

  CreateAlertContactGroupResponse() {}

  explicit CreateAlertContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAlertContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAlertContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAlertContactGroupResponse() = default;
};
class CreateDispatchRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> dispatchRule{};
  shared_ptr<string> regionId{};

  CreateDispatchRuleRequest() {}

  explicit CreateDispatchRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchRule) {
      res["DispatchRule"] = boost::any(*dispatchRule);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchRule") != m.end() && !m["DispatchRule"].empty()) {
      dispatchRule = make_shared<string>(boost::any_cast<string>(m["DispatchRule"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateDispatchRuleRequest() = default;
};
class CreateDispatchRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> requestId{};

  CreateDispatchRuleResponseBody() {}

  explicit CreateDispatchRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDispatchRuleResponseBody() = default;
};
class CreateDispatchRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDispatchRuleResponseBody> body{};

  CreateDispatchRuleResponse() {}

  explicit CreateDispatchRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDispatchRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDispatchRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDispatchRuleResponse() = default;
};
class CreateEnvCustomJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> customJobName{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  CreateEnvCustomJobRequest() {}

  explicit CreateEnvCustomJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (customJobName) {
      res["CustomJobName"] = boost::any(*customJobName);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("CustomJobName") != m.end() && !m["CustomJobName"].empty()) {
      customJobName = make_shared<string>(boost::any_cast<string>(m["CustomJobName"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateEnvCustomJobRequest() = default;
};
class CreateEnvCustomJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateEnvCustomJobResponseBody() {}

  explicit CreateEnvCustomJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEnvCustomJobResponseBody() = default;
};
class CreateEnvCustomJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEnvCustomJobResponseBody> body{};

  CreateEnvCustomJobResponse() {}

  explicit CreateEnvCustomJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEnvCustomJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEnvCustomJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEnvCustomJobResponse() = default;
};
class CreateEnvPodMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> configYaml{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  CreateEnvPodMonitorRequest() {}

  explicit CreateEnvPodMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateEnvPodMonitorRequest() = default;
};
class CreateEnvPodMonitorResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> matchedMsg{};
  shared_ptr<string> matchedTargetCount{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> podMonitorName{};

  CreateEnvPodMonitorResponseBodyData() {}

  explicit CreateEnvPodMonitorResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchedMsg) {
      res["MatchedMsg"] = boost::any(*matchedMsg);
    }
    if (matchedTargetCount) {
      res["MatchedTargetCount"] = boost::any(*matchedTargetCount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (podMonitorName) {
      res["PodMonitorName"] = boost::any(*podMonitorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchedMsg") != m.end() && !m["MatchedMsg"].empty()) {
      matchedMsg = make_shared<string>(boost::any_cast<string>(m["MatchedMsg"]));
    }
    if (m.find("MatchedTargetCount") != m.end() && !m["MatchedTargetCount"].empty()) {
      matchedTargetCount = make_shared<string>(boost::any_cast<string>(m["MatchedTargetCount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PodMonitorName") != m.end() && !m["PodMonitorName"].empty()) {
      podMonitorName = make_shared<string>(boost::any_cast<string>(m["PodMonitorName"]));
    }
  }


  virtual ~CreateEnvPodMonitorResponseBodyData() = default;
};
class CreateEnvPodMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CreateEnvPodMonitorResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateEnvPodMonitorResponseBody() {}

  explicit CreateEnvPodMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateEnvPodMonitorResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateEnvPodMonitorResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEnvPodMonitorResponseBody() = default;
};
class CreateEnvPodMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEnvPodMonitorResponseBody> body{};

  CreateEnvPodMonitorResponse() {}

  explicit CreateEnvPodMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEnvPodMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEnvPodMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEnvPodMonitorResponse() = default;
};
class CreateEnvServiceMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> configYaml{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  CreateEnvServiceMonitorRequest() {}

  explicit CreateEnvServiceMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateEnvServiceMonitorRequest() = default;
};
class CreateEnvServiceMonitorResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> matchedMsg{};
  shared_ptr<long> matchedTargetCount{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> serviceMonitorName{};

  CreateEnvServiceMonitorResponseBodyData() {}

  explicit CreateEnvServiceMonitorResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchedMsg) {
      res["MatchedMsg"] = boost::any(*matchedMsg);
    }
    if (matchedTargetCount) {
      res["MatchedTargetCount"] = boost::any(*matchedTargetCount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (serviceMonitorName) {
      res["ServiceMonitorName"] = boost::any(*serviceMonitorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchedMsg") != m.end() && !m["MatchedMsg"].empty()) {
      matchedMsg = make_shared<string>(boost::any_cast<string>(m["MatchedMsg"]));
    }
    if (m.find("MatchedTargetCount") != m.end() && !m["MatchedTargetCount"].empty()) {
      matchedTargetCount = make_shared<long>(boost::any_cast<long>(m["MatchedTargetCount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ServiceMonitorName") != m.end() && !m["ServiceMonitorName"].empty()) {
      serviceMonitorName = make_shared<string>(boost::any_cast<string>(m["ServiceMonitorName"]));
    }
  }


  virtual ~CreateEnvServiceMonitorResponseBodyData() = default;
};
class CreateEnvServiceMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CreateEnvServiceMonitorResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateEnvServiceMonitorResponseBody() {}

  explicit CreateEnvServiceMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateEnvServiceMonitorResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateEnvServiceMonitorResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEnvServiceMonitorResponseBody() = default;
};
class CreateEnvServiceMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEnvServiceMonitorResponseBody> body{};

  CreateEnvServiceMonitorResponse() {}

  explicit CreateEnvServiceMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEnvServiceMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEnvServiceMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEnvServiceMonitorResponse() = default;
};
class CreateEnvironmentRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateEnvironmentRequestTags() {}

  explicit CreateEnvironmentRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateEnvironmentRequestTags() = default;
};
class CreateEnvironmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> bindResourceId{};
  shared_ptr<string> environmentName{};
  shared_ptr<string> environmentSubType{};
  shared_ptr<string> environmentType{};
  shared_ptr<string> feePackage{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<bool> initEnvironment{};
  shared_ptr<string> managedType{};
  shared_ptr<string> prometheusInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateEnvironmentRequestTags>> tags{};

  CreateEnvironmentRequest() {}

  explicit CreateEnvironmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (bindResourceId) {
      res["BindResourceId"] = boost::any(*bindResourceId);
    }
    if (environmentName) {
      res["EnvironmentName"] = boost::any(*environmentName);
    }
    if (environmentSubType) {
      res["EnvironmentSubType"] = boost::any(*environmentSubType);
    }
    if (environmentType) {
      res["EnvironmentType"] = boost::any(*environmentType);
    }
    if (feePackage) {
      res["FeePackage"] = boost::any(*feePackage);
    }
    if (grafanaWorkspaceId) {
      res["GrafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (initEnvironment) {
      res["InitEnvironment"] = boost::any(*initEnvironment);
    }
    if (managedType) {
      res["ManagedType"] = boost::any(*managedType);
    }
    if (prometheusInstanceId) {
      res["PrometheusInstanceId"] = boost::any(*prometheusInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("BindResourceId") != m.end() && !m["BindResourceId"].empty()) {
      bindResourceId = make_shared<string>(boost::any_cast<string>(m["BindResourceId"]));
    }
    if (m.find("EnvironmentName") != m.end() && !m["EnvironmentName"].empty()) {
      environmentName = make_shared<string>(boost::any_cast<string>(m["EnvironmentName"]));
    }
    if (m.find("EnvironmentSubType") != m.end() && !m["EnvironmentSubType"].empty()) {
      environmentSubType = make_shared<string>(boost::any_cast<string>(m["EnvironmentSubType"]));
    }
    if (m.find("EnvironmentType") != m.end() && !m["EnvironmentType"].empty()) {
      environmentType = make_shared<string>(boost::any_cast<string>(m["EnvironmentType"]));
    }
    if (m.find("FeePackage") != m.end() && !m["FeePackage"].empty()) {
      feePackage = make_shared<string>(boost::any_cast<string>(m["FeePackage"]));
    }
    if (m.find("GrafanaWorkspaceId") != m.end() && !m["GrafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceId"]));
    }
    if (m.find("InitEnvironment") != m.end() && !m["InitEnvironment"].empty()) {
      initEnvironment = make_shared<bool>(boost::any_cast<bool>(m["InitEnvironment"]));
    }
    if (m.find("ManagedType") != m.end() && !m["ManagedType"].empty()) {
      managedType = make_shared<string>(boost::any_cast<string>(m["ManagedType"]));
    }
    if (m.find("PrometheusInstanceId") != m.end() && !m["PrometheusInstanceId"].empty()) {
      prometheusInstanceId = make_shared<string>(boost::any_cast<string>(m["PrometheusInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateEnvironmentRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEnvironmentRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateEnvironmentRequestTags>>(expect1);
      }
    }
  }


  virtual ~CreateEnvironmentRequest() = default;
};
class CreateEnvironmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateEnvironmentResponseBody() {}

  explicit CreateEnvironmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEnvironmentResponseBody() = default;
};
class CreateEnvironmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEnvironmentResponseBody> body{};

  CreateEnvironmentResponse() {}

  explicit CreateEnvironmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEnvironmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEnvironmentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEnvironmentResponse() = default;
};
class CreateGrafanaWorkspaceRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateGrafanaWorkspaceRequestTags() {}

  explicit CreateGrafanaWorkspaceRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateGrafanaWorkspaceRequestTags() = default;
};
class CreateGrafanaWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> description{};
  shared_ptr<string> grafanaVersion{};
  shared_ptr<string> grafanaWorkspaceEdition{};
  shared_ptr<string> grafanaWorkspaceName{};
  shared_ptr<string> password{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateGrafanaWorkspaceRequestTags>> tags{};

  CreateGrafanaWorkspaceRequest() {}

  explicit CreateGrafanaWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (grafanaVersion) {
      res["GrafanaVersion"] = boost::any(*grafanaVersion);
    }
    if (grafanaWorkspaceEdition) {
      res["GrafanaWorkspaceEdition"] = boost::any(*grafanaWorkspaceEdition);
    }
    if (grafanaWorkspaceName) {
      res["GrafanaWorkspaceName"] = boost::any(*grafanaWorkspaceName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GrafanaVersion") != m.end() && !m["GrafanaVersion"].empty()) {
      grafanaVersion = make_shared<string>(boost::any_cast<string>(m["GrafanaVersion"]));
    }
    if (m.find("GrafanaWorkspaceEdition") != m.end() && !m["GrafanaWorkspaceEdition"].empty()) {
      grafanaWorkspaceEdition = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceEdition"]));
    }
    if (m.find("GrafanaWorkspaceName") != m.end() && !m["GrafanaWorkspaceName"].empty()) {
      grafanaWorkspaceName = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateGrafanaWorkspaceRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateGrafanaWorkspaceRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateGrafanaWorkspaceRequestTags>>(expect1);
      }
    }
  }


  virtual ~CreateGrafanaWorkspaceRequest() = default;
};
class CreateGrafanaWorkspaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> description{};
  shared_ptr<string> grafanaVersion{};
  shared_ptr<string> grafanaWorkspaceEdition{};
  shared_ptr<string> grafanaWorkspaceName{};
  shared_ptr<string> password{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> tagsShrink{};

  CreateGrafanaWorkspaceShrinkRequest() {}

  explicit CreateGrafanaWorkspaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (grafanaVersion) {
      res["GrafanaVersion"] = boost::any(*grafanaVersion);
    }
    if (grafanaWorkspaceEdition) {
      res["GrafanaWorkspaceEdition"] = boost::any(*grafanaWorkspaceEdition);
    }
    if (grafanaWorkspaceName) {
      res["GrafanaWorkspaceName"] = boost::any(*grafanaWorkspaceName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GrafanaVersion") != m.end() && !m["GrafanaVersion"].empty()) {
      grafanaVersion = make_shared<string>(boost::any_cast<string>(m["GrafanaVersion"]));
    }
    if (m.find("GrafanaWorkspaceEdition") != m.end() && !m["GrafanaWorkspaceEdition"].empty()) {
      grafanaWorkspaceEdition = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceEdition"]));
    }
    if (m.find("GrafanaWorkspaceName") != m.end() && !m["GrafanaWorkspaceName"].empty()) {
      grafanaWorkspaceName = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~CreateGrafanaWorkspaceShrinkRequest() = default;
};
class CreateGrafanaWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GrafanaWorkspace> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateGrafanaWorkspaceResponseBody() {}

  explicit CreateGrafanaWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GrafanaWorkspace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GrafanaWorkspace>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CreateGrafanaWorkspaceResponseBody() = default;
};
class CreateGrafanaWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateGrafanaWorkspaceResponseBody> body{};

  CreateGrafanaWorkspaceResponse() {}

  explicit CreateGrafanaWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateGrafanaWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateGrafanaWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateGrafanaWorkspaceResponse() = default;
};
class CreateIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRecover{};
  shared_ptr<string> description{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<long> recoverTime{};
  shared_ptr<string> regionId{};

  CreateIntegrationRequest() {}

  explicit CreateIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRecover) {
      res["AutoRecover"] = boost::any(*autoRecover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRecover") != m.end() && !m["AutoRecover"].empty()) {
      autoRecover = make_shared<bool>(boost::any_cast<bool>(m["AutoRecover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateIntegrationRequest() = default;
};
class CreateIntegrationResponseBodyIntegration : public Darabonba::Model {
public:
  shared_ptr<bool> autoRecover{};
  shared_ptr<string> description{};
  shared_ptr<long> integrationId{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<long> recoverTime{};

  CreateIntegrationResponseBodyIntegration() {}

  explicit CreateIntegrationResponseBodyIntegration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRecover) {
      res["AutoRecover"] = boost::any(*autoRecover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRecover") != m.end() && !m["AutoRecover"].empty()) {
      autoRecover = make_shared<bool>(boost::any_cast<bool>(m["AutoRecover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
  }


  virtual ~CreateIntegrationResponseBodyIntegration() = default;
};
class CreateIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateIntegrationResponseBodyIntegration> integration{};
  shared_ptr<string> requestId{};

  CreateIntegrationResponseBody() {}

  explicit CreateIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integration) {
      res["Integration"] = integration ? boost::any(integration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      if (typeid(map<string, boost::any>) == m["Integration"].type()) {
        CreateIntegrationResponseBodyIntegration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Integration"]));
        integration = make_shared<CreateIntegrationResponseBodyIntegration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIntegrationResponseBody() = default;
};
class CreateIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIntegrationResponseBody> body{};

  CreateIntegrationResponse() {}

  explicit CreateIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIntegrationResponse() = default;
};
class CreateOrUpdateAlertRuleRequestMarkTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleRequestMarkTags() {}

  explicit CreateOrUpdateAlertRuleRequestMarkTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleRequestMarkTags() = default;
};
class CreateOrUpdateAlertRuleRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleRequestTags() {}

  explicit CreateOrUpdateAlertRuleRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleRequestTags() = default;
};
class CreateOrUpdateAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertCheckType{};
  shared_ptr<long> alertGroup{};
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<string> alertPiplines{};
  shared_ptr<string> alertRuleContent{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> alertType{};
  shared_ptr<string> annotations{};
  shared_ptr<bool> autoAddNewApplication{};
  shared_ptr<string> autoAddTargetConfig{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> dataConfig{};
  shared_ptr<long> duration{};
  shared_ptr<string> filters{};
  shared_ptr<string> labels{};
  shared_ptr<string> level{};
  shared_ptr<vector<CreateOrUpdateAlertRuleRequestMarkTags>> markTags{};
  shared_ptr<string> message{};
  shared_ptr<string> metricsKey{};
  shared_ptr<string> metricsType{};
  shared_ptr<string> notice{};
  shared_ptr<string> notifyMode{};
  shared_ptr<string> notifyStrategy{};
  shared_ptr<string> pids{};
  shared_ptr<string> product{};
  shared_ptr<string> promQL{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateOrUpdateAlertRuleRequestTags>> tags{};

  CreateOrUpdateAlertRuleRequest() {}

  explicit CreateOrUpdateAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertCheckType) {
      res["AlertCheckType"] = boost::any(*alertCheckType);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertPiplines) {
      res["AlertPiplines"] = boost::any(*alertPiplines);
    }
    if (alertRuleContent) {
      res["AlertRuleContent"] = boost::any(*alertRuleContent);
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (autoAddNewApplication) {
      res["AutoAddNewApplication"] = boost::any(*autoAddNewApplication);
    }
    if (autoAddTargetConfig) {
      res["AutoAddTargetConfig"] = boost::any(*autoAddTargetConfig);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dataConfig) {
      res["DataConfig"] = boost::any(*dataConfig);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (filters) {
      res["Filters"] = boost::any(*filters);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (markTags) {
      vector<boost::any> temp1;
      for(auto item1:*markTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MarkTags"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (metricsKey) {
      res["MetricsKey"] = boost::any(*metricsKey);
    }
    if (metricsType) {
      res["MetricsType"] = boost::any(*metricsType);
    }
    if (notice) {
      res["Notice"] = boost::any(*notice);
    }
    if (notifyMode) {
      res["NotifyMode"] = boost::any(*notifyMode);
    }
    if (notifyStrategy) {
      res["NotifyStrategy"] = boost::any(*notifyStrategy);
    }
    if (pids) {
      res["Pids"] = boost::any(*pids);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (promQL) {
      res["PromQL"] = boost::any(*promQL);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertCheckType") != m.end() && !m["AlertCheckType"].empty()) {
      alertCheckType = make_shared<string>(boost::any_cast<string>(m["AlertCheckType"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<long>(boost::any_cast<long>(m["AlertGroup"]));
    }
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertPiplines") != m.end() && !m["AlertPiplines"].empty()) {
      alertPiplines = make_shared<string>(boost::any_cast<string>(m["AlertPiplines"]));
    }
    if (m.find("AlertRuleContent") != m.end() && !m["AlertRuleContent"].empty()) {
      alertRuleContent = make_shared<string>(boost::any_cast<string>(m["AlertRuleContent"]));
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<string>(boost::any_cast<string>(m["AlertType"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("AutoAddNewApplication") != m.end() && !m["AutoAddNewApplication"].empty()) {
      autoAddNewApplication = make_shared<bool>(boost::any_cast<bool>(m["AutoAddNewApplication"]));
    }
    if (m.find("AutoAddTargetConfig") != m.end() && !m["AutoAddTargetConfig"].empty()) {
      autoAddTargetConfig = make_shared<string>(boost::any_cast<string>(m["AutoAddTargetConfig"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DataConfig") != m.end() && !m["DataConfig"].empty()) {
      dataConfig = make_shared<string>(boost::any_cast<string>(m["DataConfig"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      filters = make_shared<string>(boost::any_cast<string>(m["Filters"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MarkTags") != m.end() && !m["MarkTags"].empty()) {
      if (typeid(vector<boost::any>) == m["MarkTags"].type()) {
        vector<CreateOrUpdateAlertRuleRequestMarkTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MarkTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleRequestMarkTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        markTags = make_shared<vector<CreateOrUpdateAlertRuleRequestMarkTags>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MetricsKey") != m.end() && !m["MetricsKey"].empty()) {
      metricsKey = make_shared<string>(boost::any_cast<string>(m["MetricsKey"]));
    }
    if (m.find("MetricsType") != m.end() && !m["MetricsType"].empty()) {
      metricsType = make_shared<string>(boost::any_cast<string>(m["MetricsType"]));
    }
    if (m.find("Notice") != m.end() && !m["Notice"].empty()) {
      notice = make_shared<string>(boost::any_cast<string>(m["Notice"]));
    }
    if (m.find("NotifyMode") != m.end() && !m["NotifyMode"].empty()) {
      notifyMode = make_shared<string>(boost::any_cast<string>(m["NotifyMode"]));
    }
    if (m.find("NotifyStrategy") != m.end() && !m["NotifyStrategy"].empty()) {
      notifyStrategy = make_shared<string>(boost::any_cast<string>(m["NotifyStrategy"]));
    }
    if (m.find("Pids") != m.end() && !m["Pids"].empty()) {
      pids = make_shared<string>(boost::any_cast<string>(m["Pids"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("PromQL") != m.end() && !m["PromQL"].empty()) {
      promQL = make_shared<string>(boost::any_cast<string>(m["PromQL"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateOrUpdateAlertRuleRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateOrUpdateAlertRuleRequestTags>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateAlertRuleRequest() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems : public Darabonba::Model {
public:
  shared_ptr<string> aggregate{};
  shared_ptr<string> metricKey{};
  shared_ptr<double> n{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregate) {
      res["Aggregate"] = boost::any(*aggregate);
    }
    if (metricKey) {
      res["MetricKey"] = boost::any(*metricKey);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregate") != m.end() && !m["Aggregate"].empty()) {
      aggregate = make_shared<string>(boost::any_cast<string>(m["Aggregate"]));
    }
    if (m.find("MetricKey") != m.end() && !m["MetricKey"].empty()) {
      metricKey = make_shared<string>(boost::any_cast<string>(m["MetricKey"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<double>(boost::any_cast<double>(m["N"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems>> alertRuleItems{};
  shared_ptr<string> condition{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRuleItems) {
      vector<boost::any> temp1;
      for(auto item1:*alertRuleItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertRuleItems"] = boost::any(temp1);
    }
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRuleItems") != m.end() && !m["AlertRuleItems"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertRuleItems"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertRuleItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertRuleItems = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems>>(expect1);
      }
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opt{};
  shared_ptr<bool> show{};
  shared_ptr<string> t{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opt) {
      res["Opt"] = boost::any(*opt);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (t) {
      res["T"] = boost::any(*t);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Opt") != m.end() && !m["Opt"].empty()) {
      opt = make_shared<string>(boost::any_cast<string>(m["Opt"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("T") != m.end() && !m["T"].empty()) {
      t = make_shared<string>(boost::any_cast<string>(m["T"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters : public Darabonba::Model {
public:
  shared_ptr<string> filterKey{};
  shared_ptr<string> filterOpt{};
  shared_ptr<vector<string>> filterValues{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterKey) {
      res["FilterKey"] = boost::any(*filterKey);
    }
    if (filterOpt) {
      res["FilterOpt"] = boost::any(*filterOpt);
    }
    if (filterValues) {
      res["FilterValues"] = boost::any(*filterValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterKey") != m.end() && !m["FilterKey"].empty()) {
      filterKey = make_shared<string>(boost::any_cast<string>(m["FilterKey"]));
    }
    if (m.find("FilterOpt") != m.end() && !m["FilterOpt"].empty()) {
      filterOpt = make_shared<string>(boost::any_cast<string>(m["FilterOpt"]));
    }
    if (m.find("FilterValues") != m.end() && !m["FilterValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters>> customSLSFilters{};
  shared_ptr<vector<string>> customSLSGroupByDimensions{};
  shared_ptr<vector<string>> customSLSWheres{};
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters>> dimFilters{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSLSFilters) {
      vector<boost::any> temp1;
      for(auto item1:*customSLSFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSLSFilters"] = boost::any(temp1);
    }
    if (customSLSGroupByDimensions) {
      res["CustomSLSGroupByDimensions"] = boost::any(*customSLSGroupByDimensions);
    }
    if (customSLSWheres) {
      res["CustomSLSWheres"] = boost::any(*customSLSWheres);
    }
    if (dimFilters) {
      vector<boost::any> temp1;
      for(auto item1:*dimFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DimFilters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSLSFilters") != m.end() && !m["CustomSLSFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSLSFilters"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSLSFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSLSFilters = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters>>(expect1);
      }
    }
    if (m.find("CustomSLSGroupByDimensions") != m.end() && !m["CustomSLSGroupByDimensions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomSLSGroupByDimensions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomSLSGroupByDimensions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customSLSGroupByDimensions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomSLSWheres") != m.end() && !m["CustomSLSWheres"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomSLSWheres"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomSLSWheres"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customSLSWheres = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DimFilters") != m.end() && !m["DimFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["DimFilters"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DimFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimFilters = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleTags() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleTags() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRule : public Darabonba::Model {
public:
  shared_ptr<string> alertCheckType{};
  shared_ptr<long> alertGroup{};
  shared_ptr<double> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent> alertRuleContent{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> alertType{};
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations>> annotations{};
  shared_ptr<bool> autoAddNewApplication{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> extend{};
  shared_ptr<CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters> filters{};
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels>> labels{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> metricsType{};
  shared_ptr<string> notifyMode{};
  shared_ptr<string> notifyStrategy{};
  shared_ptr<vector<string>> pids{};
  shared_ptr<string> promQL{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleTags>> tags{};
  shared_ptr<long> updatedTime{};
  shared_ptr<string> userId{};

  CreateOrUpdateAlertRuleResponseBodyAlertRule() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertCheckType) {
      res["AlertCheckType"] = boost::any(*alertCheckType);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertRuleContent) {
      res["AlertRuleContent"] = alertRuleContent ? boost::any(alertRuleContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (autoAddNewApplication) {
      res["AutoAddNewApplication"] = boost::any(*autoAddNewApplication);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (filters) {
      res["Filters"] = filters ? boost::any(filters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (metricsType) {
      res["MetricsType"] = boost::any(*metricsType);
    }
    if (notifyMode) {
      res["NotifyMode"] = boost::any(*notifyMode);
    }
    if (notifyStrategy) {
      res["NotifyStrategy"] = boost::any(*notifyStrategy);
    }
    if (pids) {
      res["Pids"] = boost::any(*pids);
    }
    if (promQL) {
      res["PromQL"] = boost::any(*promQL);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertCheckType") != m.end() && !m["AlertCheckType"].empty()) {
      alertCheckType = make_shared<string>(boost::any_cast<string>(m["AlertCheckType"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<long>(boost::any_cast<long>(m["AlertGroup"]));
    }
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<double>(boost::any_cast<double>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertRuleContent") != m.end() && !m["AlertRuleContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRuleContent"].type()) {
        CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRuleContent"]));
        alertRuleContent = make_shared<CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent>(model1);
      }
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<string>(boost::any_cast<string>(m["AlertType"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations>>(expect1);
      }
    }
    if (m.find("AutoAddNewApplication") != m.end() && !m["AutoAddNewApplication"].empty()) {
      autoAddNewApplication = make_shared<bool>(boost::any_cast<bool>(m["AutoAddNewApplication"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filters"].type()) {
        CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filters"]));
        filters = make_shared<CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters>(model1);
      }
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels>>(expect1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MetricsType") != m.end() && !m["MetricsType"].empty()) {
      metricsType = make_shared<string>(boost::any_cast<string>(m["MetricsType"]));
    }
    if (m.find("NotifyMode") != m.end() && !m["NotifyMode"].empty()) {
      notifyMode = make_shared<string>(boost::any_cast<string>(m["NotifyMode"]));
    }
    if (m.find("NotifyStrategy") != m.end() && !m["NotifyStrategy"].empty()) {
      notifyStrategy = make_shared<string>(boost::any_cast<string>(m["NotifyStrategy"]));
    }
    if (m.find("Pids") != m.end() && !m["Pids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Pids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Pids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PromQL") != m.end() && !m["PromQL"].empty()) {
      promQL = make_shared<string>(boost::any_cast<string>(m["PromQL"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleTags>>(expect1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRule() = default;
};
class CreateOrUpdateAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateAlertRuleResponseBodyAlertRule> alertRule{};
  shared_ptr<string> requestId{};

  CreateOrUpdateAlertRuleResponseBody() {}

  explicit CreateOrUpdateAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRule) {
      res["AlertRule"] = alertRule ? boost::any(alertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRule") != m.end() && !m["AlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRule"].type()) {
        CreateOrUpdateAlertRuleResponseBodyAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRule"]));
        alertRule = make_shared<CreateOrUpdateAlertRuleResponseBodyAlertRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBody() = default;
};
class CreateOrUpdateAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateAlertRuleResponseBody> body{};

  CreateOrUpdateAlertRuleResponse() {}

  explicit CreateOrUpdateAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponse() = default;
};
class CreateOrUpdateContactRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpUserId{};
  shared_ptr<string> dingRobotUrl{};
  shared_ptr<string> email{};
  shared_ptr<bool> isEmailVerify{};
  shared_ptr<string> phone{};
  shared_ptr<long> reissueSendNotice{};
  shared_ptr<string> resourceGroupId{};

  CreateOrUpdateContactRequest() {}

  explicit CreateOrUpdateContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (corpUserId) {
      res["CorpUserId"] = boost::any(*corpUserId);
    }
    if (dingRobotUrl) {
      res["DingRobotUrl"] = boost::any(*dingRobotUrl);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (isEmailVerify) {
      res["IsEmailVerify"] = boost::any(*isEmailVerify);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (reissueSendNotice) {
      res["ReissueSendNotice"] = boost::any(*reissueSendNotice);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("CorpUserId") != m.end() && !m["CorpUserId"].empty()) {
      corpUserId = make_shared<string>(boost::any_cast<string>(m["CorpUserId"]));
    }
    if (m.find("DingRobotUrl") != m.end() && !m["DingRobotUrl"].empty()) {
      dingRobotUrl = make_shared<string>(boost::any_cast<string>(m["DingRobotUrl"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("IsEmailVerify") != m.end() && !m["IsEmailVerify"].empty()) {
      isEmailVerify = make_shared<bool>(boost::any_cast<bool>(m["IsEmailVerify"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ReissueSendNotice") != m.end() && !m["ReissueSendNotice"].empty()) {
      reissueSendNotice = make_shared<long>(boost::any_cast<long>(m["ReissueSendNotice"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateOrUpdateContactRequest() = default;
};
class CreateOrUpdateContactResponseBodyAlertContact : public Darabonba::Model {
public:
  shared_ptr<double> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> dingRobotUrl{};
  shared_ptr<string> email{};
  shared_ptr<bool> isVerify{};
  shared_ptr<string> phone{};
  shared_ptr<long> reissueSendNotice{};
  shared_ptr<bool> isEmailVerify{};

  CreateOrUpdateContactResponseBodyAlertContact() {}

  explicit CreateOrUpdateContactResponseBodyAlertContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (dingRobotUrl) {
      res["DingRobotUrl"] = boost::any(*dingRobotUrl);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (isVerify) {
      res["IsVerify"] = boost::any(*isVerify);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (reissueSendNotice) {
      res["ReissueSendNotice"] = boost::any(*reissueSendNotice);
    }
    if (isEmailVerify) {
      res["isEmailVerify"] = boost::any(*isEmailVerify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<double>(boost::any_cast<double>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("DingRobotUrl") != m.end() && !m["DingRobotUrl"].empty()) {
      dingRobotUrl = make_shared<string>(boost::any_cast<string>(m["DingRobotUrl"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("IsVerify") != m.end() && !m["IsVerify"].empty()) {
      isVerify = make_shared<bool>(boost::any_cast<bool>(m["IsVerify"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ReissueSendNotice") != m.end() && !m["ReissueSendNotice"].empty()) {
      reissueSendNotice = make_shared<long>(boost::any_cast<long>(m["ReissueSendNotice"]));
    }
    if (m.find("isEmailVerify") != m.end() && !m["isEmailVerify"].empty()) {
      isEmailVerify = make_shared<bool>(boost::any_cast<bool>(m["isEmailVerify"]));
    }
  }


  virtual ~CreateOrUpdateContactResponseBodyAlertContact() = default;
};
class CreateOrUpdateContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateContactResponseBodyAlertContact> alertContact{};
  shared_ptr<string> requestId{};

  CreateOrUpdateContactResponseBody() {}

  explicit CreateOrUpdateContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertContact) {
      res["AlertContact"] = alertContact ? boost::any(alertContact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertContact") != m.end() && !m["AlertContact"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertContact"].type()) {
        CreateOrUpdateContactResponseBodyAlertContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertContact"]));
        alertContact = make_shared<CreateOrUpdateContactResponseBodyAlertContact>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateContactResponseBody() = default;
};
class CreateOrUpdateContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateContactResponseBody> body{};

  CreateOrUpdateContactResponse() {}

  explicit CreateOrUpdateContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateContactResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateContactResponse() = default;
};
class CreateOrUpdateContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactGroupId{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> contactIds{};

  CreateOrUpdateContactGroupRequest() {}

  explicit CreateOrUpdateContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<long>(boost::any_cast<long>(m["ContactGroupId"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
  }


  virtual ~CreateOrUpdateContactGroupRequest() = default;
};
class CreateOrUpdateContactGroupResponseBodyAlertContactGroup : public Darabonba::Model {
public:
  shared_ptr<double> contactGroupId{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> contactIds{};

  CreateOrUpdateContactGroupResponseBodyAlertContactGroup() {}

  explicit CreateOrUpdateContactGroupResponseBodyAlertContactGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<double>(boost::any_cast<double>(m["ContactGroupId"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
  }


  virtual ~CreateOrUpdateContactGroupResponseBodyAlertContactGroup() = default;
};
class CreateOrUpdateContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateContactGroupResponseBodyAlertContactGroup> alertContactGroup{};
  shared_ptr<string> requestId{};

  CreateOrUpdateContactGroupResponseBody() {}

  explicit CreateOrUpdateContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertContactGroup) {
      res["AlertContactGroup"] = alertContactGroup ? boost::any(alertContactGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertContactGroup") != m.end() && !m["AlertContactGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertContactGroup"].type()) {
        CreateOrUpdateContactGroupResponseBodyAlertContactGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertContactGroup"]));
        alertContactGroup = make_shared<CreateOrUpdateContactGroupResponseBodyAlertContactGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateContactGroupResponseBody() = default;
};
class CreateOrUpdateContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateContactGroupResponseBody> body{};

  CreateOrUpdateContactGroupResponse() {}

  explicit CreateOrUpdateContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateContactGroupResponse() = default;
};
class CreateOrUpdateEventBridgeIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> accessSecret{};
  shared_ptr<string> description{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> eventBusName{};
  shared_ptr<string> eventBusRegionId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};

  CreateOrUpdateEventBridgeIntegrationRequest() {}

  explicit CreateOrUpdateEventBridgeIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (accessSecret) {
      res["AccessSecret"] = boost::any(*accessSecret);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (eventBusName) {
      res["EventBusName"] = boost::any(*eventBusName);
    }
    if (eventBusRegionId) {
      res["EventBusRegionId"] = boost::any(*eventBusRegionId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AccessSecret") != m.end() && !m["AccessSecret"].empty()) {
      accessSecret = make_shared<string>(boost::any_cast<string>(m["AccessSecret"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EventBusName") != m.end() && !m["EventBusName"].empty()) {
      eventBusName = make_shared<string>(boost::any_cast<string>(m["EventBusName"]));
    }
    if (m.find("EventBusRegionId") != m.end() && !m["EventBusRegionId"].empty()) {
      eventBusRegionId = make_shared<string>(boost::any_cast<string>(m["EventBusRegionId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~CreateOrUpdateEventBridgeIntegrationRequest() = default;
};
class CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> accessSecret{};
  shared_ptr<string> description{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> eventBusName{};
  shared_ptr<string> eventBusRegionId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};

  CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration() {}

  explicit CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (accessSecret) {
      res["AccessSecret"] = boost::any(*accessSecret);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (eventBusName) {
      res["EventBusName"] = boost::any(*eventBusName);
    }
    if (eventBusRegionId) {
      res["EventBusRegionId"] = boost::any(*eventBusRegionId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AccessSecret") != m.end() && !m["AccessSecret"].empty()) {
      accessSecret = make_shared<string>(boost::any_cast<string>(m["AccessSecret"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EventBusName") != m.end() && !m["EventBusName"].empty()) {
      eventBusName = make_shared<string>(boost::any_cast<string>(m["EventBusName"]));
    }
    if (m.find("EventBusRegionId") != m.end() && !m["EventBusRegionId"].empty()) {
      eventBusRegionId = make_shared<string>(boost::any_cast<string>(m["EventBusRegionId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration() = default;
};
class CreateOrUpdateEventBridgeIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration> eventBridgeIntegration{};
  shared_ptr<string> requestId{};

  CreateOrUpdateEventBridgeIntegrationResponseBody() {}

  explicit CreateOrUpdateEventBridgeIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventBridgeIntegration) {
      res["EventBridgeIntegration"] = eventBridgeIntegration ? boost::any(eventBridgeIntegration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventBridgeIntegration") != m.end() && !m["EventBridgeIntegration"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventBridgeIntegration"].type()) {
        CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventBridgeIntegration"]));
        eventBridgeIntegration = make_shared<CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateEventBridgeIntegrationResponseBody() = default;
};
class CreateOrUpdateEventBridgeIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateEventBridgeIntegrationResponseBody> body{};

  CreateOrUpdateEventBridgeIntegrationResponse() {}

  explicit CreateOrUpdateEventBridgeIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateEventBridgeIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateEventBridgeIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateEventBridgeIntegrationResponse() = default;
};
class CreateOrUpdateIMRobotRequest : public Darabonba::Model {
public:
  shared_ptr<string> cardTemplate{};
  shared_ptr<bool> dailyNoc{};
  shared_ptr<string> dailyNocTime{};
  shared_ptr<string> dingSignKey{};
  shared_ptr<bool> enableOutgoing{};
  shared_ptr<string> robotAddress{};
  shared_ptr<long> robotId{};
  shared_ptr<string> robotName{};
  shared_ptr<string> token{};
  shared_ptr<string> type{};

  CreateOrUpdateIMRobotRequest() {}

  explicit CreateOrUpdateIMRobotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardTemplate) {
      res["CardTemplate"] = boost::any(*cardTemplate);
    }
    if (dailyNoc) {
      res["DailyNoc"] = boost::any(*dailyNoc);
    }
    if (dailyNocTime) {
      res["DailyNocTime"] = boost::any(*dailyNocTime);
    }
    if (dingSignKey) {
      res["DingSignKey"] = boost::any(*dingSignKey);
    }
    if (enableOutgoing) {
      res["EnableOutgoing"] = boost::any(*enableOutgoing);
    }
    if (robotAddress) {
      res["RobotAddress"] = boost::any(*robotAddress);
    }
    if (robotId) {
      res["RobotId"] = boost::any(*robotId);
    }
    if (robotName) {
      res["RobotName"] = boost::any(*robotName);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CardTemplate") != m.end() && !m["CardTemplate"].empty()) {
      cardTemplate = make_shared<string>(boost::any_cast<string>(m["CardTemplate"]));
    }
    if (m.find("DailyNoc") != m.end() && !m["DailyNoc"].empty()) {
      dailyNoc = make_shared<bool>(boost::any_cast<bool>(m["DailyNoc"]));
    }
    if (m.find("DailyNocTime") != m.end() && !m["DailyNocTime"].empty()) {
      dailyNocTime = make_shared<string>(boost::any_cast<string>(m["DailyNocTime"]));
    }
    if (m.find("DingSignKey") != m.end() && !m["DingSignKey"].empty()) {
      dingSignKey = make_shared<string>(boost::any_cast<string>(m["DingSignKey"]));
    }
    if (m.find("EnableOutgoing") != m.end() && !m["EnableOutgoing"].empty()) {
      enableOutgoing = make_shared<bool>(boost::any_cast<bool>(m["EnableOutgoing"]));
    }
    if (m.find("RobotAddress") != m.end() && !m["RobotAddress"].empty()) {
      robotAddress = make_shared<string>(boost::any_cast<string>(m["RobotAddress"]));
    }
    if (m.find("RobotId") != m.end() && !m["RobotId"].empty()) {
      robotId = make_shared<long>(boost::any_cast<long>(m["RobotId"]));
    }
    if (m.find("RobotName") != m.end() && !m["RobotName"].empty()) {
      robotName = make_shared<string>(boost::any_cast<string>(m["RobotName"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateOrUpdateIMRobotRequest() = default;
};
class CreateOrUpdateIMRobotResponseBodyAlertRobot : public Darabonba::Model {
public:
  shared_ptr<string> cardTemplate{};
  shared_ptr<bool> dailyNoc{};
  shared_ptr<string> dailyNocTime{};
  shared_ptr<bool> enableOutgoing{};
  shared_ptr<string> robotAddress{};
  shared_ptr<double> robotId{};
  shared_ptr<string> robotName{};
  shared_ptr<string> token{};
  shared_ptr<string> type{};

  CreateOrUpdateIMRobotResponseBodyAlertRobot() {}

  explicit CreateOrUpdateIMRobotResponseBodyAlertRobot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardTemplate) {
      res["CardTemplate"] = boost::any(*cardTemplate);
    }
    if (dailyNoc) {
      res["DailyNoc"] = boost::any(*dailyNoc);
    }
    if (dailyNocTime) {
      res["DailyNocTime"] = boost::any(*dailyNocTime);
    }
    if (enableOutgoing) {
      res["EnableOutgoing"] = boost::any(*enableOutgoing);
    }
    if (robotAddress) {
      res["RobotAddress"] = boost::any(*robotAddress);
    }
    if (robotId) {
      res["RobotId"] = boost::any(*robotId);
    }
    if (robotName) {
      res["RobotName"] = boost::any(*robotName);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CardTemplate") != m.end() && !m["CardTemplate"].empty()) {
      cardTemplate = make_shared<string>(boost::any_cast<string>(m["CardTemplate"]));
    }
    if (m.find("DailyNoc") != m.end() && !m["DailyNoc"].empty()) {
      dailyNoc = make_shared<bool>(boost::any_cast<bool>(m["DailyNoc"]));
    }
    if (m.find("DailyNocTime") != m.end() && !m["DailyNocTime"].empty()) {
      dailyNocTime = make_shared<string>(boost::any_cast<string>(m["DailyNocTime"]));
    }
    if (m.find("EnableOutgoing") != m.end() && !m["EnableOutgoing"].empty()) {
      enableOutgoing = make_shared<bool>(boost::any_cast<bool>(m["EnableOutgoing"]));
    }
    if (m.find("RobotAddress") != m.end() && !m["RobotAddress"].empty()) {
      robotAddress = make_shared<string>(boost::any_cast<string>(m["RobotAddress"]));
    }
    if (m.find("RobotId") != m.end() && !m["RobotId"].empty()) {
      robotId = make_shared<double>(boost::any_cast<double>(m["RobotId"]));
    }
    if (m.find("RobotName") != m.end() && !m["RobotName"].empty()) {
      robotName = make_shared<string>(boost::any_cast<string>(m["RobotName"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateOrUpdateIMRobotResponseBodyAlertRobot() = default;
};
class CreateOrUpdateIMRobotResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateIMRobotResponseBodyAlertRobot> alertRobot{};
  shared_ptr<string> requestId{};

  CreateOrUpdateIMRobotResponseBody() {}

  explicit CreateOrUpdateIMRobotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRobot) {
      res["AlertRobot"] = alertRobot ? boost::any(alertRobot->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRobot") != m.end() && !m["AlertRobot"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRobot"].type()) {
        CreateOrUpdateIMRobotResponseBodyAlertRobot model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRobot"]));
        alertRobot = make_shared<CreateOrUpdateIMRobotResponseBodyAlertRobot>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateIMRobotResponseBody() = default;
};
class CreateOrUpdateIMRobotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateIMRobotResponseBody> body{};

  CreateOrUpdateIMRobotResponse() {}

  explicit CreateOrUpdateIMRobotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateIMRobotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateIMRobotResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateIMRobotResponse() = default;
};
class CreateOrUpdateNotificationPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<bool> directedMode{};
  shared_ptr<long> escalationPolicyId{};
  shared_ptr<string> groupRule{};
  shared_ptr<long> id{};
  shared_ptr<long> integrationId{};
  shared_ptr<string> matchingRules{};
  shared_ptr<string> name{};
  shared_ptr<string> notifyRule{};
  shared_ptr<string> notifyTemplate{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> repeat{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<bool> sendRecoverMessage{};
  shared_ptr<string> state{};

  CreateOrUpdateNotificationPolicyRequest() {}

  explicit CreateOrUpdateNotificationPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directedMode) {
      res["DirectedMode"] = boost::any(*directedMode);
    }
    if (escalationPolicyId) {
      res["EscalationPolicyId"] = boost::any(*escalationPolicyId);
    }
    if (groupRule) {
      res["GroupRule"] = boost::any(*groupRule);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (matchingRules) {
      res["MatchingRules"] = boost::any(*matchingRules);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyRule) {
      res["NotifyRule"] = boost::any(*notifyRule);
    }
    if (notifyTemplate) {
      res["NotifyTemplate"] = boost::any(*notifyTemplate);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeat) {
      res["Repeat"] = boost::any(*repeat);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (sendRecoverMessage) {
      res["SendRecoverMessage"] = boost::any(*sendRecoverMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectedMode") != m.end() && !m["DirectedMode"].empty()) {
      directedMode = make_shared<bool>(boost::any_cast<bool>(m["DirectedMode"]));
    }
    if (m.find("EscalationPolicyId") != m.end() && !m["EscalationPolicyId"].empty()) {
      escalationPolicyId = make_shared<long>(boost::any_cast<long>(m["EscalationPolicyId"]));
    }
    if (m.find("GroupRule") != m.end() && !m["GroupRule"].empty()) {
      groupRule = make_shared<string>(boost::any_cast<string>(m["GroupRule"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      matchingRules = make_shared<string>(boost::any_cast<string>(m["MatchingRules"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyRule") != m.end() && !m["NotifyRule"].empty()) {
      notifyRule = make_shared<string>(boost::any_cast<string>(m["NotifyRule"]));
    }
    if (m.find("NotifyTemplate") != m.end() && !m["NotifyTemplate"].empty()) {
      notifyTemplate = make_shared<string>(boost::any_cast<string>(m["NotifyTemplate"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Repeat") != m.end() && !m["Repeat"].empty()) {
      repeat = make_shared<bool>(boost::any_cast<bool>(m["Repeat"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("SendRecoverMessage") != m.end() && !m["SendRecoverMessage"].empty()) {
      sendRecoverMessage = make_shared<bool>(boost::any_cast<bool>(m["SendRecoverMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyRequest() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule : public Darabonba::Model {
public:
  shared_ptr<long> groupInterval{};
  shared_ptr<long> groupWait{};
  shared_ptr<vector<string>> groupingFields{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInterval) {
      res["GroupInterval"] = boost::any(*groupInterval);
    }
    if (groupWait) {
      res["GroupWait"] = boost::any(*groupWait);
    }
    if (groupingFields) {
      res["GroupingFields"] = boost::any(*groupingFields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInterval") != m.end() && !m["GroupInterval"].empty()) {
      groupInterval = make_shared<long>(boost::any_cast<long>(m["GroupInterval"]));
    }
    if (m.find("GroupWait") != m.end() && !m["GroupWait"].empty()) {
      groupWait = make_shared<long>(boost::any_cast<long>(m["GroupWait"]));
    }
    if (m.find("GroupingFields") != m.end() && !m["GroupingFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupingFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupingFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupingFields = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions>> matchingConditions{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchingConditions) {
      vector<boost::any> temp1;
      for(auto item1:*matchingConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchingConditions") != m.end() && !m["MatchingConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingConditions"].type()) {
        vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingConditions = make_shared<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<long> notifyObjectId{};
  shared_ptr<string> notifyObjectName{};
  shared_ptr<string> notifyObjectType{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyChannels) {
      res["NotifyChannels"] = boost::any(*notifyChannels);
    }
    if (notifyObjectId) {
      res["NotifyObjectId"] = boost::any(*notifyObjectId);
    }
    if (notifyObjectName) {
      res["NotifyObjectName"] = boost::any(*notifyObjectName);
    }
    if (notifyObjectType) {
      res["NotifyObjectType"] = boost::any(*notifyObjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyChannels") != m.end() && !m["NotifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyObjectId") != m.end() && !m["NotifyObjectId"].empty()) {
      notifyObjectId = make_shared<long>(boost::any_cast<long>(m["NotifyObjectId"]));
    }
    if (m.find("NotifyObjectName") != m.end() && !m["NotifyObjectName"].empty()) {
      notifyObjectName = make_shared<string>(boost::any_cast<string>(m["NotifyObjectName"]));
    }
    if (m.find("NotifyObjectType") != m.end() && !m["NotifyObjectType"].empty()) {
      notifyObjectType = make_shared<string>(boost::any_cast<string>(m["NotifyObjectType"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<string> notifyEndTime{};
  shared_ptr<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects>> notifyObjects{};
  shared_ptr<string> notifyStartTime{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyChannels) {
      res["NotifyChannels"] = boost::any(*notifyChannels);
    }
    if (notifyEndTime) {
      res["NotifyEndTime"] = boost::any(*notifyEndTime);
    }
    if (notifyObjects) {
      vector<boost::any> temp1;
      for(auto item1:*notifyObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotifyObjects"] = boost::any(temp1);
    }
    if (notifyStartTime) {
      res["NotifyStartTime"] = boost::any(*notifyStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyChannels") != m.end() && !m["NotifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyEndTime") != m.end() && !m["NotifyEndTime"].empty()) {
      notifyEndTime = make_shared<string>(boost::any_cast<string>(m["NotifyEndTime"]));
    }
    if (m.find("NotifyObjects") != m.end() && !m["NotifyObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["NotifyObjects"].type()) {
        vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotifyObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyObjects = make_shared<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects>>(expect1);
      }
    }
    if (m.find("NotifyStartTime") != m.end() && !m["NotifyStartTime"].empty()) {
      notifyStartTime = make_shared<string>(boost::any_cast<string>(m["NotifyStartTime"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> emailContent{};
  shared_ptr<string> emailRecoverContent{};
  shared_ptr<string> emailRecoverTitle{};
  shared_ptr<string> emailTitle{};
  shared_ptr<string> robotContent{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> smsRecoverContent{};
  shared_ptr<string> ttsContent{};
  shared_ptr<string> ttsRecoverContent{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emailContent) {
      res["EmailContent"] = boost::any(*emailContent);
    }
    if (emailRecoverContent) {
      res["EmailRecoverContent"] = boost::any(*emailRecoverContent);
    }
    if (emailRecoverTitle) {
      res["EmailRecoverTitle"] = boost::any(*emailRecoverTitle);
    }
    if (emailTitle) {
      res["EmailTitle"] = boost::any(*emailTitle);
    }
    if (robotContent) {
      res["RobotContent"] = boost::any(*robotContent);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (smsRecoverContent) {
      res["SmsRecoverContent"] = boost::any(*smsRecoverContent);
    }
    if (ttsContent) {
      res["TtsContent"] = boost::any(*ttsContent);
    }
    if (ttsRecoverContent) {
      res["TtsRecoverContent"] = boost::any(*ttsRecoverContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmailContent") != m.end() && !m["EmailContent"].empty()) {
      emailContent = make_shared<string>(boost::any_cast<string>(m["EmailContent"]));
    }
    if (m.find("EmailRecoverContent") != m.end() && !m["EmailRecoverContent"].empty()) {
      emailRecoverContent = make_shared<string>(boost::any_cast<string>(m["EmailRecoverContent"]));
    }
    if (m.find("EmailRecoverTitle") != m.end() && !m["EmailRecoverTitle"].empty()) {
      emailRecoverTitle = make_shared<string>(boost::any_cast<string>(m["EmailRecoverTitle"]));
    }
    if (m.find("EmailTitle") != m.end() && !m["EmailTitle"].empty()) {
      emailTitle = make_shared<string>(boost::any_cast<string>(m["EmailTitle"]));
    }
    if (m.find("RobotContent") != m.end() && !m["RobotContent"].empty()) {
      robotContent = make_shared<string>(boost::any_cast<string>(m["RobotContent"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SmsRecoverContent") != m.end() && !m["SmsRecoverContent"].empty()) {
      smsRecoverContent = make_shared<string>(boost::any_cast<string>(m["SmsRecoverContent"]));
    }
    if (m.find("TtsContent") != m.end() && !m["TtsContent"].empty()) {
      ttsContent = make_shared<string>(boost::any_cast<string>(m["TtsContent"]));
    }
    if (m.find("TtsRecoverContent") != m.end() && !m["TtsRecoverContent"].empty()) {
      ttsRecoverContent = make_shared<string>(boost::any_cast<string>(m["TtsRecoverContent"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> directedMode{};
  shared_ptr<long> escalationPolicyId{};
  shared_ptr<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule> groupRule{};
  shared_ptr<long> id{};
  shared_ptr<long> integrationId{};
  shared_ptr<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules>> matchingRules{};
  shared_ptr<string> name{};
  shared_ptr<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule> notifyRule{};
  shared_ptr<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate> notifyTemplate{};
  shared_ptr<bool> repeat{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<bool> sendRecoverMessage{};
  shared_ptr<string> state{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directedMode) {
      res["DirectedMode"] = boost::any(*directedMode);
    }
    if (escalationPolicyId) {
      res["EscalationPolicyId"] = boost::any(*escalationPolicyId);
    }
    if (groupRule) {
      res["GroupRule"] = groupRule ? boost::any(groupRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (matchingRules) {
      vector<boost::any> temp1;
      for(auto item1:*matchingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingRules"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyRule) {
      res["NotifyRule"] = notifyRule ? boost::any(notifyRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyTemplate) {
      res["NotifyTemplate"] = notifyTemplate ? boost::any(notifyTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (repeat) {
      res["Repeat"] = boost::any(*repeat);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (sendRecoverMessage) {
      res["SendRecoverMessage"] = boost::any(*sendRecoverMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectedMode") != m.end() && !m["DirectedMode"].empty()) {
      directedMode = make_shared<bool>(boost::any_cast<bool>(m["DirectedMode"]));
    }
    if (m.find("EscalationPolicyId") != m.end() && !m["EscalationPolicyId"].empty()) {
      escalationPolicyId = make_shared<long>(boost::any_cast<long>(m["EscalationPolicyId"]));
    }
    if (m.find("GroupRule") != m.end() && !m["GroupRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupRule"].type()) {
        CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupRule"]));
        groupRule = make_shared<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingRules"].type()) {
        vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingRules = make_shared<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyRule") != m.end() && !m["NotifyRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyRule"].type()) {
        CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyRule"]));
        notifyRule = make_shared<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule>(model1);
      }
    }
    if (m.find("NotifyTemplate") != m.end() && !m["NotifyTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyTemplate"].type()) {
        CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyTemplate"]));
        notifyTemplate = make_shared<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate>(model1);
      }
    }
    if (m.find("Repeat") != m.end() && !m["Repeat"].empty()) {
      repeat = make_shared<bool>(boost::any_cast<bool>(m["Repeat"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("SendRecoverMessage") != m.end() && !m["SendRecoverMessage"].empty()) {
      sendRecoverMessage = make_shared<bool>(boost::any_cast<bool>(m["SendRecoverMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy() = default;
};
class CreateOrUpdateNotificationPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy> notificationPolicy{};
  shared_ptr<string> requestId{};

  CreateOrUpdateNotificationPolicyResponseBody() {}

  explicit CreateOrUpdateNotificationPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationPolicy) {
      res["NotificationPolicy"] = notificationPolicy ? boost::any(notificationPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationPolicy") != m.end() && !m["NotificationPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotificationPolicy"].type()) {
        CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotificationPolicy"]));
        notificationPolicy = make_shared<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBody() = default;
};
class CreateOrUpdateNotificationPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateNotificationPolicyResponseBody> body{};

  CreateOrUpdateNotificationPolicyResponse() {}

  explicit CreateOrUpdateNotificationPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateNotificationPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateNotificationPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponse() = default;
};
class CreateOrUpdateSilencePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> effectiveTimeType{};
  shared_ptr<long> id{};
  shared_ptr<string> matchingRules{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<string> timePeriod{};
  shared_ptr<string> timeSlots{};

  CreateOrUpdateSilencePolicyRequest() {}

  explicit CreateOrUpdateSilencePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveTimeType) {
      res["EffectiveTimeType"] = boost::any(*effectiveTimeType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchingRules) {
      res["MatchingRules"] = boost::any(*matchingRules);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timePeriod) {
      res["TimePeriod"] = boost::any(*timePeriod);
    }
    if (timeSlots) {
      res["TimeSlots"] = boost::any(*timeSlots);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveTimeType") != m.end() && !m["EffectiveTimeType"].empty()) {
      effectiveTimeType = make_shared<string>(boost::any_cast<string>(m["EffectiveTimeType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      matchingRules = make_shared<string>(boost::any_cast<string>(m["MatchingRules"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TimePeriod") != m.end() && !m["TimePeriod"].empty()) {
      timePeriod = make_shared<string>(boost::any_cast<string>(m["TimePeriod"]));
    }
    if (m.find("TimeSlots") != m.end() && !m["TimeSlots"].empty()) {
      timeSlots = make_shared<string>(boost::any_cast<string>(m["TimeSlots"]));
    }
  }


  virtual ~CreateOrUpdateSilencePolicyRequest() = default;
};
class CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions() {}

  explicit CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions() = default;
};
class CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions>> matchingConditions{};

  CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules() {}

  explicit CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchingConditions) {
      vector<boost::any> temp1;
      for(auto item1:*matchingConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchingConditions") != m.end() && !m["MatchingConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingConditions"].type()) {
        vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingConditions = make_shared<vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules() = default;
};
class CreateOrUpdateSilencePolicyResponseBodySilencePolicy : public Darabonba::Model {
public:
  shared_ptr<string> effectiveTimeType{};
  shared_ptr<long> id{};
  shared_ptr<vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules>> matchingRules{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> timePeriod{};
  shared_ptr<string> timeSlots{};

  CreateOrUpdateSilencePolicyResponseBodySilencePolicy() {}

  explicit CreateOrUpdateSilencePolicyResponseBodySilencePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveTimeType) {
      res["EffectiveTimeType"] = boost::any(*effectiveTimeType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchingRules) {
      vector<boost::any> temp1;
      for(auto item1:*matchingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingRules"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timePeriod) {
      res["TimePeriod"] = boost::any(*timePeriod);
    }
    if (timeSlots) {
      res["TimeSlots"] = boost::any(*timeSlots);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveTimeType") != m.end() && !m["EffectiveTimeType"].empty()) {
      effectiveTimeType = make_shared<string>(boost::any_cast<string>(m["EffectiveTimeType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingRules"].type()) {
        vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingRules = make_shared<vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TimePeriod") != m.end() && !m["TimePeriod"].empty()) {
      timePeriod = make_shared<string>(boost::any_cast<string>(m["TimePeriod"]));
    }
    if (m.find("TimeSlots") != m.end() && !m["TimeSlots"].empty()) {
      timeSlots = make_shared<string>(boost::any_cast<string>(m["TimeSlots"]));
    }
  }


  virtual ~CreateOrUpdateSilencePolicyResponseBodySilencePolicy() = default;
};
class CreateOrUpdateSilencePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateOrUpdateSilencePolicyResponseBodySilencePolicy> silencePolicy{};

  CreateOrUpdateSilencePolicyResponseBody() {}

  explicit CreateOrUpdateSilencePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (silencePolicy) {
      res["SilencePolicy"] = silencePolicy ? boost::any(silencePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SilencePolicy") != m.end() && !m["SilencePolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["SilencePolicy"].type()) {
        CreateOrUpdateSilencePolicyResponseBodySilencePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SilencePolicy"]));
        silencePolicy = make_shared<CreateOrUpdateSilencePolicyResponseBodySilencePolicy>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateSilencePolicyResponseBody() = default;
};
class CreateOrUpdateSilencePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateSilencePolicyResponseBody> body{};

  CreateOrUpdateSilencePolicyResponse() {}

  explicit CreateOrUpdateSilencePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateSilencePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateSilencePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateSilencePolicyResponse() = default;
};
class CreateOrUpdateWebhookContactRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizHeaders{};
  shared_ptr<string> bizParams{};
  shared_ptr<string> body{};
  shared_ptr<string> method{};
  shared_ptr<string> recoverBody{};
  shared_ptr<string> url{};
  shared_ptr<long> webhookId{};
  shared_ptr<string> webhookName{};

  CreateOrUpdateWebhookContactRequest() {}

  explicit CreateOrUpdateWebhookContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizHeaders) {
      res["BizHeaders"] = boost::any(*bizHeaders);
    }
    if (bizParams) {
      res["BizParams"] = boost::any(*bizParams);
    }
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (recoverBody) {
      res["RecoverBody"] = boost::any(*recoverBody);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (webhookId) {
      res["WebhookId"] = boost::any(*webhookId);
    }
    if (webhookName) {
      res["WebhookName"] = boost::any(*webhookName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizHeaders") != m.end() && !m["BizHeaders"].empty()) {
      bizHeaders = make_shared<string>(boost::any_cast<string>(m["BizHeaders"]));
    }
    if (m.find("BizParams") != m.end() && !m["BizParams"].empty()) {
      bizParams = make_shared<string>(boost::any_cast<string>(m["BizParams"]));
    }
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("RecoverBody") != m.end() && !m["RecoverBody"].empty()) {
      recoverBody = make_shared<string>(boost::any_cast<string>(m["RecoverBody"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WebhookId") != m.end() && !m["WebhookId"].empty()) {
      webhookId = make_shared<long>(boost::any_cast<long>(m["WebhookId"]));
    }
    if (m.find("WebhookName") != m.end() && !m["WebhookName"].empty()) {
      webhookName = make_shared<string>(boost::any_cast<string>(m["WebhookName"]));
    }
  }


  virtual ~CreateOrUpdateWebhookContactRequest() = default;
};
class CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook : public Darabonba::Model {
public:
  shared_ptr<string> bizHeaders{};
  shared_ptr<string> bizParams{};
  shared_ptr<string> body{};
  shared_ptr<string> method{};
  shared_ptr<string> recoverBody{};
  shared_ptr<string> url{};

  CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook() {}

  explicit CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizHeaders) {
      res["BizHeaders"] = boost::any(*bizHeaders);
    }
    if (bizParams) {
      res["BizParams"] = boost::any(*bizParams);
    }
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (recoverBody) {
      res["RecoverBody"] = boost::any(*recoverBody);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizHeaders") != m.end() && !m["BizHeaders"].empty()) {
      bizHeaders = make_shared<string>(boost::any_cast<string>(m["BizHeaders"]));
    }
    if (m.find("BizParams") != m.end() && !m["BizParams"].empty()) {
      bizParams = make_shared<string>(boost::any_cast<string>(m["BizParams"]));
    }
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("RecoverBody") != m.end() && !m["RecoverBody"].empty()) {
      recoverBody = make_shared<string>(boost::any_cast<string>(m["RecoverBody"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook() = default;
};
class CreateOrUpdateWebhookContactResponseBodyWebhookContact : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook> webhook{};
  shared_ptr<double> webhookId{};
  shared_ptr<string> webhookName{};

  CreateOrUpdateWebhookContactResponseBodyWebhookContact() {}

  explicit CreateOrUpdateWebhookContactResponseBodyWebhookContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webhook) {
      res["Webhook"] = webhook ? boost::any(webhook->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webhookId) {
      res["WebhookId"] = boost::any(*webhookId);
    }
    if (webhookName) {
      res["WebhookName"] = boost::any(*webhookName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webhook"].type()) {
        CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webhook"]));
        webhook = make_shared<CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook>(model1);
      }
    }
    if (m.find("WebhookId") != m.end() && !m["WebhookId"].empty()) {
      webhookId = make_shared<double>(boost::any_cast<double>(m["WebhookId"]));
    }
    if (m.find("WebhookName") != m.end() && !m["WebhookName"].empty()) {
      webhookName = make_shared<string>(boost::any_cast<string>(m["WebhookName"]));
    }
  }


  virtual ~CreateOrUpdateWebhookContactResponseBodyWebhookContact() = default;
};
class CreateOrUpdateWebhookContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateOrUpdateWebhookContactResponseBodyWebhookContact> webhookContact{};

  CreateOrUpdateWebhookContactResponseBody() {}

  explicit CreateOrUpdateWebhookContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (webhookContact) {
      res["WebhookContact"] = webhookContact ? boost::any(webhookContact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WebhookContact") != m.end() && !m["WebhookContact"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebhookContact"].type()) {
        CreateOrUpdateWebhookContactResponseBodyWebhookContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebhookContact"]));
        webhookContact = make_shared<CreateOrUpdateWebhookContactResponseBodyWebhookContact>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateWebhookContactResponseBody() = default;
};
class CreateOrUpdateWebhookContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateWebhookContactResponseBody> body{};

  CreateOrUpdateWebhookContactResponse() {}

  explicit CreateOrUpdateWebhookContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateWebhookContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateWebhookContactResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateWebhookContactResponse() = default;
};
class CreatePrometheusAlertRuleRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreatePrometheusAlertRuleRequestTags() {}

  explicit CreatePrometheusAlertRuleRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleRequestTags() = default;
};
class CreatePrometheusAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<string> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<string> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreatePrometheusAlertRuleRequestTags>> tags{};
  shared_ptr<string> type{};

  CreatePrometheusAlertRuleRequest() {}

  explicit CreatePrometheusAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreatePrometheusAlertRuleRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePrometheusAlertRuleRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreatePrometheusAlertRuleRequestTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleRequest() = default;
};
class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() {}

  explicit CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() = default;
};
class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() {}

  explicit CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() = default;
};
class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule() {}

  explicit CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>>(expect1);
      }
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule() = default;
};
class CreatePrometheusAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule> prometheusAlertRule{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreatePrometheusAlertRuleResponseBody() {}

  explicit CreatePrometheusAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (prometheusAlertRule) {
      res["PrometheusAlertRule"] = prometheusAlertRule ? boost::any(prometheusAlertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PrometheusAlertRule") != m.end() && !m["PrometheusAlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrometheusAlertRule"].type()) {
        CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrometheusAlertRule"]));
        prometheusAlertRule = make_shared<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleResponseBody() = default;
};
class CreatePrometheusAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePrometheusAlertRuleResponseBody> body{};

  CreatePrometheusAlertRuleResponse() {}

  explicit CreatePrometheusAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePrometheusAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePrometheusAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePrometheusAlertRuleResponse() = default;
};
class CreatePrometheusInstanceRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreatePrometheusInstanceRequestTags() {}

  explicit CreatePrometheusInstanceRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePrometheusInstanceRequestTags() = default;
};
class CreatePrometheusInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allSubClustersSuccess{};
  shared_ptr<long> archiveDuration{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<long> duration{};
  shared_ptr<string> grafanaInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> subClustersJson{};
  shared_ptr<vector<CreatePrometheusInstanceRequestTags>> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  CreatePrometheusInstanceRequest() {}

  explicit CreatePrometheusInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allSubClustersSuccess) {
      res["AllSubClustersSuccess"] = boost::any(*allSubClustersSuccess);
    }
    if (archiveDuration) {
      res["ArchiveDuration"] = boost::any(*archiveDuration);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (grafanaInstanceId) {
      res["GrafanaInstanceId"] = boost::any(*grafanaInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (subClustersJson) {
      res["SubClustersJson"] = boost::any(*subClustersJson);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllSubClustersSuccess") != m.end() && !m["AllSubClustersSuccess"].empty()) {
      allSubClustersSuccess = make_shared<bool>(boost::any_cast<bool>(m["AllSubClustersSuccess"]));
    }
    if (m.find("ArchiveDuration") != m.end() && !m["ArchiveDuration"].empty()) {
      archiveDuration = make_shared<long>(boost::any_cast<long>(m["ArchiveDuration"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("GrafanaInstanceId") != m.end() && !m["GrafanaInstanceId"].empty()) {
      grafanaInstanceId = make_shared<string>(boost::any_cast<string>(m["GrafanaInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SubClustersJson") != m.end() && !m["SubClustersJson"].empty()) {
      subClustersJson = make_shared<string>(boost::any_cast<string>(m["SubClustersJson"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreatePrometheusInstanceRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePrometheusInstanceRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreatePrometheusInstanceRequestTags>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreatePrometheusInstanceRequest() = default;
};
class CreatePrometheusInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreatePrometheusInstanceResponseBody() {}

  explicit CreatePrometheusInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePrometheusInstanceResponseBody() = default;
};
class CreatePrometheusInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePrometheusInstanceResponseBody> body{};

  CreatePrometheusInstanceResponse() {}

  explicit CreatePrometheusInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePrometheusInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePrometheusInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePrometheusInstanceResponse() = default;
};
class CreatePrometheusMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  CreatePrometheusMonitoringRequest() {}

  explicit CreatePrometheusMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreatePrometheusMonitoringRequest() = default;
};
class CreatePrometheusMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreatePrometheusMonitoringResponseBody() {}

  explicit CreatePrometheusMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePrometheusMonitoringResponseBody() = default;
};
class CreatePrometheusMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePrometheusMonitoringResponseBody> body{};

  CreatePrometheusMonitoringResponse() {}

  explicit CreatePrometheusMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePrometheusMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePrometheusMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePrometheusMonitoringResponse() = default;
};
class CreateRetcodeAppRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateRetcodeAppRequestTags() {}

  explicit CreateRetcodeAppRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateRetcodeAppRequestTags() = default;
};
class CreateRetcodeAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> retcodeAppName{};
  shared_ptr<string> retcodeAppType{};
  shared_ptr<vector<CreateRetcodeAppRequestTags>> tags{};

  CreateRetcodeAppRequest() {}

  explicit CreateRetcodeAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retcodeAppName) {
      res["RetcodeAppName"] = boost::any(*retcodeAppName);
    }
    if (retcodeAppType) {
      res["RetcodeAppType"] = boost::any(*retcodeAppType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetcodeAppName") != m.end() && !m["RetcodeAppName"].empty()) {
      retcodeAppName = make_shared<string>(boost::any_cast<string>(m["RetcodeAppName"]));
    }
    if (m.find("RetcodeAppType") != m.end() && !m["RetcodeAppType"].empty()) {
      retcodeAppType = make_shared<string>(boost::any_cast<string>(m["RetcodeAppType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateRetcodeAppRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRetcodeAppRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateRetcodeAppRequestTags>>(expect1);
      }
    }
  }


  virtual ~CreateRetcodeAppRequest() = default;
};
class CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags() {}

  explicit CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags() = default;
};
class CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags : public Darabonba::Model {
public:
  shared_ptr<vector<CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags>> tags{};

  CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags() {}

  explicit CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags>>(expect1);
      }
    }
  }


  virtual ~CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags() = default;
};
class CreateRetcodeAppResponseBodyRetcodeAppDataBean : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> pid{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags> tags{};

  CreateRetcodeAppResponseBodyRetcodeAppDataBean() {}

  explicit CreateRetcodeAppResponseBodyRetcodeAppDataBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags>(model1);
      }
    }
  }


  virtual ~CreateRetcodeAppResponseBodyRetcodeAppDataBean() = default;
};
class CreateRetcodeAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateRetcodeAppResponseBodyRetcodeAppDataBean> retcodeAppDataBean{};
  shared_ptr<bool> success{};

  CreateRetcodeAppResponseBody() {}

  explicit CreateRetcodeAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retcodeAppDataBean) {
      res["RetcodeAppDataBean"] = retcodeAppDataBean ? boost::any(retcodeAppDataBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetcodeAppDataBean") != m.end() && !m["RetcodeAppDataBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetcodeAppDataBean"].type()) {
        CreateRetcodeAppResponseBodyRetcodeAppDataBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetcodeAppDataBean"]));
        retcodeAppDataBean = make_shared<CreateRetcodeAppResponseBodyRetcodeAppDataBean>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateRetcodeAppResponseBody() = default;
};
class CreateRetcodeAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRetcodeAppResponseBody> body{};

  CreateRetcodeAppResponse() {}

  explicit CreateRetcodeAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRetcodeAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRetcodeAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRetcodeAppResponse() = default;
};
class CreateRumAppRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateRumAppRequestTag() {}

  explicit CreateRumAppRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateRumAppRequestTag() = default;
};
class CreateRumAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appGroup{};
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> nickName{};
  shared_ptr<string> packageName{};
  shared_ptr<string> realRegionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> siteType{};
  shared_ptr<string> source{};
  shared_ptr<vector<CreateRumAppRequestTag>> tag{};

  CreateRumAppRequest() {}

  explicit CreateRumAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGroup) {
      res["AppGroup"] = boost::any(*appGroup);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    if (realRegionId) {
      res["RealRegionId"] = boost::any(*realRegionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (siteType) {
      res["SiteType"] = boost::any(*siteType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGroup") != m.end() && !m["AppGroup"].empty()) {
      appGroup = make_shared<string>(boost::any_cast<string>(m["AppGroup"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
    if (m.find("RealRegionId") != m.end() && !m["RealRegionId"].empty()) {
      realRegionId = make_shared<string>(boost::any_cast<string>(m["RealRegionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SiteType") != m.end() && !m["SiteType"].empty()) {
      siteType = make_shared<string>(boost::any_cast<string>(m["SiteType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateRumAppRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRumAppRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateRumAppRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateRumAppRequest() = default;
};
class CreateRumAppShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appGroup{};
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> nickName{};
  shared_ptr<string> packageName{};
  shared_ptr<string> realRegionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> siteType{};
  shared_ptr<string> source{};
  shared_ptr<string> tagShrink{};

  CreateRumAppShrinkRequest() {}

  explicit CreateRumAppShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGroup) {
      res["AppGroup"] = boost::any(*appGroup);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    if (realRegionId) {
      res["RealRegionId"] = boost::any(*realRegionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (siteType) {
      res["SiteType"] = boost::any(*siteType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tagShrink) {
      res["Tag"] = boost::any(*tagShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGroup") != m.end() && !m["AppGroup"].empty()) {
      appGroup = make_shared<string>(boost::any_cast<string>(m["AppGroup"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
    if (m.find("RealRegionId") != m.end() && !m["RealRegionId"].empty()) {
      realRegionId = make_shared<string>(boost::any_cast<string>(m["RealRegionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SiteType") != m.end() && !m["SiteType"].empty()) {
      siteType = make_shared<string>(boost::any_cast<string>(m["SiteType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tagShrink = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~CreateRumAppShrinkRequest() = default;
};
class CreateRumAppResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> cdnDomain{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> pid{};

  CreateRumAppResponseBodyData() {}

  explicit CreateRumAppResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnDomain) {
      res["CdnDomain"] = boost::any(*cdnDomain);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnDomain") != m.end() && !m["CdnDomain"].empty()) {
      cdnDomain = make_shared<string>(boost::any_cast<string>(m["CdnDomain"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
  }


  virtual ~CreateRumAppResponseBodyData() = default;
};
class CreateRumAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CreateRumAppResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> success{};

  CreateRumAppResponseBody() {}

  explicit CreateRumAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateRumAppResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateRumAppResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateRumAppResponseBody() = default;
};
class CreateRumAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRumAppResponseBody> body{};

  CreateRumAppResponse() {}

  explicit CreateRumAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRumAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRumAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRumAppResponse() = default;
};
class CreateRumUploadFileUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> contentType{};
  shared_ptr<string> fileName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourcemapType{};
  shared_ptr<string> uuid{};
  shared_ptr<string> versionId{};

  CreateRumUploadFileUrlRequest() {}

  explicit CreateRumUploadFileUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourcemapType) {
      res["SourcemapType"] = boost::any(*sourcemapType);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourcemapType") != m.end() && !m["SourcemapType"].empty()) {
      sourcemapType = make_shared<string>(boost::any_cast<string>(m["SourcemapType"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~CreateRumUploadFileUrlRequest() = default;
};
class CreateRumUploadFileUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateRumUploadFileUrlResponseBody() {}

  explicit CreateRumUploadFileUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateRumUploadFileUrlResponseBody() = default;
};
class CreateRumUploadFileUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRumUploadFileUrlResponseBody> body{};

  CreateRumUploadFileUrlResponse() {}

  explicit CreateRumUploadFileUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRumUploadFileUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRumUploadFileUrlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRumUploadFileUrlResponse() = default;
};
class CreateSyntheticTaskRequestCommonParamAlertList : public Darabonba::Model {
public:
  shared_ptr<long> isCritical{};
  shared_ptr<string> name{};
  shared_ptr<long> symbols{};

  CreateSyntheticTaskRequestCommonParamAlertList() {}

  explicit CreateSyntheticTaskRequestCommonParamAlertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCritical) {
      res["IsCritical"] = boost::any(*isCritical);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (symbols) {
      res["Symbols"] = boost::any(*symbols);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCritical") != m.end() && !m["IsCritical"].empty()) {
      isCritical = make_shared<long>(boost::any_cast<long>(m["IsCritical"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Symbols") != m.end() && !m["Symbols"].empty()) {
      symbols = make_shared<long>(boost::any_cast<long>(m["Symbols"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestCommonParamAlertList() = default;
};
class CreateSyntheticTaskRequestCommonParam : public Darabonba::Model {
public:
  shared_ptr<string> alarmFlag{};
  shared_ptr<vector<CreateSyntheticTaskRequestCommonParamAlertList>> alertList{};
  shared_ptr<string> alertNotifierId{};
  shared_ptr<string> alertPolicyId{};
  shared_ptr<long> monitorSamples{};
  shared_ptr<long> startExecutionTime{};

  CreateSyntheticTaskRequestCommonParam() {}

  explicit CreateSyntheticTaskRequestCommonParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmFlag) {
      res["AlarmFlag"] = boost::any(*alarmFlag);
    }
    if (alertList) {
      vector<boost::any> temp1;
      for(auto item1:*alertList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertList"] = boost::any(temp1);
    }
    if (alertNotifierId) {
      res["AlertNotifierId"] = boost::any(*alertNotifierId);
    }
    if (alertPolicyId) {
      res["AlertPolicyId"] = boost::any(*alertPolicyId);
    }
    if (monitorSamples) {
      res["MonitorSamples"] = boost::any(*monitorSamples);
    }
    if (startExecutionTime) {
      res["StartExecutionTime"] = boost::any(*startExecutionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmFlag") != m.end() && !m["AlarmFlag"].empty()) {
      alarmFlag = make_shared<string>(boost::any_cast<string>(m["AlarmFlag"]));
    }
    if (m.find("AlertList") != m.end() && !m["AlertList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertList"].type()) {
        vector<CreateSyntheticTaskRequestCommonParamAlertList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSyntheticTaskRequestCommonParamAlertList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertList = make_shared<vector<CreateSyntheticTaskRequestCommonParamAlertList>>(expect1);
      }
    }
    if (m.find("AlertNotifierId") != m.end() && !m["AlertNotifierId"].empty()) {
      alertNotifierId = make_shared<string>(boost::any_cast<string>(m["AlertNotifierId"]));
    }
    if (m.find("AlertPolicyId") != m.end() && !m["AlertPolicyId"].empty()) {
      alertPolicyId = make_shared<string>(boost::any_cast<string>(m["AlertPolicyId"]));
    }
    if (m.find("MonitorSamples") != m.end() && !m["MonitorSamples"].empty()) {
      monitorSamples = make_shared<long>(boost::any_cast<long>(m["MonitorSamples"]));
    }
    if (m.find("StartExecutionTime") != m.end() && !m["StartExecutionTime"].empty()) {
      startExecutionTime = make_shared<long>(boost::any_cast<long>(m["StartExecutionTime"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestCommonParam() = default;
};
class CreateSyntheticTaskRequestDownload : public Darabonba::Model {
public:
  shared_ptr<double> connectionTimeout{};
  shared_ptr<string> downloadCustomHeaderContent{};
  shared_ptr<long> downloadCustomHost{};
  shared_ptr<string> downloadCustomHostIp{};
  shared_ptr<string> downloadIgnoreCertificateError{};
  shared_ptr<long> downloadKernel{};
  shared_ptr<long> downloadRedirection{};
  shared_ptr<long> downloadTransmissionSize{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<string> quickProtocol{};
  shared_ptr<string> validateKeywords{};
  shared_ptr<long> verifyWay{};
  shared_ptr<string> whiteList{};

  CreateSyntheticTaskRequestDownload() {}

  explicit CreateSyntheticTaskRequestDownload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionTimeout) {
      res["ConnectionTimeout"] = boost::any(*connectionTimeout);
    }
    if (downloadCustomHeaderContent) {
      res["DownloadCustomHeaderContent"] = boost::any(*downloadCustomHeaderContent);
    }
    if (downloadCustomHost) {
      res["DownloadCustomHost"] = boost::any(*downloadCustomHost);
    }
    if (downloadCustomHostIp) {
      res["DownloadCustomHostIp"] = boost::any(*downloadCustomHostIp);
    }
    if (downloadIgnoreCertificateError) {
      res["DownloadIgnoreCertificateError"] = boost::any(*downloadIgnoreCertificateError);
    }
    if (downloadKernel) {
      res["DownloadKernel"] = boost::any(*downloadKernel);
    }
    if (downloadRedirection) {
      res["DownloadRedirection"] = boost::any(*downloadRedirection);
    }
    if (downloadTransmissionSize) {
      res["DownloadTransmissionSize"] = boost::any(*downloadTransmissionSize);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (quickProtocol) {
      res["QuickProtocol"] = boost::any(*quickProtocol);
    }
    if (validateKeywords) {
      res["ValidateKeywords"] = boost::any(*validateKeywords);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionTimeout") != m.end() && !m["ConnectionTimeout"].empty()) {
      connectionTimeout = make_shared<double>(boost::any_cast<double>(m["ConnectionTimeout"]));
    }
    if (m.find("DownloadCustomHeaderContent") != m.end() && !m["DownloadCustomHeaderContent"].empty()) {
      downloadCustomHeaderContent = make_shared<string>(boost::any_cast<string>(m["DownloadCustomHeaderContent"]));
    }
    if (m.find("DownloadCustomHost") != m.end() && !m["DownloadCustomHost"].empty()) {
      downloadCustomHost = make_shared<long>(boost::any_cast<long>(m["DownloadCustomHost"]));
    }
    if (m.find("DownloadCustomHostIp") != m.end() && !m["DownloadCustomHostIp"].empty()) {
      downloadCustomHostIp = make_shared<string>(boost::any_cast<string>(m["DownloadCustomHostIp"]));
    }
    if (m.find("DownloadIgnoreCertificateError") != m.end() && !m["DownloadIgnoreCertificateError"].empty()) {
      downloadIgnoreCertificateError = make_shared<string>(boost::any_cast<string>(m["DownloadIgnoreCertificateError"]));
    }
    if (m.find("DownloadKernel") != m.end() && !m["DownloadKernel"].empty()) {
      downloadKernel = make_shared<long>(boost::any_cast<long>(m["DownloadKernel"]));
    }
    if (m.find("DownloadRedirection") != m.end() && !m["DownloadRedirection"].empty()) {
      downloadRedirection = make_shared<long>(boost::any_cast<long>(m["DownloadRedirection"]));
    }
    if (m.find("DownloadTransmissionSize") != m.end() && !m["DownloadTransmissionSize"].empty()) {
      downloadTransmissionSize = make_shared<long>(boost::any_cast<long>(m["DownloadTransmissionSize"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("QuickProtocol") != m.end() && !m["QuickProtocol"].empty()) {
      quickProtocol = make_shared<string>(boost::any_cast<string>(m["QuickProtocol"]));
    }
    if (m.find("ValidateKeywords") != m.end() && !m["ValidateKeywords"].empty()) {
      validateKeywords = make_shared<string>(boost::any_cast<string>(m["ValidateKeywords"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestDownload() = default;
};
class CreateSyntheticTaskRequestExtendInterval : public Darabonba::Model {
public:
  shared_ptr<vector<long>> days{};
  shared_ptr<long> endHour{};
  shared_ptr<long> endMinute{};
  shared_ptr<string> endTime{};
  shared_ptr<long> startHour{};
  shared_ptr<long> startMinute{};
  shared_ptr<string> startTime{};

  CreateSyntheticTaskRequestExtendInterval() {}

  explicit CreateSyntheticTaskRequestExtendInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (endHour) {
      res["EndHour"] = boost::any(*endHour);
    }
    if (endMinute) {
      res["EndMinute"] = boost::any(*endMinute);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startHour) {
      res["StartHour"] = boost::any(*startHour);
    }
    if (startMinute) {
      res["StartMinute"] = boost::any(*startMinute);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Days"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Days"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      days = make_shared<vector<long>>(toVec1);
    }
    if (m.find("EndHour") != m.end() && !m["EndHour"].empty()) {
      endHour = make_shared<long>(boost::any_cast<long>(m["EndHour"]));
    }
    if (m.find("EndMinute") != m.end() && !m["EndMinute"].empty()) {
      endMinute = make_shared<long>(boost::any_cast<long>(m["EndMinute"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartHour") != m.end() && !m["StartHour"].empty()) {
      startHour = make_shared<long>(boost::any_cast<long>(m["StartHour"]));
    }
    if (m.find("StartMinute") != m.end() && !m["StartMinute"].empty()) {
      startMinute = make_shared<long>(boost::any_cast<long>(m["StartMinute"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestExtendInterval() = default;
};
class CreateSyntheticTaskRequestMonitorList : public Darabonba::Model {
public:
  shared_ptr<long> cityCode{};
  shared_ptr<long> monitorType{};
  shared_ptr<long> netServiceId{};

  CreateSyntheticTaskRequestMonitorList() {}

  explicit CreateSyntheticTaskRequestMonitorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (monitorType) {
      res["MonitorType"] = boost::any(*monitorType);
    }
    if (netServiceId) {
      res["NetServiceId"] = boost::any(*netServiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("MonitorType") != m.end() && !m["MonitorType"].empty()) {
      monitorType = make_shared<long>(boost::any_cast<long>(m["MonitorType"]));
    }
    if (m.find("NetServiceId") != m.end() && !m["NetServiceId"].empty()) {
      netServiceId = make_shared<long>(boost::any_cast<long>(m["NetServiceId"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestMonitorList() = default;
};
class CreateSyntheticTaskRequestNavigation : public Darabonba::Model {
public:
  shared_ptr<string> DNSHijackWhiteList{};
  shared_ptr<string> elementBlacklist{};
  shared_ptr<long> executeActiveX{};
  shared_ptr<long> executeApplication{};
  shared_ptr<long> executeScript{};
  shared_ptr<long> filterInvalidIP{};
  shared_ptr<long> flowHijackJumpTimes{};
  shared_ptr<string> flowHijackLogo{};
  shared_ptr<string> monitorTimeout{};
  shared_ptr<string> navAutomaticScrolling{};
  shared_ptr<string> navCustomHeader{};
  shared_ptr<string> navCustomHeaderContent{};
  shared_ptr<long> navCustomHost{};
  shared_ptr<string> navCustomHostIp{};
  shared_ptr<long> navDisableCache{};
  shared_ptr<string> navDisableCompression{};
  shared_ptr<long> navIgnoreCertificateError{};
  shared_ptr<long> navRedirection{};
  shared_ptr<long> navReturnElement{};
  shared_ptr<string> pageTamper{};
  shared_ptr<string> processName{};
  shared_ptr<string> QUICDomain{};
  shared_ptr<long> QUICVersion{};
  shared_ptr<long> requestHeader{};
  shared_ptr<long> responseHeader{};
  shared_ptr<double> slowElementThreshold{};
  shared_ptr<string> verifyStringBlacklist{};
  shared_ptr<string> verifyStringWhiteList{};
  shared_ptr<double> waitCompletionTime{};

  CreateSyntheticTaskRequestNavigation() {}

  explicit CreateSyntheticTaskRequestNavigation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DNSHijackWhiteList) {
      res["DNSHijackWhiteList"] = boost::any(*DNSHijackWhiteList);
    }
    if (elementBlacklist) {
      res["ElementBlacklist"] = boost::any(*elementBlacklist);
    }
    if (executeActiveX) {
      res["ExecuteActiveX"] = boost::any(*executeActiveX);
    }
    if (executeApplication) {
      res["ExecuteApplication"] = boost::any(*executeApplication);
    }
    if (executeScript) {
      res["ExecuteScript"] = boost::any(*executeScript);
    }
    if (filterInvalidIP) {
      res["FilterInvalidIP"] = boost::any(*filterInvalidIP);
    }
    if (flowHijackJumpTimes) {
      res["FlowHijackJumpTimes"] = boost::any(*flowHijackJumpTimes);
    }
    if (flowHijackLogo) {
      res["FlowHijackLogo"] = boost::any(*flowHijackLogo);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (navAutomaticScrolling) {
      res["NavAutomaticScrolling"] = boost::any(*navAutomaticScrolling);
    }
    if (navCustomHeader) {
      res["NavCustomHeader"] = boost::any(*navCustomHeader);
    }
    if (navCustomHeaderContent) {
      res["NavCustomHeaderContent"] = boost::any(*navCustomHeaderContent);
    }
    if (navCustomHost) {
      res["NavCustomHost"] = boost::any(*navCustomHost);
    }
    if (navCustomHostIp) {
      res["NavCustomHostIp"] = boost::any(*navCustomHostIp);
    }
    if (navDisableCache) {
      res["NavDisableCache"] = boost::any(*navDisableCache);
    }
    if (navDisableCompression) {
      res["NavDisableCompression"] = boost::any(*navDisableCompression);
    }
    if (navIgnoreCertificateError) {
      res["NavIgnoreCertificateError"] = boost::any(*navIgnoreCertificateError);
    }
    if (navRedirection) {
      res["NavRedirection"] = boost::any(*navRedirection);
    }
    if (navReturnElement) {
      res["NavReturnElement"] = boost::any(*navReturnElement);
    }
    if (pageTamper) {
      res["PageTamper"] = boost::any(*pageTamper);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (QUICDomain) {
      res["QUICDomain"] = boost::any(*QUICDomain);
    }
    if (QUICVersion) {
      res["QUICVersion"] = boost::any(*QUICVersion);
    }
    if (requestHeader) {
      res["RequestHeader"] = boost::any(*requestHeader);
    }
    if (responseHeader) {
      res["ResponseHeader"] = boost::any(*responseHeader);
    }
    if (slowElementThreshold) {
      res["SlowElementThreshold"] = boost::any(*slowElementThreshold);
    }
    if (verifyStringBlacklist) {
      res["VerifyStringBlacklist"] = boost::any(*verifyStringBlacklist);
    }
    if (verifyStringWhiteList) {
      res["VerifyStringWhiteList"] = boost::any(*verifyStringWhiteList);
    }
    if (waitCompletionTime) {
      res["WaitCompletionTime"] = boost::any(*waitCompletionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DNSHijackWhiteList") != m.end() && !m["DNSHijackWhiteList"].empty()) {
      DNSHijackWhiteList = make_shared<string>(boost::any_cast<string>(m["DNSHijackWhiteList"]));
    }
    if (m.find("ElementBlacklist") != m.end() && !m["ElementBlacklist"].empty()) {
      elementBlacklist = make_shared<string>(boost::any_cast<string>(m["ElementBlacklist"]));
    }
    if (m.find("ExecuteActiveX") != m.end() && !m["ExecuteActiveX"].empty()) {
      executeActiveX = make_shared<long>(boost::any_cast<long>(m["ExecuteActiveX"]));
    }
    if (m.find("ExecuteApplication") != m.end() && !m["ExecuteApplication"].empty()) {
      executeApplication = make_shared<long>(boost::any_cast<long>(m["ExecuteApplication"]));
    }
    if (m.find("ExecuteScript") != m.end() && !m["ExecuteScript"].empty()) {
      executeScript = make_shared<long>(boost::any_cast<long>(m["ExecuteScript"]));
    }
    if (m.find("FilterInvalidIP") != m.end() && !m["FilterInvalidIP"].empty()) {
      filterInvalidIP = make_shared<long>(boost::any_cast<long>(m["FilterInvalidIP"]));
    }
    if (m.find("FlowHijackJumpTimes") != m.end() && !m["FlowHijackJumpTimes"].empty()) {
      flowHijackJumpTimes = make_shared<long>(boost::any_cast<long>(m["FlowHijackJumpTimes"]));
    }
    if (m.find("FlowHijackLogo") != m.end() && !m["FlowHijackLogo"].empty()) {
      flowHijackLogo = make_shared<string>(boost::any_cast<string>(m["FlowHijackLogo"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<string>(boost::any_cast<string>(m["MonitorTimeout"]));
    }
    if (m.find("NavAutomaticScrolling") != m.end() && !m["NavAutomaticScrolling"].empty()) {
      navAutomaticScrolling = make_shared<string>(boost::any_cast<string>(m["NavAutomaticScrolling"]));
    }
    if (m.find("NavCustomHeader") != m.end() && !m["NavCustomHeader"].empty()) {
      navCustomHeader = make_shared<string>(boost::any_cast<string>(m["NavCustomHeader"]));
    }
    if (m.find("NavCustomHeaderContent") != m.end() && !m["NavCustomHeaderContent"].empty()) {
      navCustomHeaderContent = make_shared<string>(boost::any_cast<string>(m["NavCustomHeaderContent"]));
    }
    if (m.find("NavCustomHost") != m.end() && !m["NavCustomHost"].empty()) {
      navCustomHost = make_shared<long>(boost::any_cast<long>(m["NavCustomHost"]));
    }
    if (m.find("NavCustomHostIp") != m.end() && !m["NavCustomHostIp"].empty()) {
      navCustomHostIp = make_shared<string>(boost::any_cast<string>(m["NavCustomHostIp"]));
    }
    if (m.find("NavDisableCache") != m.end() && !m["NavDisableCache"].empty()) {
      navDisableCache = make_shared<long>(boost::any_cast<long>(m["NavDisableCache"]));
    }
    if (m.find("NavDisableCompression") != m.end() && !m["NavDisableCompression"].empty()) {
      navDisableCompression = make_shared<string>(boost::any_cast<string>(m["NavDisableCompression"]));
    }
    if (m.find("NavIgnoreCertificateError") != m.end() && !m["NavIgnoreCertificateError"].empty()) {
      navIgnoreCertificateError = make_shared<long>(boost::any_cast<long>(m["NavIgnoreCertificateError"]));
    }
    if (m.find("NavRedirection") != m.end() && !m["NavRedirection"].empty()) {
      navRedirection = make_shared<long>(boost::any_cast<long>(m["NavRedirection"]));
    }
    if (m.find("NavReturnElement") != m.end() && !m["NavReturnElement"].empty()) {
      navReturnElement = make_shared<long>(boost::any_cast<long>(m["NavReturnElement"]));
    }
    if (m.find("PageTamper") != m.end() && !m["PageTamper"].empty()) {
      pageTamper = make_shared<string>(boost::any_cast<string>(m["PageTamper"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("QUICDomain") != m.end() && !m["QUICDomain"].empty()) {
      QUICDomain = make_shared<string>(boost::any_cast<string>(m["QUICDomain"]));
    }
    if (m.find("QUICVersion") != m.end() && !m["QUICVersion"].empty()) {
      QUICVersion = make_shared<long>(boost::any_cast<long>(m["QUICVersion"]));
    }
    if (m.find("RequestHeader") != m.end() && !m["RequestHeader"].empty()) {
      requestHeader = make_shared<long>(boost::any_cast<long>(m["RequestHeader"]));
    }
    if (m.find("ResponseHeader") != m.end() && !m["ResponseHeader"].empty()) {
      responseHeader = make_shared<long>(boost::any_cast<long>(m["ResponseHeader"]));
    }
    if (m.find("SlowElementThreshold") != m.end() && !m["SlowElementThreshold"].empty()) {
      slowElementThreshold = make_shared<double>(boost::any_cast<double>(m["SlowElementThreshold"]));
    }
    if (m.find("VerifyStringBlacklist") != m.end() && !m["VerifyStringBlacklist"].empty()) {
      verifyStringBlacklist = make_shared<string>(boost::any_cast<string>(m["VerifyStringBlacklist"]));
    }
    if (m.find("VerifyStringWhiteList") != m.end() && !m["VerifyStringWhiteList"].empty()) {
      verifyStringWhiteList = make_shared<string>(boost::any_cast<string>(m["VerifyStringWhiteList"]));
    }
    if (m.find("WaitCompletionTime") != m.end() && !m["WaitCompletionTime"].empty()) {
      waitCompletionTime = make_shared<double>(boost::any_cast<double>(m["WaitCompletionTime"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestNavigation() = default;
};
class CreateSyntheticTaskRequestNet : public Darabonba::Model {
public:
  shared_ptr<string> netDNSNs{};
  shared_ptr<long> netDNSQueryMethod{};
  shared_ptr<long> netDNSServer{};
  shared_ptr<long> netDNSSwitch{};
  shared_ptr<long> netDNSTimeout{};
  shared_ptr<long> netDigSwitch{};
  shared_ptr<long> netICMPActive{};
  shared_ptr<long> netICMPDataCut{};
  shared_ptr<long> netICMPInterval{};
  shared_ptr<long> netICMPNum{};
  shared_ptr<long> netICMPSize{};
  shared_ptr<long> netICMPSwitch{};
  shared_ptr<long> netICMPTimeout{};
  shared_ptr<long> netTraceRouteNum{};
  shared_ptr<long> netTraceRouteSwitch{};
  shared_ptr<long> netTraceRouteTimeout{};
  shared_ptr<string> whiteList{};

  CreateSyntheticTaskRequestNet() {}

  explicit CreateSyntheticTaskRequestNet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (netDNSNs) {
      res["NetDNSNs"] = boost::any(*netDNSNs);
    }
    if (netDNSQueryMethod) {
      res["NetDNSQueryMethod"] = boost::any(*netDNSQueryMethod);
    }
    if (netDNSServer) {
      res["NetDNSServer"] = boost::any(*netDNSServer);
    }
    if (netDNSSwitch) {
      res["NetDNSSwitch"] = boost::any(*netDNSSwitch);
    }
    if (netDNSTimeout) {
      res["NetDNSTimeout"] = boost::any(*netDNSTimeout);
    }
    if (netDigSwitch) {
      res["NetDigSwitch"] = boost::any(*netDigSwitch);
    }
    if (netICMPActive) {
      res["NetICMPActive"] = boost::any(*netICMPActive);
    }
    if (netICMPDataCut) {
      res["NetICMPDataCut"] = boost::any(*netICMPDataCut);
    }
    if (netICMPInterval) {
      res["NetICMPInterval"] = boost::any(*netICMPInterval);
    }
    if (netICMPNum) {
      res["NetICMPNum"] = boost::any(*netICMPNum);
    }
    if (netICMPSize) {
      res["NetICMPSize"] = boost::any(*netICMPSize);
    }
    if (netICMPSwitch) {
      res["NetICMPSwitch"] = boost::any(*netICMPSwitch);
    }
    if (netICMPTimeout) {
      res["NetICMPTimeout"] = boost::any(*netICMPTimeout);
    }
    if (netTraceRouteNum) {
      res["NetTraceRouteNum"] = boost::any(*netTraceRouteNum);
    }
    if (netTraceRouteSwitch) {
      res["NetTraceRouteSwitch"] = boost::any(*netTraceRouteSwitch);
    }
    if (netTraceRouteTimeout) {
      res["NetTraceRouteTimeout"] = boost::any(*netTraceRouteTimeout);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetDNSNs") != m.end() && !m["NetDNSNs"].empty()) {
      netDNSNs = make_shared<string>(boost::any_cast<string>(m["NetDNSNs"]));
    }
    if (m.find("NetDNSQueryMethod") != m.end() && !m["NetDNSQueryMethod"].empty()) {
      netDNSQueryMethod = make_shared<long>(boost::any_cast<long>(m["NetDNSQueryMethod"]));
    }
    if (m.find("NetDNSServer") != m.end() && !m["NetDNSServer"].empty()) {
      netDNSServer = make_shared<long>(boost::any_cast<long>(m["NetDNSServer"]));
    }
    if (m.find("NetDNSSwitch") != m.end() && !m["NetDNSSwitch"].empty()) {
      netDNSSwitch = make_shared<long>(boost::any_cast<long>(m["NetDNSSwitch"]));
    }
    if (m.find("NetDNSTimeout") != m.end() && !m["NetDNSTimeout"].empty()) {
      netDNSTimeout = make_shared<long>(boost::any_cast<long>(m["NetDNSTimeout"]));
    }
    if (m.find("NetDigSwitch") != m.end() && !m["NetDigSwitch"].empty()) {
      netDigSwitch = make_shared<long>(boost::any_cast<long>(m["NetDigSwitch"]));
    }
    if (m.find("NetICMPActive") != m.end() && !m["NetICMPActive"].empty()) {
      netICMPActive = make_shared<long>(boost::any_cast<long>(m["NetICMPActive"]));
    }
    if (m.find("NetICMPDataCut") != m.end() && !m["NetICMPDataCut"].empty()) {
      netICMPDataCut = make_shared<long>(boost::any_cast<long>(m["NetICMPDataCut"]));
    }
    if (m.find("NetICMPInterval") != m.end() && !m["NetICMPInterval"].empty()) {
      netICMPInterval = make_shared<long>(boost::any_cast<long>(m["NetICMPInterval"]));
    }
    if (m.find("NetICMPNum") != m.end() && !m["NetICMPNum"].empty()) {
      netICMPNum = make_shared<long>(boost::any_cast<long>(m["NetICMPNum"]));
    }
    if (m.find("NetICMPSize") != m.end() && !m["NetICMPSize"].empty()) {
      netICMPSize = make_shared<long>(boost::any_cast<long>(m["NetICMPSize"]));
    }
    if (m.find("NetICMPSwitch") != m.end() && !m["NetICMPSwitch"].empty()) {
      netICMPSwitch = make_shared<long>(boost::any_cast<long>(m["NetICMPSwitch"]));
    }
    if (m.find("NetICMPTimeout") != m.end() && !m["NetICMPTimeout"].empty()) {
      netICMPTimeout = make_shared<long>(boost::any_cast<long>(m["NetICMPTimeout"]));
    }
    if (m.find("NetTraceRouteNum") != m.end() && !m["NetTraceRouteNum"].empty()) {
      netTraceRouteNum = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteNum"]));
    }
    if (m.find("NetTraceRouteSwitch") != m.end() && !m["NetTraceRouteSwitch"].empty()) {
      netTraceRouteSwitch = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteSwitch"]));
    }
    if (m.find("NetTraceRouteTimeout") != m.end() && !m["NetTraceRouteTimeout"].empty()) {
      netTraceRouteTimeout = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteTimeout"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestNet() = default;
};
class CreateSyntheticTaskRequestProtocolRequestContentBodyFormData : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateSyntheticTaskRequestProtocolRequestContentBodyFormData() {}

  explicit CreateSyntheticTaskRequestProtocolRequestContentBodyFormData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocolRequestContentBodyFormData() = default;
};
class CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding() {}

  explicit CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding() = default;
};
class CreateSyntheticTaskRequestProtocolRequestContentBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateSyntheticTaskRequestProtocolRequestContentBodyFormData>> formData{};
  shared_ptr<string> language{};
  shared_ptr<string> mode{};
  shared_ptr<string> raw{};
  shared_ptr<vector<CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding>> urlEncoding{};

  CreateSyntheticTaskRequestProtocolRequestContentBody() {}

  explicit CreateSyntheticTaskRequestProtocolRequestContentBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formData) {
      vector<boost::any> temp1;
      for(auto item1:*formData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FormData"] = boost::any(temp1);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (raw) {
      res["Raw"] = boost::any(*raw);
    }
    if (urlEncoding) {
      vector<boost::any> temp1;
      for(auto item1:*urlEncoding){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlEncoding"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FormData") != m.end() && !m["FormData"].empty()) {
      if (typeid(vector<boost::any>) == m["FormData"].type()) {
        vector<CreateSyntheticTaskRequestProtocolRequestContentBodyFormData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FormData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSyntheticTaskRequestProtocolRequestContentBodyFormData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        formData = make_shared<vector<CreateSyntheticTaskRequestProtocolRequestContentBodyFormData>>(expect1);
      }
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Raw") != m.end() && !m["Raw"].empty()) {
      raw = make_shared<string>(boost::any_cast<string>(m["Raw"]));
    }
    if (m.find("UrlEncoding") != m.end() && !m["UrlEncoding"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlEncoding"].type()) {
        vector<CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlEncoding"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlEncoding = make_shared<vector<CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding>>(expect1);
      }
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocolRequestContentBody() = default;
};
class CreateSyntheticTaskRequestProtocolRequestContentHeader : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateSyntheticTaskRequestProtocolRequestContentHeader() {}

  explicit CreateSyntheticTaskRequestProtocolRequestContentHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocolRequestContentHeader() = default;
};
class CreateSyntheticTaskRequestProtocolRequestContent : public Darabonba::Model {
public:
  shared_ptr<CreateSyntheticTaskRequestProtocolRequestContentBody> body{};
  shared_ptr<vector<CreateSyntheticTaskRequestProtocolRequestContentHeader>> header{};
  shared_ptr<string> method{};

  CreateSyntheticTaskRequestProtocolRequestContent() {}

  explicit CreateSyntheticTaskRequestProtocolRequestContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (header) {
      vector<boost::any> temp1;
      for(auto item1:*header){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Header"] = boost::any(temp1);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      if (typeid(map<string, boost::any>) == m["Body"].type()) {
        CreateSyntheticTaskRequestProtocolRequestContentBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Body"]));
        body = make_shared<CreateSyntheticTaskRequestProtocolRequestContentBody>(model1);
      }
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(vector<boost::any>) == m["Header"].type()) {
        vector<CreateSyntheticTaskRequestProtocolRequestContentHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Header"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSyntheticTaskRequestProtocolRequestContentHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        header = make_shared<vector<CreateSyntheticTaskRequestProtocolRequestContentHeader>>(expect1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocolRequestContent() = default;
};
class CreateSyntheticTaskRequestProtocol : public Darabonba::Model {
public:
  shared_ptr<long> characterEncoding{};
  shared_ptr<long> customHost{};
  shared_ptr<string> customHostIp{};
  shared_ptr<long> protocolConnectionTime{};
  shared_ptr<string> protocolMonitorTimeout{};
  shared_ptr<long> receivedDataSize{};
  shared_ptr<CreateSyntheticTaskRequestProtocolRequestContent> requestContent{};
  shared_ptr<string> verifyContent{};
  shared_ptr<long> verifyWay{};

  CreateSyntheticTaskRequestProtocol() {}

  explicit CreateSyntheticTaskRequestProtocol(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (characterEncoding) {
      res["CharacterEncoding"] = boost::any(*characterEncoding);
    }
    if (customHost) {
      res["CustomHost"] = boost::any(*customHost);
    }
    if (customHostIp) {
      res["CustomHostIp"] = boost::any(*customHostIp);
    }
    if (protocolConnectionTime) {
      res["ProtocolConnectionTime"] = boost::any(*protocolConnectionTime);
    }
    if (protocolMonitorTimeout) {
      res["ProtocolMonitorTimeout"] = boost::any(*protocolMonitorTimeout);
    }
    if (receivedDataSize) {
      res["ReceivedDataSize"] = boost::any(*receivedDataSize);
    }
    if (requestContent) {
      res["RequestContent"] = requestContent ? boost::any(requestContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (verifyContent) {
      res["VerifyContent"] = boost::any(*verifyContent);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharacterEncoding") != m.end() && !m["CharacterEncoding"].empty()) {
      characterEncoding = make_shared<long>(boost::any_cast<long>(m["CharacterEncoding"]));
    }
    if (m.find("CustomHost") != m.end() && !m["CustomHost"].empty()) {
      customHost = make_shared<long>(boost::any_cast<long>(m["CustomHost"]));
    }
    if (m.find("CustomHostIp") != m.end() && !m["CustomHostIp"].empty()) {
      customHostIp = make_shared<string>(boost::any_cast<string>(m["CustomHostIp"]));
    }
    if (m.find("ProtocolConnectionTime") != m.end() && !m["ProtocolConnectionTime"].empty()) {
      protocolConnectionTime = make_shared<long>(boost::any_cast<long>(m["ProtocolConnectionTime"]));
    }
    if (m.find("ProtocolMonitorTimeout") != m.end() && !m["ProtocolMonitorTimeout"].empty()) {
      protocolMonitorTimeout = make_shared<string>(boost::any_cast<string>(m["ProtocolMonitorTimeout"]));
    }
    if (m.find("ReceivedDataSize") != m.end() && !m["ReceivedDataSize"].empty()) {
      receivedDataSize = make_shared<long>(boost::any_cast<long>(m["ReceivedDataSize"]));
    }
    if (m.find("RequestContent") != m.end() && !m["RequestContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestContent"].type()) {
        CreateSyntheticTaskRequestProtocolRequestContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestContent"]));
        requestContent = make_shared<CreateSyntheticTaskRequestProtocolRequestContent>(model1);
      }
    }
    if (m.find("VerifyContent") != m.end() && !m["VerifyContent"].empty()) {
      verifyContent = make_shared<string>(boost::any_cast<string>(m["VerifyContent"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocol() = default;
};
class CreateSyntheticTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CreateSyntheticTaskRequestCommonParam> commonParam{};
  shared_ptr<CreateSyntheticTaskRequestDownload> download{};
  shared_ptr<CreateSyntheticTaskRequestExtendInterval> extendInterval{};
  shared_ptr<string> intervalTime{};
  shared_ptr<string> intervalType{};
  shared_ptr<long> ipType{};
  shared_ptr<vector<CreateSyntheticTaskRequestMonitorList>> monitorList{};
  shared_ptr<CreateSyntheticTaskRequestNavigation> navigation{};
  shared_ptr<CreateSyntheticTaskRequestNet> net{};
  shared_ptr<CreateSyntheticTaskRequestProtocol> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskType{};
  shared_ptr<bool> updateTask{};
  shared_ptr<string> url{};

  CreateSyntheticTaskRequest() {}

  explicit CreateSyntheticTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonParam) {
      res["CommonParam"] = commonParam ? boost::any(commonParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (download) {
      res["Download"] = download ? boost::any(download->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendInterval) {
      res["ExtendInterval"] = extendInterval ? boost::any(extendInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (intervalTime) {
      res["IntervalTime"] = boost::any(*intervalTime);
    }
    if (intervalType) {
      res["IntervalType"] = boost::any(*intervalType);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (monitorList) {
      vector<boost::any> temp1;
      for(auto item1:*monitorList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorList"] = boost::any(temp1);
    }
    if (navigation) {
      res["Navigation"] = navigation ? boost::any(navigation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (net) {
      res["Net"] = net ? boost::any(net->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocol) {
      res["Protocol"] = protocol ? boost::any(protocol->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (updateTask) {
      res["UpdateTask"] = boost::any(*updateTask);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonParam") != m.end() && !m["CommonParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonParam"].type()) {
        CreateSyntheticTaskRequestCommonParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonParam"]));
        commonParam = make_shared<CreateSyntheticTaskRequestCommonParam>(model1);
      }
    }
    if (m.find("Download") != m.end() && !m["Download"].empty()) {
      if (typeid(map<string, boost::any>) == m["Download"].type()) {
        CreateSyntheticTaskRequestDownload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Download"]));
        download = make_shared<CreateSyntheticTaskRequestDownload>(model1);
      }
    }
    if (m.find("ExtendInterval") != m.end() && !m["ExtendInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendInterval"].type()) {
        CreateSyntheticTaskRequestExtendInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendInterval"]));
        extendInterval = make_shared<CreateSyntheticTaskRequestExtendInterval>(model1);
      }
    }
    if (m.find("IntervalTime") != m.end() && !m["IntervalTime"].empty()) {
      intervalTime = make_shared<string>(boost::any_cast<string>(m["IntervalTime"]));
    }
    if (m.find("IntervalType") != m.end() && !m["IntervalType"].empty()) {
      intervalType = make_shared<string>(boost::any_cast<string>(m["IntervalType"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("MonitorList") != m.end() && !m["MonitorList"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorList"].type()) {
        vector<CreateSyntheticTaskRequestMonitorList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSyntheticTaskRequestMonitorList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorList = make_shared<vector<CreateSyntheticTaskRequestMonitorList>>(expect1);
      }
    }
    if (m.find("Navigation") != m.end() && !m["Navigation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Navigation"].type()) {
        CreateSyntheticTaskRequestNavigation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Navigation"]));
        navigation = make_shared<CreateSyntheticTaskRequestNavigation>(model1);
      }
    }
    if (m.find("Net") != m.end() && !m["Net"].empty()) {
      if (typeid(map<string, boost::any>) == m["Net"].type()) {
        CreateSyntheticTaskRequestNet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Net"]));
        net = make_shared<CreateSyntheticTaskRequestNet>(model1);
      }
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      if (typeid(map<string, boost::any>) == m["Protocol"].type()) {
        CreateSyntheticTaskRequestProtocol model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Protocol"]));
        protocol = make_shared<CreateSyntheticTaskRequestProtocol>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("UpdateTask") != m.end() && !m["UpdateTask"].empty()) {
      updateTask = make_shared<bool>(boost::any_cast<bool>(m["UpdateTask"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateSyntheticTaskRequest() = default;
};
class CreateSyntheticTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> commonParamShrink{};
  shared_ptr<string> downloadShrink{};
  shared_ptr<string> extendIntervalShrink{};
  shared_ptr<string> intervalTime{};
  shared_ptr<string> intervalType{};
  shared_ptr<long> ipType{};
  shared_ptr<string> monitorListShrink{};
  shared_ptr<string> navigationShrink{};
  shared_ptr<string> netShrink{};
  shared_ptr<string> protocolShrink{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskType{};
  shared_ptr<bool> updateTask{};
  shared_ptr<string> url{};

  CreateSyntheticTaskShrinkRequest() {}

  explicit CreateSyntheticTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonParamShrink) {
      res["CommonParam"] = boost::any(*commonParamShrink);
    }
    if (downloadShrink) {
      res["Download"] = boost::any(*downloadShrink);
    }
    if (extendIntervalShrink) {
      res["ExtendInterval"] = boost::any(*extendIntervalShrink);
    }
    if (intervalTime) {
      res["IntervalTime"] = boost::any(*intervalTime);
    }
    if (intervalType) {
      res["IntervalType"] = boost::any(*intervalType);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (monitorListShrink) {
      res["MonitorList"] = boost::any(*monitorListShrink);
    }
    if (navigationShrink) {
      res["Navigation"] = boost::any(*navigationShrink);
    }
    if (netShrink) {
      res["Net"] = boost::any(*netShrink);
    }
    if (protocolShrink) {
      res["Protocol"] = boost::any(*protocolShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (updateTask) {
      res["UpdateTask"] = boost::any(*updateTask);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonParam") != m.end() && !m["CommonParam"].empty()) {
      commonParamShrink = make_shared<string>(boost::any_cast<string>(m["CommonParam"]));
    }
    if (m.find("Download") != m.end() && !m["Download"].empty()) {
      downloadShrink = make_shared<string>(boost::any_cast<string>(m["Download"]));
    }
    if (m.find("ExtendInterval") != m.end() && !m["ExtendInterval"].empty()) {
      extendIntervalShrink = make_shared<string>(boost::any_cast<string>(m["ExtendInterval"]));
    }
    if (m.find("IntervalTime") != m.end() && !m["IntervalTime"].empty()) {
      intervalTime = make_shared<string>(boost::any_cast<string>(m["IntervalTime"]));
    }
    if (m.find("IntervalType") != m.end() && !m["IntervalType"].empty()) {
      intervalType = make_shared<string>(boost::any_cast<string>(m["IntervalType"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("MonitorList") != m.end() && !m["MonitorList"].empty()) {
      monitorListShrink = make_shared<string>(boost::any_cast<string>(m["MonitorList"]));
    }
    if (m.find("Navigation") != m.end() && !m["Navigation"].empty()) {
      navigationShrink = make_shared<string>(boost::any_cast<string>(m["Navigation"]));
    }
    if (m.find("Net") != m.end() && !m["Net"].empty()) {
      netShrink = make_shared<string>(boost::any_cast<string>(m["Net"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocolShrink = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("UpdateTask") != m.end() && !m["UpdateTask"].empty()) {
      updateTask = make_shared<bool>(boost::any_cast<bool>(m["UpdateTask"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateSyntheticTaskShrinkRequest() = default;
};
class CreateSyntheticTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> taskId{};

  CreateSyntheticTaskResponseBodyData() {}

  explicit CreateSyntheticTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~CreateSyntheticTaskResponseBodyData() = default;
};
class CreateSyntheticTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateSyntheticTaskResponseBodyData> data{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  CreateSyntheticTaskResponseBody() {}

  explicit CreateSyntheticTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateSyntheticTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateSyntheticTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSyntheticTaskResponseBody() = default;
};
class CreateSyntheticTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSyntheticTaskResponseBody> body{};

  CreateSyntheticTaskResponse() {}

  explicit CreateSyntheticTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSyntheticTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSyntheticTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSyntheticTaskResponse() = default;
};
class CreateTimingSyntheticTaskRequestAvailableAssertions : public Darabonba::Model {
public:
  shared_ptr<string> expect{};
  shared_ptr<string> operator_{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  CreateTimingSyntheticTaskRequestAvailableAssertions() {}

  explicit CreateTimingSyntheticTaskRequestAvailableAssertions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expect) {
      res["Expect"] = boost::any(*expect);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expect") != m.end() && !m["Expect"].empty()) {
      expect = make_shared<string>(boost::any_cast<string>(m["Expect"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestAvailableAssertions() = default;
};
class CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ipType{};
  shared_ptr<vector<string>> ips{};

  CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts() {}

  explicit CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts() = default;
};
class CreateTimingSyntheticTaskRequestCommonSettingCustomHost : public Darabonba::Model {
public:
  shared_ptr<vector<CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts>> hosts{};
  shared_ptr<long> selectType{};

  CreateTimingSyntheticTaskRequestCommonSettingCustomHost() {}

  explicit CreateTimingSyntheticTaskRequestCommonSettingCustomHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (selectType) {
      res["SelectType"] = boost::any(*selectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts>>(expect1);
      }
    }
    if (m.find("SelectType") != m.end() && !m["SelectType"].empty()) {
      selectType = make_shared<long>(boost::any_cast<long>(m["SelectType"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestCommonSettingCustomHost() = default;
};
class CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting : public Darabonba::Model {
public:
  shared_ptr<string> prometheusClusterId{};
  shared_ptr<string> prometheusClusterRegion{};
  shared_ptr<map<string, string>> prometheusLabels{};

  CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting() {}

  explicit CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prometheusClusterId) {
      res["PrometheusClusterId"] = boost::any(*prometheusClusterId);
    }
    if (prometheusClusterRegion) {
      res["PrometheusClusterRegion"] = boost::any(*prometheusClusterRegion);
    }
    if (prometheusLabels) {
      res["PrometheusLabels"] = boost::any(*prometheusLabels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrometheusClusterId") != m.end() && !m["PrometheusClusterId"].empty()) {
      prometheusClusterId = make_shared<string>(boost::any_cast<string>(m["PrometheusClusterId"]));
    }
    if (m.find("PrometheusClusterRegion") != m.end() && !m["PrometheusClusterRegion"].empty()) {
      prometheusClusterRegion = make_shared<string>(boost::any_cast<string>(m["PrometheusClusterRegion"]));
    }
    if (m.find("PrometheusLabels") != m.end() && !m["PrometheusLabels"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["PrometheusLabels"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      prometheusLabels = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting() = default;
};
class CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> secureGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting() {}

  explicit CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (secureGroupId) {
      res["SecureGroupId"] = boost::any(*secureGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecureGroupId") != m.end() && !m["SecureGroupId"].empty()) {
      secureGroupId = make_shared<string>(boost::any_cast<string>(m["SecureGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting() = default;
};
class CreateTimingSyntheticTaskRequestCommonSetting : public Darabonba::Model {
public:
  shared_ptr<CreateTimingSyntheticTaskRequestCommonSettingCustomHost> customHost{};
  shared_ptr<CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting> customPrometheusSetting{};
  shared_ptr<CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting> customVPCSetting{};
  shared_ptr<long> ipType{};
  shared_ptr<bool> isOpenTrace{};
  shared_ptr<long> monitorSamples{};
  shared_ptr<long> traceClientType{};
  shared_ptr<string> xtraceRegion{};

  CreateTimingSyntheticTaskRequestCommonSetting() {}

  explicit CreateTimingSyntheticTaskRequestCommonSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customHost) {
      res["CustomHost"] = customHost ? boost::any(customHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customPrometheusSetting) {
      res["CustomPrometheusSetting"] = customPrometheusSetting ? boost::any(customPrometheusSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customVPCSetting) {
      res["CustomVPCSetting"] = customVPCSetting ? boost::any(customVPCSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (isOpenTrace) {
      res["IsOpenTrace"] = boost::any(*isOpenTrace);
    }
    if (monitorSamples) {
      res["MonitorSamples"] = boost::any(*monitorSamples);
    }
    if (traceClientType) {
      res["TraceClientType"] = boost::any(*traceClientType);
    }
    if (xtraceRegion) {
      res["XtraceRegion"] = boost::any(*xtraceRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomHost") != m.end() && !m["CustomHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomHost"].type()) {
        CreateTimingSyntheticTaskRequestCommonSettingCustomHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomHost"]));
        customHost = make_shared<CreateTimingSyntheticTaskRequestCommonSettingCustomHost>(model1);
      }
    }
    if (m.find("CustomPrometheusSetting") != m.end() && !m["CustomPrometheusSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomPrometheusSetting"].type()) {
        CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomPrometheusSetting"]));
        customPrometheusSetting = make_shared<CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting>(model1);
      }
    }
    if (m.find("CustomVPCSetting") != m.end() && !m["CustomVPCSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomVPCSetting"].type()) {
        CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomVPCSetting"]));
        customVPCSetting = make_shared<CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting>(model1);
      }
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("IsOpenTrace") != m.end() && !m["IsOpenTrace"].empty()) {
      isOpenTrace = make_shared<bool>(boost::any_cast<bool>(m["IsOpenTrace"]));
    }
    if (m.find("MonitorSamples") != m.end() && !m["MonitorSamples"].empty()) {
      monitorSamples = make_shared<long>(boost::any_cast<long>(m["MonitorSamples"]));
    }
    if (m.find("TraceClientType") != m.end() && !m["TraceClientType"].empty()) {
      traceClientType = make_shared<long>(boost::any_cast<long>(m["TraceClientType"]));
    }
    if (m.find("XtraceRegion") != m.end() && !m["XtraceRegion"].empty()) {
      xtraceRegion = make_shared<string>(boost::any_cast<string>(m["XtraceRegion"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestCommonSetting() = default;
};
class CreateTimingSyntheticTaskRequestCustomPeriod : public Darabonba::Model {
public:
  shared_ptr<long> endHour{};
  shared_ptr<long> startHour{};

  CreateTimingSyntheticTaskRequestCustomPeriod() {}

  explicit CreateTimingSyntheticTaskRequestCustomPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endHour) {
      res["EndHour"] = boost::any(*endHour);
    }
    if (startHour) {
      res["StartHour"] = boost::any(*startHour);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndHour") != m.end() && !m["EndHour"].empty()) {
      endHour = make_shared<long>(boost::any_cast<long>(m["EndHour"]));
    }
    if (m.find("StartHour") != m.end() && !m["StartHour"].empty()) {
      startHour = make_shared<long>(boost::any_cast<long>(m["StartHour"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestCustomPeriod() = default;
};
class CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> type{};

  CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody() {}

  explicit CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody() = default;
};
class CreateTimingSyntheticTaskRequestMonitorConfApiHTTP : public Darabonba::Model {
public:
  shared_ptr<bool> checkCert{};
  shared_ptr<long> connectTimeout{};
  shared_ptr<string> method{};
  shared_ptr<long> protocolAlpnProtocol{};
  shared_ptr<CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody> requestBody{};
  shared_ptr<map<string, string>> requestHeaders{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};

  CreateTimingSyntheticTaskRequestMonitorConfApiHTTP() {}

  explicit CreateTimingSyntheticTaskRequestMonitorConfApiHTTP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkCert) {
      res["CheckCert"] = boost::any(*checkCert);
    }
    if (connectTimeout) {
      res["ConnectTimeout"] = boost::any(*connectTimeout);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (protocolAlpnProtocol) {
      res["ProtocolAlpnProtocol"] = boost::any(*protocolAlpnProtocol);
    }
    if (requestBody) {
      res["RequestBody"] = requestBody ? boost::any(requestBody->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestHeaders) {
      res["RequestHeaders"] = boost::any(*requestHeaders);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckCert") != m.end() && !m["CheckCert"].empty()) {
      checkCert = make_shared<bool>(boost::any_cast<bool>(m["CheckCert"]));
    }
    if (m.find("ConnectTimeout") != m.end() && !m["ConnectTimeout"].empty()) {
      connectTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectTimeout"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("ProtocolAlpnProtocol") != m.end() && !m["ProtocolAlpnProtocol"].empty()) {
      protocolAlpnProtocol = make_shared<long>(boost::any_cast<long>(m["ProtocolAlpnProtocol"]));
    }
    if (m.find("RequestBody") != m.end() && !m["RequestBody"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestBody"].type()) {
        CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestBody"]));
        requestBody = make_shared<CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody>(model1);
      }
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["RequestHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      requestHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestMonitorConfApiHTTP() = default;
};
class CreateTimingSyntheticTaskRequestMonitorConfFileDownload : public Darabonba::Model {
public:
  shared_ptr<long> connectionTimeout{};
  shared_ptr<map<string, string>> customHeaderContent{};
  shared_ptr<long> downloadKernel{};
  shared_ptr<long> ignoreCertificateAuthError{};
  shared_ptr<long> ignoreCertificateCanceledError{};
  shared_ptr<long> ignoreCertificateOutOfDateError{};
  shared_ptr<long> ignoreCertificateStatusError{};
  shared_ptr<long> ignoreCertificateUntrustworthyError{};
  shared_ptr<long> ignoreCertificateUsingError{};
  shared_ptr<long> ignoreInvalidHostError{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<long> quickProtocol{};
  shared_ptr<long> redirection{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> transmissionSize{};
  shared_ptr<string> validateKeywords{};
  shared_ptr<long> verifyWay{};
  shared_ptr<string> whiteList{};

  CreateTimingSyntheticTaskRequestMonitorConfFileDownload() {}

  explicit CreateTimingSyntheticTaskRequestMonitorConfFileDownload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionTimeout) {
      res["ConnectionTimeout"] = boost::any(*connectionTimeout);
    }
    if (customHeaderContent) {
      res["CustomHeaderContent"] = boost::any(*customHeaderContent);
    }
    if (downloadKernel) {
      res["DownloadKernel"] = boost::any(*downloadKernel);
    }
    if (ignoreCertificateAuthError) {
      res["IgnoreCertificateAuthError"] = boost::any(*ignoreCertificateAuthError);
    }
    if (ignoreCertificateCanceledError) {
      res["IgnoreCertificateCanceledError"] = boost::any(*ignoreCertificateCanceledError);
    }
    if (ignoreCertificateOutOfDateError) {
      res["IgnoreCertificateOutOfDateError"] = boost::any(*ignoreCertificateOutOfDateError);
    }
    if (ignoreCertificateStatusError) {
      res["IgnoreCertificateStatusError"] = boost::any(*ignoreCertificateStatusError);
    }
    if (ignoreCertificateUntrustworthyError) {
      res["IgnoreCertificateUntrustworthyError"] = boost::any(*ignoreCertificateUntrustworthyError);
    }
    if (ignoreCertificateUsingError) {
      res["IgnoreCertificateUsingError"] = boost::any(*ignoreCertificateUsingError);
    }
    if (ignoreInvalidHostError) {
      res["IgnoreInvalidHostError"] = boost::any(*ignoreInvalidHostError);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (quickProtocol) {
      res["QuickProtocol"] = boost::any(*quickProtocol);
    }
    if (redirection) {
      res["Redirection"] = boost::any(*redirection);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (transmissionSize) {
      res["TransmissionSize"] = boost::any(*transmissionSize);
    }
    if (validateKeywords) {
      res["ValidateKeywords"] = boost::any(*validateKeywords);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionTimeout") != m.end() && !m["ConnectionTimeout"].empty()) {
      connectionTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectionTimeout"]));
    }
    if (m.find("CustomHeaderContent") != m.end() && !m["CustomHeaderContent"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["CustomHeaderContent"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customHeaderContent = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("DownloadKernel") != m.end() && !m["DownloadKernel"].empty()) {
      downloadKernel = make_shared<long>(boost::any_cast<long>(m["DownloadKernel"]));
    }
    if (m.find("IgnoreCertificateAuthError") != m.end() && !m["IgnoreCertificateAuthError"].empty()) {
      ignoreCertificateAuthError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateAuthError"]));
    }
    if (m.find("IgnoreCertificateCanceledError") != m.end() && !m["IgnoreCertificateCanceledError"].empty()) {
      ignoreCertificateCanceledError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateCanceledError"]));
    }
    if (m.find("IgnoreCertificateOutOfDateError") != m.end() && !m["IgnoreCertificateOutOfDateError"].empty()) {
      ignoreCertificateOutOfDateError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateOutOfDateError"]));
    }
    if (m.find("IgnoreCertificateStatusError") != m.end() && !m["IgnoreCertificateStatusError"].empty()) {
      ignoreCertificateStatusError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateStatusError"]));
    }
    if (m.find("IgnoreCertificateUntrustworthyError") != m.end() && !m["IgnoreCertificateUntrustworthyError"].empty()) {
      ignoreCertificateUntrustworthyError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateUntrustworthyError"]));
    }
    if (m.find("IgnoreCertificateUsingError") != m.end() && !m["IgnoreCertificateUsingError"].empty()) {
      ignoreCertificateUsingError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateUsingError"]));
    }
    if (m.find("IgnoreInvalidHostError") != m.end() && !m["IgnoreInvalidHostError"].empty()) {
      ignoreInvalidHostError = make_shared<long>(boost::any_cast<long>(m["IgnoreInvalidHostError"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("QuickProtocol") != m.end() && !m["QuickProtocol"].empty()) {
      quickProtocol = make_shared<long>(boost::any_cast<long>(m["QuickProtocol"]));
    }
    if (m.find("Redirection") != m.end() && !m["Redirection"].empty()) {
      redirection = make_shared<long>(boost::any_cast<long>(m["Redirection"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("TransmissionSize") != m.end() && !m["TransmissionSize"].empty()) {
      transmissionSize = make_shared<long>(boost::any_cast<long>(m["TransmissionSize"]));
    }
    if (m.find("ValidateKeywords") != m.end() && !m["ValidateKeywords"].empty()) {
      validateKeywords = make_shared<string>(boost::any_cast<string>(m["ValidateKeywords"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestMonitorConfFileDownload() = default;
};
class CreateTimingSyntheticTaskRequestMonitorConfNetDNS : public Darabonba::Model {
public:
  shared_ptr<long> dnsServerIpType{};
  shared_ptr<string> nsServer{};
  shared_ptr<long> queryMethod{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};

  CreateTimingSyntheticTaskRequestMonitorConfNetDNS() {}

  explicit CreateTimingSyntheticTaskRequestMonitorConfNetDNS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsServerIpType) {
      res["DnsServerIpType"] = boost::any(*dnsServerIpType);
    }
    if (nsServer) {
      res["NsServer"] = boost::any(*nsServer);
    }
    if (queryMethod) {
      res["QueryMethod"] = boost::any(*queryMethod);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsServerIpType") != m.end() && !m["DnsServerIpType"].empty()) {
      dnsServerIpType = make_shared<long>(boost::any_cast<long>(m["DnsServerIpType"]));
    }
    if (m.find("NsServer") != m.end() && !m["NsServer"].empty()) {
      nsServer = make_shared<string>(boost::any_cast<string>(m["NsServer"]));
    }
    if (m.find("QueryMethod") != m.end() && !m["QueryMethod"].empty()) {
      queryMethod = make_shared<long>(boost::any_cast<long>(m["QueryMethod"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestMonitorConfNetDNS() = default;
};
class CreateTimingSyntheticTaskRequestMonitorConfNetICMP : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<long> packageNum{};
  shared_ptr<long> packageSize{};
  shared_ptr<bool> splitPackage{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};
  shared_ptr<bool> tracertEnable{};
  shared_ptr<long> tracertNumMax{};
  shared_ptr<long> tracertTimeout{};

  CreateTimingSyntheticTaskRequestMonitorConfNetICMP() {}

  explicit CreateTimingSyntheticTaskRequestMonitorConfNetICMP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (packageNum) {
      res["PackageNum"] = boost::any(*packageNum);
    }
    if (packageSize) {
      res["PackageSize"] = boost::any(*packageSize);
    }
    if (splitPackage) {
      res["SplitPackage"] = boost::any(*splitPackage);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (tracertEnable) {
      res["TracertEnable"] = boost::any(*tracertEnable);
    }
    if (tracertNumMax) {
      res["TracertNumMax"] = boost::any(*tracertNumMax);
    }
    if (tracertTimeout) {
      res["TracertTimeout"] = boost::any(*tracertTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("PackageNum") != m.end() && !m["PackageNum"].empty()) {
      packageNum = make_shared<long>(boost::any_cast<long>(m["PackageNum"]));
    }
    if (m.find("PackageSize") != m.end() && !m["PackageSize"].empty()) {
      packageSize = make_shared<long>(boost::any_cast<long>(m["PackageSize"]));
    }
    if (m.find("SplitPackage") != m.end() && !m["SplitPackage"].empty()) {
      splitPackage = make_shared<bool>(boost::any_cast<bool>(m["SplitPackage"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TracertEnable") != m.end() && !m["TracertEnable"].empty()) {
      tracertEnable = make_shared<bool>(boost::any_cast<bool>(m["TracertEnable"]));
    }
    if (m.find("TracertNumMax") != m.end() && !m["TracertNumMax"].empty()) {
      tracertNumMax = make_shared<long>(boost::any_cast<long>(m["TracertNumMax"]));
    }
    if (m.find("TracertTimeout") != m.end() && !m["TracertTimeout"].empty()) {
      tracertTimeout = make_shared<long>(boost::any_cast<long>(m["TracertTimeout"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestMonitorConfNetICMP() = default;
};
class CreateTimingSyntheticTaskRequestMonitorConfNetTCP : public Darabonba::Model {
public:
  shared_ptr<long> connectTimes{};
  shared_ptr<long> interval{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};
  shared_ptr<bool> tracertEnable{};
  shared_ptr<long> tracertNumMax{};
  shared_ptr<long> tracertTimeout{};

  CreateTimingSyntheticTaskRequestMonitorConfNetTCP() {}

  explicit CreateTimingSyntheticTaskRequestMonitorConfNetTCP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectTimes) {
      res["ConnectTimes"] = boost::any(*connectTimes);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (tracertEnable) {
      res["TracertEnable"] = boost::any(*tracertEnable);
    }
    if (tracertNumMax) {
      res["TracertNumMax"] = boost::any(*tracertNumMax);
    }
    if (tracertTimeout) {
      res["TracertTimeout"] = boost::any(*tracertTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectTimes") != m.end() && !m["ConnectTimes"].empty()) {
      connectTimes = make_shared<long>(boost::any_cast<long>(m["ConnectTimes"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TracertEnable") != m.end() && !m["TracertEnable"].empty()) {
      tracertEnable = make_shared<bool>(boost::any_cast<bool>(m["TracertEnable"]));
    }
    if (m.find("TracertNumMax") != m.end() && !m["TracertNumMax"].empty()) {
      tracertNumMax = make_shared<long>(boost::any_cast<long>(m["TracertNumMax"]));
    }
    if (m.find("TracertTimeout") != m.end() && !m["TracertTimeout"].empty()) {
      tracertTimeout = make_shared<long>(boost::any_cast<long>(m["TracertTimeout"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestMonitorConfNetTCP() = default;
};
class CreateTimingSyntheticTaskRequestMonitorConfStream : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> customHeaderContent{};
  shared_ptr<long> playerType{};
  shared_ptr<long> streamAddressType{};
  shared_ptr<long> streamMonitorTimeout{};
  shared_ptr<long> streamType{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> whiteList{};

  CreateTimingSyntheticTaskRequestMonitorConfStream() {}

  explicit CreateTimingSyntheticTaskRequestMonitorConfStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customHeaderContent) {
      res["CustomHeaderContent"] = boost::any(*customHeaderContent);
    }
    if (playerType) {
      res["PlayerType"] = boost::any(*playerType);
    }
    if (streamAddressType) {
      res["StreamAddressType"] = boost::any(*streamAddressType);
    }
    if (streamMonitorTimeout) {
      res["StreamMonitorTimeout"] = boost::any(*streamMonitorTimeout);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomHeaderContent") != m.end() && !m["CustomHeaderContent"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["CustomHeaderContent"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customHeaderContent = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("PlayerType") != m.end() && !m["PlayerType"].empty()) {
      playerType = make_shared<long>(boost::any_cast<long>(m["PlayerType"]));
    }
    if (m.find("StreamAddressType") != m.end() && !m["StreamAddressType"].empty()) {
      streamAddressType = make_shared<long>(boost::any_cast<long>(m["StreamAddressType"]));
    }
    if (m.find("StreamMonitorTimeout") != m.end() && !m["StreamMonitorTimeout"].empty()) {
      streamMonitorTimeout = make_shared<long>(boost::any_cast<long>(m["StreamMonitorTimeout"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<long>(boost::any_cast<long>(m["StreamType"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestMonitorConfStream() = default;
};
class CreateTimingSyntheticTaskRequestMonitorConfWebsite : public Darabonba::Model {
public:
  shared_ptr<long> automaticScrolling{};
  shared_ptr<long> customHeader{};
  shared_ptr<map<string, string>> customHeaderContent{};
  shared_ptr<string> DNSHijackWhitelist{};
  shared_ptr<long> disableCache{};
  shared_ptr<long> disableCompression{};
  shared_ptr<string> elementBlacklist{};
  shared_ptr<long> filterInvalidIP{};
  shared_ptr<long> flowHijackJumpTimes{};
  shared_ptr<string> flowHijackLogo{};
  shared_ptr<long> ignoreCertificateError{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<string> pageTamper{};
  shared_ptr<long> redirection{};
  shared_ptr<long> slowElementThreshold{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> verifyStringBlacklist{};
  shared_ptr<string> verifyStringWhitelist{};
  shared_ptr<long> waitCompletionTime{};

  CreateTimingSyntheticTaskRequestMonitorConfWebsite() {}

  explicit CreateTimingSyntheticTaskRequestMonitorConfWebsite(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (automaticScrolling) {
      res["AutomaticScrolling"] = boost::any(*automaticScrolling);
    }
    if (customHeader) {
      res["CustomHeader"] = boost::any(*customHeader);
    }
    if (customHeaderContent) {
      res["CustomHeaderContent"] = boost::any(*customHeaderContent);
    }
    if (DNSHijackWhitelist) {
      res["DNSHijackWhitelist"] = boost::any(*DNSHijackWhitelist);
    }
    if (disableCache) {
      res["DisableCache"] = boost::any(*disableCache);
    }
    if (disableCompression) {
      res["DisableCompression"] = boost::any(*disableCompression);
    }
    if (elementBlacklist) {
      res["ElementBlacklist"] = boost::any(*elementBlacklist);
    }
    if (filterInvalidIP) {
      res["FilterInvalidIP"] = boost::any(*filterInvalidIP);
    }
    if (flowHijackJumpTimes) {
      res["FlowHijackJumpTimes"] = boost::any(*flowHijackJumpTimes);
    }
    if (flowHijackLogo) {
      res["FlowHijackLogo"] = boost::any(*flowHijackLogo);
    }
    if (ignoreCertificateError) {
      res["IgnoreCertificateError"] = boost::any(*ignoreCertificateError);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (pageTamper) {
      res["PageTamper"] = boost::any(*pageTamper);
    }
    if (redirection) {
      res["Redirection"] = boost::any(*redirection);
    }
    if (slowElementThreshold) {
      res["SlowElementThreshold"] = boost::any(*slowElementThreshold);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (verifyStringBlacklist) {
      res["VerifyStringBlacklist"] = boost::any(*verifyStringBlacklist);
    }
    if (verifyStringWhitelist) {
      res["VerifyStringWhitelist"] = boost::any(*verifyStringWhitelist);
    }
    if (waitCompletionTime) {
      res["WaitCompletionTime"] = boost::any(*waitCompletionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutomaticScrolling") != m.end() && !m["AutomaticScrolling"].empty()) {
      automaticScrolling = make_shared<long>(boost::any_cast<long>(m["AutomaticScrolling"]));
    }
    if (m.find("CustomHeader") != m.end() && !m["CustomHeader"].empty()) {
      customHeader = make_shared<long>(boost::any_cast<long>(m["CustomHeader"]));
    }
    if (m.find("CustomHeaderContent") != m.end() && !m["CustomHeaderContent"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["CustomHeaderContent"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customHeaderContent = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("DNSHijackWhitelist") != m.end() && !m["DNSHijackWhitelist"].empty()) {
      DNSHijackWhitelist = make_shared<string>(boost::any_cast<string>(m["DNSHijackWhitelist"]));
    }
    if (m.find("DisableCache") != m.end() && !m["DisableCache"].empty()) {
      disableCache = make_shared<long>(boost::any_cast<long>(m["DisableCache"]));
    }
    if (m.find("DisableCompression") != m.end() && !m["DisableCompression"].empty()) {
      disableCompression = make_shared<long>(boost::any_cast<long>(m["DisableCompression"]));
    }
    if (m.find("ElementBlacklist") != m.end() && !m["ElementBlacklist"].empty()) {
      elementBlacklist = make_shared<string>(boost::any_cast<string>(m["ElementBlacklist"]));
    }
    if (m.find("FilterInvalidIP") != m.end() && !m["FilterInvalidIP"].empty()) {
      filterInvalidIP = make_shared<long>(boost::any_cast<long>(m["FilterInvalidIP"]));
    }
    if (m.find("FlowHijackJumpTimes") != m.end() && !m["FlowHijackJumpTimes"].empty()) {
      flowHijackJumpTimes = make_shared<long>(boost::any_cast<long>(m["FlowHijackJumpTimes"]));
    }
    if (m.find("FlowHijackLogo") != m.end() && !m["FlowHijackLogo"].empty()) {
      flowHijackLogo = make_shared<string>(boost::any_cast<string>(m["FlowHijackLogo"]));
    }
    if (m.find("IgnoreCertificateError") != m.end() && !m["IgnoreCertificateError"].empty()) {
      ignoreCertificateError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateError"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("PageTamper") != m.end() && !m["PageTamper"].empty()) {
      pageTamper = make_shared<string>(boost::any_cast<string>(m["PageTamper"]));
    }
    if (m.find("Redirection") != m.end() && !m["Redirection"].empty()) {
      redirection = make_shared<long>(boost::any_cast<long>(m["Redirection"]));
    }
    if (m.find("SlowElementThreshold") != m.end() && !m["SlowElementThreshold"].empty()) {
      slowElementThreshold = make_shared<long>(boost::any_cast<long>(m["SlowElementThreshold"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("VerifyStringBlacklist") != m.end() && !m["VerifyStringBlacklist"].empty()) {
      verifyStringBlacklist = make_shared<string>(boost::any_cast<string>(m["VerifyStringBlacklist"]));
    }
    if (m.find("VerifyStringWhitelist") != m.end() && !m["VerifyStringWhitelist"].empty()) {
      verifyStringWhitelist = make_shared<string>(boost::any_cast<string>(m["VerifyStringWhitelist"]));
    }
    if (m.find("WaitCompletionTime") != m.end() && !m["WaitCompletionTime"].empty()) {
      waitCompletionTime = make_shared<long>(boost::any_cast<long>(m["WaitCompletionTime"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestMonitorConfWebsite() = default;
};
class CreateTimingSyntheticTaskRequestMonitorConf : public Darabonba::Model {
public:
  shared_ptr<CreateTimingSyntheticTaskRequestMonitorConfApiHTTP> apiHTTP{};
  shared_ptr<CreateTimingSyntheticTaskRequestMonitorConfFileDownload> fileDownload{};
  shared_ptr<CreateTimingSyntheticTaskRequestMonitorConfNetDNS> netDNS{};
  shared_ptr<CreateTimingSyntheticTaskRequestMonitorConfNetICMP> netICMP{};
  shared_ptr<CreateTimingSyntheticTaskRequestMonitorConfNetTCP> netTCP{};
  shared_ptr<CreateTimingSyntheticTaskRequestMonitorConfStream> stream{};
  shared_ptr<CreateTimingSyntheticTaskRequestMonitorConfWebsite> website{};

  CreateTimingSyntheticTaskRequestMonitorConf() {}

  explicit CreateTimingSyntheticTaskRequestMonitorConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHTTP) {
      res["ApiHTTP"] = apiHTTP ? boost::any(apiHTTP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileDownload) {
      res["FileDownload"] = fileDownload ? boost::any(fileDownload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (netDNS) {
      res["NetDNS"] = netDNS ? boost::any(netDNS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (netICMP) {
      res["NetICMP"] = netICMP ? boost::any(netICMP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (netTCP) {
      res["NetTCP"] = netTCP ? boost::any(netTCP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stream) {
      res["Stream"] = stream ? boost::any(stream->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (website) {
      res["Website"] = website ? boost::any(website->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHTTP") != m.end() && !m["ApiHTTP"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiHTTP"].type()) {
        CreateTimingSyntheticTaskRequestMonitorConfApiHTTP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiHTTP"]));
        apiHTTP = make_shared<CreateTimingSyntheticTaskRequestMonitorConfApiHTTP>(model1);
      }
    }
    if (m.find("FileDownload") != m.end() && !m["FileDownload"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileDownload"].type()) {
        CreateTimingSyntheticTaskRequestMonitorConfFileDownload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileDownload"]));
        fileDownload = make_shared<CreateTimingSyntheticTaskRequestMonitorConfFileDownload>(model1);
      }
    }
    if (m.find("NetDNS") != m.end() && !m["NetDNS"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetDNS"].type()) {
        CreateTimingSyntheticTaskRequestMonitorConfNetDNS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetDNS"]));
        netDNS = make_shared<CreateTimingSyntheticTaskRequestMonitorConfNetDNS>(model1);
      }
    }
    if (m.find("NetICMP") != m.end() && !m["NetICMP"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetICMP"].type()) {
        CreateTimingSyntheticTaskRequestMonitorConfNetICMP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetICMP"]));
        netICMP = make_shared<CreateTimingSyntheticTaskRequestMonitorConfNetICMP>(model1);
      }
    }
    if (m.find("NetTCP") != m.end() && !m["NetTCP"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetTCP"].type()) {
        CreateTimingSyntheticTaskRequestMonitorConfNetTCP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetTCP"]));
        netTCP = make_shared<CreateTimingSyntheticTaskRequestMonitorConfNetTCP>(model1);
      }
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      if (typeid(map<string, boost::any>) == m["Stream"].type()) {
        CreateTimingSyntheticTaskRequestMonitorConfStream model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Stream"]));
        stream = make_shared<CreateTimingSyntheticTaskRequestMonitorConfStream>(model1);
      }
    }
    if (m.find("Website") != m.end() && !m["Website"].empty()) {
      if (typeid(map<string, boost::any>) == m["Website"].type()) {
        CreateTimingSyntheticTaskRequestMonitorConfWebsite model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Website"]));
        website = make_shared<CreateTimingSyntheticTaskRequestMonitorConfWebsite>(model1);
      }
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestMonitorConf() = default;
};
class CreateTimingSyntheticTaskRequestMonitors : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<long> clientType{};
  shared_ptr<string> operatorCode{};

  CreateTimingSyntheticTaskRequestMonitors() {}

  explicit CreateTimingSyntheticTaskRequestMonitors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (operatorCode) {
      res["OperatorCode"] = boost::any(*operatorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<long>(boost::any_cast<long>(m["ClientType"]));
    }
    if (m.find("OperatorCode") != m.end() && !m["OperatorCode"].empty()) {
      operatorCode = make_shared<string>(boost::any_cast<string>(m["OperatorCode"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestMonitors() = default;
};
class CreateTimingSyntheticTaskRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateTimingSyntheticTaskRequestTags() {}

  explicit CreateTimingSyntheticTaskRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequestTags() = default;
};
class CreateTimingSyntheticTaskRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateTimingSyntheticTaskRequestAvailableAssertions>> availableAssertions{};
  shared_ptr<CreateTimingSyntheticTaskRequestCommonSetting> commonSetting{};
  shared_ptr<CreateTimingSyntheticTaskRequestCustomPeriod> customPeriod{};
  shared_ptr<string> frequency{};
  shared_ptr<long> monitorCategory{};
  shared_ptr<CreateTimingSyntheticTaskRequestMonitorConf> monitorConf{};
  shared_ptr<vector<CreateTimingSyntheticTaskRequestMonitors>> monitors{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateTimingSyntheticTaskRequestTags>> tags{};
  shared_ptr<long> taskType{};

  CreateTimingSyntheticTaskRequest() {}

  explicit CreateTimingSyntheticTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableAssertions) {
      vector<boost::any> temp1;
      for(auto item1:*availableAssertions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableAssertions"] = boost::any(temp1);
    }
    if (commonSetting) {
      res["CommonSetting"] = commonSetting ? boost::any(commonSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customPeriod) {
      res["CustomPeriod"] = customPeriod ? boost::any(customPeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (monitorCategory) {
      res["MonitorCategory"] = boost::any(*monitorCategory);
    }
    if (monitorConf) {
      res["MonitorConf"] = monitorConf ? boost::any(monitorConf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (monitors) {
      vector<boost::any> temp1;
      for(auto item1:*monitors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Monitors"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableAssertions") != m.end() && !m["AvailableAssertions"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableAssertions"].type()) {
        vector<CreateTimingSyntheticTaskRequestAvailableAssertions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableAssertions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTimingSyntheticTaskRequestAvailableAssertions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableAssertions = make_shared<vector<CreateTimingSyntheticTaskRequestAvailableAssertions>>(expect1);
      }
    }
    if (m.find("CommonSetting") != m.end() && !m["CommonSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonSetting"].type()) {
        CreateTimingSyntheticTaskRequestCommonSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonSetting"]));
        commonSetting = make_shared<CreateTimingSyntheticTaskRequestCommonSetting>(model1);
      }
    }
    if (m.find("CustomPeriod") != m.end() && !m["CustomPeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomPeriod"].type()) {
        CreateTimingSyntheticTaskRequestCustomPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomPeriod"]));
        customPeriod = make_shared<CreateTimingSyntheticTaskRequestCustomPeriod>(model1);
      }
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("MonitorCategory") != m.end() && !m["MonitorCategory"].empty()) {
      monitorCategory = make_shared<long>(boost::any_cast<long>(m["MonitorCategory"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorConf"].type()) {
        CreateTimingSyntheticTaskRequestMonitorConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorConf"]));
        monitorConf = make_shared<CreateTimingSyntheticTaskRequestMonitorConf>(model1);
      }
    }
    if (m.find("Monitors") != m.end() && !m["Monitors"].empty()) {
      if (typeid(vector<boost::any>) == m["Monitors"].type()) {
        vector<CreateTimingSyntheticTaskRequestMonitors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Monitors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTimingSyntheticTaskRequestMonitors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitors = make_shared<vector<CreateTimingSyntheticTaskRequestMonitors>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateTimingSyntheticTaskRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTimingSyntheticTaskRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateTimingSyntheticTaskRequestTags>>(expect1);
      }
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskRequest() = default;
};
class CreateTimingSyntheticTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> availableAssertionsShrink{};
  shared_ptr<string> commonSettingShrink{};
  shared_ptr<string> customPeriodShrink{};
  shared_ptr<string> frequency{};
  shared_ptr<long> monitorCategory{};
  shared_ptr<string> monitorConfShrink{};
  shared_ptr<string> monitorsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<long> taskType{};

  CreateTimingSyntheticTaskShrinkRequest() {}

  explicit CreateTimingSyntheticTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableAssertionsShrink) {
      res["AvailableAssertions"] = boost::any(*availableAssertionsShrink);
    }
    if (commonSettingShrink) {
      res["CommonSetting"] = boost::any(*commonSettingShrink);
    }
    if (customPeriodShrink) {
      res["CustomPeriod"] = boost::any(*customPeriodShrink);
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (monitorCategory) {
      res["MonitorCategory"] = boost::any(*monitorCategory);
    }
    if (monitorConfShrink) {
      res["MonitorConf"] = boost::any(*monitorConfShrink);
    }
    if (monitorsShrink) {
      res["Monitors"] = boost::any(*monitorsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableAssertions") != m.end() && !m["AvailableAssertions"].empty()) {
      availableAssertionsShrink = make_shared<string>(boost::any_cast<string>(m["AvailableAssertions"]));
    }
    if (m.find("CommonSetting") != m.end() && !m["CommonSetting"].empty()) {
      commonSettingShrink = make_shared<string>(boost::any_cast<string>(m["CommonSetting"]));
    }
    if (m.find("CustomPeriod") != m.end() && !m["CustomPeriod"].empty()) {
      customPeriodShrink = make_shared<string>(boost::any_cast<string>(m["CustomPeriod"]));
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("MonitorCategory") != m.end() && !m["MonitorCategory"].empty()) {
      monitorCategory = make_shared<long>(boost::any_cast<long>(m["MonitorCategory"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConfShrink = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("Monitors") != m.end() && !m["Monitors"].empty()) {
      monitorsShrink = make_shared<string>(boost::any_cast<string>(m["Monitors"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskShrinkRequest() = default;
};
class CreateTimingSyntheticTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  CreateTimingSyntheticTaskResponseBodyData() {}

  explicit CreateTimingSyntheticTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskResponseBodyData() = default;
};
class CreateTimingSyntheticTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CreateTimingSyntheticTaskResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateTimingSyntheticTaskResponseBody() {}

  explicit CreateTimingSyntheticTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateTimingSyntheticTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateTimingSyntheticTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateTimingSyntheticTaskResponseBody() = default;
};
class CreateTimingSyntheticTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTimingSyntheticTaskResponseBody> body{};

  CreateTimingSyntheticTaskResponse() {}

  explicit CreateTimingSyntheticTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTimingSyntheticTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTimingSyntheticTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTimingSyntheticTaskResponse() = default;
};
class CreateWebhookRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> contactName{};
  shared_ptr<string> httpHeaders{};
  shared_ptr<string> httpParams{};
  shared_ptr<string> method{};
  shared_ptr<string> recoverBody{};
  shared_ptr<string> regionId{};
  shared_ptr<string> url{};

  CreateWebhookRequest() {}

  explicit CreateWebhookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (httpHeaders) {
      res["HttpHeaders"] = boost::any(*httpHeaders);
    }
    if (httpParams) {
      res["HttpParams"] = boost::any(*httpParams);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (recoverBody) {
      res["RecoverBody"] = boost::any(*recoverBody);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("HttpHeaders") != m.end() && !m["HttpHeaders"].empty()) {
      httpHeaders = make_shared<string>(boost::any_cast<string>(m["HttpHeaders"]));
    }
    if (m.find("HttpParams") != m.end() && !m["HttpParams"].empty()) {
      httpParams = make_shared<string>(boost::any_cast<string>(m["HttpParams"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("RecoverBody") != m.end() && !m["RecoverBody"].empty()) {
      recoverBody = make_shared<string>(boost::any_cast<string>(m["RecoverBody"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateWebhookRequest() = default;
};
class CreateWebhookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> requestId{};

  CreateWebhookResponseBody() {}

  explicit CreateWebhookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWebhookResponseBody() = default;
};
class CreateWebhookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWebhookResponseBody> body{};

  CreateWebhookResponse() {}

  explicit CreateWebhookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWebhookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWebhookResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWebhookResponse() = default;
};
class DelAuthTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  DelAuthTokenRequest() {}

  explicit DelAuthTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DelAuthTokenRequest() = default;
};
class DelAuthTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DelAuthTokenResponseBody() {}

  explicit DelAuthTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DelAuthTokenResponseBody() = default;
};
class DelAuthTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DelAuthTokenResponseBody> body{};

  DelAuthTokenResponse() {}

  explicit DelAuthTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DelAuthTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DelAuthTokenResponseBody>(model1);
      }
    }
  }


  virtual ~DelAuthTokenResponse() = default;
};
class DeleteAddonReleaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<string> environmentId{};
  shared_ptr<bool> force{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseName{};

  DeleteAddonReleaseRequest() {}

  explicit DeleteAddonReleaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseName) {
      res["ReleaseName"] = boost::any(*releaseName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseName") != m.end() && !m["ReleaseName"].empty()) {
      releaseName = make_shared<string>(boost::any_cast<string>(m["ReleaseName"]));
    }
  }


  virtual ~DeleteAddonReleaseRequest() = default;
};
class DeleteAddonReleaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteAddonReleaseResponseBody() {}

  explicit DeleteAddonReleaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAddonReleaseResponseBody() = default;
};
class DeleteAddonReleaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAddonReleaseResponseBody> body{};

  DeleteAddonReleaseResponse() {}

  explicit DeleteAddonReleaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAddonReleaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAddonReleaseResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAddonReleaseResponse() = default;
};
class DeleteAlertContactRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> regionId{};

  DeleteAlertContactRequest() {}

  explicit DeleteAlertContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteAlertContactRequest() = default;
};
class DeleteAlertContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteAlertContactResponseBody() {}

  explicit DeleteAlertContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAlertContactResponseBody() = default;
};
class DeleteAlertContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertContactResponseBody> body{};

  DeleteAlertContactResponse() {}

  explicit DeleteAlertContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertContactResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertContactResponse() = default;
};
class DeleteAlertContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactGroupId{};
  shared_ptr<string> regionId{};

  DeleteAlertContactGroupRequest() {}

  explicit DeleteAlertContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<long>(boost::any_cast<long>(m["ContactGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteAlertContactGroupRequest() = default;
};
class DeleteAlertContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteAlertContactGroupResponseBody() {}

  explicit DeleteAlertContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAlertContactGroupResponseBody() = default;
};
class DeleteAlertContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertContactGroupResponseBody> body{};

  DeleteAlertContactGroupResponse() {}

  explicit DeleteAlertContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertContactGroupResponse() = default;
};
class DeleteAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};

  DeleteAlertRuleRequest() {}

  explicit DeleteAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
  }


  virtual ~DeleteAlertRuleRequest() = default;
};
class DeleteAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteAlertRuleResponseBody() {}

  explicit DeleteAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAlertRuleResponseBody() = default;
};
class DeleteAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertRuleResponseBody> body{};

  DeleteAlertRuleResponse() {}

  explicit DeleteAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertRuleResponse() = default;
};
class DeleteAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertIds{};
  shared_ptr<string> regionId{};

  DeleteAlertRulesRequest() {}

  explicit DeleteAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertIds) {
      res["AlertIds"] = boost::any(*alertIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertIds") != m.end() && !m["AlertIds"].empty()) {
      alertIds = make_shared<string>(boost::any_cast<string>(m["AlertIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteAlertRulesRequest() = default;
};
class DeleteAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteAlertRulesResponseBody() {}

  explicit DeleteAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAlertRulesResponseBody() = default;
};
class DeleteAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertRulesResponseBody> body{};

  DeleteAlertRulesResponse() {}

  explicit DeleteAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertRulesResponse() = default;
};
class DeleteAppListRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> pids{};
  shared_ptr<string> regionId{};

  DeleteAppListRequest() {}

  explicit DeleteAppListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pids) {
      res["Pids"] = boost::any(*pids);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pids") != m.end() && !m["Pids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Pids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Pids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteAppListRequest() = default;
};
class DeleteAppListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteAppListResponseBody() {}

  explicit DeleteAppListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAppListResponseBody() = default;
};
class DeleteAppListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAppListResponseBody> body{};

  DeleteAppListResponse() {}

  explicit DeleteAppListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAppListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAppListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAppListResponse() = default;
};
class DeleteCmsExporterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  DeleteCmsExporterRequest() {}

  explicit DeleteCmsExporterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCmsExporterRequest() = default;
};
class DeleteCmsExporterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DeleteCmsExporterResponseBody() {}

  explicit DeleteCmsExporterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCmsExporterResponseBody() = default;
};
class DeleteCmsExporterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCmsExporterResponseBody> body{};

  DeleteCmsExporterResponse() {}

  explicit DeleteCmsExporterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCmsExporterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCmsExporterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCmsExporterResponse() = default;
};
class DeleteContactRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};

  DeleteContactRequest() {}

  explicit DeleteContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
  }


  virtual ~DeleteContactRequest() = default;
};
class DeleteContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteContactResponseBody() {}

  explicit DeleteContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteContactResponseBody() = default;
};
class DeleteContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactResponseBody> body{};

  DeleteContactResponse() {}

  explicit DeleteContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactResponse() = default;
};
class DeleteContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactGroupId{};

  DeleteContactGroupRequest() {}

  explicit DeleteContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<long>(boost::any_cast<long>(m["ContactGroupId"]));
    }
  }


  virtual ~DeleteContactGroupRequest() = default;
};
class DeleteContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteContactGroupResponseBody() {}

  explicit DeleteContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteContactGroupResponseBody() = default;
};
class DeleteContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactGroupResponseBody> body{};

  DeleteContactGroupResponse() {}

  explicit DeleteContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactGroupResponse() = default;
};
class DeleteDispatchRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  DeleteDispatchRuleRequest() {}

  explicit DeleteDispatchRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDispatchRuleRequest() = default;
};
class DeleteDispatchRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDispatchRuleResponseBody() {}

  explicit DeleteDispatchRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDispatchRuleResponseBody() = default;
};
class DeleteDispatchRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDispatchRuleResponseBody> body{};

  DeleteDispatchRuleResponse() {}

  explicit DeleteDispatchRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDispatchRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDispatchRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDispatchRuleResponse() = default;
};
class DeleteEnvCustomJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> customJobName{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  DeleteEnvCustomJobRequest() {}

  explicit DeleteEnvCustomJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customJobName) {
      res["CustomJobName"] = boost::any(*customJobName);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomJobName") != m.end() && !m["CustomJobName"].empty()) {
      customJobName = make_shared<string>(boost::any_cast<string>(m["CustomJobName"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteEnvCustomJobRequest() = default;
};
class DeleteEnvCustomJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteEnvCustomJobResponseBody() {}

  explicit DeleteEnvCustomJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEnvCustomJobResponseBody() = default;
};
class DeleteEnvCustomJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEnvCustomJobResponseBody> body{};

  DeleteEnvCustomJobResponse() {}

  explicit DeleteEnvCustomJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEnvCustomJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEnvCustomJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEnvCustomJobResponse() = default;
};
class DeleteEnvPodMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> environmentId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> podMonitorName{};
  shared_ptr<string> regionId{};

  DeleteEnvPodMonitorRequest() {}

  explicit DeleteEnvPodMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (podMonitorName) {
      res["PodMonitorName"] = boost::any(*podMonitorName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PodMonitorName") != m.end() && !m["PodMonitorName"].empty()) {
      podMonitorName = make_shared<string>(boost::any_cast<string>(m["PodMonitorName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteEnvPodMonitorRequest() = default;
};
class DeleteEnvPodMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteEnvPodMonitorResponseBody() {}

  explicit DeleteEnvPodMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEnvPodMonitorResponseBody() = default;
};
class DeleteEnvPodMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEnvPodMonitorResponseBody> body{};

  DeleteEnvPodMonitorResponse() {}

  explicit DeleteEnvPodMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEnvPodMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEnvPodMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEnvPodMonitorResponse() = default;
};
class DeleteEnvServiceMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> environmentId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceMonitorName{};

  DeleteEnvServiceMonitorRequest() {}

  explicit DeleteEnvServiceMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceMonitorName) {
      res["ServiceMonitorName"] = boost::any(*serviceMonitorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceMonitorName") != m.end() && !m["ServiceMonitorName"].empty()) {
      serviceMonitorName = make_shared<string>(boost::any_cast<string>(m["ServiceMonitorName"]));
    }
  }


  virtual ~DeleteEnvServiceMonitorRequest() = default;
};
class DeleteEnvServiceMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteEnvServiceMonitorResponseBody() {}

  explicit DeleteEnvServiceMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEnvServiceMonitorResponseBody() = default;
};
class DeleteEnvServiceMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEnvServiceMonitorResponseBody> body{};

  DeleteEnvServiceMonitorResponse() {}

  explicit DeleteEnvServiceMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEnvServiceMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEnvServiceMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEnvServiceMonitorResponse() = default;
};
class DeleteEnvironmentRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deletePromInstance{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  DeleteEnvironmentRequest() {}

  explicit DeleteEnvironmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deletePromInstance) {
      res["DeletePromInstance"] = boost::any(*deletePromInstance);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeletePromInstance") != m.end() && !m["DeletePromInstance"].empty()) {
      deletePromInstance = make_shared<bool>(boost::any_cast<bool>(m["DeletePromInstance"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteEnvironmentRequest() = default;
};
class DeleteEnvironmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteEnvironmentResponseBody() {}

  explicit DeleteEnvironmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEnvironmentResponseBody() = default;
};
class DeleteEnvironmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEnvironmentResponseBody> body{};

  DeleteEnvironmentResponse() {}

  explicit DeleteEnvironmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEnvironmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEnvironmentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEnvironmentResponse() = default;
};
class DeleteEnvironmentFeatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> environmentId{};
  shared_ptr<string> featureName{};
  shared_ptr<string> regionId{};

  DeleteEnvironmentFeatureRequest() {}

  explicit DeleteEnvironmentFeatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (featureName) {
      res["FeatureName"] = boost::any(*featureName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("FeatureName") != m.end() && !m["FeatureName"].empty()) {
      featureName = make_shared<string>(boost::any_cast<string>(m["FeatureName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteEnvironmentFeatureRequest() = default;
};
class DeleteEnvironmentFeatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteEnvironmentFeatureResponseBody() {}

  explicit DeleteEnvironmentFeatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteEnvironmentFeatureResponseBody() = default;
};
class DeleteEnvironmentFeatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEnvironmentFeatureResponseBody> body{};

  DeleteEnvironmentFeatureResponse() {}

  explicit DeleteEnvironmentFeatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEnvironmentFeatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEnvironmentFeatureResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEnvironmentFeatureResponse() = default;
};
class DeleteEventBridgeIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteEventBridgeIntegrationRequest() {}

  explicit DeleteEventBridgeIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteEventBridgeIntegrationRequest() = default;
};
class DeleteEventBridgeIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteEventBridgeIntegrationResponseBody() {}

  explicit DeleteEventBridgeIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEventBridgeIntegrationResponseBody() = default;
};
class DeleteEventBridgeIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEventBridgeIntegrationResponseBody> body{};

  DeleteEventBridgeIntegrationResponse() {}

  explicit DeleteEventBridgeIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEventBridgeIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEventBridgeIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEventBridgeIntegrationResponse() = default;
};
class DeleteGrafanaResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> regionId{};

  DeleteGrafanaResourceRequest() {}

  explicit DeleteGrafanaResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteGrafanaResourceRequest() = default;
};
class DeleteGrafanaResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteGrafanaResourceResponseBody() {}

  explicit DeleteGrafanaResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteGrafanaResourceResponseBody() = default;
};
class DeleteGrafanaResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGrafanaResourceResponseBody> body{};

  DeleteGrafanaResourceResponse() {}

  explicit DeleteGrafanaResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGrafanaResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGrafanaResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGrafanaResourceResponse() = default;
};
class DeleteGrafanaWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<string> regionId{};

  DeleteGrafanaWorkspaceRequest() {}

  explicit DeleteGrafanaWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grafanaWorkspaceId) {
      res["GrafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrafanaWorkspaceId") != m.end() && !m["GrafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteGrafanaWorkspaceRequest() = default;
};
class DeleteGrafanaWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteGrafanaWorkspaceResponseBody() {}

  explicit DeleteGrafanaWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DeleteGrafanaWorkspaceResponseBody() = default;
};
class DeleteGrafanaWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGrafanaWorkspaceResponseBody> body{};

  DeleteGrafanaWorkspaceResponse() {}

  explicit DeleteGrafanaWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGrafanaWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGrafanaWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGrafanaWorkspaceResponse() = default;
};
class DeleteIMRobotRequest : public Darabonba::Model {
public:
  shared_ptr<long> robotId{};

  DeleteIMRobotRequest() {}

  explicit DeleteIMRobotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (robotId) {
      res["RobotId"] = boost::any(*robotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RobotId") != m.end() && !m["RobotId"].empty()) {
      robotId = make_shared<long>(boost::any_cast<long>(m["RobotId"]));
    }
  }


  virtual ~DeleteIMRobotRequest() = default;
};
class DeleteIMRobotResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteIMRobotResponseBody() {}

  explicit DeleteIMRobotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIMRobotResponseBody() = default;
};
class DeleteIMRobotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIMRobotResponseBody> body{};

  DeleteIMRobotResponse() {}

  explicit DeleteIMRobotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIMRobotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIMRobotResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIMRobotResponse() = default;
};
class DeleteIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integration{};
  shared_ptr<string> regionId{};

  DeleteIntegrationRequest() {}

  explicit DeleteIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integration) {
      res["Integration"] = boost::any(*integration);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      integration = make_shared<string>(boost::any_cast<string>(m["Integration"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteIntegrationRequest() = default;
};
class DeleteIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteIntegrationResponseBody() {}

  explicit DeleteIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIntegrationResponseBody() = default;
};
class DeleteIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIntegrationResponseBody> body{};

  DeleteIntegrationResponse() {}

  explicit DeleteIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIntegrationResponse() = default;
};
class DeleteIntegrationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> integrationId{};

  DeleteIntegrationsRequest() {}

  explicit DeleteIntegrationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
  }


  virtual ~DeleteIntegrationsRequest() = default;
};
class DeleteIntegrationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteIntegrationsResponseBody() {}

  explicit DeleteIntegrationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIntegrationsResponseBody() = default;
};
class DeleteIntegrationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIntegrationsResponseBody> body{};

  DeleteIntegrationsResponse() {}

  explicit DeleteIntegrationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIntegrationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIntegrationsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIntegrationsResponse() = default;
};
class DeleteNotificationPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteNotificationPolicyRequest() {}

  explicit DeleteNotificationPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteNotificationPolicyRequest() = default;
};
class DeleteNotificationPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteNotificationPolicyResponseBody() {}

  explicit DeleteNotificationPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNotificationPolicyResponseBody() = default;
};
class DeleteNotificationPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNotificationPolicyResponseBody> body{};

  DeleteNotificationPolicyResponse() {}

  explicit DeleteNotificationPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNotificationPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNotificationPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNotificationPolicyResponse() = default;
};
class DeletePrometheusAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> clusterId{};

  DeletePrometheusAlertRuleRequest() {}

  explicit DeletePrometheusAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DeletePrometheusAlertRuleRequest() = default;
};
class DeletePrometheusAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeletePrometheusAlertRuleResponseBody() {}

  explicit DeletePrometheusAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeletePrometheusAlertRuleResponseBody() = default;
};
class DeletePrometheusAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePrometheusAlertRuleResponseBody> body{};

  DeletePrometheusAlertRuleResponse() {}

  explicit DeletePrometheusAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrometheusAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrometheusAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrometheusAlertRuleResponse() = default;
};
class DeletePrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> regionId{};

  DeletePrometheusGlobalViewRequest() {}

  explicit DeletePrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeletePrometheusGlobalViewRequest() = default;
};
class DeletePrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeletePrometheusGlobalViewResponseBody() {}

  explicit DeletePrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePrometheusGlobalViewResponseBody() = default;
};
class DeletePrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePrometheusGlobalViewResponseBody> body{};

  DeletePrometheusGlobalViewResponse() {}

  explicit DeletePrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrometheusGlobalViewResponse() = default;
};
class DeletePrometheusIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> regionId{};

  DeletePrometheusIntegrationRequest() {}

  explicit DeletePrometheusIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeletePrometheusIntegrationRequest() = default;
};
class DeletePrometheusIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeletePrometheusIntegrationResponseBody() {}

  explicit DeletePrometheusIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePrometheusIntegrationResponseBody() = default;
};
class DeletePrometheusIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePrometheusIntegrationResponseBody> body{};

  DeletePrometheusIntegrationResponse() {}

  explicit DeletePrometheusIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrometheusIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrometheusIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrometheusIntegrationResponse() = default;
};
class DeletePrometheusMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  DeletePrometheusMonitoringRequest() {}

  explicit DeletePrometheusMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeletePrometheusMonitoringRequest() = default;
};
class DeletePrometheusMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeletePrometheusMonitoringResponseBody() {}

  explicit DeletePrometheusMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePrometheusMonitoringResponseBody() = default;
};
class DeletePrometheusMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePrometheusMonitoringResponseBody> body{};

  DeletePrometheusMonitoringResponse() {}

  explicit DeletePrometheusMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrometheusMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrometheusMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrometheusMonitoringResponse() = default;
};
class DeleteRetcodeAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};

  DeleteRetcodeAppRequest() {}

  explicit DeleteRetcodeAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteRetcodeAppRequest() = default;
};
class DeleteRetcodeAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteRetcodeAppResponseBody() {}

  explicit DeleteRetcodeAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteRetcodeAppResponseBody() = default;
};
class DeleteRetcodeAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRetcodeAppResponseBody> body{};

  DeleteRetcodeAppResponse() {}

  explicit DeleteRetcodeAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRetcodeAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRetcodeAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRetcodeAppResponse() = default;
};
class DeleteRumAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appGroup{};
  shared_ptr<string> appId{};
  shared_ptr<string> realRegionId{};
  shared_ptr<string> regionId{};

  DeleteRumAppRequest() {}

  explicit DeleteRumAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGroup) {
      res["AppGroup"] = boost::any(*appGroup);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (realRegionId) {
      res["RealRegionId"] = boost::any(*realRegionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGroup") != m.end() && !m["AppGroup"].empty()) {
      appGroup = make_shared<string>(boost::any_cast<string>(m["AppGroup"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RealRegionId") != m.end() && !m["RealRegionId"].empty()) {
      realRegionId = make_shared<string>(boost::any_cast<string>(m["RealRegionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteRumAppRequest() = default;
};
class DeleteRumAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DeleteRumAppResponseBody() {}

  explicit DeleteRumAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteRumAppResponseBody() = default;
};
class DeleteRumAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRumAppResponseBody> body{};

  DeleteRumAppResponse() {}

  explicit DeleteRumAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRumAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRumAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRumAppResponse() = default;
};
class DeleteRumUploadFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> batchItems{};
  shared_ptr<string> fileName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> versionId{};

  DeleteRumUploadFileRequest() {}

  explicit DeleteRumUploadFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchItems) {
      res["BatchItems"] = boost::any(*batchItems);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchItems") != m.end() && !m["BatchItems"].empty()) {
      batchItems = make_shared<string>(boost::any_cast<string>(m["BatchItems"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DeleteRumUploadFileRequest() = default;
};
class DeleteRumUploadFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteRumUploadFileResponseBody() {}

  explicit DeleteRumUploadFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteRumUploadFileResponseBody() = default;
};
class DeleteRumUploadFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRumUploadFileResponseBody> body{};

  DeleteRumUploadFileResponse() {}

  explicit DeleteRumUploadFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRumUploadFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRumUploadFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRumUploadFileResponse() = default;
};
class DeleteScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<long> scenarioId{};

  DeleteScenarioRequest() {}

  explicit DeleteScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<long>(boost::any_cast<long>(m["ScenarioId"]));
    }
  }


  virtual ~DeleteScenarioRequest() = default;
};
class DeleteScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteScenarioResponseBody() {}

  explicit DeleteScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteScenarioResponseBody() = default;
};
class DeleteScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScenarioResponseBody> body{};

  DeleteScenarioResponse() {}

  explicit DeleteScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScenarioResponse() = default;
};
class DeleteSilencePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteSilencePolicyRequest() {}

  explicit DeleteSilencePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteSilencePolicyRequest() = default;
};
class DeleteSilencePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteSilencePolicyResponseBody() {}

  explicit DeleteSilencePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSilencePolicyResponseBody() = default;
};
class DeleteSilencePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSilencePolicyResponseBody> body{};

  DeleteSilencePolicyResponse() {}

  explicit DeleteSilencePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSilencePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSilencePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSilencePolicyResponse() = default;
};
class DeleteSourceMapRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fidList{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};

  DeleteSourceMapRequest() {}

  explicit DeleteSourceMapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fidList) {
      res["FidList"] = boost::any(*fidList);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FidList") != m.end() && !m["FidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fidList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteSourceMapRequest() = default;
};
class DeleteSourceMapShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> fidListShrink{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};

  DeleteSourceMapShrinkRequest() {}

  explicit DeleteSourceMapShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fidListShrink) {
      res["FidList"] = boost::any(*fidListShrink);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FidList") != m.end() && !m["FidList"].empty()) {
      fidListShrink = make_shared<string>(boost::any_cast<string>(m["FidList"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteSourceMapShrinkRequest() = default;
};
class DeleteSourceMapResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DeleteSourceMapResponseBody() {}

  explicit DeleteSourceMapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSourceMapResponseBody() = default;
};
class DeleteSourceMapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSourceMapResponseBody> body{};

  DeleteSourceMapResponse() {}

  explicit DeleteSourceMapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSourceMapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSourceMapResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSourceMapResponse() = default;
};
class DeleteSyntheticTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> taskIds{};

  DeleteSyntheticTaskRequest() {}

  explicit DeleteSyntheticTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteSyntheticTaskRequest() = default;
};
class DeleteSyntheticTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteSyntheticTaskResponseBody() {}

  explicit DeleteSyntheticTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteSyntheticTaskResponseBody() = default;
};
class DeleteSyntheticTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSyntheticTaskResponseBody> body{};

  DeleteSyntheticTaskResponse() {}

  explicit DeleteSyntheticTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSyntheticTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSyntheticTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSyntheticTaskResponse() = default;
};
class DeleteTimingSyntheticTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> taskId{};

  DeleteTimingSyntheticTaskRequest() {}

  explicit DeleteTimingSyntheticTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteTimingSyntheticTaskRequest() = default;
};
class DeleteTimingSyntheticTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteTimingSyntheticTaskResponseBody() {}

  explicit DeleteTimingSyntheticTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTimingSyntheticTaskResponseBody() = default;
};
class DeleteTimingSyntheticTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTimingSyntheticTaskResponseBody> body{};

  DeleteTimingSyntheticTaskResponse() {}

  explicit DeleteTimingSyntheticTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTimingSyntheticTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTimingSyntheticTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTimingSyntheticTaskResponse() = default;
};
class DeleteTraceAppRequestDeleteReasonReasonIds : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  DeleteTraceAppRequestDeleteReasonReasonIds() {}

  explicit DeleteTraceAppRequestDeleteReasonReasonIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteTraceAppRequestDeleteReasonReasonIds() = default;
};
class DeleteTraceAppRequestDeleteReason : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteTraceAppRequestDeleteReasonReasonIds>> reasonIds{};
  shared_ptr<string> remark{};

  DeleteTraceAppRequestDeleteReason() {}

  explicit DeleteTraceAppRequestDeleteReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reasonIds) {
      vector<boost::any> temp1;
      for(auto item1:*reasonIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReasonIds"] = boost::any(temp1);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReasonIds") != m.end() && !m["ReasonIds"].empty()) {
      if (typeid(vector<boost::any>) == m["ReasonIds"].type()) {
        vector<DeleteTraceAppRequestDeleteReasonReasonIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReasonIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteTraceAppRequestDeleteReasonReasonIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reasonIds = make_shared<vector<DeleteTraceAppRequestDeleteReasonReasonIds>>(expect1);
      }
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~DeleteTraceAppRequestDeleteReason() = default;
};
class DeleteTraceAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<DeleteTraceAppRequestDeleteReason> deleteReason{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  DeleteTraceAppRequest() {}

  explicit DeleteTraceAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deleteReason) {
      res["DeleteReason"] = deleteReason ? boost::any(deleteReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeleteReason") != m.end() && !m["DeleteReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeleteReason"].type()) {
        DeleteTraceAppRequestDeleteReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeleteReason"]));
        deleteReason = make_shared<DeleteTraceAppRequestDeleteReason>(model1);
      }
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteTraceAppRequest() = default;
};
class DeleteTraceAppShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> deleteReasonShrink{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  DeleteTraceAppShrinkRequest() {}

  explicit DeleteTraceAppShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deleteReasonShrink) {
      res["DeleteReason"] = boost::any(*deleteReasonShrink);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeleteReason") != m.end() && !m["DeleteReason"].empty()) {
      deleteReasonShrink = make_shared<string>(boost::any_cast<string>(m["DeleteReason"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteTraceAppShrinkRequest() = default;
};
class DeleteTraceAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTraceAppResponseBody() {}

  explicit DeleteTraceAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTraceAppResponseBody() = default;
};
class DeleteTraceAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTraceAppResponseBody> body{};

  DeleteTraceAppResponse() {}

  explicit DeleteTraceAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTraceAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTraceAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTraceAppResponse() = default;
};
class DeleteWebhookContactRequest : public Darabonba::Model {
public:
  shared_ptr<long> webhookId{};

  DeleteWebhookContactRequest() {}

  explicit DeleteWebhookContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webhookId) {
      res["WebhookId"] = boost::any(*webhookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WebhookId") != m.end() && !m["WebhookId"].empty()) {
      webhookId = make_shared<long>(boost::any_cast<long>(m["WebhookId"]));
    }
  }


  virtual ~DeleteWebhookContactRequest() = default;
};
class DeleteWebhookContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteWebhookContactResponseBody() {}

  explicit DeleteWebhookContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWebhookContactResponseBody() = default;
};
class DeleteWebhookContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWebhookContactResponseBody> body{};

  DeleteWebhookContactResponse() {}

  explicit DeleteWebhookContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWebhookContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWebhookContactResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWebhookContactResponse() = default;
};
class DescribeAddonReleaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseName{};

  DescribeAddonReleaseRequest() {}

  explicit DescribeAddonReleaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseName) {
      res["ReleaseName"] = boost::any(*releaseName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseName") != m.end() && !m["ReleaseName"].empty()) {
      releaseName = make_shared<string>(boost::any_cast<string>(m["ReleaseName"]));
    }
  }


  virtual ~DescribeAddonReleaseRequest() = default;
};
class DescribeAddonReleaseResponseBodyDataReleaseConditions : public Darabonba::Model {
public:
  shared_ptr<string> firstTransitionTime{};
  shared_ptr<string> lastTransitionTime{};
  shared_ptr<string> message{};
  shared_ptr<string> reason{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeAddonReleaseResponseBodyDataReleaseConditions() {}

  explicit DescribeAddonReleaseResponseBodyDataReleaseConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstTransitionTime) {
      res["FirstTransitionTime"] = boost::any(*firstTransitionTime);
    }
    if (lastTransitionTime) {
      res["LastTransitionTime"] = boost::any(*lastTransitionTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstTransitionTime") != m.end() && !m["FirstTransitionTime"].empty()) {
      firstTransitionTime = make_shared<string>(boost::any_cast<string>(m["FirstTransitionTime"]));
    }
    if (m.find("LastTransitionTime") != m.end() && !m["LastTransitionTime"].empty()) {
      lastTransitionTime = make_shared<string>(boost::any_cast<string>(m["LastTransitionTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeAddonReleaseResponseBodyDataReleaseConditions() = default;
};
class DescribeAddonReleaseResponseBodyDataRelease : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<long> alertRuleCount{};
  shared_ptr<vector<DescribeAddonReleaseResponseBodyDataReleaseConditions>> conditions{};
  shared_ptr<string> createTime{};
  shared_ptr<long> dashboardCount{};
  shared_ptr<string> environmentId{};
  shared_ptr<long> exporterCount{};
  shared_ptr<bool> haveConfig{};
  shared_ptr<string> installUserId{};
  shared_ptr<string> language{};
  shared_ptr<bool> managed{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseId{};
  shared_ptr<string> releaseName{};
  shared_ptr<string> scene{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> userID{};
  shared_ptr<string> version{};

  DescribeAddonReleaseResponseBodyDataRelease() {}

  explicit DescribeAddonReleaseResponseBodyDataRelease(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (alertRuleCount) {
      res["AlertRuleCount"] = boost::any(*alertRuleCount);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dashboardCount) {
      res["DashboardCount"] = boost::any(*dashboardCount);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (exporterCount) {
      res["ExporterCount"] = boost::any(*exporterCount);
    }
    if (haveConfig) {
      res["HaveConfig"] = boost::any(*haveConfig);
    }
    if (installUserId) {
      res["InstallUserId"] = boost::any(*installUserId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (managed) {
      res["Managed"] = boost::any(*managed);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseId) {
      res["ReleaseId"] = boost::any(*releaseId);
    }
    if (releaseName) {
      res["ReleaseName"] = boost::any(*releaseName);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userID) {
      res["UserID"] = boost::any(*userID);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("AlertRuleCount") != m.end() && !m["AlertRuleCount"].empty()) {
      alertRuleCount = make_shared<long>(boost::any_cast<long>(m["AlertRuleCount"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<DescribeAddonReleaseResponseBodyDataReleaseConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAddonReleaseResponseBodyDataReleaseConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<DescribeAddonReleaseResponseBodyDataReleaseConditions>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DashboardCount") != m.end() && !m["DashboardCount"].empty()) {
      dashboardCount = make_shared<long>(boost::any_cast<long>(m["DashboardCount"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("ExporterCount") != m.end() && !m["ExporterCount"].empty()) {
      exporterCount = make_shared<long>(boost::any_cast<long>(m["ExporterCount"]));
    }
    if (m.find("HaveConfig") != m.end() && !m["HaveConfig"].empty()) {
      haveConfig = make_shared<bool>(boost::any_cast<bool>(m["HaveConfig"]));
    }
    if (m.find("InstallUserId") != m.end() && !m["InstallUserId"].empty()) {
      installUserId = make_shared<string>(boost::any_cast<string>(m["InstallUserId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Managed") != m.end() && !m["Managed"].empty()) {
      managed = make_shared<bool>(boost::any_cast<bool>(m["Managed"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseId") != m.end() && !m["ReleaseId"].empty()) {
      releaseId = make_shared<string>(boost::any_cast<string>(m["ReleaseId"]));
    }
    if (m.find("ReleaseName") != m.end() && !m["ReleaseName"].empty()) {
      releaseName = make_shared<string>(boost::any_cast<string>(m["ReleaseName"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UserID") != m.end() && !m["UserID"].empty()) {
      userID = make_shared<string>(boost::any_cast<string>(m["UserID"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAddonReleaseResponseBodyDataRelease() = default;
};
class DescribeAddonReleaseResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<DescribeAddonReleaseResponseBodyDataRelease> release{};

  DescribeAddonReleaseResponseBodyData() {}

  explicit DescribeAddonReleaseResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (release) {
      res["Release"] = release ? boost::any(release->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Release") != m.end() && !m["Release"].empty()) {
      if (typeid(map<string, boost::any>) == m["Release"].type()) {
        DescribeAddonReleaseResponseBodyDataRelease model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Release"]));
        release = make_shared<DescribeAddonReleaseResponseBodyDataRelease>(model1);
      }
    }
  }


  virtual ~DescribeAddonReleaseResponseBodyData() = default;
};
class DescribeAddonReleaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeAddonReleaseResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeAddonReleaseResponseBody() {}

  explicit DescribeAddonReleaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeAddonReleaseResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeAddonReleaseResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeAddonReleaseResponseBody() = default;
};
class DescribeAddonReleaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAddonReleaseResponseBody> body{};

  DescribeAddonReleaseResponse() {}

  explicit DescribeAddonReleaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAddonReleaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAddonReleaseResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAddonReleaseResponse() = default;
};
class DescribeContactGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> groupIds{};
  shared_ptr<bool> isDetail{};
  shared_ptr<long> page{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};

  DescribeContactGroupsRequest() {}

  explicit DescribeContactGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (isDetail) {
      res["IsDetail"] = boost::any(*isDetail);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      groupIds = make_shared<string>(boost::any_cast<string>(m["GroupIds"]));
    }
    if (m.find("IsDetail") != m.end() && !m["IsDetail"].empty()) {
      isDetail = make_shared<bool>(boost::any_cast<bool>(m["IsDetail"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeContactGroupsRequest() = default;
};
class DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts : public Darabonba::Model {
public:
  shared_ptr<long> armsContactId{};
  shared_ptr<double> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> email{};
  shared_ptr<string> phone{};

  DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts() {}

  explicit DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsContactId) {
      res["ArmsContactId"] = boost::any(*armsContactId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmsContactId") != m.end() && !m["ArmsContactId"].empty()) {
      armsContactId = make_shared<long>(boost::any_cast<long>(m["ArmsContactId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<double>(boost::any_cast<double>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts() = default;
};
class DescribeContactGroupsResponseBodyPageBeanAlertContactGroups : public Darabonba::Model {
public:
  shared_ptr<long> armsContactGroupId{};
  shared_ptr<double> contactGroupId{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts>> contacts{};

  DescribeContactGroupsResponseBodyPageBeanAlertContactGroups() {}

  explicit DescribeContactGroupsResponseBodyPageBeanAlertContactGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsContactGroupId) {
      res["ArmsContactGroupId"] = boost::any(*armsContactGroupId);
    }
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmsContactGroupId") != m.end() && !m["ArmsContactGroupId"].empty()) {
      armsContactGroupId = make_shared<long>(boost::any_cast<long>(m["ArmsContactGroupId"]));
    }
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<double>(boost::any_cast<double>(m["ContactGroupId"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts>>(expect1);
      }
    }
  }


  virtual ~DescribeContactGroupsResponseBodyPageBeanAlertContactGroups() = default;
};
class DescribeContactGroupsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroups>> alertContactGroups{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  DescribeContactGroupsResponseBodyPageBean() {}

  explicit DescribeContactGroupsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertContactGroups) {
      vector<boost::any> temp1;
      for(auto item1:*alertContactGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertContactGroups"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertContactGroups") != m.end() && !m["AlertContactGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertContactGroups"].type()) {
        vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertContactGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContactGroupsResponseBodyPageBeanAlertContactGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertContactGroups = make_shared<vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroups>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeContactGroupsResponseBodyPageBean() = default;
};
class DescribeContactGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeContactGroupsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  DescribeContactGroupsResponseBody() {}

  explicit DescribeContactGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        DescribeContactGroupsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<DescribeContactGroupsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeContactGroupsResponseBody() = default;
};
class DescribeContactGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContactGroupsResponseBody> body{};

  DescribeContactGroupsResponse() {}

  explicit DescribeContactGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContactGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContactGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContactGroupsResponse() = default;
};
class DescribeContactsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactIds{};
  shared_ptr<string> contactName{};
  shared_ptr<string> email{};
  shared_ptr<long> page{};
  shared_ptr<string> phone{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};
  shared_ptr<string> verbose{};

  DescribeContactsRequest() {}

  explicit DescribeContactsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (verbose) {
      res["Verbose"] = boost::any(*verbose);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Verbose") != m.end() && !m["Verbose"].empty()) {
      verbose = make_shared<string>(boost::any_cast<string>(m["Verbose"]));
    }
  }


  virtual ~DescribeContactsRequest() = default;
};
class DescribeContactsResponseBodyPageBeanAlertContacts : public Darabonba::Model {
public:
  shared_ptr<long> armsContactId{};
  shared_ptr<double> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> email{};
  shared_ptr<bool> isEmailVerify{};
  shared_ptr<bool> isVerify{};
  shared_ptr<string> phone{};
  shared_ptr<long> reissueSendNotice{};

  DescribeContactsResponseBodyPageBeanAlertContacts() {}

  explicit DescribeContactsResponseBodyPageBeanAlertContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsContactId) {
      res["ArmsContactId"] = boost::any(*armsContactId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (isEmailVerify) {
      res["IsEmailVerify"] = boost::any(*isEmailVerify);
    }
    if (isVerify) {
      res["IsVerify"] = boost::any(*isVerify);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (reissueSendNotice) {
      res["ReissueSendNotice"] = boost::any(*reissueSendNotice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmsContactId") != m.end() && !m["ArmsContactId"].empty()) {
      armsContactId = make_shared<long>(boost::any_cast<long>(m["ArmsContactId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<double>(boost::any_cast<double>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("IsEmailVerify") != m.end() && !m["IsEmailVerify"].empty()) {
      isEmailVerify = make_shared<bool>(boost::any_cast<bool>(m["IsEmailVerify"]));
    }
    if (m.find("IsVerify") != m.end() && !m["IsVerify"].empty()) {
      isVerify = make_shared<bool>(boost::any_cast<bool>(m["IsVerify"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ReissueSendNotice") != m.end() && !m["ReissueSendNotice"].empty()) {
      reissueSendNotice = make_shared<long>(boost::any_cast<long>(m["ReissueSendNotice"]));
    }
  }


  virtual ~DescribeContactsResponseBodyPageBeanAlertContacts() = default;
};
class DescribeContactsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeContactsResponseBodyPageBeanAlertContacts>> alertContacts{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  DescribeContactsResponseBodyPageBean() {}

  explicit DescribeContactsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertContacts) {
      vector<boost::any> temp1;
      for(auto item1:*alertContacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertContacts"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertContacts") != m.end() && !m["AlertContacts"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertContacts"].type()) {
        vector<DescribeContactsResponseBodyPageBeanAlertContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertContacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContactsResponseBodyPageBeanAlertContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertContacts = make_shared<vector<DescribeContactsResponseBodyPageBeanAlertContacts>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeContactsResponseBodyPageBean() = default;
};
class DescribeContactsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeContactsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  DescribeContactsResponseBody() {}

  explicit DescribeContactsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        DescribeContactsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<DescribeContactsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeContactsResponseBody() = default;
};
class DescribeContactsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContactsResponseBody> body{};

  DescribeContactsResponse() {}

  explicit DescribeContactsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContactsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContactsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContactsResponse() = default;
};
class DescribeDispatchRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  DescribeDispatchRuleRequest() {}

  explicit DescribeDispatchRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDispatchRuleRequest() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleGroupRules : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<long> groupInterval{};
  shared_ptr<long> groupWaitTime{};
  shared_ptr<vector<string>> groupingFields{};
  shared_ptr<long> repeatInterval{};

  DescribeDispatchRuleResponseBodyDispatchRuleGroupRules() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleGroupRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupInterval) {
      res["GroupInterval"] = boost::any(*groupInterval);
    }
    if (groupWaitTime) {
      res["GroupWaitTime"] = boost::any(*groupWaitTime);
    }
    if (groupingFields) {
      res["GroupingFields"] = boost::any(*groupingFields);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupInterval") != m.end() && !m["GroupInterval"].empty()) {
      groupInterval = make_shared<long>(boost::any_cast<long>(m["GroupInterval"]));
    }
    if (m.find("GroupWaitTime") != m.end() && !m["GroupWaitTime"].empty()) {
      groupWaitTime = make_shared<long>(boost::any_cast<long>(m["GroupWaitTime"]));
    }
    if (m.find("GroupingFields") != m.end() && !m["GroupingFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupingFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupingFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupingFields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleGroupRules() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions>> labelMatchExpressions{};

  DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelMatchExpressions) {
      vector<boost::any> temp1;
      for(auto item1:*labelMatchExpressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LabelMatchExpressions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LabelMatchExpressions") != m.end() && !m["LabelMatchExpressions"].empty()) {
      if (typeid(vector<boost::any>) == m["LabelMatchExpressions"].type()) {
        vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LabelMatchExpressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labelMatchExpressions = make_shared<vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions>>(expect1);
      }
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups>> labelMatchExpressionGroups{};

  DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelMatchExpressionGroups) {
      vector<boost::any> temp1;
      for(auto item1:*labelMatchExpressionGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LabelMatchExpressionGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LabelMatchExpressionGroups") != m.end() && !m["LabelMatchExpressionGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["LabelMatchExpressionGroups"].type()) {
        vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LabelMatchExpressionGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labelMatchExpressionGroups = make_shared<vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups>>(expect1);
      }
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> notifyObjectId{};
  shared_ptr<string> notifyType{};

  DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyObjectId) {
      res["NotifyObjectId"] = boost::any(*notifyObjectId);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyObjectId") != m.end() && !m["NotifyObjectId"].empty()) {
      notifyObjectId = make_shared<string>(boost::any_cast<string>(m["NotifyObjectId"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects>> notifyObjects{};

  DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyChannels) {
      res["NotifyChannels"] = boost::any(*notifyChannels);
    }
    if (notifyObjects) {
      vector<boost::any> temp1;
      for(auto item1:*notifyObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotifyObjects"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyChannels") != m.end() && !m["NotifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyObjects") != m.end() && !m["NotifyObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["NotifyObjects"].type()) {
        vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotifyObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyObjects = make_shared<vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects>>(expect1);
      }
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRule : public Darabonba::Model {
public:
  shared_ptr<string> dispatchType{};
  shared_ptr<vector<DescribeDispatchRuleResponseBodyDispatchRuleGroupRules>> groupRules{};
  shared_ptr<bool> isRecover{};
  shared_ptr<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid> labelMatchExpressionGrid{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules>> notifyRules{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> state{};

  DescribeDispatchRuleResponseBodyDispatchRule() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchType) {
      res["DispatchType"] = boost::any(*dispatchType);
    }
    if (groupRules) {
      vector<boost::any> temp1;
      for(auto item1:*groupRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupRules"] = boost::any(temp1);
    }
    if (isRecover) {
      res["IsRecover"] = boost::any(*isRecover);
    }
    if (labelMatchExpressionGrid) {
      res["LabelMatchExpressionGrid"] = labelMatchExpressionGrid ? boost::any(labelMatchExpressionGrid->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyRules) {
      vector<boost::any> temp1;
      for(auto item1:*notifyRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotifyRules"] = boost::any(temp1);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchType") != m.end() && !m["DispatchType"].empty()) {
      dispatchType = make_shared<string>(boost::any_cast<string>(m["DispatchType"]));
    }
    if (m.find("GroupRules") != m.end() && !m["GroupRules"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupRules"].type()) {
        vector<DescribeDispatchRuleResponseBodyDispatchRuleGroupRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDispatchRuleResponseBodyDispatchRuleGroupRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupRules = make_shared<vector<DescribeDispatchRuleResponseBodyDispatchRuleGroupRules>>(expect1);
      }
    }
    if (m.find("IsRecover") != m.end() && !m["IsRecover"].empty()) {
      isRecover = make_shared<bool>(boost::any_cast<bool>(m["IsRecover"]));
    }
    if (m.find("LabelMatchExpressionGrid") != m.end() && !m["LabelMatchExpressionGrid"].empty()) {
      if (typeid(map<string, boost::any>) == m["LabelMatchExpressionGrid"].type()) {
        DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LabelMatchExpressionGrid"]));
        labelMatchExpressionGrid = make_shared<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyRules") != m.end() && !m["NotifyRules"].empty()) {
      if (typeid(vector<boost::any>) == m["NotifyRules"].type()) {
        vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotifyRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyRules = make_shared<vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules>>(expect1);
      }
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRule() = default;
};
class DescribeDispatchRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDispatchRuleResponseBodyDispatchRule> dispatchRule{};
  shared_ptr<string> requestId{};

  DescribeDispatchRuleResponseBody() {}

  explicit DescribeDispatchRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchRule) {
      res["DispatchRule"] = dispatchRule ? boost::any(dispatchRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchRule") != m.end() && !m["DispatchRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["DispatchRule"].type()) {
        DescribeDispatchRuleResponseBodyDispatchRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DispatchRule"]));
        dispatchRule = make_shared<DescribeDispatchRuleResponseBodyDispatchRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDispatchRuleResponseBody() = default;
};
class DescribeDispatchRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDispatchRuleResponseBody> body{};

  DescribeDispatchRuleResponse() {}

  explicit DescribeDispatchRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDispatchRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDispatchRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDispatchRuleResponse() = default;
};
class DescribeEnvCustomJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> customJobName{};
  shared_ptr<bool> encryptYaml{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  DescribeEnvCustomJobRequest() {}

  explicit DescribeEnvCustomJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customJobName) {
      res["CustomJobName"] = boost::any(*customJobName);
    }
    if (encryptYaml) {
      res["EncryptYaml"] = boost::any(*encryptYaml);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomJobName") != m.end() && !m["CustomJobName"].empty()) {
      customJobName = make_shared<string>(boost::any_cast<string>(m["CustomJobName"]));
    }
    if (m.find("EncryptYaml") != m.end() && !m["EncryptYaml"].empty()) {
      encryptYaml = make_shared<bool>(boost::any_cast<bool>(m["EncryptYaml"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeEnvCustomJobRequest() = default;
};
class DescribeEnvCustomJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> configYaml{};
  shared_ptr<string> customJobName{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  DescribeEnvCustomJobResponseBodyData() {}

  explicit DescribeEnvCustomJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (customJobName) {
      res["CustomJobName"] = boost::any(*customJobName);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("CustomJobName") != m.end() && !m["CustomJobName"].empty()) {
      customJobName = make_shared<string>(boost::any_cast<string>(m["CustomJobName"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeEnvCustomJobResponseBodyData() = default;
};
class DescribeEnvCustomJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnvCustomJobResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DescribeEnvCustomJobResponseBody() {}

  explicit DescribeEnvCustomJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeEnvCustomJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeEnvCustomJobResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnvCustomJobResponseBody() = default;
};
class DescribeEnvCustomJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnvCustomJobResponseBody> body{};

  DescribeEnvCustomJobResponse() {}

  explicit DescribeEnvCustomJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnvCustomJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnvCustomJobResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnvCustomJobResponse() = default;
};
class DescribeEnvPodMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> environmentId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> podMonitorName{};
  shared_ptr<string> regionId{};

  DescribeEnvPodMonitorRequest() {}

  explicit DescribeEnvPodMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (podMonitorName) {
      res["PodMonitorName"] = boost::any(*podMonitorName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PodMonitorName") != m.end() && !m["PodMonitorName"].empty()) {
      podMonitorName = make_shared<string>(boost::any_cast<string>(m["PodMonitorName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeEnvPodMonitorRequest() = default;
};
class DescribeEnvPodMonitorResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> configYaml{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> podMonitorName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  DescribeEnvPodMonitorResponseBodyData() {}

  explicit DescribeEnvPodMonitorResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (podMonitorName) {
      res["PodMonitorName"] = boost::any(*podMonitorName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PodMonitorName") != m.end() && !m["PodMonitorName"].empty()) {
      podMonitorName = make_shared<string>(boost::any_cast<string>(m["PodMonitorName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeEnvPodMonitorResponseBodyData() = default;
};
class DescribeEnvPodMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnvPodMonitorResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DescribeEnvPodMonitorResponseBody() {}

  explicit DescribeEnvPodMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeEnvPodMonitorResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeEnvPodMonitorResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnvPodMonitorResponseBody() = default;
};
class DescribeEnvPodMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnvPodMonitorResponseBody> body{};

  DescribeEnvPodMonitorResponse() {}

  explicit DescribeEnvPodMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnvPodMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnvPodMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnvPodMonitorResponse() = default;
};
class DescribeEnvServiceMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> environmentId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceMonitorName{};

  DescribeEnvServiceMonitorRequest() {}

  explicit DescribeEnvServiceMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceMonitorName) {
      res["ServiceMonitorName"] = boost::any(*serviceMonitorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceMonitorName") != m.end() && !m["ServiceMonitorName"].empty()) {
      serviceMonitorName = make_shared<string>(boost::any_cast<string>(m["ServiceMonitorName"]));
    }
  }


  virtual ~DescribeEnvServiceMonitorRequest() = default;
};
class DescribeEnvServiceMonitorResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> configYaml{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceMonitorName{};
  shared_ptr<string> status{};

  DescribeEnvServiceMonitorResponseBodyData() {}

  explicit DescribeEnvServiceMonitorResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceMonitorName) {
      res["ServiceMonitorName"] = boost::any(*serviceMonitorName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceMonitorName") != m.end() && !m["ServiceMonitorName"].empty()) {
      serviceMonitorName = make_shared<string>(boost::any_cast<string>(m["ServiceMonitorName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeEnvServiceMonitorResponseBodyData() = default;
};
class DescribeEnvServiceMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnvServiceMonitorResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DescribeEnvServiceMonitorResponseBody() {}

  explicit DescribeEnvServiceMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeEnvServiceMonitorResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeEnvServiceMonitorResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnvServiceMonitorResponseBody() = default;
};
class DescribeEnvServiceMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnvServiceMonitorResponseBody> body{};

  DescribeEnvServiceMonitorResponse() {}

  explicit DescribeEnvServiceMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnvServiceMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnvServiceMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnvServiceMonitorResponse() = default;
};
class DescribeEnvironmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  DescribeEnvironmentRequest() {}

  explicit DescribeEnvironmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeEnvironmentRequest() = default;
};
class DescribeEnvironmentResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEnvironmentResponseBodyDataTags() {}

  explicit DescribeEnvironmentResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEnvironmentResponseBodyDataTags() = default;
};
class DescribeEnvironmentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> bindResourceId{};
  shared_ptr<string> bindResourceProfile{};
  shared_ptr<string> bindResourceStatus{};
  shared_ptr<string> bindResourceStoreDuration{};
  shared_ptr<string> bindResourceType{};
  shared_ptr<string> bindVpcCidr{};
  shared_ptr<string> dbInstanceStatus{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> environmentName{};
  shared_ptr<string> environmentSubType{};
  shared_ptr<string> environmentType{};
  shared_ptr<string> feePackage{};
  shared_ptr<string> grafaDataSourceName{};
  shared_ptr<string> grafanaDatasourceUid{};
  shared_ptr<string> grafanaFolderTitle{};
  shared_ptr<string> grafanaFolderUid{};
  shared_ptr<string> grafanaFolderUrl{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<string> managedType{};
  shared_ptr<string> prometheusInstanceId{};
  shared_ptr<string> prometheusInstanceName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<DescribeEnvironmentResponseBodyDataTags>> tags{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  DescribeEnvironmentResponseBodyData() {}

  explicit DescribeEnvironmentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindResourceId) {
      res["BindResourceId"] = boost::any(*bindResourceId);
    }
    if (bindResourceProfile) {
      res["BindResourceProfile"] = boost::any(*bindResourceProfile);
    }
    if (bindResourceStatus) {
      res["BindResourceStatus"] = boost::any(*bindResourceStatus);
    }
    if (bindResourceStoreDuration) {
      res["BindResourceStoreDuration"] = boost::any(*bindResourceStoreDuration);
    }
    if (bindResourceType) {
      res["BindResourceType"] = boost::any(*bindResourceType);
    }
    if (bindVpcCidr) {
      res["BindVpcCidr"] = boost::any(*bindVpcCidr);
    }
    if (dbInstanceStatus) {
      res["DbInstanceStatus"] = boost::any(*dbInstanceStatus);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (environmentName) {
      res["EnvironmentName"] = boost::any(*environmentName);
    }
    if (environmentSubType) {
      res["EnvironmentSubType"] = boost::any(*environmentSubType);
    }
    if (environmentType) {
      res["EnvironmentType"] = boost::any(*environmentType);
    }
    if (feePackage) {
      res["FeePackage"] = boost::any(*feePackage);
    }
    if (grafaDataSourceName) {
      res["GrafaDataSourceName"] = boost::any(*grafaDataSourceName);
    }
    if (grafanaDatasourceUid) {
      res["GrafanaDatasourceUid"] = boost::any(*grafanaDatasourceUid);
    }
    if (grafanaFolderTitle) {
      res["GrafanaFolderTitle"] = boost::any(*grafanaFolderTitle);
    }
    if (grafanaFolderUid) {
      res["GrafanaFolderUid"] = boost::any(*grafanaFolderUid);
    }
    if (grafanaFolderUrl) {
      res["GrafanaFolderUrl"] = boost::any(*grafanaFolderUrl);
    }
    if (grafanaWorkspaceId) {
      res["GrafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (managedType) {
      res["ManagedType"] = boost::any(*managedType);
    }
    if (prometheusInstanceId) {
      res["PrometheusInstanceId"] = boost::any(*prometheusInstanceId);
    }
    if (prometheusInstanceName) {
      res["PrometheusInstanceName"] = boost::any(*prometheusInstanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindResourceId") != m.end() && !m["BindResourceId"].empty()) {
      bindResourceId = make_shared<string>(boost::any_cast<string>(m["BindResourceId"]));
    }
    if (m.find("BindResourceProfile") != m.end() && !m["BindResourceProfile"].empty()) {
      bindResourceProfile = make_shared<string>(boost::any_cast<string>(m["BindResourceProfile"]));
    }
    if (m.find("BindResourceStatus") != m.end() && !m["BindResourceStatus"].empty()) {
      bindResourceStatus = make_shared<string>(boost::any_cast<string>(m["BindResourceStatus"]));
    }
    if (m.find("BindResourceStoreDuration") != m.end() && !m["BindResourceStoreDuration"].empty()) {
      bindResourceStoreDuration = make_shared<string>(boost::any_cast<string>(m["BindResourceStoreDuration"]));
    }
    if (m.find("BindResourceType") != m.end() && !m["BindResourceType"].empty()) {
      bindResourceType = make_shared<string>(boost::any_cast<string>(m["BindResourceType"]));
    }
    if (m.find("BindVpcCidr") != m.end() && !m["BindVpcCidr"].empty()) {
      bindVpcCidr = make_shared<string>(boost::any_cast<string>(m["BindVpcCidr"]));
    }
    if (m.find("DbInstanceStatus") != m.end() && !m["DbInstanceStatus"].empty()) {
      dbInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DbInstanceStatus"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("EnvironmentName") != m.end() && !m["EnvironmentName"].empty()) {
      environmentName = make_shared<string>(boost::any_cast<string>(m["EnvironmentName"]));
    }
    if (m.find("EnvironmentSubType") != m.end() && !m["EnvironmentSubType"].empty()) {
      environmentSubType = make_shared<string>(boost::any_cast<string>(m["EnvironmentSubType"]));
    }
    if (m.find("EnvironmentType") != m.end() && !m["EnvironmentType"].empty()) {
      environmentType = make_shared<string>(boost::any_cast<string>(m["EnvironmentType"]));
    }
    if (m.find("FeePackage") != m.end() && !m["FeePackage"].empty()) {
      feePackage = make_shared<string>(boost::any_cast<string>(m["FeePackage"]));
    }
    if (m.find("GrafaDataSourceName") != m.end() && !m["GrafaDataSourceName"].empty()) {
      grafaDataSourceName = make_shared<string>(boost::any_cast<string>(m["GrafaDataSourceName"]));
    }
    if (m.find("GrafanaDatasourceUid") != m.end() && !m["GrafanaDatasourceUid"].empty()) {
      grafanaDatasourceUid = make_shared<string>(boost::any_cast<string>(m["GrafanaDatasourceUid"]));
    }
    if (m.find("GrafanaFolderTitle") != m.end() && !m["GrafanaFolderTitle"].empty()) {
      grafanaFolderTitle = make_shared<string>(boost::any_cast<string>(m["GrafanaFolderTitle"]));
    }
    if (m.find("GrafanaFolderUid") != m.end() && !m["GrafanaFolderUid"].empty()) {
      grafanaFolderUid = make_shared<string>(boost::any_cast<string>(m["GrafanaFolderUid"]));
    }
    if (m.find("GrafanaFolderUrl") != m.end() && !m["GrafanaFolderUrl"].empty()) {
      grafanaFolderUrl = make_shared<string>(boost::any_cast<string>(m["GrafanaFolderUrl"]));
    }
    if (m.find("GrafanaWorkspaceId") != m.end() && !m["GrafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceId"]));
    }
    if (m.find("ManagedType") != m.end() && !m["ManagedType"].empty()) {
      managedType = make_shared<string>(boost::any_cast<string>(m["ManagedType"]));
    }
    if (m.find("PrometheusInstanceId") != m.end() && !m["PrometheusInstanceId"].empty()) {
      prometheusInstanceId = make_shared<string>(boost::any_cast<string>(m["PrometheusInstanceId"]));
    }
    if (m.find("PrometheusInstanceName") != m.end() && !m["PrometheusInstanceName"].empty()) {
      prometheusInstanceName = make_shared<string>(boost::any_cast<string>(m["PrometheusInstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeEnvironmentResponseBodyDataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnvironmentResponseBodyDataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeEnvironmentResponseBodyDataTags>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~DescribeEnvironmentResponseBodyData() = default;
};
class DescribeEnvironmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnvironmentResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DescribeEnvironmentResponseBody() {}

  explicit DescribeEnvironmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeEnvironmentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeEnvironmentResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnvironmentResponseBody() = default;
};
class DescribeEnvironmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnvironmentResponseBody> body{};

  DescribeEnvironmentResponse() {}

  explicit DescribeEnvironmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnvironmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnvironmentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnvironmentResponse() = default;
};
class DescribeEnvironmentFeatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> featureName{};
  shared_ptr<string> regionId{};

  DescribeEnvironmentFeatureRequest() {}

  explicit DescribeEnvironmentFeatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (featureName) {
      res["FeatureName"] = boost::any(*featureName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("FeatureName") != m.end() && !m["FeatureName"].empty()) {
      featureName = make_shared<string>(boost::any_cast<string>(m["FeatureName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeEnvironmentFeatureRequest() = default;
};
class DescribeEnvironmentFeatureResponseBodyDataFeature : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<map<string, string>> config{};
  shared_ptr<string> description{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> icon{};
  shared_ptr<string> language{};
  shared_ptr<string> latestVersion{};
  shared_ptr<bool> managed{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> version{};

  DescribeEnvironmentFeatureResponseBodyDataFeature() {}

  explicit DescribeEnvironmentFeatureResponseBodyDataFeature(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (latestVersion) {
      res["LatestVersion"] = boost::any(*latestVersion);
    }
    if (managed) {
      res["Managed"] = boost::any(*managed);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Config"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      config = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LatestVersion") != m.end() && !m["LatestVersion"].empty()) {
      latestVersion = make_shared<string>(boost::any_cast<string>(m["LatestVersion"]));
    }
    if (m.find("Managed") != m.end() && !m["Managed"].empty()) {
      managed = make_shared<bool>(boost::any_cast<bool>(m["Managed"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEnvironmentFeatureResponseBodyDataFeature() = default;
};
class DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> args{};
  shared_ptr<string> image{};
  shared_ptr<string> name{};

  DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers() {}

  explicit DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Args"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Args"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      args = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers() = default;
};
class DescribeEnvironmentFeatureResponseBodyDataFeatureStatus : public Darabonba::Model {
public:
  shared_ptr<string> bindResourceId{};
  shared_ptr<vector<DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers>> featureContainers{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> vSwitchId{};

  DescribeEnvironmentFeatureResponseBodyDataFeatureStatus() {}

  explicit DescribeEnvironmentFeatureResponseBodyDataFeatureStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindResourceId) {
      res["BindResourceId"] = boost::any(*bindResourceId);
    }
    if (featureContainers) {
      vector<boost::any> temp1;
      for(auto item1:*featureContainers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FeatureContainers"] = boost::any(temp1);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindResourceId") != m.end() && !m["BindResourceId"].empty()) {
      bindResourceId = make_shared<string>(boost::any_cast<string>(m["BindResourceId"]));
    }
    if (m.find("FeatureContainers") != m.end() && !m["FeatureContainers"].empty()) {
      if (typeid(vector<boost::any>) == m["FeatureContainers"].type()) {
        vector<DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FeatureContainers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        featureContainers = make_shared<vector<DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers>>(expect1);
      }
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeEnvironmentFeatureResponseBodyDataFeatureStatus() = default;
};
class DescribeEnvironmentFeatureResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<DescribeEnvironmentFeatureResponseBodyDataFeature> feature{};
  shared_ptr<DescribeEnvironmentFeatureResponseBodyDataFeatureStatus> featureStatus{};

  DescribeEnvironmentFeatureResponseBodyData() {}

  explicit DescribeEnvironmentFeatureResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feature) {
      res["Feature"] = feature ? boost::any(feature->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (featureStatus) {
      res["FeatureStatus"] = featureStatus ? boost::any(featureStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Feature") != m.end() && !m["Feature"].empty()) {
      if (typeid(map<string, boost::any>) == m["Feature"].type()) {
        DescribeEnvironmentFeatureResponseBodyDataFeature model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Feature"]));
        feature = make_shared<DescribeEnvironmentFeatureResponseBodyDataFeature>(model1);
      }
    }
    if (m.find("FeatureStatus") != m.end() && !m["FeatureStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["FeatureStatus"].type()) {
        DescribeEnvironmentFeatureResponseBodyDataFeatureStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FeatureStatus"]));
        featureStatus = make_shared<DescribeEnvironmentFeatureResponseBodyDataFeatureStatus>(model1);
      }
    }
  }


  virtual ~DescribeEnvironmentFeatureResponseBodyData() = default;
};
class DescribeEnvironmentFeatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnvironmentFeatureResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeEnvironmentFeatureResponseBody() {}

  explicit DescribeEnvironmentFeatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeEnvironmentFeatureResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeEnvironmentFeatureResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEnvironmentFeatureResponseBody() = default;
};
class DescribeEnvironmentFeatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnvironmentFeatureResponseBody> body{};

  DescribeEnvironmentFeatureResponse() {}

  explicit DescribeEnvironmentFeatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnvironmentFeatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnvironmentFeatureResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnvironmentFeatureResponse() = default;
};
class DescribeIMRobotsRequest : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<string> robotIds{};
  shared_ptr<string> robotName{};
  shared_ptr<long> size{};

  DescribeIMRobotsRequest() {}

  explicit DescribeIMRobotsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (robotIds) {
      res["RobotIds"] = boost::any(*robotIds);
    }
    if (robotName) {
      res["RobotName"] = boost::any(*robotName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("RobotIds") != m.end() && !m["RobotIds"].empty()) {
      robotIds = make_shared<string>(boost::any_cast<string>(m["RobotIds"]));
    }
    if (m.find("RobotName") != m.end() && !m["RobotName"].empty()) {
      robotName = make_shared<string>(boost::any_cast<string>(m["RobotName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeIMRobotsRequest() = default;
};
class DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules() {}

  explicit DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules() = default;
};
class DescribeIMRobotsResponseBodyPageBeanAlertIMRobots : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<bool> dailyNoc{};
  shared_ptr<string> dailyNocTime{};
  shared_ptr<string> dingSignKey{};
  shared_ptr<vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules>> dispatchRules{};
  shared_ptr<string> robotAddr{};
  shared_ptr<double> robotId{};
  shared_ptr<string> robotName{};
  shared_ptr<string> type{};

  DescribeIMRobotsResponseBodyPageBeanAlertIMRobots() {}

  explicit DescribeIMRobotsResponseBodyPageBeanAlertIMRobots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dailyNoc) {
      res["DailyNoc"] = boost::any(*dailyNoc);
    }
    if (dailyNocTime) {
      res["DailyNocTime"] = boost::any(*dailyNocTime);
    }
    if (dingSignKey) {
      res["DingSignKey"] = boost::any(*dingSignKey);
    }
    if (dispatchRules) {
      vector<boost::any> temp1;
      for(auto item1:*dispatchRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DispatchRules"] = boost::any(temp1);
    }
    if (robotAddr) {
      res["RobotAddr"] = boost::any(*robotAddr);
    }
    if (robotId) {
      res["RobotId"] = boost::any(*robotId);
    }
    if (robotName) {
      res["RobotName"] = boost::any(*robotName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DailyNoc") != m.end() && !m["DailyNoc"].empty()) {
      dailyNoc = make_shared<bool>(boost::any_cast<bool>(m["DailyNoc"]));
    }
    if (m.find("DailyNocTime") != m.end() && !m["DailyNocTime"].empty()) {
      dailyNocTime = make_shared<string>(boost::any_cast<string>(m["DailyNocTime"]));
    }
    if (m.find("DingSignKey") != m.end() && !m["DingSignKey"].empty()) {
      dingSignKey = make_shared<string>(boost::any_cast<string>(m["DingSignKey"]));
    }
    if (m.find("DispatchRules") != m.end() && !m["DispatchRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DispatchRules"].type()) {
        vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DispatchRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dispatchRules = make_shared<vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules>>(expect1);
      }
    }
    if (m.find("RobotAddr") != m.end() && !m["RobotAddr"].empty()) {
      robotAddr = make_shared<string>(boost::any_cast<string>(m["RobotAddr"]));
    }
    if (m.find("RobotId") != m.end() && !m["RobotId"].empty()) {
      robotId = make_shared<double>(boost::any_cast<double>(m["RobotId"]));
    }
    if (m.find("RobotName") != m.end() && !m["RobotName"].empty()) {
      robotName = make_shared<string>(boost::any_cast<string>(m["RobotName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeIMRobotsResponseBodyPageBeanAlertIMRobots() = default;
};
class DescribeIMRobotsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobots>> alertIMRobots{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  DescribeIMRobotsResponseBodyPageBean() {}

  explicit DescribeIMRobotsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertIMRobots) {
      vector<boost::any> temp1;
      for(auto item1:*alertIMRobots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertIMRobots"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertIMRobots") != m.end() && !m["AlertIMRobots"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertIMRobots"].type()) {
        vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertIMRobots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIMRobotsResponseBodyPageBeanAlertIMRobots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertIMRobots = make_shared<vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobots>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeIMRobotsResponseBodyPageBean() = default;
};
class DescribeIMRobotsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIMRobotsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  DescribeIMRobotsResponseBody() {}

  explicit DescribeIMRobotsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        DescribeIMRobotsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<DescribeIMRobotsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeIMRobotsResponseBody() = default;
};
class DescribeIMRobotsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIMRobotsResponseBody> body{};

  DescribeIMRobotsResponse() {}

  explicit DescribeIMRobotsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIMRobotsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIMRobotsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIMRobotsResponse() = default;
};
class DescribePrometheusAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> clusterId{};

  DescribePrometheusAlertRuleRequest() {}

  explicit DescribePrometheusAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribePrometheusAlertRuleRequest() = default;
};
class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() {}

  explicit DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() = default;
};
class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() {}

  explicit DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() = default;
};
class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule() {}

  explicit DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>>(expect1);
      }
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule() = default;
};
class DescribePrometheusAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule> prometheusAlertRule{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribePrometheusAlertRuleResponseBody() {}

  explicit DescribePrometheusAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (prometheusAlertRule) {
      res["PrometheusAlertRule"] = prometheusAlertRule ? boost::any(prometheusAlertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PrometheusAlertRule") != m.end() && !m["PrometheusAlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrometheusAlertRule"].type()) {
        DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrometheusAlertRule"]));
        prometheusAlertRule = make_shared<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribePrometheusAlertRuleResponseBody() = default;
};
class DescribePrometheusAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePrometheusAlertRuleResponseBody> body{};

  DescribePrometheusAlertRuleResponse() {}

  explicit DescribePrometheusAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePrometheusAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePrometheusAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePrometheusAlertRuleResponse() = default;
};
class DescribeTraceLicenseKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeTraceLicenseKeyRequest() {}

  explicit DescribeTraceLicenseKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeTraceLicenseKeyRequest() = default;
};
class DescribeTraceLicenseKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> licenseKey{};
  shared_ptr<string> requestId{};

  DescribeTraceLicenseKeyResponseBody() {}

  explicit DescribeTraceLicenseKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (licenseKey) {
      res["LicenseKey"] = boost::any(*licenseKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LicenseKey") != m.end() && !m["LicenseKey"].empty()) {
      licenseKey = make_shared<string>(boost::any_cast<string>(m["LicenseKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeTraceLicenseKeyResponseBody() = default;
};
class DescribeTraceLicenseKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTraceLicenseKeyResponseBody> body{};

  DescribeTraceLicenseKeyResponse() {}

  explicit DescribeTraceLicenseKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTraceLicenseKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTraceLicenseKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTraceLicenseKeyResponse() = default;
};
class DescribeWebhookContactsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactIds{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<string> webhookName{};

  DescribeWebhookContactsRequest() {}

  explicit DescribeWebhookContactsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (webhookName) {
      res["WebhookName"] = boost::any(*webhookName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("WebhookName") != m.end() && !m["WebhookName"].empty()) {
      webhookName = make_shared<string>(boost::any_cast<string>(m["WebhookName"]));
    }
  }


  virtual ~DescribeWebhookContactsRequest() = default;
};
class DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> bizHeaders{};
  shared_ptr<map<string, boost::any>> bizParams{};
  shared_ptr<string> body{};
  shared_ptr<string> method{};
  shared_ptr<string> recoverBody{};
  shared_ptr<string> url{};

  DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook() {}

  explicit DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizHeaders) {
      res["BizHeaders"] = boost::any(*bizHeaders);
    }
    if (bizParams) {
      res["BizParams"] = boost::any(*bizParams);
    }
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (recoverBody) {
      res["RecoverBody"] = boost::any(*recoverBody);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizHeaders") != m.end() && !m["BizHeaders"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["BizHeaders"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bizHeaders = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("BizParams") != m.end() && !m["BizParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["BizParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bizParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("RecoverBody") != m.end() && !m["RecoverBody"].empty()) {
      recoverBody = make_shared<string>(boost::any_cast<string>(m["RecoverBody"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook() = default;
};
class DescribeWebhookContactsResponseBodyPageBeanWebhookContacts : public Darabonba::Model {
public:
  shared_ptr<DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook> webhook{};
  shared_ptr<double> webhookId{};
  shared_ptr<string> webhookName{};

  DescribeWebhookContactsResponseBodyPageBeanWebhookContacts() {}

  explicit DescribeWebhookContactsResponseBodyPageBeanWebhookContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webhook) {
      res["Webhook"] = webhook ? boost::any(webhook->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webhookId) {
      res["WebhookId"] = boost::any(*webhookId);
    }
    if (webhookName) {
      res["WebhookName"] = boost::any(*webhookName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webhook"].type()) {
        DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webhook"]));
        webhook = make_shared<DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook>(model1);
      }
    }
    if (m.find("WebhookId") != m.end() && !m["WebhookId"].empty()) {
      webhookId = make_shared<double>(boost::any_cast<double>(m["WebhookId"]));
    }
    if (m.find("WebhookName") != m.end() && !m["WebhookName"].empty()) {
      webhookName = make_shared<string>(boost::any_cast<string>(m["WebhookName"]));
    }
  }


  virtual ~DescribeWebhookContactsResponseBodyPageBeanWebhookContacts() = default;
};
class DescribeWebhookContactsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};
  shared_ptr<vector<DescribeWebhookContactsResponseBodyPageBeanWebhookContacts>> webhookContacts{};

  DescribeWebhookContactsResponseBodyPageBean() {}

  explicit DescribeWebhookContactsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (webhookContacts) {
      vector<boost::any> temp1;
      for(auto item1:*webhookContacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebhookContacts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("WebhookContacts") != m.end() && !m["WebhookContacts"].empty()) {
      if (typeid(vector<boost::any>) == m["WebhookContacts"].type()) {
        vector<DescribeWebhookContactsResponseBodyPageBeanWebhookContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebhookContacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebhookContactsResponseBodyPageBeanWebhookContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webhookContacts = make_shared<vector<DescribeWebhookContactsResponseBodyPageBeanWebhookContacts>>(expect1);
      }
    }
  }


  virtual ~DescribeWebhookContactsResponseBodyPageBean() = default;
};
class DescribeWebhookContactsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeWebhookContactsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  DescribeWebhookContactsResponseBody() {}

  explicit DescribeWebhookContactsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        DescribeWebhookContactsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<DescribeWebhookContactsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeWebhookContactsResponseBody() = default;
};
class DescribeWebhookContactsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebhookContactsResponseBody> body{};

  DescribeWebhookContactsResponse() {}

  explicit DescribeWebhookContactsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebhookContactsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebhookContactsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebhookContactsResponse() = default;
};
class DoInsightsActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> module{};

  DoInsightsActionRequest() {}

  explicit DoInsightsActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
  }


  virtual ~DoInsightsActionRequest() = default;
};
class DoInsightsActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DoInsightsActionResponseBody() {}

  explicit DoInsightsActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DoInsightsActionResponseBody() = default;
};
class DoInsightsActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DoInsightsActionResponseBody> body{};

  DoInsightsActionResponse() {}

  explicit DoInsightsActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DoInsightsActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DoInsightsActionResponseBody>(model1);
      }
    }
  }


  virtual ~DoInsightsActionResponse() = default;
};
class EnableMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dropMetric{};
  shared_ptr<string> regionId{};

  EnableMetricRequest() {}

  explicit EnableMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dropMetric) {
      res["DropMetric"] = boost::any(*dropMetric);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DropMetric") != m.end() && !m["DropMetric"].empty()) {
      dropMetric = make_shared<string>(boost::any_cast<string>(m["DropMetric"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~EnableMetricRequest() = default;
};
class EnableMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableMetricResponseBody() {}

  explicit EnableMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableMetricResponseBody() = default;
};
class EnableMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableMetricResponseBody> body{};

  EnableMetricResponse() {}

  explicit EnableMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableMetricResponseBody>(model1);
      }
    }
  }


  virtual ~EnableMetricResponse() = default;
};
class GetAgentDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  GetAgentDownloadUrlRequest() {}

  explicit GetAgentDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetAgentDownloadUrlRequest() = default;
};
class GetAgentDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> armsAgentDownloadUrl{};
  shared_ptr<string> requestId{};

  GetAgentDownloadUrlResponseBody() {}

  explicit GetAgentDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsAgentDownloadUrl) {
      res["ArmsAgentDownloadUrl"] = boost::any(*armsAgentDownloadUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmsAgentDownloadUrl") != m.end() && !m["ArmsAgentDownloadUrl"].empty()) {
      armsAgentDownloadUrl = make_shared<string>(boost::any_cast<string>(m["ArmsAgentDownloadUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAgentDownloadUrlResponseBody() = default;
};
class GetAgentDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAgentDownloadUrlResponseBody> body{};

  GetAgentDownloadUrlResponse() {}

  explicit GetAgentDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAgentDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAgentDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetAgentDownloadUrlResponse() = default;
};
class GetAgentDownloadUrlV2Request : public Darabonba::Model {
public:
  shared_ptr<string> agentType{};
  shared_ptr<string> archType{};
  shared_ptr<string> osType{};

  GetAgentDownloadUrlV2Request() {}

  explicit GetAgentDownloadUrlV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentType) {
      res["AgentType"] = boost::any(*agentType);
    }
    if (archType) {
      res["ArchType"] = boost::any(*archType);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentType") != m.end() && !m["AgentType"].empty()) {
      agentType = make_shared<string>(boost::any_cast<string>(m["AgentType"]));
    }
    if (m.find("ArchType") != m.end() && !m["ArchType"].empty()) {
      archType = make_shared<string>(boost::any_cast<string>(m["ArchType"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
  }


  virtual ~GetAgentDownloadUrlV2Request() = default;
};
class GetAgentDownloadUrlV2ResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> url{};
  shared_ptr<string> version{};

  GetAgentDownloadUrlV2ResponseBodyData() {}

  explicit GetAgentDownloadUrlV2ResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetAgentDownloadUrlV2ResponseBodyData() = default;
};
class GetAgentDownloadUrlV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetAgentDownloadUrlV2ResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAgentDownloadUrlV2ResponseBody() {}

  explicit GetAgentDownloadUrlV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAgentDownloadUrlV2ResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAgentDownloadUrlV2ResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAgentDownloadUrlV2ResponseBody() = default;
};
class GetAgentDownloadUrlV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAgentDownloadUrlV2ResponseBody> body{};

  GetAgentDownloadUrlV2Response() {}

  explicit GetAgentDownloadUrlV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAgentDownloadUrlV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAgentDownloadUrlV2ResponseBody>(model1);
      }
    }
  }


  virtual ~GetAgentDownloadUrlV2Response() = default;
};
class GetAlertRulesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetAlertRulesRequestTags() {}

  explicit GetAlertRulesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesRequestTags() = default;
};
class GetAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertIds{};
  shared_ptr<string> alertNames{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> alertType{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> page{};
  shared_ptr<string> productCode{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};
  shared_ptr<vector<GetAlertRulesRequestTags>> tags{};

  GetAlertRulesRequest() {}

  explicit GetAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertIds) {
      res["AlertIds"] = boost::any(*alertIds);
    }
    if (alertNames) {
      res["AlertNames"] = boost::any(*alertNames);
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertIds") != m.end() && !m["AlertIds"].empty()) {
      alertIds = make_shared<string>(boost::any_cast<string>(m["AlertIds"]));
    }
    if (m.find("AlertNames") != m.end() && !m["AlertNames"].empty()) {
      alertNames = make_shared<string>(boost::any_cast<string>(m["AlertNames"]));
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<string>(boost::any_cast<string>(m["AlertType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetAlertRulesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetAlertRulesRequestTags>>(expect1);
      }
    }
  }


  virtual ~GetAlertRulesRequest() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems : public Darabonba::Model {
public:
  shared_ptr<string> aggregate{};
  shared_ptr<string> metricKey{};
  shared_ptr<long> n{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregate) {
      res["Aggregate"] = boost::any(*aggregate);
    }
    if (metricKey) {
      res["MetricKey"] = boost::any(*metricKey);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregate") != m.end() && !m["Aggregate"].empty()) {
      aggregate = make_shared<string>(boost::any_cast<string>(m["Aggregate"]));
    }
    if (m.find("MetricKey") != m.end() && !m["MetricKey"].empty()) {
      metricKey = make_shared<string>(boost::any_cast<string>(m["MetricKey"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent : public Darabonba::Model {
public:
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems>> alertRuleItems{};
  shared_ptr<string> condition{};

  GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRuleItems) {
      vector<boost::any> temp1;
      for(auto item1:*alertRuleItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertRuleItems"] = boost::any(temp1);
    }
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRuleItems") != m.end() && !m["AlertRuleItems"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertRuleItems"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertRuleItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertRuleItems = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems>>(expect1);
      }
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opt{};
  shared_ptr<bool> show{};
  shared_ptr<string> t{};
  shared_ptr<string> value{};

  GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opt) {
      res["Opt"] = boost::any(*opt);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (t) {
      res["T"] = boost::any(*t);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Opt") != m.end() && !m["Opt"].empty()) {
      opt = make_shared<string>(boost::any_cast<string>(m["Opt"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("T") != m.end() && !m["T"].empty()) {
      t = make_shared<string>(boost::any_cast<string>(m["T"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters : public Darabonba::Model {
public:
  shared_ptr<string> filterKey{};
  shared_ptr<string> filterOpt{};
  shared_ptr<vector<string>> filterValues{};

  GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterKey) {
      res["FilterKey"] = boost::any(*filterKey);
    }
    if (filterOpt) {
      res["FilterOpt"] = boost::any(*filterOpt);
    }
    if (filterValues) {
      res["FilterValues"] = boost::any(*filterValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterKey") != m.end() && !m["FilterKey"].empty()) {
      filterKey = make_shared<string>(boost::any_cast<string>(m["FilterKey"]));
    }
    if (m.find("FilterOpt") != m.end() && !m["FilterOpt"].empty()) {
      filterOpt = make_shared<string>(boost::any_cast<string>(m["FilterOpt"]));
    }
    if (m.find("FilterValues") != m.end() && !m["FilterValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesFilters : public Darabonba::Model {
public:
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters>> customSLSFilters{};
  shared_ptr<vector<string>> customSLSGroupByDimensions{};
  shared_ptr<vector<string>> customSLSWheres{};
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters>> dimFilters{};

  GetAlertRulesResponseBodyPageBeanAlertRulesFilters() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSLSFilters) {
      vector<boost::any> temp1;
      for(auto item1:*customSLSFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSLSFilters"] = boost::any(temp1);
    }
    if (customSLSGroupByDimensions) {
      res["CustomSLSGroupByDimensions"] = boost::any(*customSLSGroupByDimensions);
    }
    if (customSLSWheres) {
      res["CustomSLSWheres"] = boost::any(*customSLSWheres);
    }
    if (dimFilters) {
      vector<boost::any> temp1;
      for(auto item1:*dimFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DimFilters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSLSFilters") != m.end() && !m["CustomSLSFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSLSFilters"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSLSFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSLSFilters = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters>>(expect1);
      }
    }
    if (m.find("CustomSLSGroupByDimensions") != m.end() && !m["CustomSLSGroupByDimensions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomSLSGroupByDimensions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomSLSGroupByDimensions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customSLSGroupByDimensions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomSLSWheres") != m.end() && !m["CustomSLSWheres"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomSLSWheres"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomSLSWheres"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customSLSWheres = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DimFilters") != m.end() && !m["DimFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["DimFilters"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DimFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimFilters = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters>>(expect1);
      }
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesFilters() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  GetAlertRulesResponseBodyPageBeanAlertRulesLabels() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesLabels() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetAlertRulesResponseBodyPageBeanAlertRulesTags() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesTags() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRules : public Darabonba::Model {
public:
  shared_ptr<string> alertCheckType{};
  shared_ptr<long> alertGroup{};
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent> alertRuleContent{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> alertType{};
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations>> annotations{};
  shared_ptr<bool> autoAddNewApplication{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> extend{};
  shared_ptr<GetAlertRulesResponseBodyPageBeanAlertRulesFilters> filters{};
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesLabels>> labels{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> metricsType{};
  shared_ptr<string> notifyStrategy{};
  shared_ptr<vector<string>> pids{};
  shared_ptr<string> promQL{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesTags>> tags{};
  shared_ptr<long> updatedTime{};
  shared_ptr<string> userId{};

  GetAlertRulesResponseBodyPageBeanAlertRules() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertCheckType) {
      res["AlertCheckType"] = boost::any(*alertCheckType);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertRuleContent) {
      res["AlertRuleContent"] = alertRuleContent ? boost::any(alertRuleContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (autoAddNewApplication) {
      res["AutoAddNewApplication"] = boost::any(*autoAddNewApplication);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (filters) {
      res["Filters"] = filters ? boost::any(filters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (metricsType) {
      res["MetricsType"] = boost::any(*metricsType);
    }
    if (notifyStrategy) {
      res["NotifyStrategy"] = boost::any(*notifyStrategy);
    }
    if (pids) {
      res["Pids"] = boost::any(*pids);
    }
    if (promQL) {
      res["PromQL"] = boost::any(*promQL);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertCheckType") != m.end() && !m["AlertCheckType"].empty()) {
      alertCheckType = make_shared<string>(boost::any_cast<string>(m["AlertCheckType"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<long>(boost::any_cast<long>(m["AlertGroup"]));
    }
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertRuleContent") != m.end() && !m["AlertRuleContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRuleContent"].type()) {
        GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRuleContent"]));
        alertRuleContent = make_shared<GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent>(model1);
      }
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<string>(boost::any_cast<string>(m["AlertType"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations>>(expect1);
      }
    }
    if (m.find("AutoAddNewApplication") != m.end() && !m["AutoAddNewApplication"].empty()) {
      autoAddNewApplication = make_shared<bool>(boost::any_cast<bool>(m["AutoAddNewApplication"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filters"].type()) {
        GetAlertRulesResponseBodyPageBeanAlertRulesFilters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filters"]));
        filters = make_shared<GetAlertRulesResponseBodyPageBeanAlertRulesFilters>(model1);
      }
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesLabels>>(expect1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MetricsType") != m.end() && !m["MetricsType"].empty()) {
      metricsType = make_shared<string>(boost::any_cast<string>(m["MetricsType"]));
    }
    if (m.find("NotifyStrategy") != m.end() && !m["NotifyStrategy"].empty()) {
      notifyStrategy = make_shared<string>(boost::any_cast<string>(m["NotifyStrategy"]));
    }
    if (m.find("Pids") != m.end() && !m["Pids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Pids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Pids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PromQL") != m.end() && !m["PromQL"].empty()) {
      promQL = make_shared<string>(boost::any_cast<string>(m["PromQL"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesTags>>(expect1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRules() = default;
};
class GetAlertRulesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRules>> alertRules{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  GetAlertRulesResponseBodyPageBean() {}

  explicit GetAlertRulesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRules) {
      vector<boost::any> temp1;
      for(auto item1:*alertRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertRules"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRules") != m.end() && !m["AlertRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertRules"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertRules = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRules>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBean() = default;
};
class GetAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAlertRulesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  GetAlertRulesResponseBody() {}

  explicit GetAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        GetAlertRulesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<GetAlertRulesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAlertRulesResponseBody() = default;
};
class GetAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAlertRulesResponseBody> body{};

  GetAlertRulesResponse() {}

  explicit GetAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~GetAlertRulesResponse() = default;
};
class GetAppApiByPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<long> intervalMills{};
  shared_ptr<string> PId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  GetAppApiByPageRequest() {}

  explicit GetAppApiByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (intervalMills) {
      res["IntervalMills"] = boost::any(*intervalMills);
    }
    if (PId) {
      res["PId"] = boost::any(*PId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("IntervalMills") != m.end() && !m["IntervalMills"].empty()) {
      intervalMills = make_shared<long>(boost::any_cast<long>(m["IntervalMills"]));
    }
    if (m.find("PId") != m.end() && !m["PId"].empty()) {
      PId = make_shared<string>(boost::any_cast<string>(m["PId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetAppApiByPageRequest() = default;
};
class GetAppApiByPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> completed{};
  shared_ptr<vector<map<string, boost::any>>> items{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> total{};

  GetAppApiByPageResponseBodyData() {}

  explicit GetAppApiByPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completed) {
      res["Completed"] = boost::any(*completed);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Completed") != m.end() && !m["Completed"].empty()) {
      completed = make_shared<bool>(boost::any_cast<bool>(m["Completed"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      items = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
  }


  virtual ~GetAppApiByPageResponseBodyData() = default;
};
class GetAppApiByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetAppApiByPageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAppApiByPageResponseBody() {}

  explicit GetAppApiByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAppApiByPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAppApiByPageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAppApiByPageResponseBody() = default;
};
class GetAppApiByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAppApiByPageResponseBody> body{};

  GetAppApiByPageResponse() {}

  explicit GetAppApiByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAppApiByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAppApiByPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetAppApiByPageResponse() = default;
};
class GetAppJVMConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  GetAppJVMConfigRequest() {}

  explicit GetAppJVMConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetAppJVMConfigRequest() = default;
};
class GetAppJVMConfigResponseBodyJvmInfoList : public Darabonba::Model {
public:
  shared_ptr<string> agentVersion{};
  shared_ptr<string> hostName{};
  shared_ptr<string> ip{};
  shared_ptr<string> pid{};
  shared_ptr<string> procId{};
  shared_ptr<string> vmArgs{};

  GetAppJVMConfigResponseBodyJvmInfoList() {}

  explicit GetAppJVMConfigResponseBodyJvmInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentVersion) {
      res["AgentVersion"] = boost::any(*agentVersion);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (procId) {
      res["ProcId"] = boost::any(*procId);
    }
    if (vmArgs) {
      res["VmArgs"] = boost::any(*vmArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentVersion") != m.end() && !m["AgentVersion"].empty()) {
      agentVersion = make_shared<string>(boost::any_cast<string>(m["AgentVersion"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("ProcId") != m.end() && !m["ProcId"].empty()) {
      procId = make_shared<string>(boost::any_cast<string>(m["ProcId"]));
    }
    if (m.find("VmArgs") != m.end() && !m["VmArgs"].empty()) {
      vmArgs = make_shared<string>(boost::any_cast<string>(m["VmArgs"]));
    }
  }


  virtual ~GetAppJVMConfigResponseBodyJvmInfoList() = default;
};
class GetAppJVMConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetAppJVMConfigResponseBodyJvmInfoList>> jvmInfoList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAppJVMConfigResponseBody() {}

  explicit GetAppJVMConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (jvmInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*jvmInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JvmInfoList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("JvmInfoList") != m.end() && !m["JvmInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["JvmInfoList"].type()) {
        vector<GetAppJVMConfigResponseBodyJvmInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JvmInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAppJVMConfigResponseBodyJvmInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jvmInfoList = make_shared<vector<GetAppJVMConfigResponseBodyJvmInfoList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAppJVMConfigResponseBody() = default;
};
class GetAppJVMConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAppJVMConfigResponseBody> body{};

  GetAppJVMConfigResponse() {}

  explicit GetAppJVMConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAppJVMConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAppJVMConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetAppJVMConfigResponse() = default;
};
class GetAuthTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetAuthTokenRequest() {}

  explicit GetAuthTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetAuthTokenRequest() = default;
};
class GetAuthTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAuthTokenResponseBody() {}

  explicit GetAuthTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAuthTokenResponseBody() = default;
};
class GetAuthTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAuthTokenResponseBody> body{};

  GetAuthTokenResponse() {}

  explicit GetAuthTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAuthTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAuthTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GetAuthTokenResponse() = default;
};
class GetCloudClusterAllUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetCloudClusterAllUrlRequest() {}

  explicit GetCloudClusterAllUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetCloudClusterAllUrlRequest() = default;
};
class GetCloudClusterAllUrlResponseBodyDataRemoteUrl : public Darabonba::Model {
public:
  shared_ptr<bool> authToken{};
  shared_ptr<string> grafanaUrl{};
  shared_ptr<string> internetGrafanaUrl{};
  shared_ptr<string> internetPushGatewayUrl{};
  shared_ptr<string> internetRemoteReadUrl{};
  shared_ptr<string> internetRemoteWriteUrl{};
  shared_ptr<string> pushGatewayUrl{};
  shared_ptr<string> remoteReadUrl{};
  shared_ptr<string> remoteWriteUrl{};
  shared_ptr<string> token{};

  GetCloudClusterAllUrlResponseBodyDataRemoteUrl() {}

  explicit GetCloudClusterAllUrlResponseBodyDataRemoteUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (grafanaUrl) {
      res["GrafanaUrl"] = boost::any(*grafanaUrl);
    }
    if (internetGrafanaUrl) {
      res["InternetGrafanaUrl"] = boost::any(*internetGrafanaUrl);
    }
    if (internetPushGatewayUrl) {
      res["InternetPushGatewayUrl"] = boost::any(*internetPushGatewayUrl);
    }
    if (internetRemoteReadUrl) {
      res["InternetRemoteReadUrl"] = boost::any(*internetRemoteReadUrl);
    }
    if (internetRemoteWriteUrl) {
      res["InternetRemoteWriteUrl"] = boost::any(*internetRemoteWriteUrl);
    }
    if (pushGatewayUrl) {
      res["PushGatewayUrl"] = boost::any(*pushGatewayUrl);
    }
    if (remoteReadUrl) {
      res["RemoteReadUrl"] = boost::any(*remoteReadUrl);
    }
    if (remoteWriteUrl) {
      res["RemoteWriteUrl"] = boost::any(*remoteWriteUrl);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<bool>(boost::any_cast<bool>(m["AuthToken"]));
    }
    if (m.find("GrafanaUrl") != m.end() && !m["GrafanaUrl"].empty()) {
      grafanaUrl = make_shared<string>(boost::any_cast<string>(m["GrafanaUrl"]));
    }
    if (m.find("InternetGrafanaUrl") != m.end() && !m["InternetGrafanaUrl"].empty()) {
      internetGrafanaUrl = make_shared<string>(boost::any_cast<string>(m["InternetGrafanaUrl"]));
    }
    if (m.find("InternetPushGatewayUrl") != m.end() && !m["InternetPushGatewayUrl"].empty()) {
      internetPushGatewayUrl = make_shared<string>(boost::any_cast<string>(m["InternetPushGatewayUrl"]));
    }
    if (m.find("InternetRemoteReadUrl") != m.end() && !m["InternetRemoteReadUrl"].empty()) {
      internetRemoteReadUrl = make_shared<string>(boost::any_cast<string>(m["InternetRemoteReadUrl"]));
    }
    if (m.find("InternetRemoteWriteUrl") != m.end() && !m["InternetRemoteWriteUrl"].empty()) {
      internetRemoteWriteUrl = make_shared<string>(boost::any_cast<string>(m["InternetRemoteWriteUrl"]));
    }
    if (m.find("PushGatewayUrl") != m.end() && !m["PushGatewayUrl"].empty()) {
      pushGatewayUrl = make_shared<string>(boost::any_cast<string>(m["PushGatewayUrl"]));
    }
    if (m.find("RemoteReadUrl") != m.end() && !m["RemoteReadUrl"].empty()) {
      remoteReadUrl = make_shared<string>(boost::any_cast<string>(m["RemoteReadUrl"]));
    }
    if (m.find("RemoteWriteUrl") != m.end() && !m["RemoteWriteUrl"].empty()) {
      remoteWriteUrl = make_shared<string>(boost::any_cast<string>(m["RemoteWriteUrl"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~GetCloudClusterAllUrlResponseBodyDataRemoteUrl() = default;
};
class GetCloudClusterAllUrlResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> productCode{};
  shared_ptr<string> region{};
  shared_ptr<GetCloudClusterAllUrlResponseBodyDataRemoteUrl> remoteUrl{};

  GetCloudClusterAllUrlResponseBodyData() {}

  explicit GetCloudClusterAllUrlResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (remoteUrl) {
      res["RemoteUrl"] = remoteUrl ? boost::any(remoteUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RemoteUrl") != m.end() && !m["RemoteUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["RemoteUrl"].type()) {
        GetCloudClusterAllUrlResponseBodyDataRemoteUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RemoteUrl"]));
        remoteUrl = make_shared<GetCloudClusterAllUrlResponseBodyDataRemoteUrl>(model1);
      }
    }
  }


  virtual ~GetCloudClusterAllUrlResponseBodyData() = default;
};
class GetCloudClusterAllUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetCloudClusterAllUrlResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCloudClusterAllUrlResponseBody() {}

  explicit GetCloudClusterAllUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetCloudClusterAllUrlResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCloudClusterAllUrlResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetCloudClusterAllUrlResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCloudClusterAllUrlResponseBody() = default;
};
class GetCloudClusterAllUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCloudClusterAllUrlResponseBody> body{};

  GetCloudClusterAllUrlResponse() {}

  explicit GetCloudClusterAllUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCloudClusterAllUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCloudClusterAllUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetCloudClusterAllUrlResponse() = default;
};
class GetClusterAllUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetClusterAllUrlRequest() {}

  explicit GetClusterAllUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetClusterAllUrlRequest() = default;
};
class GetClusterAllUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetClusterAllUrlResponseBody() {}

  explicit GetClusterAllUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetClusterAllUrlResponseBody() = default;
};
class GetClusterAllUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterAllUrlResponseBody> body{};

  GetClusterAllUrlResponse() {}

  explicit GetClusterAllUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterAllUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterAllUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterAllUrlResponse() = default;
};
class GetCommercialStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> regionId{};

  GetCommercialStatusRequest() {}

  explicit GetCommercialStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetCommercialStatusRequest() = default;
};
class GetCommercialStatusResponseBodyUserAndCommodityStatus : public Darabonba::Model {
public:
  shared_ptr<bool> basic{};
  shared_ptr<string> chargeType{};
  shared_ptr<bool> enable{};
  shared_ptr<map<string, boost::any>> extraInfo{};
  shared_ptr<long> freeDays{};
  shared_ptr<string> lable{};
  shared_ptr<string> status{};

  GetCommercialStatusResponseBodyUserAndCommodityStatus() {}

  explicit GetCommercialStatusResponseBodyUserAndCommodityStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basic) {
      res["Basic"] = boost::any(*basic);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (freeDays) {
      res["FreeDays"] = boost::any(*freeDays);
    }
    if (lable) {
      res["Lable"] = boost::any(*lable);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Basic") != m.end() && !m["Basic"].empty()) {
      basic = make_shared<bool>(boost::any_cast<bool>(m["Basic"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FreeDays") != m.end() && !m["FreeDays"].empty()) {
      freeDays = make_shared<long>(boost::any_cast<long>(m["FreeDays"]));
    }
    if (m.find("Lable") != m.end() && !m["Lable"].empty()) {
      lable = make_shared<string>(boost::any_cast<string>(m["Lable"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetCommercialStatusResponseBodyUserAndCommodityStatus() = default;
};
class GetCommercialStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetCommercialStatusResponseBodyUserAndCommodityStatus> userAndCommodityStatus{};

  GetCommercialStatusResponseBody() {}

  explicit GetCommercialStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userAndCommodityStatus) {
      res["UserAndCommodityStatus"] = userAndCommodityStatus ? boost::any(userAndCommodityStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserAndCommodityStatus") != m.end() && !m["UserAndCommodityStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserAndCommodityStatus"].type()) {
        GetCommercialStatusResponseBodyUserAndCommodityStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserAndCommodityStatus"]));
        userAndCommodityStatus = make_shared<GetCommercialStatusResponseBodyUserAndCommodityStatus>(model1);
      }
    }
  }


  virtual ~GetCommercialStatusResponseBody() = default;
};
class GetCommercialStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCommercialStatusResponseBody> body{};

  GetCommercialStatusResponse() {}

  explicit GetCommercialStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCommercialStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCommercialStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetCommercialStatusResponse() = default;
};
class GetExploreUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> expression{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  GetExploreUrlRequest() {}

  explicit GetExploreUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetExploreUrlRequest() = default;
};
class GetExploreUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetExploreUrlResponseBody() {}

  explicit GetExploreUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetExploreUrlResponseBody() = default;
};
class GetExploreUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetExploreUrlResponseBody> body{};

  GetExploreUrlResponse() {}

  explicit GetExploreUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetExploreUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetExploreUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetExploreUrlResponse() = default;
};
class GetGrafanaWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<string> regionId{};

  GetGrafanaWorkspaceRequest() {}

  explicit GetGrafanaWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (grafanaWorkspaceId) {
      res["GrafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("GrafanaWorkspaceId") != m.end() && !m["GrafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetGrafanaWorkspaceRequest() = default;
};
class GetGrafanaWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GrafanaWorkspace> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  GetGrafanaWorkspaceResponseBody() {}

  explicit GetGrafanaWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GrafanaWorkspace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GrafanaWorkspace>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~GetGrafanaWorkspaceResponseBody() = default;
};
class GetGrafanaWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGrafanaWorkspaceResponseBody> body{};

  GetGrafanaWorkspaceResponse() {}

  explicit GetGrafanaWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGrafanaWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGrafanaWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~GetGrafanaWorkspaceResponse() = default;
};
class GetIntegrationStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integration{};
  shared_ptr<string> regionId{};

  GetIntegrationStateRequest() {}

  explicit GetIntegrationStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integration) {
      res["Integration"] = boost::any(*integration);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      integration = make_shared<string>(boost::any_cast<string>(m["Integration"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetIntegrationStateRequest() = default;
};
class GetIntegrationStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> state{};

  GetIntegrationStateResponseBody() {}

  explicit GetIntegrationStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<bool>(boost::any_cast<bool>(m["State"]));
    }
  }


  virtual ~GetIntegrationStateResponseBody() = default;
};
class GetIntegrationStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIntegrationStateResponseBody> body{};

  GetIntegrationStateResponse() {}

  explicit GetIntegrationStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIntegrationStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIntegrationStateResponseBody>(model1);
      }
    }
  }


  virtual ~GetIntegrationStateResponse() = default;
};
class GetManagedPrometheusStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vpcId{};

  GetManagedPrometheusStatusRequest() {}

  explicit GetManagedPrometheusStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetManagedPrometheusStatusRequest() = default;
};
class GetManagedPrometheusStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetManagedPrometheusStatusResponseBody() {}

  explicit GetManagedPrometheusStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetManagedPrometheusStatusResponseBody() = default;
};
class GetManagedPrometheusStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetManagedPrometheusStatusResponseBody> body{};

  GetManagedPrometheusStatusResponse() {}

  explicit GetManagedPrometheusStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetManagedPrometheusStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetManagedPrometheusStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetManagedPrometheusStatusResponse() = default;
};
class GetMultipleTraceRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<string>> traceIDs{};

  GetMultipleTraceRequest() {}

  explicit GetMultipleTraceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (traceIDs) {
      res["TraceIDs"] = boost::any(*traceIDs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TraceIDs") != m.end() && !m["TraceIDs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TraceIDs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TraceIDs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      traceIDs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetMultipleTraceRequest() = default;
};
class GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList() {}

  explicit GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList() = default;
};
class GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList : public Darabonba::Model {
public:
  shared_ptr<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList>> tagEntryList{};
  shared_ptr<long> timestamp{};

  GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList() {}

  explicit GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagEntryList) {
      vector<boost::any> temp1;
      for(auto item1:*tagEntryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagEntryList"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagEntryList") != m.end() && !m["TagEntryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagEntryList"].type()) {
        vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagEntryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagEntryList = make_shared<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList() = default;
};
class GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList() {}

  explicit GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList() = default;
};
class GetMultipleTraceResponseBodyMultiCallChainInfosSpans : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<bool> haveStack{};
  shared_ptr<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList>> logEventList{};
  shared_ptr<string> operationName{};
  shared_ptr<string> parentSpanId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> rpcId{};
  shared_ptr<long> rpcType{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> spanId{};
  shared_ptr<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList>> tagEntryList{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> traceID{};

  GetMultipleTraceResponseBodyMultiCallChainInfosSpans() {}

  explicit GetMultipleTraceResponseBodyMultiCallChainInfosSpans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (haveStack) {
      res["HaveStack"] = boost::any(*haveStack);
    }
    if (logEventList) {
      vector<boost::any> temp1;
      for(auto item1:*logEventList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogEventList"] = boost::any(temp1);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (parentSpanId) {
      res["ParentSpanId"] = boost::any(*parentSpanId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (rpcId) {
      res["RpcId"] = boost::any(*rpcId);
    }
    if (rpcType) {
      res["RpcType"] = boost::any(*rpcType);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (spanId) {
      res["SpanId"] = boost::any(*spanId);
    }
    if (tagEntryList) {
      vector<boost::any> temp1;
      for(auto item1:*tagEntryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagEntryList"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("HaveStack") != m.end() && !m["HaveStack"].empty()) {
      haveStack = make_shared<bool>(boost::any_cast<bool>(m["HaveStack"]));
    }
    if (m.find("LogEventList") != m.end() && !m["LogEventList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogEventList"].type()) {
        vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogEventList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logEventList = make_shared<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList>>(expect1);
      }
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("ParentSpanId") != m.end() && !m["ParentSpanId"].empty()) {
      parentSpanId = make_shared<string>(boost::any_cast<string>(m["ParentSpanId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("RpcId") != m.end() && !m["RpcId"].empty()) {
      rpcId = make_shared<string>(boost::any_cast<string>(m["RpcId"]));
    }
    if (m.find("RpcType") != m.end() && !m["RpcType"].empty()) {
      rpcType = make_shared<long>(boost::any_cast<long>(m["RpcType"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("SpanId") != m.end() && !m["SpanId"].empty()) {
      spanId = make_shared<string>(boost::any_cast<string>(m["SpanId"]));
    }
    if (m.find("TagEntryList") != m.end() && !m["TagEntryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagEntryList"].type()) {
        vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagEntryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagEntryList = make_shared<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~GetMultipleTraceResponseBodyMultiCallChainInfosSpans() = default;
};
class GetMultipleTraceResponseBodyMultiCallChainInfos : public Darabonba::Model {
public:
  shared_ptr<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpans>> spans{};
  shared_ptr<string> traceID{};

  GetMultipleTraceResponseBodyMultiCallChainInfos() {}

  explicit GetMultipleTraceResponseBodyMultiCallChainInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spans) {
      vector<boost::any> temp1;
      for(auto item1:*spans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Spans"] = boost::any(temp1);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Spans") != m.end() && !m["Spans"].empty()) {
      if (typeid(vector<boost::any>) == m["Spans"].type()) {
        vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Spans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipleTraceResponseBodyMultiCallChainInfosSpans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spans = make_shared<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpans>>(expect1);
      }
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~GetMultipleTraceResponseBodyMultiCallChainInfos() = default;
};
class GetMultipleTraceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetMultipleTraceResponseBodyMultiCallChainInfos>> multiCallChainInfos{};
  shared_ptr<string> requestId{};

  GetMultipleTraceResponseBody() {}

  explicit GetMultipleTraceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (multiCallChainInfos) {
      vector<boost::any> temp1;
      for(auto item1:*multiCallChainInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultiCallChainInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MultiCallChainInfos") != m.end() && !m["MultiCallChainInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MultiCallChainInfos"].type()) {
        vector<GetMultipleTraceResponseBodyMultiCallChainInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultiCallChainInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipleTraceResponseBodyMultiCallChainInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multiCallChainInfos = make_shared<vector<GetMultipleTraceResponseBodyMultiCallChainInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMultipleTraceResponseBody() = default;
};
class GetMultipleTraceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultipleTraceResponseBody> body{};

  GetMultipleTraceResponse() {}

  explicit GetMultipleTraceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultipleTraceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultipleTraceResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultipleTraceResponse() = default;
};
class GetOnCallSchedulesDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> id{};
  shared_ptr<string> startTime{};

  GetOnCallSchedulesDetailRequest() {}

  explicit GetOnCallSchedulesDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailRequest() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries : public Darabonba::Model {
public:
  shared_ptr<string> end{};
  shared_ptr<GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact> simpleContact{};
  shared_ptr<string> start{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (simpleContact) {
      res["SimpleContact"] = simpleContact ? boost::any(simpleContact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("SimpleContact") != m.end() && !m["SimpleContact"].empty()) {
      if (typeid(map<string, boost::any>) == m["SimpleContact"].type()) {
        GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SimpleContact"]));
        simpleContact = make_shared<GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact>(model1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> end{};
  shared_ptr<GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact> simpleContact{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (simpleContact) {
      res["SimpleContact"] = simpleContact ? boost::any(simpleContact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("SimpleContact") != m.end() && !m["SimpleContact"].empty()) {
      if (typeid(map<string, boost::any>) == m["SimpleContact"].type()) {
        GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SimpleContact"]));
        simpleContact = make_shared<GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact>(model1);
      }
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries : public Darabonba::Model {
public:
  shared_ptr<string> end{};
  shared_ptr<GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact> simpleContact{};
  shared_ptr<string> start{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (simpleContact) {
      res["SimpleContact"] = simpleContact ? boost::any(simpleContact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("SimpleContact") != m.end() && !m["SimpleContact"].empty()) {
      if (typeid(map<string, boost::any>) == m["SimpleContact"].type()) {
        GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SimpleContact"]));
        simpleContact = make_shared<GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact>(model1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions : public Darabonba::Model {
public:
  shared_ptr<string> endTimeOfDay{};
  shared_ptr<string> restrictionType{};
  shared_ptr<string> startTimeOfDay{};

  GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimeOfDay) {
      res["EndTimeOfDay"] = boost::any(*endTimeOfDay);
    }
    if (restrictionType) {
      res["RestrictionType"] = boost::any(*restrictionType);
    }
    if (startTimeOfDay) {
      res["StartTimeOfDay"] = boost::any(*startTimeOfDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimeOfDay") != m.end() && !m["EndTimeOfDay"].empty()) {
      endTimeOfDay = make_shared<string>(boost::any_cast<string>(m["EndTimeOfDay"]));
    }
    if (m.find("RestrictionType") != m.end() && !m["RestrictionType"].empty()) {
      restrictionType = make_shared<string>(boost::any_cast<string>(m["RestrictionType"]));
    }
    if (m.find("StartTimeOfDay") != m.end() && !m["StartTimeOfDay"].empty()) {
      startTimeOfDay = make_shared<string>(boost::any_cast<string>(m["StartTimeOfDay"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataScheduleLayers : public Darabonba::Model {
public:
  shared_ptr<vector<long>> contactIds{};
  shared_ptr<vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions>> restrictions{};
  shared_ptr<string> rotationType{};
  shared_ptr<long> shiftLength{};
  shared_ptr<string> startTime{};

  GetOnCallSchedulesDetailResponseBodyDataScheduleLayers() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataScheduleLayers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (restrictions) {
      vector<boost::any> temp1;
      for(auto item1:*restrictions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Restrictions"] = boost::any(temp1);
    }
    if (rotationType) {
      res["RotationType"] = boost::any(*rotationType);
    }
    if (shiftLength) {
      res["ShiftLength"] = boost::any(*shiftLength);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ContactIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      contactIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Restrictions") != m.end() && !m["Restrictions"].empty()) {
      if (typeid(vector<boost::any>) == m["Restrictions"].type()) {
        vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Restrictions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restrictions = make_shared<vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions>>(expect1);
      }
    }
    if (m.find("RotationType") != m.end() && !m["RotationType"].empty()) {
      rotationType = make_shared<string>(boost::any_cast<string>(m["RotationType"]));
    }
    if (m.find("ShiftLength") != m.end() && !m["ShiftLength"].empty()) {
      shiftLength = make_shared<long>(boost::any_cast<long>(m["ShiftLength"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataScheduleLayers() = default;
};
class GetOnCallSchedulesDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> alertRobotId{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries>> renderedFinnalEntries{};
  shared_ptr<vector<vector<undefined>>> renderedLayerEntries{};
  shared_ptr<vector<GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries>> renderedSubstitudeEntries{};
  shared_ptr<vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayers>> scheduleLayers{};

  GetOnCallSchedulesDetailResponseBodyData() {}

  explicit GetOnCallSchedulesDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRobotId) {
      res["AlertRobotId"] = boost::any(*alertRobotId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (renderedFinnalEntries) {
      vector<boost::any> temp1;
      for(auto item1:*renderedFinnalEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RenderedFinnalEntries"] = boost::any(temp1);
    }
    if (renderedLayerEntries) {
      vector<boost::any> temp1;
      for(auto item1:*renderedLayerEntries){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["RenderedLayerEntries"] = boost::any(temp1);
    }
    if (renderedSubstitudeEntries) {
      vector<boost::any> temp1;
      for(auto item1:*renderedSubstitudeEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RenderedSubstitudeEntries"] = boost::any(temp1);
    }
    if (scheduleLayers) {
      vector<boost::any> temp1;
      for(auto item1:*scheduleLayers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScheduleLayers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRobotId") != m.end() && !m["AlertRobotId"].empty()) {
      alertRobotId = make_shared<long>(boost::any_cast<long>(m["AlertRobotId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RenderedFinnalEntries") != m.end() && !m["RenderedFinnalEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["RenderedFinnalEntries"].type()) {
        vector<GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RenderedFinnalEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        renderedFinnalEntries = make_shared<vector<GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries>>(expect1);
      }
    }
    if (m.find("RenderedLayerEntries") != m.end() && !m["RenderedLayerEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["RenderedLayerEntries"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RenderedLayerEntries"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        renderedLayerEntries = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
    if (m.find("RenderedSubstitudeEntries") != m.end() && !m["RenderedSubstitudeEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["RenderedSubstitudeEntries"].type()) {
        vector<GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RenderedSubstitudeEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        renderedSubstitudeEntries = make_shared<vector<GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries>>(expect1);
      }
    }
    if (m.find("ScheduleLayers") != m.end() && !m["ScheduleLayers"].empty()) {
      if (typeid(vector<boost::any>) == m["ScheduleLayers"].type()) {
        vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScheduleLayers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOnCallSchedulesDetailResponseBodyDataScheduleLayers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scheduleLayers = make_shared<vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayers>>(expect1);
      }
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyData() = default;
};
class GetOnCallSchedulesDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetOnCallSchedulesDetailResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetOnCallSchedulesDetailResponseBody() {}

  explicit GetOnCallSchedulesDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetOnCallSchedulesDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetOnCallSchedulesDetailResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBody() = default;
};
class GetOnCallSchedulesDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOnCallSchedulesDetailResponseBody> body{};

  GetOnCallSchedulesDetailResponse() {}

  explicit GetOnCallSchedulesDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOnCallSchedulesDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOnCallSchedulesDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetOnCallSchedulesDetailResponse() = default;
};
class GetPrometheusApiTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  GetPrometheusApiTokenRequest() {}

  explicit GetPrometheusApiTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPrometheusApiTokenRequest() = default;
};
class GetPrometheusApiTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> token{};

  GetPrometheusApiTokenResponseBody() {}

  explicit GetPrometheusApiTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~GetPrometheusApiTokenResponseBody() = default;
};
class GetPrometheusApiTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusApiTokenResponseBody> body{};

  GetPrometheusApiTokenResponse() {}

  explicit GetPrometheusApiTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusApiTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusApiTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusApiTokenResponse() = default;
};
class GetPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> regionId{};

  GetPrometheusGlobalViewRequest() {}

  explicit GetPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPrometheusGlobalViewRequest() = default;
};
class GetPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetPrometheusGlobalViewResponseBody() {}

  explicit GetPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPrometheusGlobalViewResponseBody() = default;
};
class GetPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusGlobalViewResponseBody> body{};

  GetPrometheusGlobalViewResponse() {}

  explicit GetPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusGlobalViewResponse() = default;
};
class GetPrometheusInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetPrometheusInstanceRequest() {}

  explicit GetPrometheusInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPrometheusInstanceRequest() = default;
};
class GetPrometheusInstanceResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  GetPrometheusInstanceResponseBodyDataTags() {}

  explicit GetPrometheusInstanceResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~GetPrometheusInstanceResponseBodyDataTags() = default;
};
class GetPrometheusInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<long> archiveDuration{};
  shared_ptr<string> authFreeReadPolicy{};
  shared_ptr<string> authFreeWritePolicy{};
  shared_ptr<string> authToken{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> dbInstanceStatus{};
  shared_ptr<bool> enableAuthFreeRead{};
  shared_ptr<bool> enableAuthFreeWrite{};
  shared_ptr<string> enableAuthToken{};
  shared_ptr<map<string, string>> extraInfo{};
  shared_ptr<string> grafanaInstanceId{};
  shared_ptr<string> httpApiInterUrl{};
  shared_ptr<string> httpApiIntraUrl{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> product{};
  shared_ptr<string> pushGatewayInterUrl{};
  shared_ptr<string> pushGatewayIntraUrl{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteReadInterUrl{};
  shared_ptr<string> remoteReadIntraUrl{};
  shared_ptr<string> remoteWriteInterUrl{};
  shared_ptr<string> remoteWriteIntraUrl{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<long> storageDuration{};
  shared_ptr<string> subClustersJson{};
  shared_ptr<vector<string>> supportAuthTypes{};
  shared_ptr<vector<GetPrometheusInstanceResponseBodyDataTags>> tags{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  GetPrometheusInstanceResponseBodyData() {}

  explicit GetPrometheusInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (archiveDuration) {
      res["ArchiveDuration"] = boost::any(*archiveDuration);
    }
    if (authFreeReadPolicy) {
      res["AuthFreeReadPolicy"] = boost::any(*authFreeReadPolicy);
    }
    if (authFreeWritePolicy) {
      res["AuthFreeWritePolicy"] = boost::any(*authFreeWritePolicy);
    }
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (dbInstanceStatus) {
      res["DbInstanceStatus"] = boost::any(*dbInstanceStatus);
    }
    if (enableAuthFreeRead) {
      res["EnableAuthFreeRead"] = boost::any(*enableAuthFreeRead);
    }
    if (enableAuthFreeWrite) {
      res["EnableAuthFreeWrite"] = boost::any(*enableAuthFreeWrite);
    }
    if (enableAuthToken) {
      res["EnableAuthToken"] = boost::any(*enableAuthToken);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (grafanaInstanceId) {
      res["GrafanaInstanceId"] = boost::any(*grafanaInstanceId);
    }
    if (httpApiInterUrl) {
      res["HttpApiInterUrl"] = boost::any(*httpApiInterUrl);
    }
    if (httpApiIntraUrl) {
      res["HttpApiIntraUrl"] = boost::any(*httpApiIntraUrl);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (pushGatewayInterUrl) {
      res["PushGatewayInterUrl"] = boost::any(*pushGatewayInterUrl);
    }
    if (pushGatewayIntraUrl) {
      res["PushGatewayIntraUrl"] = boost::any(*pushGatewayIntraUrl);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteReadInterUrl) {
      res["RemoteReadInterUrl"] = boost::any(*remoteReadInterUrl);
    }
    if (remoteReadIntraUrl) {
      res["RemoteReadIntraUrl"] = boost::any(*remoteReadIntraUrl);
    }
    if (remoteWriteInterUrl) {
      res["RemoteWriteInterUrl"] = boost::any(*remoteWriteInterUrl);
    }
    if (remoteWriteIntraUrl) {
      res["RemoteWriteIntraUrl"] = boost::any(*remoteWriteIntraUrl);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (storageDuration) {
      res["StorageDuration"] = boost::any(*storageDuration);
    }
    if (subClustersJson) {
      res["SubClustersJson"] = boost::any(*subClustersJson);
    }
    if (supportAuthTypes) {
      res["SupportAuthTypes"] = boost::any(*supportAuthTypes);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("ArchiveDuration") != m.end() && !m["ArchiveDuration"].empty()) {
      archiveDuration = make_shared<long>(boost::any_cast<long>(m["ArchiveDuration"]));
    }
    if (m.find("AuthFreeReadPolicy") != m.end() && !m["AuthFreeReadPolicy"].empty()) {
      authFreeReadPolicy = make_shared<string>(boost::any_cast<string>(m["AuthFreeReadPolicy"]));
    }
    if (m.find("AuthFreeWritePolicy") != m.end() && !m["AuthFreeWritePolicy"].empty()) {
      authFreeWritePolicy = make_shared<string>(boost::any_cast<string>(m["AuthFreeWritePolicy"]));
    }
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<string>(boost::any_cast<string>(m["AuthToken"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("DbInstanceStatus") != m.end() && !m["DbInstanceStatus"].empty()) {
      dbInstanceStatus = make_shared<string>(boost::any_cast<string>(m["DbInstanceStatus"]));
    }
    if (m.find("EnableAuthFreeRead") != m.end() && !m["EnableAuthFreeRead"].empty()) {
      enableAuthFreeRead = make_shared<bool>(boost::any_cast<bool>(m["EnableAuthFreeRead"]));
    }
    if (m.find("EnableAuthFreeWrite") != m.end() && !m["EnableAuthFreeWrite"].empty()) {
      enableAuthFreeWrite = make_shared<bool>(boost::any_cast<bool>(m["EnableAuthFreeWrite"]));
    }
    if (m.find("EnableAuthToken") != m.end() && !m["EnableAuthToken"].empty()) {
      enableAuthToken = make_shared<string>(boost::any_cast<string>(m["EnableAuthToken"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ExtraInfo"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("GrafanaInstanceId") != m.end() && !m["GrafanaInstanceId"].empty()) {
      grafanaInstanceId = make_shared<string>(boost::any_cast<string>(m["GrafanaInstanceId"]));
    }
    if (m.find("HttpApiInterUrl") != m.end() && !m["HttpApiInterUrl"].empty()) {
      httpApiInterUrl = make_shared<string>(boost::any_cast<string>(m["HttpApiInterUrl"]));
    }
    if (m.find("HttpApiIntraUrl") != m.end() && !m["HttpApiIntraUrl"].empty()) {
      httpApiIntraUrl = make_shared<string>(boost::any_cast<string>(m["HttpApiIntraUrl"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("PushGatewayInterUrl") != m.end() && !m["PushGatewayInterUrl"].empty()) {
      pushGatewayInterUrl = make_shared<string>(boost::any_cast<string>(m["PushGatewayInterUrl"]));
    }
    if (m.find("PushGatewayIntraUrl") != m.end() && !m["PushGatewayIntraUrl"].empty()) {
      pushGatewayIntraUrl = make_shared<string>(boost::any_cast<string>(m["PushGatewayIntraUrl"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteReadInterUrl") != m.end() && !m["RemoteReadInterUrl"].empty()) {
      remoteReadInterUrl = make_shared<string>(boost::any_cast<string>(m["RemoteReadInterUrl"]));
    }
    if (m.find("RemoteReadIntraUrl") != m.end() && !m["RemoteReadIntraUrl"].empty()) {
      remoteReadIntraUrl = make_shared<string>(boost::any_cast<string>(m["RemoteReadIntraUrl"]));
    }
    if (m.find("RemoteWriteInterUrl") != m.end() && !m["RemoteWriteInterUrl"].empty()) {
      remoteWriteInterUrl = make_shared<string>(boost::any_cast<string>(m["RemoteWriteInterUrl"]));
    }
    if (m.find("RemoteWriteIntraUrl") != m.end() && !m["RemoteWriteIntraUrl"].empty()) {
      remoteWriteIntraUrl = make_shared<string>(boost::any_cast<string>(m["RemoteWriteIntraUrl"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("StorageDuration") != m.end() && !m["StorageDuration"].empty()) {
      storageDuration = make_shared<long>(boost::any_cast<long>(m["StorageDuration"]));
    }
    if (m.find("SubClustersJson") != m.end() && !m["SubClustersJson"].empty()) {
      subClustersJson = make_shared<string>(boost::any_cast<string>(m["SubClustersJson"]));
    }
    if (m.find("SupportAuthTypes") != m.end() && !m["SupportAuthTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportAuthTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportAuthTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportAuthTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetPrometheusInstanceResponseBodyDataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPrometheusInstanceResponseBodyDataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetPrometheusInstanceResponseBodyDataTags>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetPrometheusInstanceResponseBodyData() = default;
};
class GetPrometheusInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetPrometheusInstanceResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetPrometheusInstanceResponseBody() {}

  explicit GetPrometheusInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPrometheusInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPrometheusInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPrometheusInstanceResponseBody() = default;
};
class GetPrometheusInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusInstanceResponseBody> body{};

  GetPrometheusInstanceResponse() {}

  explicit GetPrometheusInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusInstanceResponse() = default;
};
class GetPrometheusIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> regionId{};

  GetPrometheusIntegrationRequest() {}

  explicit GetPrometheusIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPrometheusIntegrationRequest() = default;
};
class GetPrometheusIntegrationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> canDelete{};
  shared_ptr<bool> canEditor{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerName{};
  shared_ptr<string> describe{};
  shared_ptr<string> exporterType{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> namespace_{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> param{};
  shared_ptr<bool> showDescribe{};
  shared_ptr<string> showLog{};
  shared_ptr<string> status{};
  shared_ptr<string> target{};
  shared_ptr<string> version{};

  GetPrometheusIntegrationResponseBodyData() {}

  explicit GetPrometheusIntegrationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canDelete) {
      res["CanDelete"] = boost::any(*canDelete);
    }
    if (canEditor) {
      res["CanEditor"] = boost::any(*canEditor);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (exporterType) {
      res["ExporterType"] = boost::any(*exporterType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (showDescribe) {
      res["ShowDescribe"] = boost::any(*showDescribe);
    }
    if (showLog) {
      res["ShowLog"] = boost::any(*showLog);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanDelete") != m.end() && !m["CanDelete"].empty()) {
      canDelete = make_shared<bool>(boost::any_cast<bool>(m["CanDelete"]));
    }
    if (m.find("CanEditor") != m.end() && !m["CanEditor"].empty()) {
      canEditor = make_shared<bool>(boost::any_cast<bool>(m["CanEditor"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("ExporterType") != m.end() && !m["ExporterType"].empty()) {
      exporterType = make_shared<string>(boost::any_cast<string>(m["ExporterType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("ShowDescribe") != m.end() && !m["ShowDescribe"].empty()) {
      showDescribe = make_shared<bool>(boost::any_cast<bool>(m["ShowDescribe"]));
    }
    if (m.find("ShowLog") != m.end() && !m["ShowLog"].empty()) {
      showLog = make_shared<string>(boost::any_cast<string>(m["ShowLog"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetPrometheusIntegrationResponseBodyData() = default;
};
class GetPrometheusIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetPrometheusIntegrationResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetPrometheusIntegrationResponseBody() {}

  explicit GetPrometheusIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPrometheusIntegrationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPrometheusIntegrationResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPrometheusIntegrationResponseBody() = default;
};
class GetPrometheusIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusIntegrationResponseBody> body{};

  GetPrometheusIntegrationResponse() {}

  explicit GetPrometheusIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusIntegrationResponse() = default;
};
class GetPrometheusMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  GetPrometheusMonitoringRequest() {}

  explicit GetPrometheusMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPrometheusMonitoringRequest() = default;
};
class GetPrometheusMonitoringResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetPrometheusMonitoringResponseBodyData() {}

  explicit GetPrometheusMonitoringResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPrometheusMonitoringResponseBodyData() = default;
};
class GetPrometheusMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetPrometheusMonitoringResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetPrometheusMonitoringResponseBody() {}

  explicit GetPrometheusMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPrometheusMonitoringResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPrometheusMonitoringResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPrometheusMonitoringResponseBody() = default;
};
class GetPrometheusMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusMonitoringResponseBody> body{};

  GetPrometheusMonitoringResponse() {}

  explicit GetPrometheusMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusMonitoringResponse() = default;
};
class GetRecordingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetRecordingRuleRequest() {}

  explicit GetRecordingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetRecordingRuleRequest() = default;
};
class GetRecordingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetRecordingRuleResponseBody() {}

  explicit GetRecordingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRecordingRuleResponseBody() = default;
};
class GetRecordingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRecordingRuleResponseBody> body{};

  GetRecordingRuleResponse() {}

  explicit GetRecordingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRecordingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRecordingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetRecordingRuleResponse() = default;
};
class GetRetcodeAppByPidRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetRetcodeAppByPidRequestTags() {}

  explicit GetRetcodeAppByPidRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetRetcodeAppByPidRequestTags() = default;
};
class GetRetcodeAppByPidRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<GetRetcodeAppByPidRequestTags>> tags{};

  GetRetcodeAppByPidRequest() {}

  explicit GetRetcodeAppByPidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetRetcodeAppByPidRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRetcodeAppByPidRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetRetcodeAppByPidRequestTags>>(expect1);
      }
    }
  }


  virtual ~GetRetcodeAppByPidRequest() = default;
};
class GetRetcodeAppByPidResponseBodyRetcodeAppTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetRetcodeAppByPidResponseBodyRetcodeAppTags() {}

  explicit GetRetcodeAppByPidResponseBodyRetcodeAppTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetRetcodeAppByPidResponseBodyRetcodeAppTags() = default;
};
class GetRetcodeAppByPidResponseBodyRetcodeApp : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> pid{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> retcodeAppType{};
  shared_ptr<vector<GetRetcodeAppByPidResponseBodyRetcodeAppTags>> tags{};

  GetRetcodeAppByPidResponseBodyRetcodeApp() {}

  explicit GetRetcodeAppByPidResponseBodyRetcodeApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retcodeAppType) {
      res["RetcodeAppType"] = boost::any(*retcodeAppType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetcodeAppType") != m.end() && !m["RetcodeAppType"].empty()) {
      retcodeAppType = make_shared<string>(boost::any_cast<string>(m["RetcodeAppType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetRetcodeAppByPidResponseBodyRetcodeAppTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRetcodeAppByPidResponseBodyRetcodeAppTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetRetcodeAppByPidResponseBodyRetcodeAppTags>>(expect1);
      }
    }
  }


  virtual ~GetRetcodeAppByPidResponseBodyRetcodeApp() = default;
};
class GetRetcodeAppByPidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetRetcodeAppByPidResponseBodyRetcodeApp> retcodeApp{};

  GetRetcodeAppByPidResponseBody() {}

  explicit GetRetcodeAppByPidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retcodeApp) {
      res["RetcodeApp"] = retcodeApp ? boost::any(retcodeApp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetcodeApp") != m.end() && !m["RetcodeApp"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetcodeApp"].type()) {
        GetRetcodeAppByPidResponseBodyRetcodeApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetcodeApp"]));
        retcodeApp = make_shared<GetRetcodeAppByPidResponseBodyRetcodeApp>(model1);
      }
    }
  }


  virtual ~GetRetcodeAppByPidResponseBody() = default;
};
class GetRetcodeAppByPidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRetcodeAppByPidResponseBody> body{};

  GetRetcodeAppByPidResponse() {}

  explicit GetRetcodeAppByPidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRetcodeAppByPidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRetcodeAppByPidResponseBody>(model1);
      }
    }
  }


  virtual ~GetRetcodeAppByPidResponse() = default;
};
class GetRetcodeDataByQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> from{};
  shared_ptr<string> pid{};
  shared_ptr<string> query{};
  shared_ptr<string> regionId{};
  shared_ptr<long> to{};

  GetRetcodeDataByQueryRequest() {}

  explicit GetRetcodeDataByQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<long>(boost::any_cast<long>(m["From"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<long>(boost::any_cast<long>(m["To"]));
    }
  }


  virtual ~GetRetcodeDataByQueryRequest() = default;
};
class GetRetcodeDataByQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetRetcodeDataByQueryResponseBody() {}

  explicit GetRetcodeDataByQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRetcodeDataByQueryResponseBody() = default;
};
class GetRetcodeDataByQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRetcodeDataByQueryResponseBody> body{};

  GetRetcodeDataByQueryResponse() {}

  explicit GetRetcodeDataByQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRetcodeDataByQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRetcodeDataByQueryResponseBody>(model1);
      }
    }
  }


  virtual ~GetRetcodeDataByQueryResponse() = default;
};
class GetRetcodeLogstoreRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};

  GetRetcodeLogstoreRequest() {}

  explicit GetRetcodeLogstoreRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetRetcodeLogstoreRequest() = default;
};
class GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> regionId{};

  GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig() {}

  explicit GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig() = default;
};
class GetRetcodeLogstoreResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig> retcodeSLSConfig{};
  shared_ptr<string> status{};

  GetRetcodeLogstoreResponseBodyData() {}

  explicit GetRetcodeLogstoreResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (retcodeSLSConfig) {
      res["RetcodeSLSConfig"] = retcodeSLSConfig ? boost::any(retcodeSLSConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RetcodeSLSConfig") != m.end() && !m["RetcodeSLSConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetcodeSLSConfig"].type()) {
        GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetcodeSLSConfig"]));
        retcodeSLSConfig = make_shared<GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetRetcodeLogstoreResponseBodyData() = default;
};
class GetRetcodeLogstoreResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetRetcodeLogstoreResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetRetcodeLogstoreResponseBody() {}

  explicit GetRetcodeLogstoreResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRetcodeLogstoreResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRetcodeLogstoreResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRetcodeLogstoreResponseBody() = default;
};
class GetRetcodeLogstoreResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRetcodeLogstoreResponseBody> body{};

  GetRetcodeLogstoreResponse() {}

  explicit GetRetcodeLogstoreResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRetcodeLogstoreResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRetcodeLogstoreResponseBody>(model1);
      }
    }
  }


  virtual ~GetRetcodeLogstoreResponse() = default;
};
class GetRetcodeShareUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};

  GetRetcodeShareUrlRequest() {}

  explicit GetRetcodeShareUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
  }


  virtual ~GetRetcodeShareUrlRequest() = default;
};
class GetRetcodeShareUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};

  GetRetcodeShareUrlResponseBody() {}

  explicit GetRetcodeShareUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetRetcodeShareUrlResponseBody() = default;
};
class GetRetcodeShareUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRetcodeShareUrlResponseBody> body{};

  GetRetcodeShareUrlResponse() {}

  explicit GetRetcodeShareUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRetcodeShareUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRetcodeShareUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetRetcodeShareUrlResponse() = default;
};
class GetRumAppInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appGroup{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};

  GetRumAppInfoRequest() {}

  explicit GetRumAppInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGroup) {
      res["AppGroup"] = boost::any(*appGroup);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGroup") != m.end() && !m["AppGroup"].empty()) {
      appGroup = make_shared<string>(boost::any_cast<string>(m["AppGroup"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetRumAppInfoRequest() = default;
};
class GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig : public Darabonba::Model {
public:
  shared_ptr<map<string, DataBonreeSDKConfigModuleConfigDefaultConfigValue>> defaultConfig{};
  shared_ptr<bool> enable{};
  shared_ptr<map<string, DataBonreeSDKConfigModuleConfigVersionConfigsValue>> versionConfigs{};

  GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig() {}

  explicit GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultConfig) {
      map<string, boost::any> temp1;
      for(auto item1:*defaultConfig){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["defaultConfig"] = boost::any(temp1);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (versionConfigs) {
      map<string, boost::any> temp1;
      for(auto item1:*versionConfigs){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["versionConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("defaultConfig") != m.end() && !m["defaultConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["defaultConfig"].type()) {
        map<string, DataBonreeSDKConfigModuleConfigDefaultConfigValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["defaultConfig"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            DataBonreeSDKConfigModuleConfigDefaultConfigValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        defaultConfig = make_shared<map<string, DataBonreeSDKConfigModuleConfigDefaultConfigValue>>(expect1);
      }
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("versionConfigs") != m.end() && !m["versionConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["versionConfigs"].type()) {
        map<string, DataBonreeSDKConfigModuleConfigVersionConfigsValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["versionConfigs"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            DataBonreeSDKConfigModuleConfigVersionConfigsValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        versionConfigs = make_shared<map<string, DataBonreeSDKConfigModuleConfigVersionConfigsValue>>(expect1);
      }
    }
  }


  virtual ~GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig() = default;
};
class GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig : public Darabonba::Model {
public:
  shared_ptr<long> samplingRate{};
  shared_ptr<long> samplingType{};

  GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig() {}

  explicit GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (samplingRate) {
      res["samplingRate"] = boost::any(*samplingRate);
    }
    if (samplingType) {
      res["samplingType"] = boost::any(*samplingType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("samplingRate") != m.end() && !m["samplingRate"].empty()) {
      samplingRate = make_shared<long>(boost::any_cast<long>(m["samplingRate"]));
    }
    if (m.find("samplingType") != m.end() && !m["samplingType"].empty()) {
      samplingType = make_shared<long>(boost::any_cast<long>(m["samplingType"]));
    }
  }


  virtual ~GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig() = default;
};
class GetRumAppInfoResponseBodyDataBonreeSDKConfig : public Darabonba::Model {
public:
  shared_ptr<GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig> moduleConfig{};
  shared_ptr<GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig> samplingConfig{};

  GetRumAppInfoResponseBodyDataBonreeSDKConfig() {}

  explicit GetRumAppInfoResponseBodyDataBonreeSDKConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleConfig) {
      res["moduleConfig"] = moduleConfig ? boost::any(moduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (samplingConfig) {
      res["samplingConfig"] = samplingConfig ? boost::any(samplingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("moduleConfig") != m.end() && !m["moduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["moduleConfig"].type()) {
        GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["moduleConfig"]));
        moduleConfig = make_shared<GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig>(model1);
      }
    }
    if (m.find("samplingConfig") != m.end() && !m["samplingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["samplingConfig"].type()) {
        GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["samplingConfig"]));
        samplingConfig = make_shared<GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig>(model1);
      }
    }
  }


  virtual ~GetRumAppInfoResponseBodyDataBonreeSDKConfig() = default;
};
class GetRumAppInfoResponseBodyDataServiceDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<vector<string>> propagatorTypes{};
  shared_ptr<long> samplingRate{};
  shared_ptr<bool> tracing{};

  GetRumAppInfoResponseBodyDataServiceDomainConfigs() {}

  explicit GetRumAppInfoResponseBodyDataServiceDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (propagatorTypes) {
      res["PropagatorTypes"] = boost::any(*propagatorTypes);
    }
    if (samplingRate) {
      res["SamplingRate"] = boost::any(*samplingRate);
    }
    if (tracing) {
      res["Tracing"] = boost::any(*tracing);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("PropagatorTypes") != m.end() && !m["PropagatorTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PropagatorTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PropagatorTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      propagatorTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SamplingRate") != m.end() && !m["SamplingRate"].empty()) {
      samplingRate = make_shared<long>(boost::any_cast<long>(m["SamplingRate"]));
    }
    if (m.find("Tracing") != m.end() && !m["Tracing"].empty()) {
      tracing = make_shared<bool>(boost::any_cast<bool>(m["Tracing"]));
    }
  }


  virtual ~GetRumAppInfoResponseBodyDataServiceDomainConfigs() = default;
};
class GetRumAppInfoResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetRumAppInfoResponseBodyDataTags() {}

  explicit GetRumAppInfoResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetRumAppInfoResponseBodyDataTags() = default;
};
class GetRumAppInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appGroup{};
  shared_ptr<string> appType{};
  shared_ptr<string> backendServiceTraceRegion{};
  shared_ptr<GetRumAppInfoResponseBodyDataBonreeSDKConfig> bonreeSDKConfig{};
  shared_ptr<string> cdnDomain{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> isSubscription{};
  shared_ptr<string> name{};
  shared_ptr<string> nickName{};
  shared_ptr<string> packageName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<GetRumAppInfoResponseBodyDataServiceDomainConfigs>> serviceDomainConfigs{};
  shared_ptr<string> slsLogstore{};
  shared_ptr<string> slsProject{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetRumAppInfoResponseBodyDataTags>> tags{};
  shared_ptr<string> type{};

  GetRumAppInfoResponseBodyData() {}

  explicit GetRumAppInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGroup) {
      res["AppGroup"] = boost::any(*appGroup);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (backendServiceTraceRegion) {
      res["BackendServiceTraceRegion"] = boost::any(*backendServiceTraceRegion);
    }
    if (bonreeSDKConfig) {
      res["BonreeSDKConfig"] = bonreeSDKConfig ? boost::any(bonreeSDKConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cdnDomain) {
      res["CdnDomain"] = boost::any(*cdnDomain);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (isSubscription) {
      res["IsSubscription"] = boost::any(*isSubscription);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (serviceDomainConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*serviceDomainConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceDomainConfigs"] = boost::any(temp1);
    }
    if (slsLogstore) {
      res["SlsLogstore"] = boost::any(*slsLogstore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGroup") != m.end() && !m["AppGroup"].empty()) {
      appGroup = make_shared<string>(boost::any_cast<string>(m["AppGroup"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("BackendServiceTraceRegion") != m.end() && !m["BackendServiceTraceRegion"].empty()) {
      backendServiceTraceRegion = make_shared<string>(boost::any_cast<string>(m["BackendServiceTraceRegion"]));
    }
    if (m.find("BonreeSDKConfig") != m.end() && !m["BonreeSDKConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BonreeSDKConfig"].type()) {
        GetRumAppInfoResponseBodyDataBonreeSDKConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BonreeSDKConfig"]));
        bonreeSDKConfig = make_shared<GetRumAppInfoResponseBodyDataBonreeSDKConfig>(model1);
      }
    }
    if (m.find("CdnDomain") != m.end() && !m["CdnDomain"].empty()) {
      cdnDomain = make_shared<string>(boost::any_cast<string>(m["CdnDomain"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("IsSubscription") != m.end() && !m["IsSubscription"].empty()) {
      isSubscription = make_shared<string>(boost::any_cast<string>(m["IsSubscription"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ServiceDomainConfigs") != m.end() && !m["ServiceDomainConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceDomainConfigs"].type()) {
        vector<GetRumAppInfoResponseBodyDataServiceDomainConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceDomainConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRumAppInfoResponseBodyDataServiceDomainConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceDomainConfigs = make_shared<vector<GetRumAppInfoResponseBodyDataServiceDomainConfigs>>(expect1);
      }
    }
    if (m.find("SlsLogstore") != m.end() && !m["SlsLogstore"].empty()) {
      slsLogstore = make_shared<string>(boost::any_cast<string>(m["SlsLogstore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetRumAppInfoResponseBodyDataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRumAppInfoResponseBodyDataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetRumAppInfoResponseBodyDataTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetRumAppInfoResponseBodyData() = default;
};
class GetRumAppInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetRumAppInfoResponseBodyData> data{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetRumAppInfoResponseBody() {}

  explicit GetRumAppInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRumAppInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRumAppInfoResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRumAppInfoResponseBody() = default;
};
class GetRumAppInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRumAppInfoResponseBody> body{};

  GetRumAppInfoResponse() {}

  explicit GetRumAppInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRumAppInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRumAppInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetRumAppInfoResponse() = default;
};
class GetRumAppsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetRumAppsRequestTags() {}

  explicit GetRumAppsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetRumAppsRequestTags() = default;
};
class GetRumAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appGroup{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<GetRumAppsRequestTags>> tags{};

  GetRumAppsRequest() {}

  explicit GetRumAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGroup) {
      res["AppGroup"] = boost::any(*appGroup);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGroup") != m.end() && !m["AppGroup"].empty()) {
      appGroup = make_shared<string>(boost::any_cast<string>(m["AppGroup"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetRumAppsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRumAppsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetRumAppsRequestTags>>(expect1);
      }
    }
  }


  virtual ~GetRumAppsRequest() = default;
};
class GetRumAppsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appGroup{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> tagsShrink{};

  GetRumAppsShrinkRequest() {}

  explicit GetRumAppsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGroup) {
      res["AppGroup"] = boost::any(*appGroup);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGroup") != m.end() && !m["AppGroup"].empty()) {
      appGroup = make_shared<string>(boost::any_cast<string>(m["AppGroup"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~GetRumAppsShrinkRequest() = default;
};
class GetRumAppsResponseBodyAppListServiceDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<vector<string>> propagatorTypes{};
  shared_ptr<string> tracing{};

  GetRumAppsResponseBodyAppListServiceDomainConfigs() {}

  explicit GetRumAppsResponseBodyAppListServiceDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (propagatorTypes) {
      res["PropagatorTypes"] = boost::any(*propagatorTypes);
    }
    if (tracing) {
      res["Tracing"] = boost::any(*tracing);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("PropagatorTypes") != m.end() && !m["PropagatorTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PropagatorTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PropagatorTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      propagatorTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tracing") != m.end() && !m["Tracing"].empty()) {
      tracing = make_shared<string>(boost::any_cast<string>(m["Tracing"]));
    }
  }


  virtual ~GetRumAppsResponseBodyAppListServiceDomainConfigs() = default;
};
class GetRumAppsResponseBodyAppListTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetRumAppsResponseBodyAppListTags() {}

  explicit GetRumAppsResponseBodyAppListTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetRumAppsResponseBodyAppListTags() = default;
};
class GetRumAppsResponseBodyAppList : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<boost::any> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> endpoint{};
  shared_ptr<bool> isSubscription{};
  shared_ptr<string> name{};
  shared_ptr<string> nickName{};
  shared_ptr<string> packageName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<GetRumAppsResponseBodyAppListServiceDomainConfigs>> serviceDomainConfigs{};
  shared_ptr<string> slsLogstore{};
  shared_ptr<string> slsProject{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetRumAppsResponseBodyAppListTags>> tags{};
  shared_ptr<string> type{};

  GetRumAppsResponseBodyAppList() {}

  explicit GetRumAppsResponseBodyAppList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (isSubscription) {
      res["IsSubscription"] = boost::any(*isSubscription);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (serviceDomainConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*serviceDomainConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceDomainConfigs"] = boost::any(temp1);
    }
    if (slsLogstore) {
      res["SlsLogstore"] = boost::any(*slsLogstore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<boost::any>(boost::any_cast<boost::any>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("IsSubscription") != m.end() && !m["IsSubscription"].empty()) {
      isSubscription = make_shared<bool>(boost::any_cast<bool>(m["IsSubscription"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ServiceDomainConfigs") != m.end() && !m["ServiceDomainConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceDomainConfigs"].type()) {
        vector<GetRumAppsResponseBodyAppListServiceDomainConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceDomainConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRumAppsResponseBodyAppListServiceDomainConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceDomainConfigs = make_shared<vector<GetRumAppsResponseBodyAppListServiceDomainConfigs>>(expect1);
      }
    }
    if (m.find("SlsLogstore") != m.end() && !m["SlsLogstore"].empty()) {
      slsLogstore = make_shared<string>(boost::any_cast<string>(m["SlsLogstore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetRumAppsResponseBodyAppListTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRumAppsResponseBodyAppListTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetRumAppsResponseBodyAppListTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetRumAppsResponseBodyAppList() = default;
};
class GetRumAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetRumAppsResponseBodyAppList>> appList{};
  shared_ptr<long> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetRumAppsResponseBody() {}

  explicit GetRumAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appList) {
      vector<boost::any> temp1;
      for(auto item1:*appList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppList"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppList") != m.end() && !m["AppList"].empty()) {
      if (typeid(vector<boost::any>) == m["AppList"].type()) {
        vector<GetRumAppsResponseBodyAppList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRumAppsResponseBodyAppList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appList = make_shared<vector<GetRumAppsResponseBodyAppList>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRumAppsResponseBody() = default;
};
class GetRumAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRumAppsResponseBody> body{};

  GetRumAppsResponse() {}

  explicit GetRumAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRumAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRumAppsResponseBody>(model1);
      }
    }
  }


  virtual ~GetRumAppsResponse() = default;
};
class GetRumDataForPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appGroup{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pid{};
  shared_ptr<string> query{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  GetRumDataForPageRequest() {}

  explicit GetRumDataForPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGroup) {
      res["AppGroup"] = boost::any(*appGroup);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGroup") != m.end() && !m["AppGroup"].empty()) {
      appGroup = make_shared<string>(boost::any_cast<string>(m["AppGroup"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetRumDataForPageRequest() = default;
};
class GetRumDataForPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> authentication{};
  shared_ptr<string> completion{};
  shared_ptr<vector<map<string, boost::any>>> items{};
  shared_ptr<string> page{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> preference{};
  shared_ptr<string> total{};

  GetRumDataForPageResponseBodyData() {}

  explicit GetRumDataForPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authentication) {
      res["Authentication"] = boost::any(*authentication);
    }
    if (completion) {
      res["Completion"] = boost::any(*completion);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (preference) {
      res["Preference"] = boost::any(*preference);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authentication") != m.end() && !m["Authentication"].empty()) {
      authentication = make_shared<string>(boost::any_cast<string>(m["Authentication"]));
    }
    if (m.find("Completion") != m.end() && !m["Completion"].empty()) {
      completion = make_shared<string>(boost::any_cast<string>(m["Completion"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      items = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<string>(boost::any_cast<string>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Preference") != m.end() && !m["Preference"].empty()) {
      preference = make_shared<string>(boost::any_cast<string>(m["Preference"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
  }


  virtual ~GetRumDataForPageResponseBodyData() = default;
};
class GetRumDataForPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetRumDataForPageResponseBodyData> data{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetRumDataForPageResponseBody() {}

  explicit GetRumDataForPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRumDataForPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRumDataForPageResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetRumDataForPageResponseBody() = default;
};
class GetRumDataForPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRumDataForPageResponseBody> body{};

  GetRumDataForPageResponse() {}

  explicit GetRumDataForPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRumDataForPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRumDataForPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetRumDataForPageResponse() = default;
};
class GetRumExceptionStackRequest : public Darabonba::Model {
public:
  shared_ptr<string> exceptionBinaryImages{};
  shared_ptr<string> exceptionStack{};
  shared_ptr<string> exceptionThreadId{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourcemapType{};

  GetRumExceptionStackRequest() {}

  explicit GetRumExceptionStackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exceptionBinaryImages) {
      res["ExceptionBinaryImages"] = boost::any(*exceptionBinaryImages);
    }
    if (exceptionStack) {
      res["ExceptionStack"] = boost::any(*exceptionStack);
    }
    if (exceptionThreadId) {
      res["ExceptionThreadId"] = boost::any(*exceptionThreadId);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourcemapType) {
      res["SourcemapType"] = boost::any(*sourcemapType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExceptionBinaryImages") != m.end() && !m["ExceptionBinaryImages"].empty()) {
      exceptionBinaryImages = make_shared<string>(boost::any_cast<string>(m["ExceptionBinaryImages"]));
    }
    if (m.find("ExceptionStack") != m.end() && !m["ExceptionStack"].empty()) {
      exceptionStack = make_shared<string>(boost::any_cast<string>(m["ExceptionStack"]));
    }
    if (m.find("ExceptionThreadId") != m.end() && !m["ExceptionThreadId"].empty()) {
      exceptionThreadId = make_shared<string>(boost::any_cast<string>(m["ExceptionThreadId"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourcemapType") != m.end() && !m["SourcemapType"].empty()) {
      sourcemapType = make_shared<string>(boost::any_cast<string>(m["SourcemapType"]));
    }
  }


  virtual ~GetRumExceptionStackRequest() = default;
};
class GetRumExceptionStackResponseBodyDataThreadInfoList : public Darabonba::Model {
public:
  shared_ptr<string> threadDetail{};
  shared_ptr<string> threadTag{};

  GetRumExceptionStackResponseBodyDataThreadInfoList() {}

  explicit GetRumExceptionStackResponseBodyDataThreadInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (threadDetail) {
      res["ThreadDetail"] = boost::any(*threadDetail);
    }
    if (threadTag) {
      res["ThreadTag"] = boost::any(*threadTag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThreadDetail") != m.end() && !m["ThreadDetail"].empty()) {
      threadDetail = make_shared<string>(boost::any_cast<string>(m["ThreadDetail"]));
    }
    if (m.find("ThreadTag") != m.end() && !m["ThreadTag"].empty()) {
      threadTag = make_shared<string>(boost::any_cast<string>(m["ThreadTag"]));
    }
  }


  virtual ~GetRumExceptionStackResponseBodyDataThreadInfoList() = default;
};
class GetRumExceptionStackResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> crashAddress{};
  shared_ptr<string> crashReason{};
  shared_ptr<vector<string>> lines{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> threadId{};
  shared_ptr<vector<GetRumExceptionStackResponseBodyDataThreadInfoList>> threadInfoList{};
  shared_ptr<string> uuid{};

  GetRumExceptionStackResponseBodyData() {}

  explicit GetRumExceptionStackResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (crashAddress) {
      res["CrashAddress"] = boost::any(*crashAddress);
    }
    if (crashReason) {
      res["CrashReason"] = boost::any(*crashReason);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (threadId) {
      res["ThreadId"] = boost::any(*threadId);
    }
    if (threadInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*threadInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ThreadInfoList"] = boost::any(temp1);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CrashAddress") != m.end() && !m["CrashAddress"].empty()) {
      crashAddress = make_shared<string>(boost::any_cast<string>(m["CrashAddress"]));
    }
    if (m.find("CrashReason") != m.end() && !m["CrashReason"].empty()) {
      crashReason = make_shared<string>(boost::any_cast<string>(m["CrashReason"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Lines"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Lines"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lines = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("ThreadId") != m.end() && !m["ThreadId"].empty()) {
      threadId = make_shared<string>(boost::any_cast<string>(m["ThreadId"]));
    }
    if (m.find("ThreadInfoList") != m.end() && !m["ThreadInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["ThreadInfoList"].type()) {
        vector<GetRumExceptionStackResponseBodyDataThreadInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ThreadInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRumExceptionStackResponseBodyDataThreadInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        threadInfoList = make_shared<vector<GetRumExceptionStackResponseBodyDataThreadInfoList>>(expect1);
      }
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~GetRumExceptionStackResponseBodyData() = default;
};
class GetRumExceptionStackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetRumExceptionStackResponseBodyData> data{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetRumExceptionStackResponseBody() {}

  explicit GetRumExceptionStackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRumExceptionStackResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRumExceptionStackResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetRumExceptionStackResponseBody() = default;
};
class GetRumExceptionStackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRumExceptionStackResponseBody> body{};

  GetRumExceptionStackResponse() {}

  explicit GetRumExceptionStackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRumExceptionStackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRumExceptionStackResponseBody>(model1);
      }
    }
  }


  virtual ~GetRumExceptionStackResponse() = default;
};
class GetRumOcuStatisticDataRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opType{};
  shared_ptr<boost::any> value{};

  GetRumOcuStatisticDataRequestFilter() {}

  explicit GetRumOcuStatisticDataRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<boost::any>(boost::any_cast<boost::any>(m["Value"]));
    }
  }


  virtual ~GetRumOcuStatisticDataRequestFilter() = default;
};
class GetRumOcuStatisticDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<GetRumOcuStatisticDataRequestFilter>> filter{};
  shared_ptr<vector<string>> group{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  GetRumOcuStatisticDataRequest() {}

  explicit GetRumOcuStatisticDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<GetRumOcuStatisticDataRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRumOcuStatisticDataRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<GetRumOcuStatisticDataRequestFilter>>(expect1);
      }
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Group"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Group"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      group = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetRumOcuStatisticDataRequest() = default;
};
class GetRumOcuStatisticDataShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> filterShrink{};
  shared_ptr<string> groupShrink{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  GetRumOcuStatisticDataShrinkRequest() {}

  explicit GetRumOcuStatisticDataShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterShrink) {
      res["Filter"] = boost::any(*filterShrink);
    }
    if (groupShrink) {
      res["Group"] = boost::any(*groupShrink);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filterShrink = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      groupShrink = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetRumOcuStatisticDataShrinkRequest() = default;
};
class GetRumOcuStatisticDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> complete{};
  shared_ptr<vector<map<string, boost::any>>> items{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetRumOcuStatisticDataResponseBodyData() {}

  explicit GetRumOcuStatisticDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complete) {
      res["Complete"] = boost::any(*complete);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Complete") != m.end() && !m["Complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["Complete"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      items = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetRumOcuStatisticDataResponseBodyData() = default;
};
class GetRumOcuStatisticDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetRumOcuStatisticDataResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetRumOcuStatisticDataResponseBody() {}

  explicit GetRumOcuStatisticDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRumOcuStatisticDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRumOcuStatisticDataResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRumOcuStatisticDataResponseBody() = default;
};
class GetRumOcuStatisticDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRumOcuStatisticDataResponseBody> body{};

  GetRumOcuStatisticDataResponse() {}

  explicit GetRumOcuStatisticDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRumOcuStatisticDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRumOcuStatisticDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetRumOcuStatisticDataResponse() = default;
};
class GetRumUploadFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> versionId{};

  GetRumUploadFilesRequest() {}

  explicit GetRumUploadFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~GetRumUploadFilesRequest() = default;
};
class GetRumUploadFilesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<boost::any> lastModifiedTime{};
  shared_ptr<string> size{};
  shared_ptr<string> uuid{};
  shared_ptr<string> versionId{};

  GetRumUploadFilesResponseBodyData() {}

  explicit GetRumUploadFilesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<boost::any>(boost::any_cast<boost::any>(m["LastModifiedTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~GetRumUploadFilesResponseBodyData() = default;
};
class GetRumUploadFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetRumUploadFilesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetRumUploadFilesResponseBody() {}

  explicit GetRumUploadFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetRumUploadFilesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRumUploadFilesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetRumUploadFilesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRumUploadFilesResponseBody() = default;
};
class GetRumUploadFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRumUploadFilesResponseBody> body{};

  GetRumUploadFilesResponse() {}

  explicit GetRumUploadFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRumUploadFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRumUploadFilesResponseBody>(model1);
      }
    }
  }


  virtual ~GetRumUploadFilesResponse() = default;
};
class GetSourceMapInfoRequest : public Darabonba::Model {
public:
  shared_ptr<bool> ascendingSequence{};
  shared_ptr<string> edition{};
  shared_ptr<string> ID{};
  shared_ptr<string> keyword{};
  shared_ptr<string> orderField{};
  shared_ptr<string> regionId{};

  GetSourceMapInfoRequest() {}

  explicit GetSourceMapInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ascendingSequence) {
      res["AscendingSequence"] = boost::any(*ascendingSequence);
    }
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AscendingSequence") != m.end() && !m["AscendingSequence"].empty()) {
      ascendingSequence = make_shared<bool>(boost::any_cast<bool>(m["AscendingSequence"]));
    }
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<string>(boost::any_cast<string>(m["Edition"]));
    }
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<string>(boost::any_cast<string>(m["ID"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetSourceMapInfoRequest() = default;
};
class GetSourceMapInfoResponseBodySourceMapList : public Darabonba::Model {
public:
  shared_ptr<string> fid{};
  shared_ptr<string> fileName{};
  shared_ptr<string> size{};
  shared_ptr<string> uploadTime{};
  shared_ptr<string> version{};

  GetSourceMapInfoResponseBodySourceMapList() {}

  explicit GetSourceMapInfoResponseBodySourceMapList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fid) {
      res["Fid"] = boost::any(*fid);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (uploadTime) {
      res["UploadTime"] = boost::any(*uploadTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fid") != m.end() && !m["Fid"].empty()) {
      fid = make_shared<string>(boost::any_cast<string>(m["Fid"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("UploadTime") != m.end() && !m["UploadTime"].empty()) {
      uploadTime = make_shared<string>(boost::any_cast<string>(m["UploadTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetSourceMapInfoResponseBodySourceMapList() = default;
};
class GetSourceMapInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetSourceMapInfoResponseBodySourceMapList>> sourceMapList{};

  GetSourceMapInfoResponseBody() {}

  explicit GetSourceMapInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceMapList) {
      vector<boost::any> temp1;
      for(auto item1:*sourceMapList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceMapList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceMapList") != m.end() && !m["SourceMapList"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceMapList"].type()) {
        vector<GetSourceMapInfoResponseBodySourceMapList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceMapList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSourceMapInfoResponseBodySourceMapList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceMapList = make_shared<vector<GetSourceMapInfoResponseBodySourceMapList>>(expect1);
      }
    }
  }


  virtual ~GetSourceMapInfoResponseBody() = default;
};
class GetSourceMapInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSourceMapInfoResponseBody> body{};

  GetSourceMapInfoResponse() {}

  explicit GetSourceMapInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSourceMapInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSourceMapInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetSourceMapInfoResponse() = default;
};
class GetStackRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> rpcID{};
  shared_ptr<string> spanID{};
  shared_ptr<long> startTime{};
  shared_ptr<string> traceID{};

  GetStackRequest() {}

  explicit GetStackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rpcID) {
      res["RpcID"] = boost::any(*rpcID);
    }
    if (spanID) {
      res["SpanID"] = boost::any(*spanID);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RpcID") != m.end() && !m["RpcID"].empty()) {
      rpcID = make_shared<string>(boost::any_cast<string>(m["RpcID"]));
    }
    if (m.find("SpanID") != m.end() && !m["SpanID"].empty()) {
      spanID = make_shared<string>(boost::any_cast<string>(m["SpanID"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~GetStackRequest() = default;
};
class GetStackResponseBodyStackInfoExtInfo : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> type{};

  GetStackResponseBodyStackInfoExtInfo() {}

  explicit GetStackResponseBodyStackInfoExtInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetStackResponseBodyStackInfoExtInfo() = default;
};
class GetStackResponseBodyStackInfo : public Darabonba::Model {
public:
  shared_ptr<string> api{};
  shared_ptr<string> callCount{};
  shared_ptr<long> duration{};
  shared_ptr<string> exception{};
  shared_ptr<GetStackResponseBodyStackInfoExtInfo> extInfo{};
  shared_ptr<string> line{};
  shared_ptr<string> rpcId{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> startTime{};

  GetStackResponseBodyStackInfo() {}

  explicit GetStackResponseBodyStackInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (api) {
      res["Api"] = boost::any(*api);
    }
    if (callCount) {
      res["CallCount"] = boost::any(*callCount);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (exception) {
      res["Exception"] = boost::any(*exception);
    }
    if (extInfo) {
      res["ExtInfo"] = extInfo ? boost::any(extInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (rpcId) {
      res["RpcId"] = boost::any(*rpcId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Api") != m.end() && !m["Api"].empty()) {
      api = make_shared<string>(boost::any_cast<string>(m["Api"]));
    }
    if (m.find("CallCount") != m.end() && !m["CallCount"].empty()) {
      callCount = make_shared<string>(boost::any_cast<string>(m["CallCount"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Exception") != m.end() && !m["Exception"].empty()) {
      exception = make_shared<string>(boost::any_cast<string>(m["Exception"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtInfo"].type()) {
        GetStackResponseBodyStackInfoExtInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtInfo"]));
        extInfo = make_shared<GetStackResponseBodyStackInfoExtInfo>(model1);
      }
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("RpcId") != m.end() && !m["RpcId"].empty()) {
      rpcId = make_shared<string>(boost::any_cast<string>(m["RpcId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetStackResponseBodyStackInfo() = default;
};
class GetStackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetStackResponseBodyStackInfo>> stackInfo{};

  GetStackResponseBody() {}

  explicit GetStackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stackInfo) {
      vector<boost::any> temp1;
      for(auto item1:*stackInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StackInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StackInfo") != m.end() && !m["StackInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StackInfo"].type()) {
        vector<GetStackResponseBodyStackInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StackInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetStackResponseBodyStackInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stackInfo = make_shared<vector<GetStackResponseBodyStackInfo>>(expect1);
      }
    }
  }


  virtual ~GetStackResponseBody() = default;
};
class GetStackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStackResponseBody> body{};

  GetStackResponse() {}

  explicit GetStackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStackResponseBody>(model1);
      }
    }
  }


  virtual ~GetStackResponse() = default;
};
class GetSyntheticMonitorsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<long> monitorCategory{};
  shared_ptr<long> network{};
  shared_ptr<long> taskType{};

  GetSyntheticMonitorsRequestFilter() {}

  explicit GetSyntheticMonitorsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorCategory) {
      res["MonitorCategory"] = boost::any(*monitorCategory);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorCategory") != m.end() && !m["MonitorCategory"].empty()) {
      monitorCategory = make_shared<long>(boost::any_cast<long>(m["MonitorCategory"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<long>(boost::any_cast<long>(m["Network"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
  }


  virtual ~GetSyntheticMonitorsRequestFilter() = default;
};
class GetSyntheticMonitorsRequest : public Darabonba::Model {
public:
  shared_ptr<GetSyntheticMonitorsRequestFilter> filter{};
  shared_ptr<string> regionId{};

  GetSyntheticMonitorsRequest() {}

  explicit GetSyntheticMonitorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        GetSyntheticMonitorsRequestFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<GetSyntheticMonitorsRequestFilter>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetSyntheticMonitorsRequest() = default;
};
class GetSyntheticMonitorsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> filterShrink{};
  shared_ptr<string> regionId{};

  GetSyntheticMonitorsShrinkRequest() {}

  explicit GetSyntheticMonitorsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterShrink) {
      res["Filter"] = boost::any(*filterShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filterShrink = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetSyntheticMonitorsShrinkRequest() = default;
};
class GetSyntheticMonitorsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> available{};
  shared_ptr<bool> canBeSelected{};
  shared_ptr<string> city{};
  shared_ptr<string> cityCode{};
  shared_ptr<long> clientType{};
  shared_ptr<string> country{};
  shared_ptr<long> ipv6{};
  shared_ptr<string> operator_{};
  shared_ptr<string> operatorCode{};
  shared_ptr<string> region{};

  GetSyntheticMonitorsResponseBodyData() {}

  explicit GetSyntheticMonitorsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (available) {
      res["Available"] = boost::any(*available);
    }
    if (canBeSelected) {
      res["CanBeSelected"] = boost::any(*canBeSelected);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (ipv6) {
      res["Ipv6"] = boost::any(*ipv6);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (operatorCode) {
      res["OperatorCode"] = boost::any(*operatorCode);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Available") != m.end() && !m["Available"].empty()) {
      available = make_shared<string>(boost::any_cast<string>(m["Available"]));
    }
    if (m.find("CanBeSelected") != m.end() && !m["CanBeSelected"].empty()) {
      canBeSelected = make_shared<bool>(boost::any_cast<bool>(m["CanBeSelected"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<long>(boost::any_cast<long>(m["ClientType"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Ipv6") != m.end() && !m["Ipv6"].empty()) {
      ipv6 = make_shared<long>(boost::any_cast<long>(m["Ipv6"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("OperatorCode") != m.end() && !m["OperatorCode"].empty()) {
      operatorCode = make_shared<string>(boost::any_cast<string>(m["OperatorCode"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~GetSyntheticMonitorsResponseBodyData() = default;
};
class GetSyntheticMonitorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetSyntheticMonitorsResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetSyntheticMonitorsResponseBody() {}

  explicit GetSyntheticMonitorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetSyntheticMonitorsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticMonitorsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetSyntheticMonitorsResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSyntheticMonitorsResponseBody() = default;
};
class GetSyntheticMonitorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSyntheticMonitorsResponseBody> body{};

  GetSyntheticMonitorsResponse() {}

  explicit GetSyntheticMonitorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSyntheticMonitorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSyntheticMonitorsResponseBody>(model1);
      }
    }
  }


  virtual ~GetSyntheticMonitorsResponse() = default;
};
class GetSyntheticTaskDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  GetSyntheticTaskDetailRequest() {}

  explicit GetSyntheticTaskDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetSyntheticTaskDetailRequest() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList : public Darabonba::Model {
public:
  shared_ptr<string> generalAlert{};
  shared_ptr<string> isCritical{};
  shared_ptr<string> name{};
  shared_ptr<string> seriousAlert{};
  shared_ptr<string> symbols{};

  GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generalAlert) {
      res["GeneralAlert"] = boost::any(*generalAlert);
    }
    if (isCritical) {
      res["IsCritical"] = boost::any(*isCritical);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (seriousAlert) {
      res["SeriousAlert"] = boost::any(*seriousAlert);
    }
    if (symbols) {
      res["Symbols"] = boost::any(*symbols);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GeneralAlert") != m.end() && !m["GeneralAlert"].empty()) {
      generalAlert = make_shared<string>(boost::any_cast<string>(m["GeneralAlert"]));
    }
    if (m.find("IsCritical") != m.end() && !m["IsCritical"].empty()) {
      isCritical = make_shared<string>(boost::any_cast<string>(m["IsCritical"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SeriousAlert") != m.end() && !m["SeriousAlert"].empty()) {
      seriousAlert = make_shared<string>(boost::any_cast<string>(m["SeriousAlert"]));
    }
    if (m.find("Symbols") != m.end() && !m["Symbols"].empty()) {
      symbols = make_shared<string>(boost::any_cast<string>(m["Symbols"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam : public Darabonba::Model {
public:
  shared_ptr<long> alarmFlag{};
  shared_ptr<vector<GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList>> alertList{};
  shared_ptr<string> alertNotifierId{};
  shared_ptr<string> alertPolicyId{};
  shared_ptr<string> monitorSamples{};
  shared_ptr<string> startExecutionTime{};

  GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmFlag) {
      res["AlarmFlag"] = boost::any(*alarmFlag);
    }
    if (alertList) {
      vector<boost::any> temp1;
      for(auto item1:*alertList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertList"] = boost::any(temp1);
    }
    if (alertNotifierId) {
      res["AlertNotifierId"] = boost::any(*alertNotifierId);
    }
    if (alertPolicyId) {
      res["AlertPolicyId"] = boost::any(*alertPolicyId);
    }
    if (monitorSamples) {
      res["MonitorSamples"] = boost::any(*monitorSamples);
    }
    if (startExecutionTime) {
      res["StartExecutionTime"] = boost::any(*startExecutionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmFlag") != m.end() && !m["AlarmFlag"].empty()) {
      alarmFlag = make_shared<long>(boost::any_cast<long>(m["AlarmFlag"]));
    }
    if (m.find("AlertList") != m.end() && !m["AlertList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertList"].type()) {
        vector<GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertList = make_shared<vector<GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList>>(expect1);
      }
    }
    if (m.find("AlertNotifierId") != m.end() && !m["AlertNotifierId"].empty()) {
      alertNotifierId = make_shared<string>(boost::any_cast<string>(m["AlertNotifierId"]));
    }
    if (m.find("AlertPolicyId") != m.end() && !m["AlertPolicyId"].empty()) {
      alertPolicyId = make_shared<string>(boost::any_cast<string>(m["AlertPolicyId"]));
    }
    if (m.find("MonitorSamples") != m.end() && !m["MonitorSamples"].empty()) {
      monitorSamples = make_shared<string>(boost::any_cast<string>(m["MonitorSamples"]));
    }
    if (m.find("StartExecutionTime") != m.end() && !m["StartExecutionTime"].empty()) {
      startExecutionTime = make_shared<string>(boost::any_cast<string>(m["StartExecutionTime"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailDownload : public Darabonba::Model {
public:
  shared_ptr<long> connectionTimeout{};
  shared_ptr<string> downloadCustomHeaderContent{};
  shared_ptr<long> downloadCustomHost{};
  shared_ptr<string> downloadCustomHostIp{};
  shared_ptr<long> downloadKernel{};
  shared_ptr<long> downloadRedirect{};
  shared_ptr<long> downloadTransmissionSize{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<string> quickProtocol{};
  shared_ptr<string> validateKeywords{};
  shared_ptr<long> verifyWay{};
  shared_ptr<string> whiteList{};

  GetSyntheticTaskDetailResponseBodyTaskDetailDownload() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailDownload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionTimeout) {
      res["ConnectionTimeout"] = boost::any(*connectionTimeout);
    }
    if (downloadCustomHeaderContent) {
      res["DownloadCustomHeaderContent"] = boost::any(*downloadCustomHeaderContent);
    }
    if (downloadCustomHost) {
      res["DownloadCustomHost"] = boost::any(*downloadCustomHost);
    }
    if (downloadCustomHostIp) {
      res["DownloadCustomHostIp"] = boost::any(*downloadCustomHostIp);
    }
    if (downloadKernel) {
      res["DownloadKernel"] = boost::any(*downloadKernel);
    }
    if (downloadRedirect) {
      res["DownloadRedirect"] = boost::any(*downloadRedirect);
    }
    if (downloadTransmissionSize) {
      res["DownloadTransmissionSize"] = boost::any(*downloadTransmissionSize);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (quickProtocol) {
      res["QuickProtocol"] = boost::any(*quickProtocol);
    }
    if (validateKeywords) {
      res["ValidateKeywords"] = boost::any(*validateKeywords);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionTimeout") != m.end() && !m["ConnectionTimeout"].empty()) {
      connectionTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectionTimeout"]));
    }
    if (m.find("DownloadCustomHeaderContent") != m.end() && !m["DownloadCustomHeaderContent"].empty()) {
      downloadCustomHeaderContent = make_shared<string>(boost::any_cast<string>(m["DownloadCustomHeaderContent"]));
    }
    if (m.find("DownloadCustomHost") != m.end() && !m["DownloadCustomHost"].empty()) {
      downloadCustomHost = make_shared<long>(boost::any_cast<long>(m["DownloadCustomHost"]));
    }
    if (m.find("DownloadCustomHostIp") != m.end() && !m["DownloadCustomHostIp"].empty()) {
      downloadCustomHostIp = make_shared<string>(boost::any_cast<string>(m["DownloadCustomHostIp"]));
    }
    if (m.find("DownloadKernel") != m.end() && !m["DownloadKernel"].empty()) {
      downloadKernel = make_shared<long>(boost::any_cast<long>(m["DownloadKernel"]));
    }
    if (m.find("DownloadRedirect") != m.end() && !m["DownloadRedirect"].empty()) {
      downloadRedirect = make_shared<long>(boost::any_cast<long>(m["DownloadRedirect"]));
    }
    if (m.find("DownloadTransmissionSize") != m.end() && !m["DownloadTransmissionSize"].empty()) {
      downloadTransmissionSize = make_shared<long>(boost::any_cast<long>(m["DownloadTransmissionSize"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("QuickProtocol") != m.end() && !m["QuickProtocol"].empty()) {
      quickProtocol = make_shared<string>(boost::any_cast<string>(m["QuickProtocol"]));
    }
    if (m.find("ValidateKeywords") != m.end() && !m["ValidateKeywords"].empty()) {
      validateKeywords = make_shared<string>(boost::any_cast<string>(m["ValidateKeywords"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailDownload() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval : public Darabonba::Model {
public:
  shared_ptr<vector<long>> days{};
  shared_ptr<long> endMinute{};
  shared_ptr<string> endTime{};
  shared_ptr<long> endhour{};
  shared_ptr<long> startHour{};
  shared_ptr<long> startMinute{};
  shared_ptr<string> startTime{};

  GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (endMinute) {
      res["EndMinute"] = boost::any(*endMinute);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endhour) {
      res["Endhour"] = boost::any(*endhour);
    }
    if (startHour) {
      res["StartHour"] = boost::any(*startHour);
    }
    if (startMinute) {
      res["StartMinute"] = boost::any(*startMinute);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Days"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Days"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      days = make_shared<vector<long>>(toVec1);
    }
    if (m.find("EndMinute") != m.end() && !m["EndMinute"].empty()) {
      endMinute = make_shared<long>(boost::any_cast<long>(m["EndMinute"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Endhour") != m.end() && !m["Endhour"].empty()) {
      endhour = make_shared<long>(boost::any_cast<long>(m["Endhour"]));
    }
    if (m.find("StartHour") != m.end() && !m["StartHour"].empty()) {
      startHour = make_shared<long>(boost::any_cast<long>(m["StartHour"]));
    }
    if (m.find("StartMinute") != m.end() && !m["StartMinute"].empty()) {
      startMinute = make_shared<long>(boost::any_cast<long>(m["StartMinute"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList : public Darabonba::Model {
public:
  shared_ptr<long> cityCode{};
  shared_ptr<long> monitorType{};
  shared_ptr<long> netServiceId{};
  shared_ptr<long> sendCount{};

  GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (monitorType) {
      res["MonitorType"] = boost::any(*monitorType);
    }
    if (netServiceId) {
      res["NetServiceId"] = boost::any(*netServiceId);
    }
    if (sendCount) {
      res["SendCount"] = boost::any(*sendCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("MonitorType") != m.end() && !m["MonitorType"].empty()) {
      monitorType = make_shared<long>(boost::any_cast<long>(m["MonitorType"]));
    }
    if (m.find("NetServiceId") != m.end() && !m["NetServiceId"].empty()) {
      netServiceId = make_shared<long>(boost::any_cast<long>(m["NetServiceId"]));
    }
    if (m.find("SendCount") != m.end() && !m["SendCount"].empty()) {
      sendCount = make_shared<long>(boost::any_cast<long>(m["SendCount"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailNav : public Darabonba::Model {
public:
  shared_ptr<string> dnsHijackWhitelist{};
  shared_ptr<string> elementBlacklist{};
  shared_ptr<long> executeActiveX{};
  shared_ptr<long> executeApplet{};
  shared_ptr<long> executeScript{};
  shared_ptr<long> filterInvalidIP{};
  shared_ptr<long> flowHijackJumpTimes{};
  shared_ptr<string> flowHijackLogo{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<long> navAutomaticScrolling{};
  shared_ptr<string> navCustomHeader{};
  shared_ptr<string> navCustomHeaderContent{};
  shared_ptr<long> navCustomHost{};
  shared_ptr<string> navCustomHostIp{};
  shared_ptr<long> navDisableCache{};
  shared_ptr<long> navDisableCompression{};
  shared_ptr<long> navIgnoreCertificateError{};
  shared_ptr<long> navRedirect{};
  shared_ptr<long> navReturnElement{};
  shared_ptr<string> pageTampering{};
  shared_ptr<string> processName{};
  shared_ptr<string> quicDomain{};
  shared_ptr<long> quicVersion{};
  shared_ptr<long> requestHeader{};
  shared_ptr<long> slowElementThreshold{};
  shared_ptr<string> verifyStringBlacklist{};
  shared_ptr<string> verifyStringWhitelist{};
  shared_ptr<long> waitCompletionTime{};

  GetSyntheticTaskDetailResponseBodyTaskDetailNav() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailNav(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsHijackWhitelist) {
      res["DnsHijackWhitelist"] = boost::any(*dnsHijackWhitelist);
    }
    if (elementBlacklist) {
      res["ElementBlacklist"] = boost::any(*elementBlacklist);
    }
    if (executeActiveX) {
      res["ExecuteActiveX"] = boost::any(*executeActiveX);
    }
    if (executeApplet) {
      res["ExecuteApplet"] = boost::any(*executeApplet);
    }
    if (executeScript) {
      res["ExecuteScript"] = boost::any(*executeScript);
    }
    if (filterInvalidIP) {
      res["FilterInvalidIP"] = boost::any(*filterInvalidIP);
    }
    if (flowHijackJumpTimes) {
      res["FlowHijackJumpTimes"] = boost::any(*flowHijackJumpTimes);
    }
    if (flowHijackLogo) {
      res["FlowHijackLogo"] = boost::any(*flowHijackLogo);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (navAutomaticScrolling) {
      res["NavAutomaticScrolling"] = boost::any(*navAutomaticScrolling);
    }
    if (navCustomHeader) {
      res["NavCustomHeader"] = boost::any(*navCustomHeader);
    }
    if (navCustomHeaderContent) {
      res["NavCustomHeaderContent"] = boost::any(*navCustomHeaderContent);
    }
    if (navCustomHost) {
      res["NavCustomHost"] = boost::any(*navCustomHost);
    }
    if (navCustomHostIp) {
      res["NavCustomHostIp"] = boost::any(*navCustomHostIp);
    }
    if (navDisableCache) {
      res["NavDisableCache"] = boost::any(*navDisableCache);
    }
    if (navDisableCompression) {
      res["NavDisableCompression"] = boost::any(*navDisableCompression);
    }
    if (navIgnoreCertificateError) {
      res["NavIgnoreCertificateError"] = boost::any(*navIgnoreCertificateError);
    }
    if (navRedirect) {
      res["NavRedirect"] = boost::any(*navRedirect);
    }
    if (navReturnElement) {
      res["NavReturnElement"] = boost::any(*navReturnElement);
    }
    if (pageTampering) {
      res["PageTampering"] = boost::any(*pageTampering);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (quicDomain) {
      res["QuicDomain"] = boost::any(*quicDomain);
    }
    if (quicVersion) {
      res["QuicVersion"] = boost::any(*quicVersion);
    }
    if (requestHeader) {
      res["RequestHeader"] = boost::any(*requestHeader);
    }
    if (slowElementThreshold) {
      res["SlowElementThreshold"] = boost::any(*slowElementThreshold);
    }
    if (verifyStringBlacklist) {
      res["VerifyStringBlacklist"] = boost::any(*verifyStringBlacklist);
    }
    if (verifyStringWhitelist) {
      res["VerifyStringWhitelist"] = boost::any(*verifyStringWhitelist);
    }
    if (waitCompletionTime) {
      res["WaitCompletionTime"] = boost::any(*waitCompletionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsHijackWhitelist") != m.end() && !m["DnsHijackWhitelist"].empty()) {
      dnsHijackWhitelist = make_shared<string>(boost::any_cast<string>(m["DnsHijackWhitelist"]));
    }
    if (m.find("ElementBlacklist") != m.end() && !m["ElementBlacklist"].empty()) {
      elementBlacklist = make_shared<string>(boost::any_cast<string>(m["ElementBlacklist"]));
    }
    if (m.find("ExecuteActiveX") != m.end() && !m["ExecuteActiveX"].empty()) {
      executeActiveX = make_shared<long>(boost::any_cast<long>(m["ExecuteActiveX"]));
    }
    if (m.find("ExecuteApplet") != m.end() && !m["ExecuteApplet"].empty()) {
      executeApplet = make_shared<long>(boost::any_cast<long>(m["ExecuteApplet"]));
    }
    if (m.find("ExecuteScript") != m.end() && !m["ExecuteScript"].empty()) {
      executeScript = make_shared<long>(boost::any_cast<long>(m["ExecuteScript"]));
    }
    if (m.find("FilterInvalidIP") != m.end() && !m["FilterInvalidIP"].empty()) {
      filterInvalidIP = make_shared<long>(boost::any_cast<long>(m["FilterInvalidIP"]));
    }
    if (m.find("FlowHijackJumpTimes") != m.end() && !m["FlowHijackJumpTimes"].empty()) {
      flowHijackJumpTimes = make_shared<long>(boost::any_cast<long>(m["FlowHijackJumpTimes"]));
    }
    if (m.find("FlowHijackLogo") != m.end() && !m["FlowHijackLogo"].empty()) {
      flowHijackLogo = make_shared<string>(boost::any_cast<string>(m["FlowHijackLogo"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("NavAutomaticScrolling") != m.end() && !m["NavAutomaticScrolling"].empty()) {
      navAutomaticScrolling = make_shared<long>(boost::any_cast<long>(m["NavAutomaticScrolling"]));
    }
    if (m.find("NavCustomHeader") != m.end() && !m["NavCustomHeader"].empty()) {
      navCustomHeader = make_shared<string>(boost::any_cast<string>(m["NavCustomHeader"]));
    }
    if (m.find("NavCustomHeaderContent") != m.end() && !m["NavCustomHeaderContent"].empty()) {
      navCustomHeaderContent = make_shared<string>(boost::any_cast<string>(m["NavCustomHeaderContent"]));
    }
    if (m.find("NavCustomHost") != m.end() && !m["NavCustomHost"].empty()) {
      navCustomHost = make_shared<long>(boost::any_cast<long>(m["NavCustomHost"]));
    }
    if (m.find("NavCustomHostIp") != m.end() && !m["NavCustomHostIp"].empty()) {
      navCustomHostIp = make_shared<string>(boost::any_cast<string>(m["NavCustomHostIp"]));
    }
    if (m.find("NavDisableCache") != m.end() && !m["NavDisableCache"].empty()) {
      navDisableCache = make_shared<long>(boost::any_cast<long>(m["NavDisableCache"]));
    }
    if (m.find("NavDisableCompression") != m.end() && !m["NavDisableCompression"].empty()) {
      navDisableCompression = make_shared<long>(boost::any_cast<long>(m["NavDisableCompression"]));
    }
    if (m.find("NavIgnoreCertificateError") != m.end() && !m["NavIgnoreCertificateError"].empty()) {
      navIgnoreCertificateError = make_shared<long>(boost::any_cast<long>(m["NavIgnoreCertificateError"]));
    }
    if (m.find("NavRedirect") != m.end() && !m["NavRedirect"].empty()) {
      navRedirect = make_shared<long>(boost::any_cast<long>(m["NavRedirect"]));
    }
    if (m.find("NavReturnElement") != m.end() && !m["NavReturnElement"].empty()) {
      navReturnElement = make_shared<long>(boost::any_cast<long>(m["NavReturnElement"]));
    }
    if (m.find("PageTampering") != m.end() && !m["PageTampering"].empty()) {
      pageTampering = make_shared<string>(boost::any_cast<string>(m["PageTampering"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("QuicDomain") != m.end() && !m["QuicDomain"].empty()) {
      quicDomain = make_shared<string>(boost::any_cast<string>(m["QuicDomain"]));
    }
    if (m.find("QuicVersion") != m.end() && !m["QuicVersion"].empty()) {
      quicVersion = make_shared<long>(boost::any_cast<long>(m["QuicVersion"]));
    }
    if (m.find("RequestHeader") != m.end() && !m["RequestHeader"].empty()) {
      requestHeader = make_shared<long>(boost::any_cast<long>(m["RequestHeader"]));
    }
    if (m.find("SlowElementThreshold") != m.end() && !m["SlowElementThreshold"].empty()) {
      slowElementThreshold = make_shared<long>(boost::any_cast<long>(m["SlowElementThreshold"]));
    }
    if (m.find("VerifyStringBlacklist") != m.end() && !m["VerifyStringBlacklist"].empty()) {
      verifyStringBlacklist = make_shared<string>(boost::any_cast<string>(m["VerifyStringBlacklist"]));
    }
    if (m.find("VerifyStringWhitelist") != m.end() && !m["VerifyStringWhitelist"].empty()) {
      verifyStringWhitelist = make_shared<string>(boost::any_cast<string>(m["VerifyStringWhitelist"]));
    }
    if (m.find("WaitCompletionTime") != m.end() && !m["WaitCompletionTime"].empty()) {
      waitCompletionTime = make_shared<long>(boost::any_cast<long>(m["WaitCompletionTime"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailNav() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailNet : public Darabonba::Model {
public:
  shared_ptr<long> netDigSwitch{};
  shared_ptr<string> netDnsNs{};
  shared_ptr<string> netDnsQueryMethod{};
  shared_ptr<long> netDnsServer{};
  shared_ptr<long> netDnsSwitch{};
  shared_ptr<string> netDnsTimeout{};
  shared_ptr<long> netIcmpActive{};
  shared_ptr<long> netIcmpDataCut{};
  shared_ptr<long> netIcmpInterval{};
  shared_ptr<long> netIcmpNum{};
  shared_ptr<long> netIcmpSize{};
  shared_ptr<long> netIcmpSwitch{};
  shared_ptr<long> netIcmpTimeout{};
  shared_ptr<long> netTraceRouteNum{};
  shared_ptr<long> netTraceRouteSwitch{};
  shared_ptr<long> netTraceRouteTimeout{};
  shared_ptr<string> whiteList{};

  GetSyntheticTaskDetailResponseBodyTaskDetailNet() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailNet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (netDigSwitch) {
      res["NetDigSwitch"] = boost::any(*netDigSwitch);
    }
    if (netDnsNs) {
      res["NetDnsNs"] = boost::any(*netDnsNs);
    }
    if (netDnsQueryMethod) {
      res["NetDnsQueryMethod"] = boost::any(*netDnsQueryMethod);
    }
    if (netDnsServer) {
      res["NetDnsServer"] = boost::any(*netDnsServer);
    }
    if (netDnsSwitch) {
      res["NetDnsSwitch"] = boost::any(*netDnsSwitch);
    }
    if (netDnsTimeout) {
      res["NetDnsTimeout"] = boost::any(*netDnsTimeout);
    }
    if (netIcmpActive) {
      res["NetIcmpActive"] = boost::any(*netIcmpActive);
    }
    if (netIcmpDataCut) {
      res["NetIcmpDataCut"] = boost::any(*netIcmpDataCut);
    }
    if (netIcmpInterval) {
      res["NetIcmpInterval"] = boost::any(*netIcmpInterval);
    }
    if (netIcmpNum) {
      res["NetIcmpNum"] = boost::any(*netIcmpNum);
    }
    if (netIcmpSize) {
      res["NetIcmpSize"] = boost::any(*netIcmpSize);
    }
    if (netIcmpSwitch) {
      res["NetIcmpSwitch"] = boost::any(*netIcmpSwitch);
    }
    if (netIcmpTimeout) {
      res["NetIcmpTimeout"] = boost::any(*netIcmpTimeout);
    }
    if (netTraceRouteNum) {
      res["NetTraceRouteNum"] = boost::any(*netTraceRouteNum);
    }
    if (netTraceRouteSwitch) {
      res["NetTraceRouteSwitch"] = boost::any(*netTraceRouteSwitch);
    }
    if (netTraceRouteTimeout) {
      res["NetTraceRouteTimeout"] = boost::any(*netTraceRouteTimeout);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetDigSwitch") != m.end() && !m["NetDigSwitch"].empty()) {
      netDigSwitch = make_shared<long>(boost::any_cast<long>(m["NetDigSwitch"]));
    }
    if (m.find("NetDnsNs") != m.end() && !m["NetDnsNs"].empty()) {
      netDnsNs = make_shared<string>(boost::any_cast<string>(m["NetDnsNs"]));
    }
    if (m.find("NetDnsQueryMethod") != m.end() && !m["NetDnsQueryMethod"].empty()) {
      netDnsQueryMethod = make_shared<string>(boost::any_cast<string>(m["NetDnsQueryMethod"]));
    }
    if (m.find("NetDnsServer") != m.end() && !m["NetDnsServer"].empty()) {
      netDnsServer = make_shared<long>(boost::any_cast<long>(m["NetDnsServer"]));
    }
    if (m.find("NetDnsSwitch") != m.end() && !m["NetDnsSwitch"].empty()) {
      netDnsSwitch = make_shared<long>(boost::any_cast<long>(m["NetDnsSwitch"]));
    }
    if (m.find("NetDnsTimeout") != m.end() && !m["NetDnsTimeout"].empty()) {
      netDnsTimeout = make_shared<string>(boost::any_cast<string>(m["NetDnsTimeout"]));
    }
    if (m.find("NetIcmpActive") != m.end() && !m["NetIcmpActive"].empty()) {
      netIcmpActive = make_shared<long>(boost::any_cast<long>(m["NetIcmpActive"]));
    }
    if (m.find("NetIcmpDataCut") != m.end() && !m["NetIcmpDataCut"].empty()) {
      netIcmpDataCut = make_shared<long>(boost::any_cast<long>(m["NetIcmpDataCut"]));
    }
    if (m.find("NetIcmpInterval") != m.end() && !m["NetIcmpInterval"].empty()) {
      netIcmpInterval = make_shared<long>(boost::any_cast<long>(m["NetIcmpInterval"]));
    }
    if (m.find("NetIcmpNum") != m.end() && !m["NetIcmpNum"].empty()) {
      netIcmpNum = make_shared<long>(boost::any_cast<long>(m["NetIcmpNum"]));
    }
    if (m.find("NetIcmpSize") != m.end() && !m["NetIcmpSize"].empty()) {
      netIcmpSize = make_shared<long>(boost::any_cast<long>(m["NetIcmpSize"]));
    }
    if (m.find("NetIcmpSwitch") != m.end() && !m["NetIcmpSwitch"].empty()) {
      netIcmpSwitch = make_shared<long>(boost::any_cast<long>(m["NetIcmpSwitch"]));
    }
    if (m.find("NetIcmpTimeout") != m.end() && !m["NetIcmpTimeout"].empty()) {
      netIcmpTimeout = make_shared<long>(boost::any_cast<long>(m["NetIcmpTimeout"]));
    }
    if (m.find("NetTraceRouteNum") != m.end() && !m["NetTraceRouteNum"].empty()) {
      netTraceRouteNum = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteNum"]));
    }
    if (m.find("NetTraceRouteSwitch") != m.end() && !m["NetTraceRouteSwitch"].empty()) {
      netTraceRouteSwitch = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteSwitch"]));
    }
    if (m.find("NetTraceRouteTimeout") != m.end() && !m["NetTraceRouteTimeout"].empty()) {
      netTraceRouteTimeout = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteTimeout"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailNet() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody : public Darabonba::Model {
public:
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata> formdata{};
  shared_ptr<string> language{};
  shared_ptr<string> mode{};
  shared_ptr<string> raw{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded> urlencoded{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formdata) {
      res["Formdata"] = formdata ? boost::any(formdata->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (raw) {
      res["Raw"] = boost::any(*raw);
    }
    if (urlencoded) {
      res["Urlencoded"] = urlencoded ? boost::any(urlencoded->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Formdata") != m.end() && !m["Formdata"].empty()) {
      if (typeid(map<string, boost::any>) == m["Formdata"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Formdata"]));
        formdata = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata>(model1);
      }
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Raw") != m.end() && !m["Raw"].empty()) {
      raw = make_shared<string>(boost::any_cast<string>(m["Raw"]));
    }
    if (m.find("Urlencoded") != m.end() && !m["Urlencoded"].empty()) {
      if (typeid(map<string, boost::any>) == m["Urlencoded"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Urlencoded"]));
        urlencoded = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded>(model1);
      }
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent : public Darabonba::Model {
public:
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody> body{};
  shared_ptr<vector<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader>> header{};
  shared_ptr<string> method{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (header) {
      vector<boost::any> temp1;
      for(auto item1:*header){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Header"] = boost::any(temp1);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      if (typeid(map<string, boost::any>) == m["Body"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Body"]));
        body = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody>(model1);
      }
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(vector<boost::any>) == m["Header"].type()) {
        vector<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Header"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        header = make_shared<vector<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader>>(expect1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocol : public Darabonba::Model {
public:
  shared_ptr<long> characterEncoding{};
  shared_ptr<long> customHost{};
  shared_ptr<string> customHostIp{};
  shared_ptr<long> protocolConnectionTimeout{};
  shared_ptr<long> protocolMonitorTimeout{};
  shared_ptr<long> receivedDataSize{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent> requestContent{};
  shared_ptr<string> verifyContent{};
  shared_ptr<long> verifyWay{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocol() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocol(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (characterEncoding) {
      res["CharacterEncoding"] = boost::any(*characterEncoding);
    }
    if (customHost) {
      res["CustomHost"] = boost::any(*customHost);
    }
    if (customHostIp) {
      res["CustomHostIp"] = boost::any(*customHostIp);
    }
    if (protocolConnectionTimeout) {
      res["ProtocolConnectionTimeout"] = boost::any(*protocolConnectionTimeout);
    }
    if (protocolMonitorTimeout) {
      res["ProtocolMonitorTimeout"] = boost::any(*protocolMonitorTimeout);
    }
    if (receivedDataSize) {
      res["ReceivedDataSize"] = boost::any(*receivedDataSize);
    }
    if (requestContent) {
      res["RequestContent"] = requestContent ? boost::any(requestContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (verifyContent) {
      res["VerifyContent"] = boost::any(*verifyContent);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharacterEncoding") != m.end() && !m["CharacterEncoding"].empty()) {
      characterEncoding = make_shared<long>(boost::any_cast<long>(m["CharacterEncoding"]));
    }
    if (m.find("CustomHost") != m.end() && !m["CustomHost"].empty()) {
      customHost = make_shared<long>(boost::any_cast<long>(m["CustomHost"]));
    }
    if (m.find("CustomHostIp") != m.end() && !m["CustomHostIp"].empty()) {
      customHostIp = make_shared<string>(boost::any_cast<string>(m["CustomHostIp"]));
    }
    if (m.find("ProtocolConnectionTimeout") != m.end() && !m["ProtocolConnectionTimeout"].empty()) {
      protocolConnectionTimeout = make_shared<long>(boost::any_cast<long>(m["ProtocolConnectionTimeout"]));
    }
    if (m.find("ProtocolMonitorTimeout") != m.end() && !m["ProtocolMonitorTimeout"].empty()) {
      protocolMonitorTimeout = make_shared<long>(boost::any_cast<long>(m["ProtocolMonitorTimeout"]));
    }
    if (m.find("ReceivedDataSize") != m.end() && !m["ReceivedDataSize"].empty()) {
      receivedDataSize = make_shared<long>(boost::any_cast<long>(m["ReceivedDataSize"]));
    }
    if (m.find("RequestContent") != m.end() && !m["RequestContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestContent"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestContent"]));
        requestContent = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent>(model1);
      }
    }
    if (m.find("VerifyContent") != m.end() && !m["VerifyContent"].empty()) {
      verifyContent = make_shared<string>(boost::any_cast<string>(m["VerifyContent"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocol() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetail : public Darabonba::Model {
public:
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam> commonParam{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailDownload> download{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval> extendInterval{};
  shared_ptr<long> intervalTime{};
  shared_ptr<long> intervalType{};
  shared_ptr<long> ipType{};
  shared_ptr<vector<GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList>> monitorList{};
  shared_ptr<string> monitorListString{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailNav> nav{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailNet> net{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailProtocol> protocol{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskType{};
  shared_ptr<string> url{};

  GetSyntheticTaskDetailResponseBodyTaskDetail() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonParam) {
      res["CommonParam"] = commonParam ? boost::any(commonParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (download) {
      res["Download"] = download ? boost::any(download->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendInterval) {
      res["ExtendInterval"] = extendInterval ? boost::any(extendInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (intervalTime) {
      res["IntervalTime"] = boost::any(*intervalTime);
    }
    if (intervalType) {
      res["IntervalType"] = boost::any(*intervalType);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (monitorList) {
      vector<boost::any> temp1;
      for(auto item1:*monitorList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorList"] = boost::any(temp1);
    }
    if (monitorListString) {
      res["MonitorListString"] = boost::any(*monitorListString);
    }
    if (nav) {
      res["Nav"] = nav ? boost::any(nav->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (net) {
      res["Net"] = net ? boost::any(net->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocol) {
      res["Protocol"] = protocol ? boost::any(protocol->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonParam") != m.end() && !m["CommonParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonParam"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonParam"]));
        commonParam = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam>(model1);
      }
    }
    if (m.find("Download") != m.end() && !m["Download"].empty()) {
      if (typeid(map<string, boost::any>) == m["Download"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailDownload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Download"]));
        download = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailDownload>(model1);
      }
    }
    if (m.find("ExtendInterval") != m.end() && !m["ExtendInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendInterval"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendInterval"]));
        extendInterval = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval>(model1);
      }
    }
    if (m.find("IntervalTime") != m.end() && !m["IntervalTime"].empty()) {
      intervalTime = make_shared<long>(boost::any_cast<long>(m["IntervalTime"]));
    }
    if (m.find("IntervalType") != m.end() && !m["IntervalType"].empty()) {
      intervalType = make_shared<long>(boost::any_cast<long>(m["IntervalType"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("MonitorList") != m.end() && !m["MonitorList"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorList"].type()) {
        vector<GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorList = make_shared<vector<GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList>>(expect1);
      }
    }
    if (m.find("MonitorListString") != m.end() && !m["MonitorListString"].empty()) {
      monitorListString = make_shared<string>(boost::any_cast<string>(m["MonitorListString"]));
    }
    if (m.find("Nav") != m.end() && !m["Nav"].empty()) {
      if (typeid(map<string, boost::any>) == m["Nav"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailNav model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Nav"]));
        nav = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailNav>(model1);
      }
    }
    if (m.find("Net") != m.end() && !m["Net"].empty()) {
      if (typeid(map<string, boost::any>) == m["Net"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailNet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Net"]));
        net = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailNet>(model1);
      }
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      if (typeid(map<string, boost::any>) == m["Protocol"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailProtocol model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Protocol"]));
        protocol = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailProtocol>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetail() = default;
};
class GetSyntheticTaskDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetail> taskDetail{};

  GetSyntheticTaskDetailResponseBody() {}

  explicit GetSyntheticTaskDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskDetail) {
      res["TaskDetail"] = taskDetail ? boost::any(taskDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskDetail") != m.end() && !m["TaskDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskDetail"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskDetail"]));
        taskDetail = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetail>(model1);
      }
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBody() = default;
};
class GetSyntheticTaskDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSyntheticTaskDetailResponseBody> body{};

  GetSyntheticTaskDetailResponse() {}

  explicit GetSyntheticTaskDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSyntheticTaskDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSyntheticTaskDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetSyntheticTaskDetailResponse() = default;
};
class GetSyntheticTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> taskType{};
  shared_ptr<string> url{};

  GetSyntheticTaskListRequest() {}

  explicit GetSyntheticTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetSyntheticTaskListRequest() = default;
};
class GetSyntheticTaskListResponseBodyPageInfoList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> monitorNumber{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskStatus{};
  shared_ptr<long> taskType{};
  shared_ptr<string> taskTypeName{};
  shared_ptr<string> url{};
  shared_ptr<double> usable{};

  GetSyntheticTaskListResponseBodyPageInfoList() {}

  explicit GetSyntheticTaskListResponseBodyPageInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (monitorNumber) {
      res["MonitorNumber"] = boost::any(*monitorNumber);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskTypeName) {
      res["TaskTypeName"] = boost::any(*taskTypeName);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (usable) {
      res["Usable"] = boost::any(*usable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("MonitorNumber") != m.end() && !m["MonitorNumber"].empty()) {
      monitorNumber = make_shared<long>(boost::any_cast<long>(m["MonitorNumber"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("TaskTypeName") != m.end() && !m["TaskTypeName"].empty()) {
      taskTypeName = make_shared<string>(boost::any_cast<string>(m["TaskTypeName"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Usable") != m.end() && !m["Usable"].empty()) {
      usable = make_shared<double>(boost::any_cast<double>(m["Usable"]));
    }
  }


  virtual ~GetSyntheticTaskListResponseBodyPageInfoList() = default;
};
class GetSyntheticTaskListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<string> hasNextPage{};
  shared_ptr<bool> hasPreviousPage{};
  shared_ptr<bool> isFirstPage{};
  shared_ptr<bool> isLastPage{};
  shared_ptr<vector<GetSyntheticTaskListResponseBodyPageInfoList>> list{};
  shared_ptr<string> navigateFirstPage{};
  shared_ptr<string> navigateLastPage{};
  shared_ptr<string> navigatePageNums{};
  shared_ptr<string> nextPage{};
  shared_ptr<string> pages{};
  shared_ptr<string> prepage{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  GetSyntheticTaskListResponseBodyPageInfo() {}

  explicit GetSyntheticTaskListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasNextPage) {
      res["HasNextPage"] = boost::any(*hasNextPage);
    }
    if (hasPreviousPage) {
      res["HasPreviousPage"] = boost::any(*hasPreviousPage);
    }
    if (isFirstPage) {
      res["IsFirstPage"] = boost::any(*isFirstPage);
    }
    if (isLastPage) {
      res["IsLastPage"] = boost::any(*isLastPage);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (navigateFirstPage) {
      res["NavigateFirstPage"] = boost::any(*navigateFirstPage);
    }
    if (navigateLastPage) {
      res["NavigateLastPage"] = boost::any(*navigateLastPage);
    }
    if (navigatePageNums) {
      res["NavigatePageNums"] = boost::any(*navigatePageNums);
    }
    if (nextPage) {
      res["NextPage"] = boost::any(*nextPage);
    }
    if (pages) {
      res["Pages"] = boost::any(*pages);
    }
    if (prepage) {
      res["Prepage"] = boost::any(*prepage);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasNextPage") != m.end() && !m["HasNextPage"].empty()) {
      hasNextPage = make_shared<string>(boost::any_cast<string>(m["HasNextPage"]));
    }
    if (m.find("HasPreviousPage") != m.end() && !m["HasPreviousPage"].empty()) {
      hasPreviousPage = make_shared<bool>(boost::any_cast<bool>(m["HasPreviousPage"]));
    }
    if (m.find("IsFirstPage") != m.end() && !m["IsFirstPage"].empty()) {
      isFirstPage = make_shared<bool>(boost::any_cast<bool>(m["IsFirstPage"]));
    }
    if (m.find("IsLastPage") != m.end() && !m["IsLastPage"].empty()) {
      isLastPage = make_shared<bool>(boost::any_cast<bool>(m["IsLastPage"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetSyntheticTaskListResponseBodyPageInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticTaskListResponseBodyPageInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetSyntheticTaskListResponseBodyPageInfoList>>(expect1);
      }
    }
    if (m.find("NavigateFirstPage") != m.end() && !m["NavigateFirstPage"].empty()) {
      navigateFirstPage = make_shared<string>(boost::any_cast<string>(m["NavigateFirstPage"]));
    }
    if (m.find("NavigateLastPage") != m.end() && !m["NavigateLastPage"].empty()) {
      navigateLastPage = make_shared<string>(boost::any_cast<string>(m["NavigateLastPage"]));
    }
    if (m.find("NavigatePageNums") != m.end() && !m["NavigatePageNums"].empty()) {
      navigatePageNums = make_shared<string>(boost::any_cast<string>(m["NavigatePageNums"]));
    }
    if (m.find("NextPage") != m.end() && !m["NextPage"].empty()) {
      nextPage = make_shared<string>(boost::any_cast<string>(m["NextPage"]));
    }
    if (m.find("Pages") != m.end() && !m["Pages"].empty()) {
      pages = make_shared<string>(boost::any_cast<string>(m["Pages"]));
    }
    if (m.find("Prepage") != m.end() && !m["Prepage"].empty()) {
      prepage = make_shared<string>(boost::any_cast<string>(m["Prepage"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSyntheticTaskListResponseBodyPageInfo() = default;
};
class GetSyntheticTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetSyntheticTaskListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  GetSyntheticTaskListResponseBody() {}

  explicit GetSyntheticTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        GetSyntheticTaskListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<GetSyntheticTaskListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSyntheticTaskListResponseBody() = default;
};
class GetSyntheticTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSyntheticTaskListResponseBody> body{};

  GetSyntheticTaskListResponse() {}

  explicit GetSyntheticTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSyntheticTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSyntheticTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~GetSyntheticTaskListResponse() = default;
};
class GetSyntheticTaskMonitorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  GetSyntheticTaskMonitorsRequest() {}

  explicit GetSyntheticTaskMonitorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetSyntheticTaskMonitorsRequest() = default;
};
class GetSyntheticTaskMonitorsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> busy{};
  shared_ptr<string> city{};
  shared_ptr<long> cityCode{};
  shared_ptr<long> clientType{};
  shared_ptr<string> district{};
  shared_ptr<long> netServiceId{};
  shared_ptr<string> netServiceName{};

  GetSyntheticTaskMonitorsResponseBodyData() {}

  explicit GetSyntheticTaskMonitorsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (busy) {
      res["Busy"] = boost::any(*busy);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (district) {
      res["District"] = boost::any(*district);
    }
    if (netServiceId) {
      res["NetServiceId"] = boost::any(*netServiceId);
    }
    if (netServiceName) {
      res["NetServiceName"] = boost::any(*netServiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Busy") != m.end() && !m["Busy"].empty()) {
      busy = make_shared<long>(boost::any_cast<long>(m["Busy"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<long>(boost::any_cast<long>(m["ClientType"]));
    }
    if (m.find("District") != m.end() && !m["District"].empty()) {
      district = make_shared<string>(boost::any_cast<string>(m["District"]));
    }
    if (m.find("NetServiceId") != m.end() && !m["NetServiceId"].empty()) {
      netServiceId = make_shared<long>(boost::any_cast<long>(m["NetServiceId"]));
    }
    if (m.find("NetServiceName") != m.end() && !m["NetServiceName"].empty()) {
      netServiceName = make_shared<string>(boost::any_cast<string>(m["NetServiceName"]));
    }
  }


  virtual ~GetSyntheticTaskMonitorsResponseBodyData() = default;
};
class GetSyntheticTaskMonitorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetSyntheticTaskMonitorsResponseBodyData>> data{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  GetSyntheticTaskMonitorsResponseBody() {}

  explicit GetSyntheticTaskMonitorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetSyntheticTaskMonitorsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticTaskMonitorsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetSyntheticTaskMonitorsResponseBodyData>>(expect1);
      }
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSyntheticTaskMonitorsResponseBody() = default;
};
class GetSyntheticTaskMonitorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSyntheticTaskMonitorsResponseBody> body{};

  GetSyntheticTaskMonitorsResponse() {}

  explicit GetSyntheticTaskMonitorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSyntheticTaskMonitorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSyntheticTaskMonitorsResponseBody>(model1);
      }
    }
  }


  virtual ~GetSyntheticTaskMonitorsResponse() = default;
};
class GetTimingSyntheticTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  GetTimingSyntheticTaskRequest() {}

  explicit GetTimingSyntheticTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetTimingSyntheticTaskRequest() = default;
};
class GetTimingSyntheticTaskResponseBodyDataAvailableAssertions : public Darabonba::Model {
public:
  shared_ptr<string> expect{};
  shared_ptr<string> operator_{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  GetTimingSyntheticTaskResponseBodyDataAvailableAssertions() {}

  explicit GetTimingSyntheticTaskResponseBodyDataAvailableAssertions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expect) {
      res["Expect"] = boost::any(*expect);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expect") != m.end() && !m["Expect"].empty()) {
      expect = make_shared<string>(boost::any_cast<string>(m["Expect"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataAvailableAssertions() = default;
};
class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ipType{};
  shared_ptr<vector<string>> ips{};

  GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts() {}

  explicit GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts() = default;
};
class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost : public Darabonba::Model {
public:
  shared_ptr<vector<GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts>> hosts{};
  shared_ptr<long> selectType{};

  GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost() {}

  explicit GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (selectType) {
      res["SelectType"] = boost::any(*selectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts>>(expect1);
      }
    }
    if (m.find("SelectType") != m.end() && !m["SelectType"].empty()) {
      selectType = make_shared<long>(boost::any_cast<long>(m["SelectType"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost() = default;
};
class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting : public Darabonba::Model {
public:
  shared_ptr<string> prometheusClusterId{};
  shared_ptr<string> prometheusClusterRegion{};
  shared_ptr<map<string, string>> prometheusLabels{};

  GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting() {}

  explicit GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prometheusClusterId) {
      res["PrometheusClusterId"] = boost::any(*prometheusClusterId);
    }
    if (prometheusClusterRegion) {
      res["PrometheusClusterRegion"] = boost::any(*prometheusClusterRegion);
    }
    if (prometheusLabels) {
      res["PrometheusLabels"] = boost::any(*prometheusLabels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrometheusClusterId") != m.end() && !m["PrometheusClusterId"].empty()) {
      prometheusClusterId = make_shared<string>(boost::any_cast<string>(m["PrometheusClusterId"]));
    }
    if (m.find("PrometheusClusterRegion") != m.end() && !m["PrometheusClusterRegion"].empty()) {
      prometheusClusterRegion = make_shared<string>(boost::any_cast<string>(m["PrometheusClusterRegion"]));
    }
    if (m.find("PrometheusLabels") != m.end() && !m["PrometheusLabels"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["PrometheusLabels"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      prometheusLabels = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting() = default;
};
class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> secureGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting() {}

  explicit GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (secureGroupId) {
      res["SecureGroupId"] = boost::any(*secureGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecureGroupId") != m.end() && !m["SecureGroupId"].empty()) {
      secureGroupId = make_shared<string>(boost::any_cast<string>(m["SecureGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting() = default;
};
class GetTimingSyntheticTaskResponseBodyDataCommonSetting : public Darabonba::Model {
public:
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost> customHost{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting> customPrometheusSetting{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting> customVPCSetting{};
  shared_ptr<long> ipType{};
  shared_ptr<bool> isOpenTrace{};
  shared_ptr<long> monitorSamples{};
  shared_ptr<long> traceClientType{};
  shared_ptr<string> xtraceRegion{};

  GetTimingSyntheticTaskResponseBodyDataCommonSetting() {}

  explicit GetTimingSyntheticTaskResponseBodyDataCommonSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customHost) {
      res["CustomHost"] = customHost ? boost::any(customHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customPrometheusSetting) {
      res["CustomPrometheusSetting"] = customPrometheusSetting ? boost::any(customPrometheusSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customVPCSetting) {
      res["CustomVPCSetting"] = customVPCSetting ? boost::any(customVPCSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (isOpenTrace) {
      res["IsOpenTrace"] = boost::any(*isOpenTrace);
    }
    if (monitorSamples) {
      res["MonitorSamples"] = boost::any(*monitorSamples);
    }
    if (traceClientType) {
      res["TraceClientType"] = boost::any(*traceClientType);
    }
    if (xtraceRegion) {
      res["XtraceRegion"] = boost::any(*xtraceRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomHost") != m.end() && !m["CustomHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomHost"].type()) {
        GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomHost"]));
        customHost = make_shared<GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost>(model1);
      }
    }
    if (m.find("CustomPrometheusSetting") != m.end() && !m["CustomPrometheusSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomPrometheusSetting"].type()) {
        GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomPrometheusSetting"]));
        customPrometheusSetting = make_shared<GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting>(model1);
      }
    }
    if (m.find("CustomVPCSetting") != m.end() && !m["CustomVPCSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomVPCSetting"].type()) {
        GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomVPCSetting"]));
        customVPCSetting = make_shared<GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting>(model1);
      }
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("IsOpenTrace") != m.end() && !m["IsOpenTrace"].empty()) {
      isOpenTrace = make_shared<bool>(boost::any_cast<bool>(m["IsOpenTrace"]));
    }
    if (m.find("MonitorSamples") != m.end() && !m["MonitorSamples"].empty()) {
      monitorSamples = make_shared<long>(boost::any_cast<long>(m["MonitorSamples"]));
    }
    if (m.find("TraceClientType") != m.end() && !m["TraceClientType"].empty()) {
      traceClientType = make_shared<long>(boost::any_cast<long>(m["TraceClientType"]));
    }
    if (m.find("XtraceRegion") != m.end() && !m["XtraceRegion"].empty()) {
      xtraceRegion = make_shared<string>(boost::any_cast<string>(m["XtraceRegion"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataCommonSetting() = default;
};
class GetTimingSyntheticTaskResponseBodyDataCustomPeriod : public Darabonba::Model {
public:
  shared_ptr<long> endHour{};
  shared_ptr<long> startHour{};

  GetTimingSyntheticTaskResponseBodyDataCustomPeriod() {}

  explicit GetTimingSyntheticTaskResponseBodyDataCustomPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endHour) {
      res["EndHour"] = boost::any(*endHour);
    }
    if (startHour) {
      res["StartHour"] = boost::any(*startHour);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndHour") != m.end() && !m["EndHour"].empty()) {
      endHour = make_shared<long>(boost::any_cast<long>(m["EndHour"]));
    }
    if (m.find("StartHour") != m.end() && !m["StartHour"].empty()) {
      startHour = make_shared<long>(boost::any_cast<long>(m["StartHour"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataCustomPeriod() = default;
};
class GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> type{};

  GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody() {}

  explicit GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody() = default;
};
class GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP : public Darabonba::Model {
public:
  shared_ptr<bool> checkCert{};
  shared_ptr<long> connectTimeout{};
  shared_ptr<string> method{};
  shared_ptr<long> protocolAlpnProtocol{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody> requestBody{};
  shared_ptr<map<string, string>> requestHeaders{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};

  GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP() {}

  explicit GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkCert) {
      res["CheckCert"] = boost::any(*checkCert);
    }
    if (connectTimeout) {
      res["ConnectTimeout"] = boost::any(*connectTimeout);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (protocolAlpnProtocol) {
      res["ProtocolAlpnProtocol"] = boost::any(*protocolAlpnProtocol);
    }
    if (requestBody) {
      res["RequestBody"] = requestBody ? boost::any(requestBody->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestHeaders) {
      res["RequestHeaders"] = boost::any(*requestHeaders);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckCert") != m.end() && !m["CheckCert"].empty()) {
      checkCert = make_shared<bool>(boost::any_cast<bool>(m["CheckCert"]));
    }
    if (m.find("ConnectTimeout") != m.end() && !m["ConnectTimeout"].empty()) {
      connectTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectTimeout"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("ProtocolAlpnProtocol") != m.end() && !m["ProtocolAlpnProtocol"].empty()) {
      protocolAlpnProtocol = make_shared<long>(boost::any_cast<long>(m["ProtocolAlpnProtocol"]));
    }
    if (m.find("RequestBody") != m.end() && !m["RequestBody"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestBody"].type()) {
        GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestBody"]));
        requestBody = make_shared<GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody>(model1);
      }
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["RequestHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      requestHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP() = default;
};
class GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload : public Darabonba::Model {
public:
  shared_ptr<long> connectionTimeout{};
  shared_ptr<map<string, string>> customHeaderContent{};
  shared_ptr<long> downloadKernel{};
  shared_ptr<long> ignoreCertificateAuthError{};
  shared_ptr<long> ignoreCertificateCanceledError{};
  shared_ptr<long> ignoreCertificateOutOfDateError{};
  shared_ptr<long> ignoreCertificateStatusError{};
  shared_ptr<long> ignoreCertificateUntrustworthyError{};
  shared_ptr<long> ignoreCertificateUsingError{};
  shared_ptr<long> ignoreInvalidHostError{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<long> quickProtocol{};
  shared_ptr<long> redirection{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> transmissionSize{};
  shared_ptr<string> validateKeywords{};
  shared_ptr<long> verifyWay{};
  shared_ptr<string> whiteList{};

  GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload() {}

  explicit GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionTimeout) {
      res["ConnectionTimeout"] = boost::any(*connectionTimeout);
    }
    if (customHeaderContent) {
      res["CustomHeaderContent"] = boost::any(*customHeaderContent);
    }
    if (downloadKernel) {
      res["DownloadKernel"] = boost::any(*downloadKernel);
    }
    if (ignoreCertificateAuthError) {
      res["IgnoreCertificateAuthError"] = boost::any(*ignoreCertificateAuthError);
    }
    if (ignoreCertificateCanceledError) {
      res["IgnoreCertificateCanceledError"] = boost::any(*ignoreCertificateCanceledError);
    }
    if (ignoreCertificateOutOfDateError) {
      res["IgnoreCertificateOutOfDateError"] = boost::any(*ignoreCertificateOutOfDateError);
    }
    if (ignoreCertificateStatusError) {
      res["IgnoreCertificateStatusError"] = boost::any(*ignoreCertificateStatusError);
    }
    if (ignoreCertificateUntrustworthyError) {
      res["IgnoreCertificateUntrustworthyError"] = boost::any(*ignoreCertificateUntrustworthyError);
    }
    if (ignoreCertificateUsingError) {
      res["IgnoreCertificateUsingError"] = boost::any(*ignoreCertificateUsingError);
    }
    if (ignoreInvalidHostError) {
      res["IgnoreInvalidHostError"] = boost::any(*ignoreInvalidHostError);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (quickProtocol) {
      res["QuickProtocol"] = boost::any(*quickProtocol);
    }
    if (redirection) {
      res["Redirection"] = boost::any(*redirection);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (transmissionSize) {
      res["TransmissionSize"] = boost::any(*transmissionSize);
    }
    if (validateKeywords) {
      res["ValidateKeywords"] = boost::any(*validateKeywords);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionTimeout") != m.end() && !m["ConnectionTimeout"].empty()) {
      connectionTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectionTimeout"]));
    }
    if (m.find("CustomHeaderContent") != m.end() && !m["CustomHeaderContent"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["CustomHeaderContent"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customHeaderContent = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("DownloadKernel") != m.end() && !m["DownloadKernel"].empty()) {
      downloadKernel = make_shared<long>(boost::any_cast<long>(m["DownloadKernel"]));
    }
    if (m.find("IgnoreCertificateAuthError") != m.end() && !m["IgnoreCertificateAuthError"].empty()) {
      ignoreCertificateAuthError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateAuthError"]));
    }
    if (m.find("IgnoreCertificateCanceledError") != m.end() && !m["IgnoreCertificateCanceledError"].empty()) {
      ignoreCertificateCanceledError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateCanceledError"]));
    }
    if (m.find("IgnoreCertificateOutOfDateError") != m.end() && !m["IgnoreCertificateOutOfDateError"].empty()) {
      ignoreCertificateOutOfDateError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateOutOfDateError"]));
    }
    if (m.find("IgnoreCertificateStatusError") != m.end() && !m["IgnoreCertificateStatusError"].empty()) {
      ignoreCertificateStatusError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateStatusError"]));
    }
    if (m.find("IgnoreCertificateUntrustworthyError") != m.end() && !m["IgnoreCertificateUntrustworthyError"].empty()) {
      ignoreCertificateUntrustworthyError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateUntrustworthyError"]));
    }
    if (m.find("IgnoreCertificateUsingError") != m.end() && !m["IgnoreCertificateUsingError"].empty()) {
      ignoreCertificateUsingError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateUsingError"]));
    }
    if (m.find("IgnoreInvalidHostError") != m.end() && !m["IgnoreInvalidHostError"].empty()) {
      ignoreInvalidHostError = make_shared<long>(boost::any_cast<long>(m["IgnoreInvalidHostError"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("QuickProtocol") != m.end() && !m["QuickProtocol"].empty()) {
      quickProtocol = make_shared<long>(boost::any_cast<long>(m["QuickProtocol"]));
    }
    if (m.find("Redirection") != m.end() && !m["Redirection"].empty()) {
      redirection = make_shared<long>(boost::any_cast<long>(m["Redirection"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("TransmissionSize") != m.end() && !m["TransmissionSize"].empty()) {
      transmissionSize = make_shared<long>(boost::any_cast<long>(m["TransmissionSize"]));
    }
    if (m.find("ValidateKeywords") != m.end() && !m["ValidateKeywords"].empty()) {
      validateKeywords = make_shared<string>(boost::any_cast<string>(m["ValidateKeywords"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload() = default;
};
class GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS : public Darabonba::Model {
public:
  shared_ptr<long> dnsServerIpType{};
  shared_ptr<string> nsServer{};
  shared_ptr<long> queryMethod{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};

  GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS() {}

  explicit GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsServerIpType) {
      res["DnsServerIpType"] = boost::any(*dnsServerIpType);
    }
    if (nsServer) {
      res["NsServer"] = boost::any(*nsServer);
    }
    if (queryMethod) {
      res["QueryMethod"] = boost::any(*queryMethod);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsServerIpType") != m.end() && !m["DnsServerIpType"].empty()) {
      dnsServerIpType = make_shared<long>(boost::any_cast<long>(m["DnsServerIpType"]));
    }
    if (m.find("NsServer") != m.end() && !m["NsServer"].empty()) {
      nsServer = make_shared<string>(boost::any_cast<string>(m["NsServer"]));
    }
    if (m.find("QueryMethod") != m.end() && !m["QueryMethod"].empty()) {
      queryMethod = make_shared<long>(boost::any_cast<long>(m["QueryMethod"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS() = default;
};
class GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<long> packageNum{};
  shared_ptr<long> packageSize{};
  shared_ptr<bool> splitPackage{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};
  shared_ptr<bool> tracertEnable{};
  shared_ptr<long> tracertNumMax{};
  shared_ptr<long> tracertTimeout{};

  GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP() {}

  explicit GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (packageNum) {
      res["PackageNum"] = boost::any(*packageNum);
    }
    if (packageSize) {
      res["PackageSize"] = boost::any(*packageSize);
    }
    if (splitPackage) {
      res["SplitPackage"] = boost::any(*splitPackage);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (tracertEnable) {
      res["TracertEnable"] = boost::any(*tracertEnable);
    }
    if (tracertNumMax) {
      res["TracertNumMax"] = boost::any(*tracertNumMax);
    }
    if (tracertTimeout) {
      res["TracertTimeout"] = boost::any(*tracertTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("PackageNum") != m.end() && !m["PackageNum"].empty()) {
      packageNum = make_shared<long>(boost::any_cast<long>(m["PackageNum"]));
    }
    if (m.find("PackageSize") != m.end() && !m["PackageSize"].empty()) {
      packageSize = make_shared<long>(boost::any_cast<long>(m["PackageSize"]));
    }
    if (m.find("SplitPackage") != m.end() && !m["SplitPackage"].empty()) {
      splitPackage = make_shared<bool>(boost::any_cast<bool>(m["SplitPackage"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TracertEnable") != m.end() && !m["TracertEnable"].empty()) {
      tracertEnable = make_shared<bool>(boost::any_cast<bool>(m["TracertEnable"]));
    }
    if (m.find("TracertNumMax") != m.end() && !m["TracertNumMax"].empty()) {
      tracertNumMax = make_shared<long>(boost::any_cast<long>(m["TracertNumMax"]));
    }
    if (m.find("TracertTimeout") != m.end() && !m["TracertTimeout"].empty()) {
      tracertTimeout = make_shared<long>(boost::any_cast<long>(m["TracertTimeout"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP() = default;
};
class GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP : public Darabonba::Model {
public:
  shared_ptr<long> connectTimes{};
  shared_ptr<long> interval{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};
  shared_ptr<bool> tracertEnable{};
  shared_ptr<long> tracertNumMax{};
  shared_ptr<long> tracertTimeout{};

  GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP() {}

  explicit GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectTimes) {
      res["ConnectTimes"] = boost::any(*connectTimes);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (tracertEnable) {
      res["TracertEnable"] = boost::any(*tracertEnable);
    }
    if (tracertNumMax) {
      res["TracertNumMax"] = boost::any(*tracertNumMax);
    }
    if (tracertTimeout) {
      res["TracertTimeout"] = boost::any(*tracertTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectTimes") != m.end() && !m["ConnectTimes"].empty()) {
      connectTimes = make_shared<long>(boost::any_cast<long>(m["ConnectTimes"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TracertEnable") != m.end() && !m["TracertEnable"].empty()) {
      tracertEnable = make_shared<bool>(boost::any_cast<bool>(m["TracertEnable"]));
    }
    if (m.find("TracertNumMax") != m.end() && !m["TracertNumMax"].empty()) {
      tracertNumMax = make_shared<long>(boost::any_cast<long>(m["TracertNumMax"]));
    }
    if (m.find("TracertTimeout") != m.end() && !m["TracertTimeout"].empty()) {
      tracertTimeout = make_shared<long>(boost::any_cast<long>(m["TracertTimeout"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP() = default;
};
class GetTimingSyntheticTaskResponseBodyDataMonitorConfStream : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> customHeaderContent{};
  shared_ptr<long> playerType{};
  shared_ptr<long> streamAddressType{};
  shared_ptr<long> streamMonitorTimeout{};
  shared_ptr<long> streamType{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> whiteList{};

  GetTimingSyntheticTaskResponseBodyDataMonitorConfStream() {}

  explicit GetTimingSyntheticTaskResponseBodyDataMonitorConfStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customHeaderContent) {
      res["CustomHeaderContent"] = boost::any(*customHeaderContent);
    }
    if (playerType) {
      res["PlayerType"] = boost::any(*playerType);
    }
    if (streamAddressType) {
      res["StreamAddressType"] = boost::any(*streamAddressType);
    }
    if (streamMonitorTimeout) {
      res["StreamMonitorTimeout"] = boost::any(*streamMonitorTimeout);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomHeaderContent") != m.end() && !m["CustomHeaderContent"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["CustomHeaderContent"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customHeaderContent = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("PlayerType") != m.end() && !m["PlayerType"].empty()) {
      playerType = make_shared<long>(boost::any_cast<long>(m["PlayerType"]));
    }
    if (m.find("StreamAddressType") != m.end() && !m["StreamAddressType"].empty()) {
      streamAddressType = make_shared<long>(boost::any_cast<long>(m["StreamAddressType"]));
    }
    if (m.find("StreamMonitorTimeout") != m.end() && !m["StreamMonitorTimeout"].empty()) {
      streamMonitorTimeout = make_shared<long>(boost::any_cast<long>(m["StreamMonitorTimeout"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<long>(boost::any_cast<long>(m["StreamType"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataMonitorConfStream() = default;
};
class GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite : public Darabonba::Model {
public:
  shared_ptr<long> automaticScrolling{};
  shared_ptr<long> customHeader{};
  shared_ptr<map<string, string>> customHeaderContent{};
  shared_ptr<string> DNSHijackWhitelist{};
  shared_ptr<long> disableCache{};
  shared_ptr<long> disableCompression{};
  shared_ptr<string> elementBlacklist{};
  shared_ptr<long> filterInvalidIP{};
  shared_ptr<long> flowHijackJumpTimes{};
  shared_ptr<string> flowHijackLogo{};
  shared_ptr<long> ignoreCertificateError{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<string> pageTamper{};
  shared_ptr<long> redirection{};
  shared_ptr<long> slowElementThreshold{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> verifyStringBlacklist{};
  shared_ptr<string> verifyStringWhitelist{};
  shared_ptr<long> waitCompletionTime{};

  GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite() {}

  explicit GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (automaticScrolling) {
      res["AutomaticScrolling"] = boost::any(*automaticScrolling);
    }
    if (customHeader) {
      res["CustomHeader"] = boost::any(*customHeader);
    }
    if (customHeaderContent) {
      res["CustomHeaderContent"] = boost::any(*customHeaderContent);
    }
    if (DNSHijackWhitelist) {
      res["DNSHijackWhitelist"] = boost::any(*DNSHijackWhitelist);
    }
    if (disableCache) {
      res["DisableCache"] = boost::any(*disableCache);
    }
    if (disableCompression) {
      res["DisableCompression"] = boost::any(*disableCompression);
    }
    if (elementBlacklist) {
      res["ElementBlacklist"] = boost::any(*elementBlacklist);
    }
    if (filterInvalidIP) {
      res["FilterInvalidIP"] = boost::any(*filterInvalidIP);
    }
    if (flowHijackJumpTimes) {
      res["FlowHijackJumpTimes"] = boost::any(*flowHijackJumpTimes);
    }
    if (flowHijackLogo) {
      res["FlowHijackLogo"] = boost::any(*flowHijackLogo);
    }
    if (ignoreCertificateError) {
      res["IgnoreCertificateError"] = boost::any(*ignoreCertificateError);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (pageTamper) {
      res["PageTamper"] = boost::any(*pageTamper);
    }
    if (redirection) {
      res["Redirection"] = boost::any(*redirection);
    }
    if (slowElementThreshold) {
      res["SlowElementThreshold"] = boost::any(*slowElementThreshold);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (verifyStringBlacklist) {
      res["VerifyStringBlacklist"] = boost::any(*verifyStringBlacklist);
    }
    if (verifyStringWhitelist) {
      res["VerifyStringWhitelist"] = boost::any(*verifyStringWhitelist);
    }
    if (waitCompletionTime) {
      res["WaitCompletionTime"] = boost::any(*waitCompletionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutomaticScrolling") != m.end() && !m["AutomaticScrolling"].empty()) {
      automaticScrolling = make_shared<long>(boost::any_cast<long>(m["AutomaticScrolling"]));
    }
    if (m.find("CustomHeader") != m.end() && !m["CustomHeader"].empty()) {
      customHeader = make_shared<long>(boost::any_cast<long>(m["CustomHeader"]));
    }
    if (m.find("CustomHeaderContent") != m.end() && !m["CustomHeaderContent"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["CustomHeaderContent"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customHeaderContent = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("DNSHijackWhitelist") != m.end() && !m["DNSHijackWhitelist"].empty()) {
      DNSHijackWhitelist = make_shared<string>(boost::any_cast<string>(m["DNSHijackWhitelist"]));
    }
    if (m.find("DisableCache") != m.end() && !m["DisableCache"].empty()) {
      disableCache = make_shared<long>(boost::any_cast<long>(m["DisableCache"]));
    }
    if (m.find("DisableCompression") != m.end() && !m["DisableCompression"].empty()) {
      disableCompression = make_shared<long>(boost::any_cast<long>(m["DisableCompression"]));
    }
    if (m.find("ElementBlacklist") != m.end() && !m["ElementBlacklist"].empty()) {
      elementBlacklist = make_shared<string>(boost::any_cast<string>(m["ElementBlacklist"]));
    }
    if (m.find("FilterInvalidIP") != m.end() && !m["FilterInvalidIP"].empty()) {
      filterInvalidIP = make_shared<long>(boost::any_cast<long>(m["FilterInvalidIP"]));
    }
    if (m.find("FlowHijackJumpTimes") != m.end() && !m["FlowHijackJumpTimes"].empty()) {
      flowHijackJumpTimes = make_shared<long>(boost::any_cast<long>(m["FlowHijackJumpTimes"]));
    }
    if (m.find("FlowHijackLogo") != m.end() && !m["FlowHijackLogo"].empty()) {
      flowHijackLogo = make_shared<string>(boost::any_cast<string>(m["FlowHijackLogo"]));
    }
    if (m.find("IgnoreCertificateError") != m.end() && !m["IgnoreCertificateError"].empty()) {
      ignoreCertificateError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateError"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("PageTamper") != m.end() && !m["PageTamper"].empty()) {
      pageTamper = make_shared<string>(boost::any_cast<string>(m["PageTamper"]));
    }
    if (m.find("Redirection") != m.end() && !m["Redirection"].empty()) {
      redirection = make_shared<long>(boost::any_cast<long>(m["Redirection"]));
    }
    if (m.find("SlowElementThreshold") != m.end() && !m["SlowElementThreshold"].empty()) {
      slowElementThreshold = make_shared<long>(boost::any_cast<long>(m["SlowElementThreshold"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("VerifyStringBlacklist") != m.end() && !m["VerifyStringBlacklist"].empty()) {
      verifyStringBlacklist = make_shared<string>(boost::any_cast<string>(m["VerifyStringBlacklist"]));
    }
    if (m.find("VerifyStringWhitelist") != m.end() && !m["VerifyStringWhitelist"].empty()) {
      verifyStringWhitelist = make_shared<string>(boost::any_cast<string>(m["VerifyStringWhitelist"]));
    }
    if (m.find("WaitCompletionTime") != m.end() && !m["WaitCompletionTime"].empty()) {
      waitCompletionTime = make_shared<long>(boost::any_cast<long>(m["WaitCompletionTime"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite() = default;
};
class GetTimingSyntheticTaskResponseBodyDataMonitorConf : public Darabonba::Model {
public:
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP> apiHTTP{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload> fileDownload{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS> netDNS{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP> netICMP{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP> netTCP{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataMonitorConfStream> stream{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite> website{};

  GetTimingSyntheticTaskResponseBodyDataMonitorConf() {}

  explicit GetTimingSyntheticTaskResponseBodyDataMonitorConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHTTP) {
      res["ApiHTTP"] = apiHTTP ? boost::any(apiHTTP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileDownload) {
      res["FileDownload"] = fileDownload ? boost::any(fileDownload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (netDNS) {
      res["NetDNS"] = netDNS ? boost::any(netDNS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (netICMP) {
      res["NetICMP"] = netICMP ? boost::any(netICMP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (netTCP) {
      res["NetTCP"] = netTCP ? boost::any(netTCP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stream) {
      res["Stream"] = stream ? boost::any(stream->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (website) {
      res["Website"] = website ? boost::any(website->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHTTP") != m.end() && !m["ApiHTTP"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiHTTP"].type()) {
        GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiHTTP"]));
        apiHTTP = make_shared<GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP>(model1);
      }
    }
    if (m.find("FileDownload") != m.end() && !m["FileDownload"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileDownload"].type()) {
        GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileDownload"]));
        fileDownload = make_shared<GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload>(model1);
      }
    }
    if (m.find("NetDNS") != m.end() && !m["NetDNS"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetDNS"].type()) {
        GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetDNS"]));
        netDNS = make_shared<GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS>(model1);
      }
    }
    if (m.find("NetICMP") != m.end() && !m["NetICMP"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetICMP"].type()) {
        GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetICMP"]));
        netICMP = make_shared<GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP>(model1);
      }
    }
    if (m.find("NetTCP") != m.end() && !m["NetTCP"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetTCP"].type()) {
        GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetTCP"]));
        netTCP = make_shared<GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP>(model1);
      }
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      if (typeid(map<string, boost::any>) == m["Stream"].type()) {
        GetTimingSyntheticTaskResponseBodyDataMonitorConfStream model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Stream"]));
        stream = make_shared<GetTimingSyntheticTaskResponseBodyDataMonitorConfStream>(model1);
      }
    }
    if (m.find("Website") != m.end() && !m["Website"].empty()) {
      if (typeid(map<string, boost::any>) == m["Website"].type()) {
        GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Website"]));
        website = make_shared<GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite>(model1);
      }
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataMonitorConf() = default;
};
class GetTimingSyntheticTaskResponseBodyDataMonitors : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<long> clientType{};
  shared_ptr<string> operatorCode{};

  GetTimingSyntheticTaskResponseBodyDataMonitors() {}

  explicit GetTimingSyntheticTaskResponseBodyDataMonitors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (operatorCode) {
      res["OperatorCode"] = boost::any(*operatorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<long>(boost::any_cast<long>(m["ClientType"]));
    }
    if (m.find("OperatorCode") != m.end() && !m["OperatorCode"].empty()) {
      operatorCode = make_shared<string>(boost::any_cast<string>(m["OperatorCode"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataMonitors() = default;
};
class GetTimingSyntheticTaskResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTimingSyntheticTaskResponseBodyDataTags() {}

  explicit GetTimingSyntheticTaskResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyDataTags() = default;
};
class GetTimingSyntheticTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetTimingSyntheticTaskResponseBodyDataAvailableAssertions>> availableAssertions{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataCommonSetting> commonSetting{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataCustomPeriod> customPeriod{};
  shared_ptr<string> frequency{};
  shared_ptr<long> monitorCategory{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyDataMonitorConf> monitorConf{};
  shared_ptr<vector<GetTimingSyntheticTaskResponseBodyDataMonitors>> monitors{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetTimingSyntheticTaskResponseBodyDataTags>> tags{};
  shared_ptr<string> taskId{};
  shared_ptr<long> taskType{};

  GetTimingSyntheticTaskResponseBodyData() {}

  explicit GetTimingSyntheticTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableAssertions) {
      vector<boost::any> temp1;
      for(auto item1:*availableAssertions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableAssertions"] = boost::any(temp1);
    }
    if (commonSetting) {
      res["CommonSetting"] = commonSetting ? boost::any(commonSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customPeriod) {
      res["CustomPeriod"] = customPeriod ? boost::any(customPeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (monitorCategory) {
      res["MonitorCategory"] = boost::any(*monitorCategory);
    }
    if (monitorConf) {
      res["MonitorConf"] = monitorConf ? boost::any(monitorConf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (monitors) {
      vector<boost::any> temp1;
      for(auto item1:*monitors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Monitors"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableAssertions") != m.end() && !m["AvailableAssertions"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableAssertions"].type()) {
        vector<GetTimingSyntheticTaskResponseBodyDataAvailableAssertions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableAssertions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTimingSyntheticTaskResponseBodyDataAvailableAssertions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableAssertions = make_shared<vector<GetTimingSyntheticTaskResponseBodyDataAvailableAssertions>>(expect1);
      }
    }
    if (m.find("CommonSetting") != m.end() && !m["CommonSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonSetting"].type()) {
        GetTimingSyntheticTaskResponseBodyDataCommonSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonSetting"]));
        commonSetting = make_shared<GetTimingSyntheticTaskResponseBodyDataCommonSetting>(model1);
      }
    }
    if (m.find("CustomPeriod") != m.end() && !m["CustomPeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomPeriod"].type()) {
        GetTimingSyntheticTaskResponseBodyDataCustomPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomPeriod"]));
        customPeriod = make_shared<GetTimingSyntheticTaskResponseBodyDataCustomPeriod>(model1);
      }
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("MonitorCategory") != m.end() && !m["MonitorCategory"].empty()) {
      monitorCategory = make_shared<long>(boost::any_cast<long>(m["MonitorCategory"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorConf"].type()) {
        GetTimingSyntheticTaskResponseBodyDataMonitorConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorConf"]));
        monitorConf = make_shared<GetTimingSyntheticTaskResponseBodyDataMonitorConf>(model1);
      }
    }
    if (m.find("Monitors") != m.end() && !m["Monitors"].empty()) {
      if (typeid(vector<boost::any>) == m["Monitors"].type()) {
        vector<GetTimingSyntheticTaskResponseBodyDataMonitors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Monitors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTimingSyntheticTaskResponseBodyDataMonitors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitors = make_shared<vector<GetTimingSyntheticTaskResponseBodyDataMonitors>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetTimingSyntheticTaskResponseBodyDataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTimingSyntheticTaskResponseBodyDataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetTimingSyntheticTaskResponseBodyDataTags>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBodyData() = default;
};
class GetTimingSyntheticTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetTimingSyntheticTaskResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetTimingSyntheticTaskResponseBody() {}

  explicit GetTimingSyntheticTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTimingSyntheticTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTimingSyntheticTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTimingSyntheticTaskResponseBody() = default;
};
class GetTimingSyntheticTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTimingSyntheticTaskResponseBody> body{};

  GetTimingSyntheticTaskResponse() {}

  explicit GetTimingSyntheticTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTimingSyntheticTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTimingSyntheticTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetTimingSyntheticTaskResponse() = default;
};
class GetTraceRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> traceID{};

  GetTraceRequest() {}

  explicit GetTraceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~GetTraceRequest() = default;
};
class GetTraceResponseBodySpansLogEventListTagEntryList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTraceResponseBodySpansLogEventListTagEntryList() {}

  explicit GetTraceResponseBodySpansLogEventListTagEntryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTraceResponseBodySpansLogEventListTagEntryList() = default;
};
class GetTraceResponseBodySpansLogEventList : public Darabonba::Model {
public:
  shared_ptr<vector<GetTraceResponseBodySpansLogEventListTagEntryList>> tagEntryList{};
  shared_ptr<long> timestamp{};

  GetTraceResponseBodySpansLogEventList() {}

  explicit GetTraceResponseBodySpansLogEventList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagEntryList) {
      vector<boost::any> temp1;
      for(auto item1:*tagEntryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagEntryList"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagEntryList") != m.end() && !m["TagEntryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagEntryList"].type()) {
        vector<GetTraceResponseBodySpansLogEventListTagEntryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagEntryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceResponseBodySpansLogEventListTagEntryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagEntryList = make_shared<vector<GetTraceResponseBodySpansLogEventListTagEntryList>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~GetTraceResponseBodySpansLogEventList() = default;
};
class GetTraceResponseBodySpansTagEntryList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTraceResponseBodySpansTagEntryList() {}

  explicit GetTraceResponseBodySpansTagEntryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTraceResponseBodySpansTagEntryList() = default;
};
class GetTraceResponseBodySpans : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> children{};
  shared_ptr<long> duration{};
  shared_ptr<bool> haveStack{};
  shared_ptr<vector<GetTraceResponseBodySpansLogEventList>> logEventList{};
  shared_ptr<string> operationName{};
  shared_ptr<string> parentSpanId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> rpcId{};
  shared_ptr<long> rpcType{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> spanId{};
  shared_ptr<vector<GetTraceResponseBodySpansTagEntryList>> tagEntryList{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> traceID{};

  GetTraceResponseBodySpans() {}

  explicit GetTraceResponseBodySpans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      res["Children"] = boost::any(*children);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (haveStack) {
      res["HaveStack"] = boost::any(*haveStack);
    }
    if (logEventList) {
      vector<boost::any> temp1;
      for(auto item1:*logEventList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogEventList"] = boost::any(temp1);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (parentSpanId) {
      res["ParentSpanId"] = boost::any(*parentSpanId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (rpcId) {
      res["RpcId"] = boost::any(*rpcId);
    }
    if (rpcType) {
      res["RpcType"] = boost::any(*rpcType);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (spanId) {
      res["SpanId"] = boost::any(*spanId);
    }
    if (tagEntryList) {
      vector<boost::any> temp1;
      for(auto item1:*tagEntryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagEntryList"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Children"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      children = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("HaveStack") != m.end() && !m["HaveStack"].empty()) {
      haveStack = make_shared<bool>(boost::any_cast<bool>(m["HaveStack"]));
    }
    if (m.find("LogEventList") != m.end() && !m["LogEventList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogEventList"].type()) {
        vector<GetTraceResponseBodySpansLogEventList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogEventList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceResponseBodySpansLogEventList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logEventList = make_shared<vector<GetTraceResponseBodySpansLogEventList>>(expect1);
      }
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("ParentSpanId") != m.end() && !m["ParentSpanId"].empty()) {
      parentSpanId = make_shared<string>(boost::any_cast<string>(m["ParentSpanId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("RpcId") != m.end() && !m["RpcId"].empty()) {
      rpcId = make_shared<string>(boost::any_cast<string>(m["RpcId"]));
    }
    if (m.find("RpcType") != m.end() && !m["RpcType"].empty()) {
      rpcType = make_shared<long>(boost::any_cast<long>(m["RpcType"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("SpanId") != m.end() && !m["SpanId"].empty()) {
      spanId = make_shared<string>(boost::any_cast<string>(m["SpanId"]));
    }
    if (m.find("TagEntryList") != m.end() && !m["TagEntryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagEntryList"].type()) {
        vector<GetTraceResponseBodySpansTagEntryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagEntryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceResponseBodySpansTagEntryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagEntryList = make_shared<vector<GetTraceResponseBodySpansTagEntryList>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~GetTraceResponseBodySpans() = default;
};
class GetTraceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetTraceResponseBodySpans>> spans{};

  GetTraceResponseBody() {}

  explicit GetTraceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spans) {
      vector<boost::any> temp1;
      for(auto item1:*spans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Spans"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Spans") != m.end() && !m["Spans"].empty()) {
      if (typeid(vector<boost::any>) == m["Spans"].type()) {
        vector<GetTraceResponseBodySpans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Spans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceResponseBodySpans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spans = make_shared<vector<GetTraceResponseBodySpans>>(expect1);
      }
    }
  }


  virtual ~GetTraceResponseBody() = default;
};
class GetTraceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTraceResponseBody> body{};

  GetTraceResponse() {}

  explicit GetTraceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTraceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTraceResponseBody>(model1);
      }
    }
  }


  virtual ~GetTraceResponse() = default;
};
class GetTraceAppRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTraceAppRequestTags() {}

  explicit GetTraceAppRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTraceAppRequestTags() = default;
};
class GetTraceAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<GetTraceAppRequestTags>> tags{};

  GetTraceAppRequest() {}

  explicit GetTraceAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetTraceAppRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceAppRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetTraceAppRequestTags>>(expect1);
      }
    }
  }


  virtual ~GetTraceAppRequest() = default;
};
class GetTraceAppResponseBodyTraceAppTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTraceAppResponseBodyTraceAppTags() {}

  explicit GetTraceAppResponseBodyTraceAppTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTraceAppResponseBodyTraceAppTags() = default;
};
class GetTraceAppResponseBodyTraceApp : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> language{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> show{};
  shared_ptr<string> source{};
  shared_ptr<vector<GetTraceAppResponseBodyTraceAppTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  GetTraceAppResponseBodyTraceApp() {}

  explicit GetTraceAppResponseBodyTraceApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetTraceAppResponseBodyTraceAppTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceAppResponseBodyTraceAppTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetTraceAppResponseBodyTraceAppTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetTraceAppResponseBodyTraceApp() = default;
};
class GetTraceAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTraceAppResponseBodyTraceApp> traceApp{};

  GetTraceAppResponseBody() {}

  explicit GetTraceAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceApp) {
      res["TraceApp"] = traceApp ? boost::any(traceApp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceApp") != m.end() && !m["TraceApp"].empty()) {
      if (typeid(map<string, boost::any>) == m["TraceApp"].type()) {
        GetTraceAppResponseBodyTraceApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TraceApp"]));
        traceApp = make_shared<GetTraceAppResponseBodyTraceApp>(model1);
      }
    }
  }


  virtual ~GetTraceAppResponseBody() = default;
};
class GetTraceAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTraceAppResponseBody> body{};

  GetTraceAppResponse() {}

  explicit GetTraceAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTraceAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTraceAppResponseBody>(model1);
      }
    }
  }


  virtual ~GetTraceAppResponse() = default;
};
class GetTraceAppConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};

  GetTraceAppConfigRequest() {}

  explicit GetTraceAppConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
  }


  virtual ~GetTraceAppConfigRequest() = default;
};
class GetTraceAppConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetTraceAppConfigResponseBody() {}

  explicit GetTraceAppConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTraceAppConfigResponseBody() = default;
};
class GetTraceAppConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTraceAppConfigResponseBody> body{};

  GetTraceAppConfigResponse() {}

  explicit GetTraceAppConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTraceAppConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTraceAppConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetTraceAppConfigResponse() = default;
};
class ImportAppAlertRulesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ImportAppAlertRulesRequestTags() {}

  explicit ImportAppAlertRulesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ImportAppAlertRulesRequestTags() = default;
};
class ImportAppAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupIds{};
  shared_ptr<bool> isAutoStart{};
  shared_ptr<string> pids{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ImportAppAlertRulesRequestTags>> tags{};
  shared_ptr<string> templageAlertConfig{};
  shared_ptr<string> templateAlertId{};

  ImportAppAlertRulesRequest() {}

  explicit ImportAppAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupIds) {
      res["ContactGroupIds"] = boost::any(*contactGroupIds);
    }
    if (isAutoStart) {
      res["IsAutoStart"] = boost::any(*isAutoStart);
    }
    if (pids) {
      res["Pids"] = boost::any(*pids);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (templageAlertConfig) {
      res["TemplageAlertConfig"] = boost::any(*templageAlertConfig);
    }
    if (templateAlertId) {
      res["TemplateAlertId"] = boost::any(*templateAlertId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupIds") != m.end() && !m["ContactGroupIds"].empty()) {
      contactGroupIds = make_shared<string>(boost::any_cast<string>(m["ContactGroupIds"]));
    }
    if (m.find("IsAutoStart") != m.end() && !m["IsAutoStart"].empty()) {
      isAutoStart = make_shared<bool>(boost::any_cast<bool>(m["IsAutoStart"]));
    }
    if (m.find("Pids") != m.end() && !m["Pids"].empty()) {
      pids = make_shared<string>(boost::any_cast<string>(m["Pids"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ImportAppAlertRulesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportAppAlertRulesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ImportAppAlertRulesRequestTags>>(expect1);
      }
    }
    if (m.find("TemplageAlertConfig") != m.end() && !m["TemplageAlertConfig"].empty()) {
      templageAlertConfig = make_shared<string>(boost::any_cast<string>(m["TemplageAlertConfig"]));
    }
    if (m.find("TemplateAlertId") != m.end() && !m["TemplateAlertId"].empty()) {
      templateAlertId = make_shared<string>(boost::any_cast<string>(m["TemplateAlertId"]));
    }
  }


  virtual ~ImportAppAlertRulesRequest() = default;
};
class ImportAppAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  ImportAppAlertRulesResponseBody() {}

  explicit ImportAppAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportAppAlertRulesResponseBody() = default;
};
class ImportAppAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportAppAlertRulesResponseBody> body{};

  ImportAppAlertRulesResponse() {}

  explicit ImportAppAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportAppAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportAppAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ImportAppAlertRulesResponse() = default;
};
class InitEnvironmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<bool> createAuthToken{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> managedType{};
  shared_ptr<string> regionId{};

  InitEnvironmentRequest() {}

  explicit InitEnvironmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (createAuthToken) {
      res["CreateAuthToken"] = boost::any(*createAuthToken);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (managedType) {
      res["ManagedType"] = boost::any(*managedType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("CreateAuthToken") != m.end() && !m["CreateAuthToken"].empty()) {
      createAuthToken = make_shared<bool>(boost::any_cast<bool>(m["CreateAuthToken"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("ManagedType") != m.end() && !m["ManagedType"].empty()) {
      managedType = make_shared<string>(boost::any_cast<string>(m["ManagedType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~InitEnvironmentRequest() = default;
};
class InitEnvironmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  InitEnvironmentResponseBody() {}

  explicit InitEnvironmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InitEnvironmentResponseBody() = default;
};
class InitEnvironmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitEnvironmentResponseBody> body{};

  InitEnvironmentResponse() {}

  explicit InitEnvironmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitEnvironmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitEnvironmentResponseBody>(model1);
      }
    }
  }


  virtual ~InitEnvironmentResponse() = default;
};
class InstallAddonRequest : public Darabonba::Model {
public:
  shared_ptr<string> addonVersion{};
  shared_ptr<string> aliyunLang{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseName{};
  shared_ptr<string> values{};

  InstallAddonRequest() {}

  explicit InstallAddonRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonVersion) {
      res["AddonVersion"] = boost::any(*addonVersion);
    }
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseName) {
      res["ReleaseName"] = boost::any(*releaseName);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonVersion") != m.end() && !m["AddonVersion"].empty()) {
      addonVersion = make_shared<string>(boost::any_cast<string>(m["AddonVersion"]));
    }
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseName") != m.end() && !m["ReleaseName"].empty()) {
      releaseName = make_shared<string>(boost::any_cast<string>(m["ReleaseName"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~InstallAddonRequest() = default;
};
class InstallAddonResponseBodyDataConditions : public Darabonba::Model {
public:
  shared_ptr<string> firstTransitionTime{};
  shared_ptr<string> lastTransitionTime{};
  shared_ptr<string> message{};
  shared_ptr<string> reason{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  InstallAddonResponseBodyDataConditions() {}

  explicit InstallAddonResponseBodyDataConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstTransitionTime) {
      res["FirstTransitionTime"] = boost::any(*firstTransitionTime);
    }
    if (lastTransitionTime) {
      res["LastTransitionTime"] = boost::any(*lastTransitionTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstTransitionTime") != m.end() && !m["FirstTransitionTime"].empty()) {
      firstTransitionTime = make_shared<string>(boost::any_cast<string>(m["FirstTransitionTime"]));
    }
    if (m.find("LastTransitionTime") != m.end() && !m["LastTransitionTime"].empty()) {
      lastTransitionTime = make_shared<string>(boost::any_cast<string>(m["LastTransitionTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~InstallAddonResponseBodyDataConditions() = default;
};
class InstallAddonResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<long> alertRuleCount{};
  shared_ptr<vector<InstallAddonResponseBodyDataConditions>> conditions{};
  shared_ptr<string> createTime{};
  shared_ptr<long> dashboardCount{};
  shared_ptr<string> environmentId{};
  shared_ptr<long> exporterCount{};
  shared_ptr<bool> haveConfig{};
  shared_ptr<string> installUserId{};
  shared_ptr<string> language{};
  shared_ptr<bool> managed{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseId{};
  shared_ptr<string> releaseName{};
  shared_ptr<string> scene{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> version{};

  InstallAddonResponseBodyData() {}

  explicit InstallAddonResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (alertRuleCount) {
      res["AlertRuleCount"] = boost::any(*alertRuleCount);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dashboardCount) {
      res["DashboardCount"] = boost::any(*dashboardCount);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (exporterCount) {
      res["ExporterCount"] = boost::any(*exporterCount);
    }
    if (haveConfig) {
      res["HaveConfig"] = boost::any(*haveConfig);
    }
    if (installUserId) {
      res["InstallUserId"] = boost::any(*installUserId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (managed) {
      res["Managed"] = boost::any(*managed);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseId) {
      res["ReleaseId"] = boost::any(*releaseId);
    }
    if (releaseName) {
      res["ReleaseName"] = boost::any(*releaseName);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("AlertRuleCount") != m.end() && !m["AlertRuleCount"].empty()) {
      alertRuleCount = make_shared<long>(boost::any_cast<long>(m["AlertRuleCount"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<InstallAddonResponseBodyDataConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstallAddonResponseBodyDataConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<InstallAddonResponseBodyDataConditions>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DashboardCount") != m.end() && !m["DashboardCount"].empty()) {
      dashboardCount = make_shared<long>(boost::any_cast<long>(m["DashboardCount"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("ExporterCount") != m.end() && !m["ExporterCount"].empty()) {
      exporterCount = make_shared<long>(boost::any_cast<long>(m["ExporterCount"]));
    }
    if (m.find("HaveConfig") != m.end() && !m["HaveConfig"].empty()) {
      haveConfig = make_shared<bool>(boost::any_cast<bool>(m["HaveConfig"]));
    }
    if (m.find("InstallUserId") != m.end() && !m["InstallUserId"].empty()) {
      installUserId = make_shared<string>(boost::any_cast<string>(m["InstallUserId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Managed") != m.end() && !m["Managed"].empty()) {
      managed = make_shared<bool>(boost::any_cast<bool>(m["Managed"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseId") != m.end() && !m["ReleaseId"].empty()) {
      releaseId = make_shared<string>(boost::any_cast<string>(m["ReleaseId"]));
    }
    if (m.find("ReleaseName") != m.end() && !m["ReleaseName"].empty()) {
      releaseName = make_shared<string>(boost::any_cast<string>(m["ReleaseName"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~InstallAddonResponseBodyData() = default;
};
class InstallAddonResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<InstallAddonResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InstallAddonResponseBody() {}

  explicit InstallAddonResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InstallAddonResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InstallAddonResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallAddonResponseBody() = default;
};
class InstallAddonResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallAddonResponseBody> body{};

  InstallAddonResponse() {}

  explicit InstallAddonResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallAddonResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallAddonResponseBody>(model1);
      }
    }
  }


  virtual ~InstallAddonResponse() = default;
};
class InstallCmsExporterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> cmsArgs{};
  shared_ptr<string> directArgs{};
  shared_ptr<bool> enableTag{};
  shared_ptr<string> regionId{};

  InstallCmsExporterRequest() {}

  explicit InstallCmsExporterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (cmsArgs) {
      res["CmsArgs"] = boost::any(*cmsArgs);
    }
    if (directArgs) {
      res["DirectArgs"] = boost::any(*directArgs);
    }
    if (enableTag) {
      res["EnableTag"] = boost::any(*enableTag);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CmsArgs") != m.end() && !m["CmsArgs"].empty()) {
      cmsArgs = make_shared<string>(boost::any_cast<string>(m["CmsArgs"]));
    }
    if (m.find("DirectArgs") != m.end() && !m["DirectArgs"].empty()) {
      directArgs = make_shared<string>(boost::any_cast<string>(m["DirectArgs"]));
    }
    if (m.find("EnableTag") != m.end() && !m["EnableTag"].empty()) {
      enableTag = make_shared<bool>(boost::any_cast<bool>(m["EnableTag"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~InstallCmsExporterRequest() = default;
};
class InstallCmsExporterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  InstallCmsExporterResponseBody() {}

  explicit InstallCmsExporterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InstallCmsExporterResponseBody() = default;
};
class InstallCmsExporterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallCmsExporterResponseBody> body{};

  InstallCmsExporterResponse() {}

  explicit InstallCmsExporterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallCmsExporterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallCmsExporterResponseBody>(model1);
      }
    }
  }


  virtual ~InstallCmsExporterResponse() = default;
};
class InstallEnvironmentFeatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> config{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> featureName{};
  shared_ptr<string> featureVersion{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};

  InstallEnvironmentFeatureRequest() {}

  explicit InstallEnvironmentFeatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (featureName) {
      res["FeatureName"] = boost::any(*featureName);
    }
    if (featureVersion) {
      res["FeatureVersion"] = boost::any(*featureVersion);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("FeatureName") != m.end() && !m["FeatureName"].empty()) {
      featureName = make_shared<string>(boost::any_cast<string>(m["FeatureName"]));
    }
    if (m.find("FeatureVersion") != m.end() && !m["FeatureVersion"].empty()) {
      featureVersion = make_shared<string>(boost::any_cast<string>(m["FeatureVersion"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~InstallEnvironmentFeatureRequest() = default;
};
class InstallEnvironmentFeatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InstallEnvironmentFeatureResponseBody() {}

  explicit InstallEnvironmentFeatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallEnvironmentFeatureResponseBody() = default;
};
class InstallEnvironmentFeatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallEnvironmentFeatureResponseBody> body{};

  InstallEnvironmentFeatureResponse() {}

  explicit InstallEnvironmentFeatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallEnvironmentFeatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallEnvironmentFeatureResponseBody>(model1);
      }
    }
  }


  virtual ~InstallEnvironmentFeatureResponse() = default;
};
class InstallManagedPrometheusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> grafanaInstanceId{};
  shared_ptr<string> kubeConfig{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  InstallManagedPrometheusRequest() {}

  explicit InstallManagedPrometheusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (grafanaInstanceId) {
      res["GrafanaInstanceId"] = boost::any(*grafanaInstanceId);
    }
    if (kubeConfig) {
      res["KubeConfig"] = boost::any(*kubeConfig);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("GrafanaInstanceId") != m.end() && !m["GrafanaInstanceId"].empty()) {
      grafanaInstanceId = make_shared<string>(boost::any_cast<string>(m["GrafanaInstanceId"]));
    }
    if (m.find("KubeConfig") != m.end() && !m["KubeConfig"].empty()) {
      kubeConfig = make_shared<string>(boost::any_cast<string>(m["KubeConfig"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~InstallManagedPrometheusRequest() = default;
};
class InstallManagedPrometheusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InstallManagedPrometheusResponseBody() {}

  explicit InstallManagedPrometheusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallManagedPrometheusResponseBody() = default;
};
class InstallManagedPrometheusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallManagedPrometheusResponseBody> body{};

  InstallManagedPrometheusResponse() {}

  explicit InstallManagedPrometheusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallManagedPrometheusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallManagedPrometheusResponseBody>(model1);
      }
    }
  }


  virtual ~InstallManagedPrometheusResponse() = default;
};
class ListActivatedAlertsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> filter{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  ListActivatedAlertsRequest() {}

  explicit ListActivatedAlertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListActivatedAlertsRequest() = default;
};
class ListActivatedAlertsResponseBodyPageAlertsDispatchRules : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};

  ListActivatedAlertsResponseBodyPageAlertsDispatchRules() {}

  explicit ListActivatedAlertsResponseBodyPageAlertsDispatchRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~ListActivatedAlertsResponseBodyPageAlertsDispatchRules() = default;
};
class ListActivatedAlertsResponseBodyPageAlerts : public Darabonba::Model {
public:
  shared_ptr<string> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<string> alertType{};
  shared_ptr<long> count{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<ListActivatedAlertsResponseBodyPageAlertsDispatchRules>> dispatchRules{};
  shared_ptr<long> endsAt{};
  shared_ptr<map<string, boost::any>> expandFields{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> involvedObjectKind{};
  shared_ptr<string> involvedObjectName{};
  shared_ptr<string> message{};
  shared_ptr<string> severity{};
  shared_ptr<long> startsAt{};
  shared_ptr<string> status{};

  ListActivatedAlertsResponseBodyPageAlerts() {}

  explicit ListActivatedAlertsResponseBodyPageAlerts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dispatchRules) {
      vector<boost::any> temp1;
      for(auto item1:*dispatchRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DispatchRules"] = boost::any(temp1);
    }
    if (endsAt) {
      res["EndsAt"] = boost::any(*endsAt);
    }
    if (expandFields) {
      res["ExpandFields"] = boost::any(*expandFields);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (involvedObjectKind) {
      res["InvolvedObjectKind"] = boost::any(*involvedObjectKind);
    }
    if (involvedObjectName) {
      res["InvolvedObjectName"] = boost::any(*involvedObjectName);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (startsAt) {
      res["StartsAt"] = boost::any(*startsAt);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<string>(boost::any_cast<string>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<string>(boost::any_cast<string>(m["AlertType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DispatchRules") != m.end() && !m["DispatchRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DispatchRules"].type()) {
        vector<ListActivatedAlertsResponseBodyPageAlertsDispatchRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DispatchRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListActivatedAlertsResponseBodyPageAlertsDispatchRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dispatchRules = make_shared<vector<ListActivatedAlertsResponseBodyPageAlertsDispatchRules>>(expect1);
      }
    }
    if (m.find("EndsAt") != m.end() && !m["EndsAt"].empty()) {
      endsAt = make_shared<long>(boost::any_cast<long>(m["EndsAt"]));
    }
    if (m.find("ExpandFields") != m.end() && !m["ExpandFields"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExpandFields"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      expandFields = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("InvolvedObjectKind") != m.end() && !m["InvolvedObjectKind"].empty()) {
      involvedObjectKind = make_shared<string>(boost::any_cast<string>(m["InvolvedObjectKind"]));
    }
    if (m.find("InvolvedObjectName") != m.end() && !m["InvolvedObjectName"].empty()) {
      involvedObjectName = make_shared<string>(boost::any_cast<string>(m["InvolvedObjectName"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("StartsAt") != m.end() && !m["StartsAt"].empty()) {
      startsAt = make_shared<long>(boost::any_cast<long>(m["StartsAt"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListActivatedAlertsResponseBodyPageAlerts() = default;
};
class ListActivatedAlertsResponseBodyPage : public Darabonba::Model {
public:
  shared_ptr<vector<ListActivatedAlertsResponseBodyPageAlerts>> alerts{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  ListActivatedAlertsResponseBodyPage() {}

  explicit ListActivatedAlertsResponseBodyPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alerts) {
      vector<boost::any> temp1;
      for(auto item1:*alerts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Alerts"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alerts") != m.end() && !m["Alerts"].empty()) {
      if (typeid(vector<boost::any>) == m["Alerts"].type()) {
        vector<ListActivatedAlertsResponseBodyPageAlerts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Alerts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListActivatedAlertsResponseBodyPageAlerts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alerts = make_shared<vector<ListActivatedAlertsResponseBodyPageAlerts>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListActivatedAlertsResponseBodyPage() = default;
};
class ListActivatedAlertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<ListActivatedAlertsResponseBodyPage> page{};
  shared_ptr<string> requestId{};

  ListActivatedAlertsResponseBody() {}

  explicit ListActivatedAlertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (page) {
      res["Page"] = page ? boost::any(page->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      if (typeid(map<string, boost::any>) == m["Page"].type()) {
        ListActivatedAlertsResponseBodyPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Page"]));
        page = make_shared<ListActivatedAlertsResponseBodyPage>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListActivatedAlertsResponseBody() = default;
};
class ListActivatedAlertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListActivatedAlertsResponseBody> body{};

  ListActivatedAlertsResponse() {}

  explicit ListActivatedAlertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListActivatedAlertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListActivatedAlertsResponseBody>(model1);
      }
    }
  }


  virtual ~ListActivatedAlertsResponse() = default;
};
class ListAddonReleasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  ListAddonReleasesRequest() {}

  explicit ListAddonReleasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListAddonReleasesRequest() = default;
};
class ListAddonReleasesResponseBodyDataReleasesConditions : public Darabonba::Model {
public:
  shared_ptr<string> firstTransitionTime{};
  shared_ptr<string> lastTransitionTime{};
  shared_ptr<string> message{};
  shared_ptr<string> reason{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListAddonReleasesResponseBodyDataReleasesConditions() {}

  explicit ListAddonReleasesResponseBodyDataReleasesConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstTransitionTime) {
      res["FirstTransitionTime"] = boost::any(*firstTransitionTime);
    }
    if (lastTransitionTime) {
      res["LastTransitionTime"] = boost::any(*lastTransitionTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstTransitionTime") != m.end() && !m["FirstTransitionTime"].empty()) {
      firstTransitionTime = make_shared<string>(boost::any_cast<string>(m["FirstTransitionTime"]));
    }
    if (m.find("LastTransitionTime") != m.end() && !m["LastTransitionTime"].empty()) {
      lastTransitionTime = make_shared<string>(boost::any_cast<string>(m["LastTransitionTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAddonReleasesResponseBodyDataReleasesConditions() = default;
};
class ListAddonReleasesResponseBodyDataReleases : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<long> alertRuleCount{};
  shared_ptr<vector<ListAddonReleasesResponseBodyDataReleasesConditions>> conditions{};
  shared_ptr<string> createTime{};
  shared_ptr<long> dashboardCount{};
  shared_ptr<string> environmentId{};
  shared_ptr<long> exporterCount{};
  shared_ptr<bool> haveConfig{};
  shared_ptr<string> installUserId{};
  shared_ptr<string> language{};
  shared_ptr<bool> managed{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseId{};
  shared_ptr<string> releaseName{};
  shared_ptr<string> scene{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> version{};

  ListAddonReleasesResponseBodyDataReleases() {}

  explicit ListAddonReleasesResponseBodyDataReleases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (alertRuleCount) {
      res["AlertRuleCount"] = boost::any(*alertRuleCount);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dashboardCount) {
      res["DashboardCount"] = boost::any(*dashboardCount);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (exporterCount) {
      res["ExporterCount"] = boost::any(*exporterCount);
    }
    if (haveConfig) {
      res["HaveConfig"] = boost::any(*haveConfig);
    }
    if (installUserId) {
      res["InstallUserId"] = boost::any(*installUserId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (managed) {
      res["Managed"] = boost::any(*managed);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseId) {
      res["ReleaseId"] = boost::any(*releaseId);
    }
    if (releaseName) {
      res["ReleaseName"] = boost::any(*releaseName);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("AlertRuleCount") != m.end() && !m["AlertRuleCount"].empty()) {
      alertRuleCount = make_shared<long>(boost::any_cast<long>(m["AlertRuleCount"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<ListAddonReleasesResponseBodyDataReleasesConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAddonReleasesResponseBodyDataReleasesConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<ListAddonReleasesResponseBodyDataReleasesConditions>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DashboardCount") != m.end() && !m["DashboardCount"].empty()) {
      dashboardCount = make_shared<long>(boost::any_cast<long>(m["DashboardCount"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("ExporterCount") != m.end() && !m["ExporterCount"].empty()) {
      exporterCount = make_shared<long>(boost::any_cast<long>(m["ExporterCount"]));
    }
    if (m.find("HaveConfig") != m.end() && !m["HaveConfig"].empty()) {
      haveConfig = make_shared<bool>(boost::any_cast<bool>(m["HaveConfig"]));
    }
    if (m.find("InstallUserId") != m.end() && !m["InstallUserId"].empty()) {
      installUserId = make_shared<string>(boost::any_cast<string>(m["InstallUserId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Managed") != m.end() && !m["Managed"].empty()) {
      managed = make_shared<bool>(boost::any_cast<bool>(m["Managed"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseId") != m.end() && !m["ReleaseId"].empty()) {
      releaseId = make_shared<string>(boost::any_cast<string>(m["ReleaseId"]));
    }
    if (m.find("ReleaseName") != m.end() && !m["ReleaseName"].empty()) {
      releaseName = make_shared<string>(boost::any_cast<string>(m["ReleaseName"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListAddonReleasesResponseBodyDataReleases() = default;
};
class ListAddonReleasesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAddonReleasesResponseBodyDataReleases>> releases{};
  shared_ptr<long> total{};

  ListAddonReleasesResponseBodyData() {}

  explicit ListAddonReleasesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (releases) {
      vector<boost::any> temp1;
      for(auto item1:*releases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Releases"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Releases") != m.end() && !m["Releases"].empty()) {
      if (typeid(vector<boost::any>) == m["Releases"].type()) {
        vector<ListAddonReleasesResponseBodyDataReleases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Releases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAddonReleasesResponseBodyDataReleases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        releases = make_shared<vector<ListAddonReleasesResponseBodyDataReleases>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListAddonReleasesResponseBodyData() = default;
};
class ListAddonReleasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListAddonReleasesResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAddonReleasesResponseBody() {}

  explicit ListAddonReleasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAddonReleasesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAddonReleasesResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAddonReleasesResponseBody() = default;
};
class ListAddonReleasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAddonReleasesResponseBody> body{};

  ListAddonReleasesResponse() {}

  explicit ListAddonReleasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAddonReleasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAddonReleasesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAddonReleasesResponse() = default;
};
class ListAddonsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> category{};
  shared_ptr<bool> regexp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> search{};

  ListAddonsRequest() {}

  explicit ListAddonsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (regexp) {
      res["Regexp"] = boost::any(*regexp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (search) {
      res["Search"] = boost::any(*search);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Regexp") != m.end() && !m["Regexp"].empty()) {
      regexp = make_shared<bool>(boost::any_cast<bool>(m["Regexp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Search") != m.end() && !m["Search"].empty()) {
      search = make_shared<string>(boost::any_cast<string>(m["Search"]));
    }
  }


  virtual ~ListAddonsRequest() = default;
};
class ListAddonsResponseBodyDataDashboards : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> url{};

  ListAddonsResponseBodyDataDashboards() {}

  explicit ListAddonsResponseBodyDataDashboards(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListAddonsResponseBodyDataDashboards() = default;
};
class ListAddonsResponseBodyDataEnvironmentsDependencies : public Darabonba::Model {
public:
  shared_ptr<vector<string>> clusterTypes{};
  shared_ptr<map<string, bool>> features{};
  shared_ptr<vector<string>> services{};

  ListAddonsResponseBodyDataEnvironmentsDependencies() {}

  explicit ListAddonsResponseBodyDataEnvironmentsDependencies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTypes) {
      res["ClusterTypes"] = boost::any(*clusterTypes);
    }
    if (features) {
      res["Features"] = boost::any(*features);
    }
    if (services) {
      res["Services"] = boost::any(*services);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTypes") != m.end() && !m["ClusterTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Features") != m.end() && !m["Features"].empty()) {
      map<string, bool> map1 = boost::any_cast<map<string, bool>>(m["Features"]);
      map<string, bool> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      features = make_shared<map<string, bool>>(toMap1);
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Services"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Services"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      services = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAddonsResponseBodyDataEnvironmentsDependencies() = default;
};
class ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule : public Darabonba::Model {
public:
  shared_ptr<vector<string>> promQL{};

  ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule() {}

  explicit ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (promQL) {
      res["PromQL"] = boost::any(*promQL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PromQL") != m.end() && !m["PromQL"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PromQL"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PromQL"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      promQL = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule() = default;
};
class ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> icon{};
  shared_ptr<string> label{};
  shared_ptr<string> name{};

  ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols() {}

  explicit ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols() = default;
};
class ListAddonsResponseBodyDataEnvironmentsPolicies : public Darabonba::Model {
public:
  shared_ptr<string> alertDefaultStatus{};
  shared_ptr<bool> defaultInstall{};
  shared_ptr<bool> enableServiceAccount{};
  shared_ptr<ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule> metricCheckRule{};
  shared_ptr<bool> needRestartAfterIntegration{};
  shared_ptr<vector<ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols>> protocols{};
  shared_ptr<string> targetAddonName{};

  ListAddonsResponseBodyDataEnvironmentsPolicies() {}

  explicit ListAddonsResponseBodyDataEnvironmentsPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertDefaultStatus) {
      res["AlertDefaultStatus"] = boost::any(*alertDefaultStatus);
    }
    if (defaultInstall) {
      res["DefaultInstall"] = boost::any(*defaultInstall);
    }
    if (enableServiceAccount) {
      res["EnableServiceAccount"] = boost::any(*enableServiceAccount);
    }
    if (metricCheckRule) {
      res["MetricCheckRule"] = metricCheckRule ? boost::any(metricCheckRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needRestartAfterIntegration) {
      res["NeedRestartAfterIntegration"] = boost::any(*needRestartAfterIntegration);
    }
    if (protocols) {
      vector<boost::any> temp1;
      for(auto item1:*protocols){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Protocols"] = boost::any(temp1);
    }
    if (targetAddonName) {
      res["TargetAddonName"] = boost::any(*targetAddonName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertDefaultStatus") != m.end() && !m["AlertDefaultStatus"].empty()) {
      alertDefaultStatus = make_shared<string>(boost::any_cast<string>(m["AlertDefaultStatus"]));
    }
    if (m.find("DefaultInstall") != m.end() && !m["DefaultInstall"].empty()) {
      defaultInstall = make_shared<bool>(boost::any_cast<bool>(m["DefaultInstall"]));
    }
    if (m.find("EnableServiceAccount") != m.end() && !m["EnableServiceAccount"].empty()) {
      enableServiceAccount = make_shared<bool>(boost::any_cast<bool>(m["EnableServiceAccount"]));
    }
    if (m.find("MetricCheckRule") != m.end() && !m["MetricCheckRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricCheckRule"].type()) {
        ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricCheckRule"]));
        metricCheckRule = make_shared<ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule>(model1);
      }
    }
    if (m.find("NeedRestartAfterIntegration") != m.end() && !m["NeedRestartAfterIntegration"].empty()) {
      needRestartAfterIntegration = make_shared<bool>(boost::any_cast<bool>(m["NeedRestartAfterIntegration"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Protocols"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        protocols = make_shared<vector<ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols>>(expect1);
      }
    }
    if (m.find("TargetAddonName") != m.end() && !m["TargetAddonName"].empty()) {
      targetAddonName = make_shared<string>(boost::any_cast<string>(m["TargetAddonName"]));
    }
  }


  virtual ~ListAddonsResponseBodyDataEnvironmentsPolicies() = default;
};
class ListAddonsResponseBodyDataEnvironments : public Darabonba::Model {
public:
  shared_ptr<ListAddonsResponseBodyDataEnvironmentsDependencies> dependencies{};
  shared_ptr<string> description{};
  shared_ptr<bool> enable{};
  shared_ptr<string> label{};
  shared_ptr<string> name{};
  shared_ptr<ListAddonsResponseBodyDataEnvironmentsPolicies> policies{};

  ListAddonsResponseBodyDataEnvironments() {}

  explicit ListAddonsResponseBodyDataEnvironments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependencies) {
      res["Dependencies"] = dependencies ? boost::any(dependencies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policies) {
      res["Policies"] = policies ? boost::any(policies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dependencies") != m.end() && !m["Dependencies"].empty()) {
      if (typeid(map<string, boost::any>) == m["Dependencies"].type()) {
        ListAddonsResponseBodyDataEnvironmentsDependencies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Dependencies"]));
        dependencies = make_shared<ListAddonsResponseBodyDataEnvironmentsDependencies>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(map<string, boost::any>) == m["Policies"].type()) {
        ListAddonsResponseBodyDataEnvironmentsPolicies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Policies"]));
        policies = make_shared<ListAddonsResponseBodyDataEnvironmentsPolicies>(model1);
      }
    }
  }


  virtual ~ListAddonsResponseBodyDataEnvironments() = default;
};
class ListAddonsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<vector<string>> categories{};
  shared_ptr<vector<ListAddonsResponseBodyDataDashboards>> dashboards{};
  shared_ptr<string> description{};
  shared_ptr<vector<ListAddonsResponseBodyDataEnvironments>> environments{};
  shared_ptr<string> icon{};
  shared_ptr<vector<string>> keywords{};
  shared_ptr<string> language{};
  shared_ptr<string> latestReleaseCreateTime{};
  shared_ptr<string> name{};
  shared_ptr<bool> once{};
  shared_ptr<string> scene{};
  shared_ptr<string> version{};
  shared_ptr<string> weight{};

  ListAddonsResponseBodyData() {}

  explicit ListAddonsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (dashboards) {
      vector<boost::any> temp1;
      for(auto item1:*dashboards){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dashboards"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (environments) {
      vector<boost::any> temp1;
      for(auto item1:*environments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Environments"] = boost::any(temp1);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (latestReleaseCreateTime) {
      res["LatestReleaseCreateTime"] = boost::any(*latestReleaseCreateTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (once) {
      res["Once"] = boost::any(*once);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Dashboards") != m.end() && !m["Dashboards"].empty()) {
      if (typeid(vector<boost::any>) == m["Dashboards"].type()) {
        vector<ListAddonsResponseBodyDataDashboards> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dashboards"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAddonsResponseBodyDataDashboards model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dashboards = make_shared<vector<ListAddonsResponseBodyDataDashboards>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Environments") != m.end() && !m["Environments"].empty()) {
      if (typeid(vector<boost::any>) == m["Environments"].type()) {
        vector<ListAddonsResponseBodyDataEnvironments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Environments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAddonsResponseBodyDataEnvironments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        environments = make_shared<vector<ListAddonsResponseBodyDataEnvironments>>(expect1);
      }
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LatestReleaseCreateTime") != m.end() && !m["LatestReleaseCreateTime"].empty()) {
      latestReleaseCreateTime = make_shared<string>(boost::any_cast<string>(m["LatestReleaseCreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Once") != m.end() && !m["Once"].empty()) {
      once = make_shared<bool>(boost::any_cast<bool>(m["Once"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~ListAddonsResponseBodyData() = default;
};
class ListAddonsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListAddonsResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAddonsResponseBody() {}

  explicit ListAddonsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAddonsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAddonsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAddonsResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAddonsResponseBody() = default;
};
class ListAddonsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAddonsResponseBody> body{};

  ListAddonsResponse() {}

  explicit ListAddonsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAddonsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAddonsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAddonsResponse() = default;
};
class ListAlertEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> matchingConditions{};
  shared_ptr<long> page{};
  shared_ptr<bool> showNotificationPolicies{};
  shared_ptr<long> size{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListAlertEventsRequest() {}

  explicit ListAlertEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (matchingConditions) {
      res["MatchingConditions"] = boost::any(*matchingConditions);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (showNotificationPolicies) {
      res["ShowNotificationPolicies"] = boost::any(*showNotificationPolicies);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("MatchingConditions") != m.end() && !m["MatchingConditions"].empty()) {
      matchingConditions = make_shared<string>(boost::any_cast<string>(m["MatchingConditions"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("ShowNotificationPolicies") != m.end() && !m["ShowNotificationPolicies"].empty()) {
      showNotificationPolicies = make_shared<bool>(boost::any_cast<bool>(m["ShowNotificationPolicies"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAlertEventsRequest() = default;
};
class ListAlertEventsResponseBodyPageBeanEventsAlarms : public Darabonba::Model {
public:
  shared_ptr<long> alarmId{};
  shared_ptr<string> alarmName{};
  shared_ptr<string> createTime{};
  shared_ptr<long> state{};

  ListAlertEventsResponseBodyPageBeanEventsAlarms() {}

  explicit ListAlertEventsResponseBodyPageBeanEventsAlarms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmId) {
      res["AlarmId"] = boost::any(*alarmId);
    }
    if (alarmName) {
      res["AlarmName"] = boost::any(*alarmName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmId") != m.end() && !m["AlarmId"].empty()) {
      alarmId = make_shared<long>(boost::any_cast<long>(m["AlarmId"]));
    }
    if (m.find("AlarmName") != m.end() && !m["AlarmName"].empty()) {
      alarmName = make_shared<string>(boost::any_cast<string>(m["AlarmName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyPageBeanEventsAlarms() = default;
};
class ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies() {}

  explicit ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies() = default;
};
class ListAlertEventsResponseBodyPageBeanEvents : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertEventsResponseBodyPageBeanEventsAlarms>> alarms{};
  shared_ptr<string> alertName{};
  shared_ptr<string> annotations{};
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> generatorURL{};
  shared_ptr<string> handlerName{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> labels{};
  shared_ptr<vector<ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies>> notificationPolicies{};
  shared_ptr<string> receiveTime{};
  shared_ptr<string> severity{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> triggerCount{};

  ListAlertEventsResponseBodyPageBeanEvents() {}

  explicit ListAlertEventsResponseBodyPageBeanEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarms) {
      vector<boost::any> temp1;
      for(auto item1:*alarms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Alarms"] = boost::any(temp1);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (generatorURL) {
      res["GeneratorURL"] = boost::any(*generatorURL);
    }
    if (handlerName) {
      res["HandlerName"] = boost::any(*handlerName);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (notificationPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*notificationPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationPolicies"] = boost::any(temp1);
    }
    if (receiveTime) {
      res["ReceiveTime"] = boost::any(*receiveTime);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (triggerCount) {
      res["TriggerCount"] = boost::any(*triggerCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alarms") != m.end() && !m["Alarms"].empty()) {
      if (typeid(vector<boost::any>) == m["Alarms"].type()) {
        vector<ListAlertEventsResponseBodyPageBeanEventsAlarms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Alarms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertEventsResponseBodyPageBeanEventsAlarms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarms = make_shared<vector<ListAlertEventsResponseBodyPageBeanEventsAlarms>>(expect1);
      }
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GeneratorURL") != m.end() && !m["GeneratorURL"].empty()) {
      generatorURL = make_shared<string>(boost::any_cast<string>(m["GeneratorURL"]));
    }
    if (m.find("HandlerName") != m.end() && !m["HandlerName"].empty()) {
      handlerName = make_shared<string>(boost::any_cast<string>(m["HandlerName"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("NotificationPolicies") != m.end() && !m["NotificationPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationPolicies"].type()) {
        vector<ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationPolicies = make_shared<vector<ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies>>(expect1);
      }
    }
    if (m.find("ReceiveTime") != m.end() && !m["ReceiveTime"].empty()) {
      receiveTime = make_shared<string>(boost::any_cast<string>(m["ReceiveTime"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TriggerCount") != m.end() && !m["TriggerCount"].empty()) {
      triggerCount = make_shared<long>(boost::any_cast<long>(m["TriggerCount"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyPageBeanEvents() = default;
};
class ListAlertEventsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertEventsResponseBodyPageBeanEvents>> events{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListAlertEventsResponseBodyPageBean() {}

  explicit ListAlertEventsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Events"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Events") != m.end() && !m["Events"].empty()) {
      if (typeid(vector<boost::any>) == m["Events"].type()) {
        vector<ListAlertEventsResponseBodyPageBeanEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertEventsResponseBodyPageBeanEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<ListAlertEventsResponseBodyPageBeanEvents>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyPageBean() = default;
};
class ListAlertEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAlertEventsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListAlertEventsResponseBody() {}

  explicit ListAlertEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListAlertEventsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListAlertEventsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAlertEventsResponseBody() = default;
};
class ListAlertEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlertEventsResponseBody> body{};

  ListAlertEventsResponse() {}

  explicit ListAlertEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertEventsResponse() = default;
};
class ListAlertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> owner{};
  shared_ptr<long> page{};
  shared_ptr<string> regionId{};
  shared_ptr<string> severity{};
  shared_ptr<bool> showActivities{};
  shared_ptr<bool> showEvents{};
  shared_ptr<long> size{};
  shared_ptr<string> startTime{};
  shared_ptr<long> state{};

  ListAlertsRequest() {}

  explicit ListAlertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (showActivities) {
      res["ShowActivities"] = boost::any(*showActivities);
    }
    if (showEvents) {
      res["ShowEvents"] = boost::any(*showEvents);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("ShowActivities") != m.end() && !m["ShowActivities"].empty()) {
      showActivities = make_shared<bool>(boost::any_cast<bool>(m["ShowActivities"]));
    }
    if (m.find("ShowEvents") != m.end() && !m["ShowEvents"].empty()) {
      showEvents = make_shared<bool>(boost::any_cast<bool>(m["ShowEvents"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~ListAlertsRequest() = default;
};
class ListAlertsResponseBodyPageBeanListAlertsActivities : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> handlerName{};
  shared_ptr<string> time{};
  shared_ptr<long> type{};

  ListAlertsResponseBodyPageBeanListAlertsActivities() {}

  explicit ListAlertsResponseBodyPageBeanListAlertsActivities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (handlerName) {
      res["HandlerName"] = boost::any(*handlerName);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HandlerName") != m.end() && !m["HandlerName"].empty()) {
      handlerName = make_shared<string>(boost::any_cast<string>(m["HandlerName"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ListAlertsResponseBodyPageBeanListAlertsActivities() = default;
};
class ListAlertsResponseBodyPageBeanListAlertsAlertEvents : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<string> annotations{};
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> generatorURL{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> labels{};
  shared_ptr<string> receiveTime{};
  shared_ptr<string> severity{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};

  ListAlertsResponseBodyPageBeanListAlertsAlertEvents() {}

  explicit ListAlertsResponseBodyPageBeanListAlertsAlertEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (generatorURL) {
      res["GeneratorURL"] = boost::any(*generatorURL);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (receiveTime) {
      res["ReceiveTime"] = boost::any(*receiveTime);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GeneratorURL") != m.end() && !m["GeneratorURL"].empty()) {
      generatorURL = make_shared<string>(boost::any_cast<string>(m["GeneratorURL"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("ReceiveTime") != m.end() && !m["ReceiveTime"].empty()) {
      receiveTime = make_shared<string>(boost::any_cast<string>(m["ReceiveTime"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListAlertsResponseBodyPageBeanListAlertsAlertEvents() = default;
};
class ListAlertsResponseBodyPageBeanListAlerts : public Darabonba::Model {
public:
  shared_ptr<long> acknowledgeTime{};
  shared_ptr<vector<ListAlertsResponseBodyPageBeanListAlertsActivities>> activities{};
  shared_ptr<vector<ListAlertsResponseBodyPageBeanListAlertsAlertEvents>> alertEvents{};
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> describe{};
  shared_ptr<double> dispatchRuleId{};
  shared_ptr<string> dispatchRuleName{};
  shared_ptr<string> handler{};
  shared_ptr<string> notifyRobots{};
  shared_ptr<string> owner{};
  shared_ptr<long> recoverTime{};
  shared_ptr<string> severity{};
  shared_ptr<string> solution{};
  shared_ptr<long> state{};

  ListAlertsResponseBodyPageBeanListAlerts() {}

  explicit ListAlertsResponseBodyPageBeanListAlerts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acknowledgeTime) {
      res["AcknowledgeTime"] = boost::any(*acknowledgeTime);
    }
    if (activities) {
      vector<boost::any> temp1;
      for(auto item1:*activities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Activities"] = boost::any(temp1);
    }
    if (alertEvents) {
      vector<boost::any> temp1;
      for(auto item1:*alertEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertEvents"] = boost::any(temp1);
    }
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (dispatchRuleName) {
      res["DispatchRuleName"] = boost::any(*dispatchRuleName);
    }
    if (handler) {
      res["Handler"] = boost::any(*handler);
    }
    if (notifyRobots) {
      res["NotifyRobots"] = boost::any(*notifyRobots);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (solution) {
      res["Solution"] = boost::any(*solution);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcknowledgeTime") != m.end() && !m["AcknowledgeTime"].empty()) {
      acknowledgeTime = make_shared<long>(boost::any_cast<long>(m["AcknowledgeTime"]));
    }
    if (m.find("Activities") != m.end() && !m["Activities"].empty()) {
      if (typeid(vector<boost::any>) == m["Activities"].type()) {
        vector<ListAlertsResponseBodyPageBeanListAlertsActivities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Activities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertsResponseBodyPageBeanListAlertsActivities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activities = make_shared<vector<ListAlertsResponseBodyPageBeanListAlertsActivities>>(expect1);
      }
    }
    if (m.find("AlertEvents") != m.end() && !m["AlertEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertEvents"].type()) {
        vector<ListAlertsResponseBodyPageBeanListAlertsAlertEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertsResponseBodyPageBeanListAlertsAlertEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertEvents = make_shared<vector<ListAlertsResponseBodyPageBeanListAlertsAlertEvents>>(expect1);
      }
    }
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<double>(boost::any_cast<double>(m["DispatchRuleId"]));
    }
    if (m.find("DispatchRuleName") != m.end() && !m["DispatchRuleName"].empty()) {
      dispatchRuleName = make_shared<string>(boost::any_cast<string>(m["DispatchRuleName"]));
    }
    if (m.find("Handler") != m.end() && !m["Handler"].empty()) {
      handler = make_shared<string>(boost::any_cast<string>(m["Handler"]));
    }
    if (m.find("NotifyRobots") != m.end() && !m["NotifyRobots"].empty()) {
      notifyRobots = make_shared<string>(boost::any_cast<string>(m["NotifyRobots"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Solution") != m.end() && !m["Solution"].empty()) {
      solution = make_shared<string>(boost::any_cast<string>(m["Solution"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~ListAlertsResponseBodyPageBeanListAlerts() = default;
};
class ListAlertsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertsResponseBodyPageBeanListAlerts>> listAlerts{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListAlertsResponseBodyPageBean() {}

  explicit ListAlertsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listAlerts) {
      vector<boost::any> temp1;
      for(auto item1:*listAlerts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListAlerts"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListAlerts") != m.end() && !m["ListAlerts"].empty()) {
      if (typeid(vector<boost::any>) == m["ListAlerts"].type()) {
        vector<ListAlertsResponseBodyPageBeanListAlerts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListAlerts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertsResponseBodyPageBeanListAlerts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listAlerts = make_shared<vector<ListAlertsResponseBodyPageBeanListAlerts>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListAlertsResponseBodyPageBean() = default;
};
class ListAlertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<ListAlertsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListAlertsResponseBody() {}

  explicit ListAlertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListAlertsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListAlertsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAlertsResponseBody() = default;
};
class ListAlertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlertsResponseBody> body{};

  ListAlertsResponse() {}

  explicit ListAlertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertsResponse() = default;
};
class ListClusterFromGrafanaRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  ListClusterFromGrafanaRequest() {}

  explicit ListClusterFromGrafanaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListClusterFromGrafanaRequest() = default;
};
class ListClusterFromGrafanaResponseBodyPromClusterList : public Darabonba::Model {
public:
  shared_ptr<string> agentStatus{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> controllerId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> extra{};
  shared_ptr<long> id{};
  shared_ptr<long> installTime{};
  shared_ptr<bool> isControllerInstalled{};
  shared_ptr<long> lastHeartBeatTime{};
  shared_ptr<long> nodeNum{};
  shared_ptr<string> options{};
  shared_ptr<string> pluginsJsonArray{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stateJson{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  ListClusterFromGrafanaResponseBodyPromClusterList() {}

  explicit ListClusterFromGrafanaResponseBodyPromClusterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStatus) {
      res["AgentStatus"] = boost::any(*agentStatus);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (controllerId) {
      res["ControllerId"] = boost::any(*controllerId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (installTime) {
      res["InstallTime"] = boost::any(*installTime);
    }
    if (isControllerInstalled) {
      res["IsControllerInstalled"] = boost::any(*isControllerInstalled);
    }
    if (lastHeartBeatTime) {
      res["LastHeartBeatTime"] = boost::any(*lastHeartBeatTime);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (pluginsJsonArray) {
      res["PluginsJsonArray"] = boost::any(*pluginsJsonArray);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stateJson) {
      res["StateJson"] = boost::any(*stateJson);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentStatus") != m.end() && !m["AgentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["AgentStatus"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("ControllerId") != m.end() && !m["ControllerId"].empty()) {
      controllerId = make_shared<string>(boost::any_cast<string>(m["ControllerId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstallTime") != m.end() && !m["InstallTime"].empty()) {
      installTime = make_shared<long>(boost::any_cast<long>(m["InstallTime"]));
    }
    if (m.find("IsControllerInstalled") != m.end() && !m["IsControllerInstalled"].empty()) {
      isControllerInstalled = make_shared<bool>(boost::any_cast<bool>(m["IsControllerInstalled"]));
    }
    if (m.find("LastHeartBeatTime") != m.end() && !m["LastHeartBeatTime"].empty()) {
      lastHeartBeatTime = make_shared<long>(boost::any_cast<long>(m["LastHeartBeatTime"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("PluginsJsonArray") != m.end() && !m["PluginsJsonArray"].empty()) {
      pluginsJsonArray = make_shared<string>(boost::any_cast<string>(m["PluginsJsonArray"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StateJson") != m.end() && !m["StateJson"].empty()) {
      stateJson = make_shared<string>(boost::any_cast<string>(m["StateJson"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListClusterFromGrafanaResponseBodyPromClusterList() = default;
};
class ListClusterFromGrafanaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterFromGrafanaResponseBodyPromClusterList>> promClusterList{};
  shared_ptr<string> requestId{};

  ListClusterFromGrafanaResponseBody() {}

  explicit ListClusterFromGrafanaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (promClusterList) {
      vector<boost::any> temp1;
      for(auto item1:*promClusterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PromClusterList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PromClusterList") != m.end() && !m["PromClusterList"].empty()) {
      if (typeid(vector<boost::any>) == m["PromClusterList"].type()) {
        vector<ListClusterFromGrafanaResponseBodyPromClusterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PromClusterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterFromGrafanaResponseBodyPromClusterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promClusterList = make_shared<vector<ListClusterFromGrafanaResponseBodyPromClusterList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClusterFromGrafanaResponseBody() = default;
};
class ListClusterFromGrafanaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterFromGrafanaResponseBody> body{};

  ListClusterFromGrafanaResponse() {}

  explicit ListClusterFromGrafanaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterFromGrafanaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterFromGrafanaResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterFromGrafanaResponse() = default;
};
class ListCmsInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> typeFilter{};

  ListCmsInstancesRequest() {}

  explicit ListCmsInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (typeFilter) {
      res["TypeFilter"] = boost::any(*typeFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TypeFilter") != m.end() && !m["TypeFilter"].empty()) {
      typeFilter = make_shared<string>(boost::any_cast<string>(m["TypeFilter"]));
    }
  }


  virtual ~ListCmsInstancesRequest() = default;
};
class ListCmsInstancesResponseBodyDataProducts : public Darabonba::Model {
public:
  shared_ptr<string> descr{};
  shared_ptr<string> id{};
  shared_ptr<string> instance{};
  shared_ptr<string> name{};
  shared_ptr<string> prod{};
  shared_ptr<string> source{};
  shared_ptr<string> state{};
  shared_ptr<string> time{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  ListCmsInstancesResponseBodyDataProducts() {}

  explicit ListCmsInstancesResponseBodyDataProducts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (descr) {
      res["Descr"] = boost::any(*descr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (prod) {
      res["Prod"] = boost::any(*prod);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Descr") != m.end() && !m["Descr"].empty()) {
      descr = make_shared<string>(boost::any_cast<string>(m["Descr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Prod") != m.end() && !m["Prod"].empty()) {
      prod = make_shared<string>(boost::any_cast<string>(m["Prod"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListCmsInstancesResponseBodyDataProducts() = default;
};
class ListCmsInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> enableTag{};
  shared_ptr<vector<ListCmsInstancesResponseBodyDataProducts>> products{};

  ListCmsInstancesResponseBodyData() {}

  explicit ListCmsInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableTag) {
      res["EnableTag"] = boost::any(*enableTag);
    }
    if (products) {
      vector<boost::any> temp1;
      for(auto item1:*products){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Products"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableTag") != m.end() && !m["EnableTag"].empty()) {
      enableTag = make_shared<bool>(boost::any_cast<bool>(m["EnableTag"]));
    }
    if (m.find("Products") != m.end() && !m["Products"].empty()) {
      if (typeid(vector<boost::any>) == m["Products"].type()) {
        vector<ListCmsInstancesResponseBodyDataProducts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Products"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCmsInstancesResponseBodyDataProducts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        products = make_shared<vector<ListCmsInstancesResponseBodyDataProducts>>(expect1);
      }
    }
  }


  virtual ~ListCmsInstancesResponseBodyData() = default;
};
class ListCmsInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCmsInstancesResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ListCmsInstancesResponseBody() {}

  explicit ListCmsInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCmsInstancesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCmsInstancesResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCmsInstancesResponseBody() = default;
};
class ListCmsInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCmsInstancesResponseBody> body{};

  ListCmsInstancesResponse() {}

  explicit ListCmsInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCmsInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCmsInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCmsInstancesResponse() = default;
};
class ListDashboardsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> dashboardName{};
  shared_ptr<string> language{};
  shared_ptr<string> product{};
  shared_ptr<bool> recreateSwitch{};
  shared_ptr<string> regionId{};
  shared_ptr<string> title{};

  ListDashboardsRequest() {}

  explicit ListDashboardsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (dashboardName) {
      res["DashboardName"] = boost::any(*dashboardName);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (recreateSwitch) {
      res["RecreateSwitch"] = boost::any(*recreateSwitch);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("DashboardName") != m.end() && !m["DashboardName"].empty()) {
      dashboardName = make_shared<string>(boost::any_cast<string>(m["DashboardName"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RecreateSwitch") != m.end() && !m["RecreateSwitch"].empty()) {
      recreateSwitch = make_shared<bool>(boost::any_cast<bool>(m["RecreateSwitch"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~ListDashboardsRequest() = default;
};
class ListDashboardsResponseBodyDashboardVosI18nChild : public Darabonba::Model {
public:
  shared_ptr<string> dashboardType{};
  shared_ptr<string> exporter{};
  shared_ptr<string> httpUrl{};
  shared_ptr<string> httpsUrl{};
  shared_ptr<string> id{};
  shared_ptr<bool> isArmsExporter{};
  shared_ptr<string> kind{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<bool> needUpdate{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> time{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<string> uid{};
  shared_ptr<string> url{};
  shared_ptr<string> version{};

  ListDashboardsResponseBodyDashboardVosI18nChild() {}

  explicit ListDashboardsResponseBodyDashboardVosI18nChild(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboardType) {
      res["DashboardType"] = boost::any(*dashboardType);
    }
    if (exporter) {
      res["Exporter"] = boost::any(*exporter);
    }
    if (httpUrl) {
      res["HttpUrl"] = boost::any(*httpUrl);
    }
    if (httpsUrl) {
      res["HttpsUrl"] = boost::any(*httpsUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isArmsExporter) {
      res["IsArmsExporter"] = boost::any(*isArmsExporter);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needUpdate) {
      res["NeedUpdate"] = boost::any(*needUpdate);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DashboardType") != m.end() && !m["DashboardType"].empty()) {
      dashboardType = make_shared<string>(boost::any_cast<string>(m["DashboardType"]));
    }
    if (m.find("Exporter") != m.end() && !m["Exporter"].empty()) {
      exporter = make_shared<string>(boost::any_cast<string>(m["Exporter"]));
    }
    if (m.find("HttpUrl") != m.end() && !m["HttpUrl"].empty()) {
      httpUrl = make_shared<string>(boost::any_cast<string>(m["HttpUrl"]));
    }
    if (m.find("HttpsUrl") != m.end() && !m["HttpsUrl"].empty()) {
      httpsUrl = make_shared<string>(boost::any_cast<string>(m["HttpsUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsArmsExporter") != m.end() && !m["IsArmsExporter"].empty()) {
      isArmsExporter = make_shared<bool>(boost::any_cast<bool>(m["IsArmsExporter"]));
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedUpdate") != m.end() && !m["NeedUpdate"].empty()) {
      needUpdate = make_shared<bool>(boost::any_cast<bool>(m["NeedUpdate"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListDashboardsResponseBodyDashboardVosI18nChild() = default;
};
class ListDashboardsResponseBodyDashboardVos : public Darabonba::Model {
public:
  shared_ptr<string> dashboardType{};
  shared_ptr<string> exporter{};
  shared_ptr<string> httpUrl{};
  shared_ptr<string> httpsUrl{};
  shared_ptr<ListDashboardsResponseBodyDashboardVosI18nChild> i18nChild{};
  shared_ptr<string> id{};
  shared_ptr<bool> isArmsExporter{};
  shared_ptr<string> kind{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<bool> needUpdate{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> time{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<string> uid{};
  shared_ptr<string> url{};
  shared_ptr<string> version{};

  ListDashboardsResponseBodyDashboardVos() {}

  explicit ListDashboardsResponseBodyDashboardVos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboardType) {
      res["DashboardType"] = boost::any(*dashboardType);
    }
    if (exporter) {
      res["Exporter"] = boost::any(*exporter);
    }
    if (httpUrl) {
      res["HttpUrl"] = boost::any(*httpUrl);
    }
    if (httpsUrl) {
      res["HttpsUrl"] = boost::any(*httpsUrl);
    }
    if (i18nChild) {
      res["I18nChild"] = i18nChild ? boost::any(i18nChild->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isArmsExporter) {
      res["IsArmsExporter"] = boost::any(*isArmsExporter);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needUpdate) {
      res["NeedUpdate"] = boost::any(*needUpdate);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DashboardType") != m.end() && !m["DashboardType"].empty()) {
      dashboardType = make_shared<string>(boost::any_cast<string>(m["DashboardType"]));
    }
    if (m.find("Exporter") != m.end() && !m["Exporter"].empty()) {
      exporter = make_shared<string>(boost::any_cast<string>(m["Exporter"]));
    }
    if (m.find("HttpUrl") != m.end() && !m["HttpUrl"].empty()) {
      httpUrl = make_shared<string>(boost::any_cast<string>(m["HttpUrl"]));
    }
    if (m.find("HttpsUrl") != m.end() && !m["HttpsUrl"].empty()) {
      httpsUrl = make_shared<string>(boost::any_cast<string>(m["HttpsUrl"]));
    }
    if (m.find("I18nChild") != m.end() && !m["I18nChild"].empty()) {
      if (typeid(map<string, boost::any>) == m["I18nChild"].type()) {
        ListDashboardsResponseBodyDashboardVosI18nChild model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["I18nChild"]));
        i18nChild = make_shared<ListDashboardsResponseBodyDashboardVosI18nChild>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsArmsExporter") != m.end() && !m["IsArmsExporter"].empty()) {
      isArmsExporter = make_shared<bool>(boost::any_cast<bool>(m["IsArmsExporter"]));
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedUpdate") != m.end() && !m["NeedUpdate"].empty()) {
      needUpdate = make_shared<bool>(boost::any_cast<bool>(m["NeedUpdate"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListDashboardsResponseBodyDashboardVos() = default;
};
class ListDashboardsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDashboardsResponseBodyDashboardVos>> dashboardVos{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> grafanaServiceOpened{};
  shared_ptr<string> prometheusServiceOpened{};
  shared_ptr<string> requestId{};

  ListDashboardsResponseBody() {}

  explicit ListDashboardsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboardVos) {
      vector<boost::any> temp1;
      for(auto item1:*dashboardVos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DashboardVos"] = boost::any(temp1);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (grafanaServiceOpened) {
      res["GrafanaServiceOpened"] = boost::any(*grafanaServiceOpened);
    }
    if (prometheusServiceOpened) {
      res["PrometheusServiceOpened"] = boost::any(*prometheusServiceOpened);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DashboardVos") != m.end() && !m["DashboardVos"].empty()) {
      if (typeid(vector<boost::any>) == m["DashboardVos"].type()) {
        vector<ListDashboardsResponseBodyDashboardVos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DashboardVos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDashboardsResponseBodyDashboardVos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dashboardVos = make_shared<vector<ListDashboardsResponseBodyDashboardVos>>(expect1);
      }
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("GrafanaServiceOpened") != m.end() && !m["GrafanaServiceOpened"].empty()) {
      grafanaServiceOpened = make_shared<string>(boost::any_cast<string>(m["GrafanaServiceOpened"]));
    }
    if (m.find("PrometheusServiceOpened") != m.end() && !m["PrometheusServiceOpened"].empty()) {
      prometheusServiceOpened = make_shared<string>(boost::any_cast<string>(m["PrometheusServiceOpened"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDashboardsResponseBody() = default;
};
class ListDashboardsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDashboardsResponseBody> body{};

  ListDashboardsResponse() {}

  explicit ListDashboardsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDashboardsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDashboardsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDashboardsResponse() = default;
};
class ListDashboardsByNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> dashBoardName{};
  shared_ptr<string> dashBoardVersion{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> groupName{};
  shared_ptr<bool> onlyQuery{};
  shared_ptr<string> productCode{};
  shared_ptr<string> regionId{};

  ListDashboardsByNameRequest() {}

  explicit ListDashboardsByNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (dashBoardName) {
      res["DashBoardName"] = boost::any(*dashBoardName);
    }
    if (dashBoardVersion) {
      res["DashBoardVersion"] = boost::any(*dashBoardVersion);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (onlyQuery) {
      res["OnlyQuery"] = boost::any(*onlyQuery);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("DashBoardName") != m.end() && !m["DashBoardName"].empty()) {
      dashBoardName = make_shared<string>(boost::any_cast<string>(m["DashBoardName"]));
    }
    if (m.find("DashBoardVersion") != m.end() && !m["DashBoardVersion"].empty()) {
      dashBoardVersion = make_shared<string>(boost::any_cast<string>(m["DashBoardVersion"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("OnlyQuery") != m.end() && !m["OnlyQuery"].empty()) {
      onlyQuery = make_shared<bool>(boost::any_cast<bool>(m["OnlyQuery"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListDashboardsByNameRequest() = default;
};
class ListDashboardsByNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListDashboardsByNameResponseBody() {}

  explicit ListDashboardsByNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDashboardsByNameResponseBody() = default;
};
class ListDashboardsByNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDashboardsByNameResponseBody> body{};

  ListDashboardsByNameResponse() {}

  explicit ListDashboardsByNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDashboardsByNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDashboardsByNameResponseBody>(model1);
      }
    }
  }


  virtual ~ListDashboardsByNameResponse() = default;
};
class ListDispatchRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> system{};

  ListDispatchRuleRequest() {}

  explicit ListDispatchRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
  }


  virtual ~ListDispatchRuleRequest() = default;
};
class ListDispatchRuleResponseBodyDispatchRules : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> state{};

  ListDispatchRuleResponseBodyDispatchRules() {}

  explicit ListDispatchRuleResponseBodyDispatchRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListDispatchRuleResponseBodyDispatchRules() = default;
};
class ListDispatchRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDispatchRuleResponseBodyDispatchRules>> dispatchRules{};
  shared_ptr<string> requestId{};

  ListDispatchRuleResponseBody() {}

  explicit ListDispatchRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchRules) {
      vector<boost::any> temp1;
      for(auto item1:*dispatchRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DispatchRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchRules") != m.end() && !m["DispatchRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DispatchRules"].type()) {
        vector<ListDispatchRuleResponseBodyDispatchRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DispatchRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDispatchRuleResponseBodyDispatchRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dispatchRules = make_shared<vector<ListDispatchRuleResponseBodyDispatchRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDispatchRuleResponseBody() = default;
};
class ListDispatchRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDispatchRuleResponseBody> body{};

  ListDispatchRuleResponse() {}

  explicit ListDispatchRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDispatchRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDispatchRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ListDispatchRuleResponse() = default;
};
class ListEnvCustomJobsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> encryptYaml{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  ListEnvCustomJobsRequest() {}

  explicit ListEnvCustomJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryptYaml) {
      res["EncryptYaml"] = boost::any(*encryptYaml);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EncryptYaml") != m.end() && !m["EncryptYaml"].empty()) {
      encryptYaml = make_shared<bool>(boost::any_cast<bool>(m["EncryptYaml"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListEnvCustomJobsRequest() = default;
};
class ListEnvCustomJobsResponseBodyDataScrapeConfigs : public Darabonba::Model {
public:
  shared_ptr<string> jobName{};
  shared_ptr<string> metricsPath{};
  shared_ptr<vector<string>> scrapeDiscoverys{};
  shared_ptr<string> scrapeInterval{};

  ListEnvCustomJobsResponseBodyDataScrapeConfigs() {}

  explicit ListEnvCustomJobsResponseBodyDataScrapeConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (metricsPath) {
      res["MetricsPath"] = boost::any(*metricsPath);
    }
    if (scrapeDiscoverys) {
      res["ScrapeDiscoverys"] = boost::any(*scrapeDiscoverys);
    }
    if (scrapeInterval) {
      res["ScrapeInterval"] = boost::any(*scrapeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("MetricsPath") != m.end() && !m["MetricsPath"].empty()) {
      metricsPath = make_shared<string>(boost::any_cast<string>(m["MetricsPath"]));
    }
    if (m.find("ScrapeDiscoverys") != m.end() && !m["ScrapeDiscoverys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScrapeDiscoverys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScrapeDiscoverys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scrapeDiscoverys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScrapeInterval") != m.end() && !m["ScrapeInterval"].empty()) {
      scrapeInterval = make_shared<string>(boost::any_cast<string>(m["ScrapeInterval"]));
    }
  }


  virtual ~ListEnvCustomJobsResponseBodyDataScrapeConfigs() = default;
};
class ListEnvCustomJobsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<string> addonReleaseName{};
  shared_ptr<string> addonVersion{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> creationTimestamp{};
  shared_ptr<string> customJobName{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ListEnvCustomJobsResponseBodyDataScrapeConfigs>> scrapeConfigs{};
  shared_ptr<string> status{};

  ListEnvCustomJobsResponseBodyData() {}

  explicit ListEnvCustomJobsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (addonReleaseName) {
      res["AddonReleaseName"] = boost::any(*addonReleaseName);
    }
    if (addonVersion) {
      res["AddonVersion"] = boost::any(*addonVersion);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (creationTimestamp) {
      res["CreationTimestamp"] = boost::any(*creationTimestamp);
    }
    if (customJobName) {
      res["CustomJobName"] = boost::any(*customJobName);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scrapeConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*scrapeConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScrapeConfigs"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("AddonReleaseName") != m.end() && !m["AddonReleaseName"].empty()) {
      addonReleaseName = make_shared<string>(boost::any_cast<string>(m["AddonReleaseName"]));
    }
    if (m.find("AddonVersion") != m.end() && !m["AddonVersion"].empty()) {
      addonVersion = make_shared<string>(boost::any_cast<string>(m["AddonVersion"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("CreationTimestamp") != m.end() && !m["CreationTimestamp"].empty()) {
      creationTimestamp = make_shared<string>(boost::any_cast<string>(m["CreationTimestamp"]));
    }
    if (m.find("CustomJobName") != m.end() && !m["CustomJobName"].empty()) {
      customJobName = make_shared<string>(boost::any_cast<string>(m["CustomJobName"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScrapeConfigs") != m.end() && !m["ScrapeConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["ScrapeConfigs"].type()) {
        vector<ListEnvCustomJobsResponseBodyDataScrapeConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScrapeConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvCustomJobsResponseBodyDataScrapeConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scrapeConfigs = make_shared<vector<ListEnvCustomJobsResponseBodyDataScrapeConfigs>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListEnvCustomJobsResponseBodyData() = default;
};
class ListEnvCustomJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListEnvCustomJobsResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListEnvCustomJobsResponseBody() {}

  explicit ListEnvCustomJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListEnvCustomJobsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvCustomJobsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListEnvCustomJobsResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEnvCustomJobsResponseBody() = default;
};
class ListEnvCustomJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEnvCustomJobsResponseBody> body{};

  ListEnvCustomJobsResponse() {}

  explicit ListEnvCustomJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEnvCustomJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEnvCustomJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEnvCustomJobsResponse() = default;
};
class ListEnvPodMonitorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  ListEnvPodMonitorsRequest() {}

  explicit ListEnvPodMonitorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListEnvPodMonitorsRequest() = default;
};
class ListEnvPodMonitorsResponseBodyDataEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> interval{};
  shared_ptr<long> matchedTargetCount{};
  shared_ptr<string> path{};
  shared_ptr<string> port{};
  shared_ptr<long> targetPort{};

  ListEnvPodMonitorsResponseBodyDataEndpoints() {}

  explicit ListEnvPodMonitorsResponseBodyDataEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (matchedTargetCount) {
      res["MatchedTargetCount"] = boost::any(*matchedTargetCount);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("MatchedTargetCount") != m.end() && !m["MatchedTargetCount"].empty()) {
      matchedTargetCount = make_shared<long>(boost::any_cast<long>(m["MatchedTargetCount"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<long>(boost::any_cast<long>(m["TargetPort"]));
    }
  }


  virtual ~ListEnvPodMonitorsResponseBodyDataEndpoints() = default;
};
class ListEnvPodMonitorsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<string> addonReleaseName{};
  shared_ptr<string> addonVersion{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> creationTimestamp{};
  shared_ptr<vector<ListEnvPodMonitorsResponseBodyDataEndpoints>> endpoints{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> podMonitorName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  ListEnvPodMonitorsResponseBodyData() {}

  explicit ListEnvPodMonitorsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (addonReleaseName) {
      res["AddonReleaseName"] = boost::any(*addonReleaseName);
    }
    if (addonVersion) {
      res["AddonVersion"] = boost::any(*addonVersion);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (creationTimestamp) {
      res["CreationTimestamp"] = boost::any(*creationTimestamp);
    }
    if (endpoints) {
      vector<boost::any> temp1;
      for(auto item1:*endpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Endpoints"] = boost::any(temp1);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (podMonitorName) {
      res["PodMonitorName"] = boost::any(*podMonitorName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("AddonReleaseName") != m.end() && !m["AddonReleaseName"].empty()) {
      addonReleaseName = make_shared<string>(boost::any_cast<string>(m["AddonReleaseName"]));
    }
    if (m.find("AddonVersion") != m.end() && !m["AddonVersion"].empty()) {
      addonVersion = make_shared<string>(boost::any_cast<string>(m["AddonVersion"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("CreationTimestamp") != m.end() && !m["CreationTimestamp"].empty()) {
      creationTimestamp = make_shared<string>(boost::any_cast<string>(m["CreationTimestamp"]));
    }
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["Endpoints"].type()) {
        vector<ListEnvPodMonitorsResponseBodyDataEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Endpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvPodMonitorsResponseBodyDataEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpoints = make_shared<vector<ListEnvPodMonitorsResponseBodyDataEndpoints>>(expect1);
      }
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PodMonitorName") != m.end() && !m["PodMonitorName"].empty()) {
      podMonitorName = make_shared<string>(boost::any_cast<string>(m["PodMonitorName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListEnvPodMonitorsResponseBodyData() = default;
};
class ListEnvPodMonitorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListEnvPodMonitorsResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListEnvPodMonitorsResponseBody() {}

  explicit ListEnvPodMonitorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListEnvPodMonitorsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvPodMonitorsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListEnvPodMonitorsResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEnvPodMonitorsResponseBody() = default;
};
class ListEnvPodMonitorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEnvPodMonitorsResponseBody> body{};

  ListEnvPodMonitorsResponse() {}

  explicit ListEnvPodMonitorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEnvPodMonitorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEnvPodMonitorsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEnvPodMonitorsResponse() = default;
};
class ListEnvServiceMonitorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  ListEnvServiceMonitorsRequest() {}

  explicit ListEnvServiceMonitorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListEnvServiceMonitorsRequest() = default;
};
class ListEnvServiceMonitorsResponseBodyDataEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> interval{};
  shared_ptr<long> matchedTargetCount{};
  shared_ptr<string> path{};
  shared_ptr<string> port{};
  shared_ptr<long> targetPort{};

  ListEnvServiceMonitorsResponseBodyDataEndpoints() {}

  explicit ListEnvServiceMonitorsResponseBodyDataEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (matchedTargetCount) {
      res["MatchedTargetCount"] = boost::any(*matchedTargetCount);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("MatchedTargetCount") != m.end() && !m["MatchedTargetCount"].empty()) {
      matchedTargetCount = make_shared<long>(boost::any_cast<long>(m["MatchedTargetCount"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<long>(boost::any_cast<long>(m["TargetPort"]));
    }
  }


  virtual ~ListEnvServiceMonitorsResponseBodyDataEndpoints() = default;
};
class ListEnvServiceMonitorsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<string> addonReleaseName{};
  shared_ptr<string> addonVersion{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> creationTimestamp{};
  shared_ptr<vector<ListEnvServiceMonitorsResponseBodyDataEndpoints>> endpoints{};
  shared_ptr<string> environmentId{};
  shared_ptr<long> matchedServiceCount{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceMonitorName{};
  shared_ptr<string> status{};

  ListEnvServiceMonitorsResponseBodyData() {}

  explicit ListEnvServiceMonitorsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (addonReleaseName) {
      res["AddonReleaseName"] = boost::any(*addonReleaseName);
    }
    if (addonVersion) {
      res["AddonVersion"] = boost::any(*addonVersion);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (creationTimestamp) {
      res["CreationTimestamp"] = boost::any(*creationTimestamp);
    }
    if (endpoints) {
      vector<boost::any> temp1;
      for(auto item1:*endpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Endpoints"] = boost::any(temp1);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (matchedServiceCount) {
      res["MatchedServiceCount"] = boost::any(*matchedServiceCount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceMonitorName) {
      res["ServiceMonitorName"] = boost::any(*serviceMonitorName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("AddonReleaseName") != m.end() && !m["AddonReleaseName"].empty()) {
      addonReleaseName = make_shared<string>(boost::any_cast<string>(m["AddonReleaseName"]));
    }
    if (m.find("AddonVersion") != m.end() && !m["AddonVersion"].empty()) {
      addonVersion = make_shared<string>(boost::any_cast<string>(m["AddonVersion"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("CreationTimestamp") != m.end() && !m["CreationTimestamp"].empty()) {
      creationTimestamp = make_shared<string>(boost::any_cast<string>(m["CreationTimestamp"]));
    }
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["Endpoints"].type()) {
        vector<ListEnvServiceMonitorsResponseBodyDataEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Endpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvServiceMonitorsResponseBodyDataEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpoints = make_shared<vector<ListEnvServiceMonitorsResponseBodyDataEndpoints>>(expect1);
      }
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("MatchedServiceCount") != m.end() && !m["MatchedServiceCount"].empty()) {
      matchedServiceCount = make_shared<long>(boost::any_cast<long>(m["MatchedServiceCount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceMonitorName") != m.end() && !m["ServiceMonitorName"].empty()) {
      serviceMonitorName = make_shared<string>(boost::any_cast<string>(m["ServiceMonitorName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListEnvServiceMonitorsResponseBodyData() = default;
};
class ListEnvServiceMonitorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListEnvServiceMonitorsResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListEnvServiceMonitorsResponseBody() {}

  explicit ListEnvServiceMonitorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListEnvServiceMonitorsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvServiceMonitorsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListEnvServiceMonitorsResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEnvServiceMonitorsResponseBody() = default;
};
class ListEnvServiceMonitorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEnvServiceMonitorsResponseBody> body{};

  ListEnvServiceMonitorsResponse() {}

  explicit ListEnvServiceMonitorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEnvServiceMonitorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEnvServiceMonitorsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEnvServiceMonitorsResponse() = default;
};
class ListEnvironmentDashboardsRequest : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scene{};

  ListEnvironmentDashboardsRequest() {}

  explicit ListEnvironmentDashboardsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
  }


  virtual ~ListEnvironmentDashboardsRequest() = default;
};
class ListEnvironmentDashboardsResponseBodyDataDashboards : public Darabonba::Model {
public:
  shared_ptr<string> folderUid{};
  shared_ptr<string> region{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> uid{};
  shared_ptr<string> url{};

  ListEnvironmentDashboardsResponseBodyDataDashboards() {}

  explicit ListEnvironmentDashboardsResponseBodyDataDashboards(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderUid) {
      res["FolderUid"] = boost::any(*folderUid);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderUid") != m.end() && !m["FolderUid"].empty()) {
      folderUid = make_shared<string>(boost::any_cast<string>(m["FolderUid"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListEnvironmentDashboardsResponseBodyDataDashboards() = default;
};
class ListEnvironmentDashboardsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListEnvironmentDashboardsResponseBodyDataDashboards>> dashboards{};
  shared_ptr<long> total{};

  ListEnvironmentDashboardsResponseBodyData() {}

  explicit ListEnvironmentDashboardsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboards) {
      vector<boost::any> temp1;
      for(auto item1:*dashboards){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dashboards"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dashboards") != m.end() && !m["Dashboards"].empty()) {
      if (typeid(vector<boost::any>) == m["Dashboards"].type()) {
        vector<ListEnvironmentDashboardsResponseBodyDataDashboards> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dashboards"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvironmentDashboardsResponseBodyDataDashboards model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dashboards = make_shared<vector<ListEnvironmentDashboardsResponseBodyDataDashboards>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListEnvironmentDashboardsResponseBodyData() = default;
};
class ListEnvironmentDashboardsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListEnvironmentDashboardsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListEnvironmentDashboardsResponseBody() {}

  explicit ListEnvironmentDashboardsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListEnvironmentDashboardsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListEnvironmentDashboardsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListEnvironmentDashboardsResponseBody() = default;
};
class ListEnvironmentDashboardsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEnvironmentDashboardsResponseBody> body{};

  ListEnvironmentDashboardsResponse() {}

  explicit ListEnvironmentDashboardsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEnvironmentDashboardsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEnvironmentDashboardsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEnvironmentDashboardsResponse() = default;
};
class ListEnvironmentFeaturesRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};

  ListEnvironmentFeaturesRequest() {}

  explicit ListEnvironmentFeaturesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListEnvironmentFeaturesRequest() = default;
};
class ListEnvironmentFeaturesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<map<string, string>> config{};
  shared_ptr<string> description{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> icon{};
  shared_ptr<string> language{};
  shared_ptr<string> latestVersion{};
  shared_ptr<bool> managed{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> version{};

  ListEnvironmentFeaturesResponseBodyData() {}

  explicit ListEnvironmentFeaturesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (latestVersion) {
      res["LatestVersion"] = boost::any(*latestVersion);
    }
    if (managed) {
      res["Managed"] = boost::any(*managed);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Config"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      config = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LatestVersion") != m.end() && !m["LatestVersion"].empty()) {
      latestVersion = make_shared<string>(boost::any_cast<string>(m["LatestVersion"]));
    }
    if (m.find("Managed") != m.end() && !m["Managed"].empty()) {
      managed = make_shared<bool>(boost::any_cast<bool>(m["Managed"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListEnvironmentFeaturesResponseBodyData() = default;
};
class ListEnvironmentFeaturesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListEnvironmentFeaturesResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListEnvironmentFeaturesResponseBody() {}

  explicit ListEnvironmentFeaturesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListEnvironmentFeaturesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvironmentFeaturesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListEnvironmentFeaturesResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListEnvironmentFeaturesResponseBody() = default;
};
class ListEnvironmentFeaturesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEnvironmentFeaturesResponseBody> body{};

  ListEnvironmentFeaturesResponse() {}

  explicit ListEnvironmentFeaturesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEnvironmentFeaturesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEnvironmentFeaturesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEnvironmentFeaturesResponse() = default;
};
class ListEnvironmentsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListEnvironmentsRequestTag() {}

  explicit ListEnvironmentsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListEnvironmentsRequestTag() = default;
};
class ListEnvironmentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<string> bindResourceId{};
  shared_ptr<string> environmentType{};
  shared_ptr<string> feePackage{};
  shared_ptr<string> filterRegionIds{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListEnvironmentsRequestTag>> tag{};

  ListEnvironmentsRequest() {}

  explicit ListEnvironmentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (bindResourceId) {
      res["BindResourceId"] = boost::any(*bindResourceId);
    }
    if (environmentType) {
      res["EnvironmentType"] = boost::any(*environmentType);
    }
    if (feePackage) {
      res["FeePackage"] = boost::any(*feePackage);
    }
    if (filterRegionIds) {
      res["FilterRegionIds"] = boost::any(*filterRegionIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("BindResourceId") != m.end() && !m["BindResourceId"].empty()) {
      bindResourceId = make_shared<string>(boost::any_cast<string>(m["BindResourceId"]));
    }
    if (m.find("EnvironmentType") != m.end() && !m["EnvironmentType"].empty()) {
      environmentType = make_shared<string>(boost::any_cast<string>(m["EnvironmentType"]));
    }
    if (m.find("FeePackage") != m.end() && !m["FeePackage"].empty()) {
      feePackage = make_shared<string>(boost::any_cast<string>(m["FeePackage"]));
    }
    if (m.find("FilterRegionIds") != m.end() && !m["FilterRegionIds"].empty()) {
      filterRegionIds = make_shared<string>(boost::any_cast<string>(m["FilterRegionIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListEnvironmentsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvironmentsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListEnvironmentsRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListEnvironmentsRequest() = default;
};
class ListEnvironmentsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> addonName{};
  shared_ptr<string> bindResourceId{};
  shared_ptr<string> environmentType{};
  shared_ptr<string> feePackage{};
  shared_ptr<string> filterRegionIds{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> tagShrink{};

  ListEnvironmentsShrinkRequest() {}

  explicit ListEnvironmentsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonName) {
      res["AddonName"] = boost::any(*addonName);
    }
    if (bindResourceId) {
      res["BindResourceId"] = boost::any(*bindResourceId);
    }
    if (environmentType) {
      res["EnvironmentType"] = boost::any(*environmentType);
    }
    if (feePackage) {
      res["FeePackage"] = boost::any(*feePackage);
    }
    if (filterRegionIds) {
      res["FilterRegionIds"] = boost::any(*filterRegionIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tagShrink) {
      res["Tag"] = boost::any(*tagShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonName") != m.end() && !m["AddonName"].empty()) {
      addonName = make_shared<string>(boost::any_cast<string>(m["AddonName"]));
    }
    if (m.find("BindResourceId") != m.end() && !m["BindResourceId"].empty()) {
      bindResourceId = make_shared<string>(boost::any_cast<string>(m["BindResourceId"]));
    }
    if (m.find("EnvironmentType") != m.end() && !m["EnvironmentType"].empty()) {
      environmentType = make_shared<string>(boost::any_cast<string>(m["EnvironmentType"]));
    }
    if (m.find("FeePackage") != m.end() && !m["FeePackage"].empty()) {
      feePackage = make_shared<string>(boost::any_cast<string>(m["FeePackage"]));
    }
    if (m.find("FilterRegionIds") != m.end() && !m["FilterRegionIds"].empty()) {
      filterRegionIds = make_shared<string>(boost::any_cast<string>(m["FilterRegionIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tagShrink = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~ListEnvironmentsShrinkRequest() = default;
};
class ListEnvironmentsResponseBodyDataEnvironmentsAddons : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> description{};
  shared_ptr<string> icon{};
  shared_ptr<string> name{};

  ListEnvironmentsResponseBodyDataEnvironmentsAddons() {}

  explicit ListEnvironmentsResponseBodyDataEnvironmentsAddons(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListEnvironmentsResponseBodyDataEnvironmentsAddons() = default;
};
class ListEnvironmentsResponseBodyDataEnvironmentsFeatures : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> description{};
  shared_ptr<string> icon{};
  shared_ptr<string> name{};

  ListEnvironmentsResponseBodyDataEnvironmentsFeatures() {}

  explicit ListEnvironmentsResponseBodyDataEnvironmentsFeatures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListEnvironmentsResponseBodyDataEnvironmentsFeatures() = default;
};
class ListEnvironmentsResponseBodyDataEnvironmentsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListEnvironmentsResponseBodyDataEnvironmentsTags() {}

  explicit ListEnvironmentsResponseBodyDataEnvironmentsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListEnvironmentsResponseBodyDataEnvironmentsTags() = default;
};
class ListEnvironmentsResponseBodyDataEnvironments : public Darabonba::Model {
public:
  shared_ptr<vector<ListEnvironmentsResponseBodyDataEnvironmentsAddons>> addons{};
  shared_ptr<string> bindResourceId{};
  shared_ptr<string> bindResourceProfile{};
  shared_ptr<string> bindResourceType{};
  shared_ptr<string> bindVpcCidr{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createdUserId{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> environmentName{};
  shared_ptr<string> environmentType{};
  shared_ptr<vector<ListEnvironmentsResponseBodyDataEnvironmentsFeatures>> features{};
  shared_ptr<string> feePackage{};
  shared_ptr<string> grafanaDatasourceUid{};
  shared_ptr<string> grafanaFolderTitle{};
  shared_ptr<string> grafanaFolderUid{};
  shared_ptr<string> latestReleaseCreateTime{};
  shared_ptr<string> managedType{};
  shared_ptr<long> prometheusId{};
  shared_ptr<string> prometheusInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> releaseCount{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListEnvironmentsResponseBodyDataEnvironmentsTags>> tags{};
  shared_ptr<string> userId{};

  ListEnvironmentsResponseBodyDataEnvironments() {}

  explicit ListEnvironmentsResponseBodyDataEnvironments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addons) {
      vector<boost::any> temp1;
      for(auto item1:*addons){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addons"] = boost::any(temp1);
    }
    if (bindResourceId) {
      res["BindResourceId"] = boost::any(*bindResourceId);
    }
    if (bindResourceProfile) {
      res["BindResourceProfile"] = boost::any(*bindResourceProfile);
    }
    if (bindResourceType) {
      res["BindResourceType"] = boost::any(*bindResourceType);
    }
    if (bindVpcCidr) {
      res["BindVpcCidr"] = boost::any(*bindVpcCidr);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createdUserId) {
      res["CreatedUserId"] = boost::any(*createdUserId);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (environmentName) {
      res["EnvironmentName"] = boost::any(*environmentName);
    }
    if (environmentType) {
      res["EnvironmentType"] = boost::any(*environmentType);
    }
    if (features) {
      vector<boost::any> temp1;
      for(auto item1:*features){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Features"] = boost::any(temp1);
    }
    if (feePackage) {
      res["FeePackage"] = boost::any(*feePackage);
    }
    if (grafanaDatasourceUid) {
      res["GrafanaDatasourceUid"] = boost::any(*grafanaDatasourceUid);
    }
    if (grafanaFolderTitle) {
      res["GrafanaFolderTitle"] = boost::any(*grafanaFolderTitle);
    }
    if (grafanaFolderUid) {
      res["GrafanaFolderUid"] = boost::any(*grafanaFolderUid);
    }
    if (latestReleaseCreateTime) {
      res["LatestReleaseCreateTime"] = boost::any(*latestReleaseCreateTime);
    }
    if (managedType) {
      res["ManagedType"] = boost::any(*managedType);
    }
    if (prometheusId) {
      res["PrometheusId"] = boost::any(*prometheusId);
    }
    if (prometheusInstanceId) {
      res["PrometheusInstanceId"] = boost::any(*prometheusInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseCount) {
      res["ReleaseCount"] = boost::any(*releaseCount);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addons") != m.end() && !m["Addons"].empty()) {
      if (typeid(vector<boost::any>) == m["Addons"].type()) {
        vector<ListEnvironmentsResponseBodyDataEnvironmentsAddons> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addons"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvironmentsResponseBodyDataEnvironmentsAddons model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addons = make_shared<vector<ListEnvironmentsResponseBodyDataEnvironmentsAddons>>(expect1);
      }
    }
    if (m.find("BindResourceId") != m.end() && !m["BindResourceId"].empty()) {
      bindResourceId = make_shared<string>(boost::any_cast<string>(m["BindResourceId"]));
    }
    if (m.find("BindResourceProfile") != m.end() && !m["BindResourceProfile"].empty()) {
      bindResourceProfile = make_shared<string>(boost::any_cast<string>(m["BindResourceProfile"]));
    }
    if (m.find("BindResourceType") != m.end() && !m["BindResourceType"].empty()) {
      bindResourceType = make_shared<string>(boost::any_cast<string>(m["BindResourceType"]));
    }
    if (m.find("BindVpcCidr") != m.end() && !m["BindVpcCidr"].empty()) {
      bindVpcCidr = make_shared<string>(boost::any_cast<string>(m["BindVpcCidr"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatedUserId") != m.end() && !m["CreatedUserId"].empty()) {
      createdUserId = make_shared<string>(boost::any_cast<string>(m["CreatedUserId"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("EnvironmentName") != m.end() && !m["EnvironmentName"].empty()) {
      environmentName = make_shared<string>(boost::any_cast<string>(m["EnvironmentName"]));
    }
    if (m.find("EnvironmentType") != m.end() && !m["EnvironmentType"].empty()) {
      environmentType = make_shared<string>(boost::any_cast<string>(m["EnvironmentType"]));
    }
    if (m.find("Features") != m.end() && !m["Features"].empty()) {
      if (typeid(vector<boost::any>) == m["Features"].type()) {
        vector<ListEnvironmentsResponseBodyDataEnvironmentsFeatures> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Features"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvironmentsResponseBodyDataEnvironmentsFeatures model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        features = make_shared<vector<ListEnvironmentsResponseBodyDataEnvironmentsFeatures>>(expect1);
      }
    }
    if (m.find("FeePackage") != m.end() && !m["FeePackage"].empty()) {
      feePackage = make_shared<string>(boost::any_cast<string>(m["FeePackage"]));
    }
    if (m.find("GrafanaDatasourceUid") != m.end() && !m["GrafanaDatasourceUid"].empty()) {
      grafanaDatasourceUid = make_shared<string>(boost::any_cast<string>(m["GrafanaDatasourceUid"]));
    }
    if (m.find("GrafanaFolderTitle") != m.end() && !m["GrafanaFolderTitle"].empty()) {
      grafanaFolderTitle = make_shared<string>(boost::any_cast<string>(m["GrafanaFolderTitle"]));
    }
    if (m.find("GrafanaFolderUid") != m.end() && !m["GrafanaFolderUid"].empty()) {
      grafanaFolderUid = make_shared<string>(boost::any_cast<string>(m["GrafanaFolderUid"]));
    }
    if (m.find("LatestReleaseCreateTime") != m.end() && !m["LatestReleaseCreateTime"].empty()) {
      latestReleaseCreateTime = make_shared<string>(boost::any_cast<string>(m["LatestReleaseCreateTime"]));
    }
    if (m.find("ManagedType") != m.end() && !m["ManagedType"].empty()) {
      managedType = make_shared<string>(boost::any_cast<string>(m["ManagedType"]));
    }
    if (m.find("PrometheusId") != m.end() && !m["PrometheusId"].empty()) {
      prometheusId = make_shared<long>(boost::any_cast<long>(m["PrometheusId"]));
    }
    if (m.find("PrometheusInstanceId") != m.end() && !m["PrometheusInstanceId"].empty()) {
      prometheusInstanceId = make_shared<string>(boost::any_cast<string>(m["PrometheusInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseCount") != m.end() && !m["ReleaseCount"].empty()) {
      releaseCount = make_shared<long>(boost::any_cast<long>(m["ReleaseCount"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListEnvironmentsResponseBodyDataEnvironmentsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvironmentsResponseBodyDataEnvironmentsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListEnvironmentsResponseBodyDataEnvironmentsTags>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListEnvironmentsResponseBodyDataEnvironments() = default;
};
class ListEnvironmentsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListEnvironmentsResponseBodyDataEnvironments>> environments{};
  shared_ptr<long> total{};

  ListEnvironmentsResponseBodyData() {}

  explicit ListEnvironmentsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environments) {
      vector<boost::any> temp1;
      for(auto item1:*environments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Environments"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Environments") != m.end() && !m["Environments"].empty()) {
      if (typeid(vector<boost::any>) == m["Environments"].type()) {
        vector<ListEnvironmentsResponseBodyDataEnvironments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Environments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnvironmentsResponseBodyDataEnvironments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        environments = make_shared<vector<ListEnvironmentsResponseBodyDataEnvironments>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListEnvironmentsResponseBodyData() = default;
};
class ListEnvironmentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListEnvironmentsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListEnvironmentsResponseBody() {}

  explicit ListEnvironmentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListEnvironmentsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListEnvironmentsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListEnvironmentsResponseBody() = default;
};
class ListEnvironmentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEnvironmentsResponseBody> body{};

  ListEnvironmentsResponse() {}

  explicit ListEnvironmentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEnvironmentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEnvironmentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEnvironmentsResponse() = default;
};
class ListEscalationPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListEscalationPoliciesRequest() {}

  explicit ListEscalationPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListEscalationPoliciesRequest() = default;
};
class ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies() {}

  explicit ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies() = default;
};
class ListEscalationPoliciesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies>> escalationPolicies{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListEscalationPoliciesResponseBodyPageBean() {}

  explicit ListEscalationPoliciesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EscalationPolicies"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EscalationPolicies") != m.end() && !m["EscalationPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["EscalationPolicies"].type()) {
        vector<ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EscalationPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPolicies = make_shared<vector<ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListEscalationPoliciesResponseBodyPageBean() = default;
};
class ListEscalationPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListEscalationPoliciesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListEscalationPoliciesResponseBody() {}

  explicit ListEscalationPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListEscalationPoliciesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListEscalationPoliciesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEscalationPoliciesResponseBody() = default;
};
class ListEscalationPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEscalationPoliciesResponseBody> body{};

  ListEscalationPoliciesResponse() {}

  explicit ListEscalationPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEscalationPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEscalationPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEscalationPoliciesResponse() = default;
};
class ListEventBridgeIntegrationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListEventBridgeIntegrationsRequest() {}

  explicit ListEventBridgeIntegrationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListEventBridgeIntegrationsRequest() = default;
};
class ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations() {}

  explicit ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations() = default;
};
class ListEventBridgeIntegrationsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations>> eventBridgeIntegrations{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListEventBridgeIntegrationsResponseBodyPageBean() {}

  explicit ListEventBridgeIntegrationsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventBridgeIntegrations) {
      vector<boost::any> temp1;
      for(auto item1:*eventBridgeIntegrations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventBridgeIntegrations"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventBridgeIntegrations") != m.end() && !m["EventBridgeIntegrations"].empty()) {
      if (typeid(vector<boost::any>) == m["EventBridgeIntegrations"].type()) {
        vector<ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventBridgeIntegrations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventBridgeIntegrations = make_shared<vector<ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListEventBridgeIntegrationsResponseBodyPageBean() = default;
};
class ListEventBridgeIntegrationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListEventBridgeIntegrationsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListEventBridgeIntegrationsResponseBody() {}

  explicit ListEventBridgeIntegrationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListEventBridgeIntegrationsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListEventBridgeIntegrationsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEventBridgeIntegrationsResponseBody() = default;
};
class ListEventBridgeIntegrationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEventBridgeIntegrationsResponseBody> body{};

  ListEventBridgeIntegrationsResponse() {}

  explicit ListEventBridgeIntegrationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEventBridgeIntegrationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEventBridgeIntegrationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEventBridgeIntegrationsResponse() = default;
};
class ListGrafanaWorkspaceRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListGrafanaWorkspaceRequestTags() {}

  explicit ListGrafanaWorkspaceRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListGrafanaWorkspaceRequestTags() = default;
};
class ListGrafanaWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListGrafanaWorkspaceRequestTags>> tags{};

  ListGrafanaWorkspaceRequest() {}

  explicit ListGrafanaWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListGrafanaWorkspaceRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGrafanaWorkspaceRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListGrafanaWorkspaceRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListGrafanaWorkspaceRequest() = default;
};
class ListGrafanaWorkspaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> tagsShrink{};

  ListGrafanaWorkspaceShrinkRequest() {}

  explicit ListGrafanaWorkspaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ListGrafanaWorkspaceShrinkRequest() = default;
};
class ListGrafanaWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GrafanaWorkspace>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ListGrafanaWorkspaceResponseBody() {}

  explicit ListGrafanaWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GrafanaWorkspace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GrafanaWorkspace>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~ListGrafanaWorkspaceResponseBody() = default;
};
class ListGrafanaWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGrafanaWorkspaceResponseBody> body{};

  ListGrafanaWorkspaceResponse() {}

  explicit ListGrafanaWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGrafanaWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGrafanaWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~ListGrafanaWorkspaceResponse() = default;
};
class ListInsightsEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> insightsTypes{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  ListInsightsEventsRequest() {}

  explicit ListInsightsEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (insightsTypes) {
      res["InsightsTypes"] = boost::any(*insightsTypes);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InsightsTypes") != m.end() && !m["InsightsTypes"].empty()) {
      insightsTypes = make_shared<string>(boost::any_cast<string>(m["InsightsTypes"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListInsightsEventsRequest() = default;
};
class ListInsightsEventsResponseBodyInsightsEvents : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<string> desc{};
  shared_ptr<string> level{};
  shared_ptr<string> pid{};
  shared_ptr<string> problemId{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  ListInsightsEventsResponseBodyInsightsEvents() {}

  explicit ListInsightsEventsResponseBodyInsightsEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (problemId) {
      res["ProblemId"] = boost::any(*problemId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["Date"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("ProblemId") != m.end() && !m["ProblemId"].empty()) {
      problemId = make_shared<string>(boost::any_cast<string>(m["ProblemId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListInsightsEventsResponseBodyInsightsEvents() = default;
};
class ListInsightsEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListInsightsEventsResponseBodyInsightsEvents>> insightsEvents{};
  shared_ptr<string> requestId{};

  ListInsightsEventsResponseBody() {}

  explicit ListInsightsEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (insightsEvents) {
      vector<boost::any> temp1;
      for(auto item1:*insightsEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InsightsEvents"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InsightsEvents") != m.end() && !m["InsightsEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["InsightsEvents"].type()) {
        vector<ListInsightsEventsResponseBodyInsightsEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InsightsEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInsightsEventsResponseBodyInsightsEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insightsEvents = make_shared<vector<ListInsightsEventsResponseBodyInsightsEvents>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInsightsEventsResponseBody() = default;
};
class ListInsightsEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInsightsEventsResponseBody> body{};

  ListInsightsEventsResponse() {}

  explicit ListInsightsEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInsightsEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInsightsEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListInsightsEventsResponse() = default;
};
class ListIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<bool> isDetail{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListIntegrationRequest() {}

  explicit ListIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (isDetail) {
      res["IsDetail"] = boost::any(*isDetail);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("IsDetail") != m.end() && !m["IsDetail"].empty()) {
      isDetail = make_shared<bool>(boost::any_cast<bool>(m["IsDetail"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListIntegrationRequest() = default;
};
class ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail : public Darabonba::Model {
public:
  shared_ptr<bool> autoRecover{};
  shared_ptr<string> description{};
  shared_ptr<string> duplicateKey{};
  shared_ptr<vector<map<string, boost::any>>> extendedFieldRedefineRules{};
  shared_ptr<vector<map<string, boost::any>>> fieldRedefineRules{};
  shared_ptr<string> initiativeRecoverField{};
  shared_ptr<string> initiativeRecoverValue{};
  shared_ptr<long> recoverTime{};
  shared_ptr<vector<long>> stat{};

  ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail() {}

  explicit ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRecover) {
      res["AutoRecover"] = boost::any(*autoRecover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duplicateKey) {
      res["DuplicateKey"] = boost::any(*duplicateKey);
    }
    if (extendedFieldRedefineRules) {
      res["ExtendedFieldRedefineRules"] = boost::any(*extendedFieldRedefineRules);
    }
    if (fieldRedefineRules) {
      res["FieldRedefineRules"] = boost::any(*fieldRedefineRules);
    }
    if (initiativeRecoverField) {
      res["InitiativeRecoverField"] = boost::any(*initiativeRecoverField);
    }
    if (initiativeRecoverValue) {
      res["InitiativeRecoverValue"] = boost::any(*initiativeRecoverValue);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    if (stat) {
      res["Stat"] = boost::any(*stat);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRecover") != m.end() && !m["AutoRecover"].empty()) {
      autoRecover = make_shared<bool>(boost::any_cast<bool>(m["AutoRecover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DuplicateKey") != m.end() && !m["DuplicateKey"].empty()) {
      duplicateKey = make_shared<string>(boost::any_cast<string>(m["DuplicateKey"]));
    }
    if (m.find("ExtendedFieldRedefineRules") != m.end() && !m["ExtendedFieldRedefineRules"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["ExtendedFieldRedefineRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExtendedFieldRedefineRules"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      extendedFieldRedefineRules = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("FieldRedefineRules") != m.end() && !m["FieldRedefineRules"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["FieldRedefineRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldRedefineRules"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      fieldRedefineRules = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("InitiativeRecoverField") != m.end() && !m["InitiativeRecoverField"].empty()) {
      initiativeRecoverField = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverField"]));
    }
    if (m.find("InitiativeRecoverValue") != m.end() && !m["InitiativeRecoverValue"].empty()) {
      initiativeRecoverValue = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverValue"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
    if (m.find("Stat") != m.end() && !m["Stat"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Stat"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Stat"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      stat = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail() = default;
};
class ListIntegrationResponseBodyPageInfoIntegrations : public Darabonba::Model {
public:
  shared_ptr<string> apiEndpoint{};
  shared_ptr<string> createTime{};
  shared_ptr<ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail> integrationDetail{};
  shared_ptr<long> integrationId{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<string> liveness{};
  shared_ptr<string> shortToken{};
  shared_ptr<bool> state{};

  ListIntegrationResponseBodyPageInfoIntegrations() {}

  explicit ListIntegrationResponseBodyPageInfoIntegrations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiEndpoint) {
      res["ApiEndpoint"] = boost::any(*apiEndpoint);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (integrationDetail) {
      res["IntegrationDetail"] = integrationDetail ? boost::any(integrationDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (shortToken) {
      res["ShortToken"] = boost::any(*shortToken);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiEndpoint") != m.end() && !m["ApiEndpoint"].empty()) {
      apiEndpoint = make_shared<string>(boost::any_cast<string>(m["ApiEndpoint"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IntegrationDetail") != m.end() && !m["IntegrationDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["IntegrationDetail"].type()) {
        ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IntegrationDetail"]));
        integrationDetail = make_shared<ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail>(model1);
      }
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("ShortToken") != m.end() && !m["ShortToken"].empty()) {
      shortToken = make_shared<string>(boost::any_cast<string>(m["ShortToken"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<bool>(boost::any_cast<bool>(m["State"]));
    }
  }


  virtual ~ListIntegrationResponseBodyPageInfoIntegrations() = default;
};
class ListIntegrationResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListIntegrationResponseBodyPageInfoIntegrations>> integrations{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListIntegrationResponseBodyPageInfo() {}

  explicit ListIntegrationResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integrations) {
      vector<boost::any> temp1;
      for(auto item1:*integrations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Integrations"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Integrations") != m.end() && !m["Integrations"].empty()) {
      if (typeid(vector<boost::any>) == m["Integrations"].type()) {
        vector<ListIntegrationResponseBodyPageInfoIntegrations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Integrations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntegrationResponseBodyPageInfoIntegrations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        integrations = make_shared<vector<ListIntegrationResponseBodyPageInfoIntegrations>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListIntegrationResponseBodyPageInfo() = default;
};
class ListIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListIntegrationResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListIntegrationResponseBody() {}

  explicit ListIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListIntegrationResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListIntegrationResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIntegrationResponseBody() = default;
};
class ListIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntegrationResponseBody> body{};

  ListIntegrationResponse() {}

  explicit ListIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntegrationResponse() = default;
};
class ListNotificationPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> directedMode{};
  shared_ptr<string> ids{};
  shared_ptr<bool> isDetail{};
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};

  ListNotificationPoliciesRequest() {}

  explicit ListNotificationPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directedMode) {
      res["DirectedMode"] = boost::any(*directedMode);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (isDetail) {
      res["IsDetail"] = boost::any(*isDetail);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectedMode") != m.end() && !m["DirectedMode"].empty()) {
      directedMode = make_shared<bool>(boost::any_cast<bool>(m["DirectedMode"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("IsDetail") != m.end() && !m["IsDetail"].empty()) {
      isDetail = make_shared<bool>(boost::any_cast<bool>(m["IsDetail"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListNotificationPoliciesRequest() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule : public Darabonba::Model {
public:
  shared_ptr<long> groupInterval{};
  shared_ptr<long> groupWait{};
  shared_ptr<vector<string>> groupingFields{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInterval) {
      res["GroupInterval"] = boost::any(*groupInterval);
    }
    if (groupWait) {
      res["GroupWait"] = boost::any(*groupWait);
    }
    if (groupingFields) {
      res["GroupingFields"] = boost::any(*groupingFields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInterval") != m.end() && !m["GroupInterval"].empty()) {
      groupInterval = make_shared<long>(boost::any_cast<long>(m["GroupInterval"]));
    }
    if (m.find("GroupWait") != m.end() && !m["GroupWait"].empty()) {
      groupWait = make_shared<long>(boost::any_cast<long>(m["GroupWait"]));
    }
    if (m.find("GroupingFields") != m.end() && !m["GroupingFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupingFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupingFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupingFields = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions>> matchingConditions{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchingConditions) {
      vector<boost::any> temp1;
      for(auto item1:*matchingConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchingConditions") != m.end() && !m["MatchingConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingConditions"].type()) {
        vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingConditions = make_shared<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions>>(expect1);
      }
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<long> notifyObjectId{};
  shared_ptr<string> notifyObjectName{};
  shared_ptr<string> notifyObjectType{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyChannels) {
      res["NotifyChannels"] = boost::any(*notifyChannels);
    }
    if (notifyObjectId) {
      res["NotifyObjectId"] = boost::any(*notifyObjectId);
    }
    if (notifyObjectName) {
      res["NotifyObjectName"] = boost::any(*notifyObjectName);
    }
    if (notifyObjectType) {
      res["NotifyObjectType"] = boost::any(*notifyObjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyChannels") != m.end() && !m["NotifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyObjectId") != m.end() && !m["NotifyObjectId"].empty()) {
      notifyObjectId = make_shared<long>(boost::any_cast<long>(m["NotifyObjectId"]));
    }
    if (m.find("NotifyObjectName") != m.end() && !m["NotifyObjectName"].empty()) {
      notifyObjectName = make_shared<string>(boost::any_cast<string>(m["NotifyObjectName"]));
    }
    if (m.find("NotifyObjectType") != m.end() && !m["NotifyObjectType"].empty()) {
      notifyObjectType = make_shared<string>(boost::any_cast<string>(m["NotifyObjectType"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<string> notifyEndTime{};
  shared_ptr<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects>> notifyObjects{};
  shared_ptr<string> notifyStartTime{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyChannels) {
      res["NotifyChannels"] = boost::any(*notifyChannels);
    }
    if (notifyEndTime) {
      res["NotifyEndTime"] = boost::any(*notifyEndTime);
    }
    if (notifyObjects) {
      vector<boost::any> temp1;
      for(auto item1:*notifyObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotifyObjects"] = boost::any(temp1);
    }
    if (notifyStartTime) {
      res["NotifyStartTime"] = boost::any(*notifyStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyChannels") != m.end() && !m["NotifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyEndTime") != m.end() && !m["NotifyEndTime"].empty()) {
      notifyEndTime = make_shared<string>(boost::any_cast<string>(m["NotifyEndTime"]));
    }
    if (m.find("NotifyObjects") != m.end() && !m["NotifyObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["NotifyObjects"].type()) {
        vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotifyObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyObjects = make_shared<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects>>(expect1);
      }
    }
    if (m.find("NotifyStartTime") != m.end() && !m["NotifyStartTime"].empty()) {
      notifyStartTime = make_shared<string>(boost::any_cast<string>(m["NotifyStartTime"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> emailContent{};
  shared_ptr<string> emailRecoverContent{};
  shared_ptr<string> emailRecoverTitle{};
  shared_ptr<string> emailTitle{};
  shared_ptr<string> robotContent{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> smsRecoverContent{};
  shared_ptr<string> ttsContent{};
  shared_ptr<string> ttsRecoverContent{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emailContent) {
      res["EmailContent"] = boost::any(*emailContent);
    }
    if (emailRecoverContent) {
      res["EmailRecoverContent"] = boost::any(*emailRecoverContent);
    }
    if (emailRecoverTitle) {
      res["EmailRecoverTitle"] = boost::any(*emailRecoverTitle);
    }
    if (emailTitle) {
      res["EmailTitle"] = boost::any(*emailTitle);
    }
    if (robotContent) {
      res["RobotContent"] = boost::any(*robotContent);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (smsRecoverContent) {
      res["SmsRecoverContent"] = boost::any(*smsRecoverContent);
    }
    if (ttsContent) {
      res["TtsContent"] = boost::any(*ttsContent);
    }
    if (ttsRecoverContent) {
      res["TtsRecoverContent"] = boost::any(*ttsRecoverContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmailContent") != m.end() && !m["EmailContent"].empty()) {
      emailContent = make_shared<string>(boost::any_cast<string>(m["EmailContent"]));
    }
    if (m.find("EmailRecoverContent") != m.end() && !m["EmailRecoverContent"].empty()) {
      emailRecoverContent = make_shared<string>(boost::any_cast<string>(m["EmailRecoverContent"]));
    }
    if (m.find("EmailRecoverTitle") != m.end() && !m["EmailRecoverTitle"].empty()) {
      emailRecoverTitle = make_shared<string>(boost::any_cast<string>(m["EmailRecoverTitle"]));
    }
    if (m.find("EmailTitle") != m.end() && !m["EmailTitle"].empty()) {
      emailTitle = make_shared<string>(boost::any_cast<string>(m["EmailTitle"]));
    }
    if (m.find("RobotContent") != m.end() && !m["RobotContent"].empty()) {
      robotContent = make_shared<string>(boost::any_cast<string>(m["RobotContent"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SmsRecoverContent") != m.end() && !m["SmsRecoverContent"].empty()) {
      smsRecoverContent = make_shared<string>(boost::any_cast<string>(m["SmsRecoverContent"]));
    }
    if (m.find("TtsContent") != m.end() && !m["TtsContent"].empty()) {
      ttsContent = make_shared<string>(boost::any_cast<string>(m["TtsContent"]));
    }
    if (m.find("TtsRecoverContent") != m.end() && !m["TtsRecoverContent"].empty()) {
      ttsRecoverContent = make_shared<string>(boost::any_cast<string>(m["TtsRecoverContent"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies : public Darabonba::Model {
public:
  shared_ptr<bool> directedMode{};
  shared_ptr<long> escalationPolicyId{};
  shared_ptr<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule> groupRule{};
  shared_ptr<long> id{};
  shared_ptr<long> integrationId{};
  shared_ptr<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules>> matchingRules{};
  shared_ptr<string> name{};
  shared_ptr<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule> notifyRule{};
  shared_ptr<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate> notifyTemplate{};
  shared_ptr<bool> repeat{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<bool> sendRecoverMessage{};
  shared_ptr<string> state{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directedMode) {
      res["DirectedMode"] = boost::any(*directedMode);
    }
    if (escalationPolicyId) {
      res["EscalationPolicyId"] = boost::any(*escalationPolicyId);
    }
    if (groupRule) {
      res["GroupRule"] = groupRule ? boost::any(groupRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (matchingRules) {
      vector<boost::any> temp1;
      for(auto item1:*matchingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingRules"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyRule) {
      res["NotifyRule"] = notifyRule ? boost::any(notifyRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyTemplate) {
      res["NotifyTemplate"] = notifyTemplate ? boost::any(notifyTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (repeat) {
      res["Repeat"] = boost::any(*repeat);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (sendRecoverMessage) {
      res["SendRecoverMessage"] = boost::any(*sendRecoverMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectedMode") != m.end() && !m["DirectedMode"].empty()) {
      directedMode = make_shared<bool>(boost::any_cast<bool>(m["DirectedMode"]));
    }
    if (m.find("EscalationPolicyId") != m.end() && !m["EscalationPolicyId"].empty()) {
      escalationPolicyId = make_shared<long>(boost::any_cast<long>(m["EscalationPolicyId"]));
    }
    if (m.find("GroupRule") != m.end() && !m["GroupRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupRule"].type()) {
        ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupRule"]));
        groupRule = make_shared<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingRules"].type()) {
        vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingRules = make_shared<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyRule") != m.end() && !m["NotifyRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyRule"].type()) {
        ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyRule"]));
        notifyRule = make_shared<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule>(model1);
      }
    }
    if (m.find("NotifyTemplate") != m.end() && !m["NotifyTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyTemplate"].type()) {
        ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyTemplate"]));
        notifyTemplate = make_shared<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate>(model1);
      }
    }
    if (m.find("Repeat") != m.end() && !m["Repeat"].empty()) {
      repeat = make_shared<bool>(boost::any_cast<bool>(m["Repeat"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("SendRecoverMessage") != m.end() && !m["SendRecoverMessage"].empty()) {
      sendRecoverMessage = make_shared<bool>(boost::any_cast<bool>(m["SendRecoverMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies() = default;
};
class ListNotificationPoliciesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies>> notificationPolicies{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListNotificationPoliciesResponseBodyPageBean() {}

  explicit ListNotificationPoliciesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*notificationPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationPolicies"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationPolicies") != m.end() && !m["NotificationPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationPolicies"].type()) {
        vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationPolicies = make_shared<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBean() = default;
};
class ListNotificationPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListNotificationPoliciesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListNotificationPoliciesResponseBody() {}

  explicit ListNotificationPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListNotificationPoliciesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListNotificationPoliciesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBody() = default;
};
class ListNotificationPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNotificationPoliciesResponseBody> body{};

  ListNotificationPoliciesResponse() {}

  explicit ListNotificationPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNotificationPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNotificationPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNotificationPoliciesResponse() = default;
};
class ListOnCallSchedulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListOnCallSchedulesRequest() {}

  explicit ListOnCallSchedulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListOnCallSchedulesRequest() = default;
};
class ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules() {}

  explicit ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules() = default;
};
class ListOnCallSchedulesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules>> onCallSchedules{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListOnCallSchedulesResponseBodyPageBean() {}

  explicit ListOnCallSchedulesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onCallSchedules) {
      vector<boost::any> temp1;
      for(auto item1:*onCallSchedules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OnCallSchedules"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnCallSchedules") != m.end() && !m["OnCallSchedules"].empty()) {
      if (typeid(vector<boost::any>) == m["OnCallSchedules"].type()) {
        vector<ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OnCallSchedules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        onCallSchedules = make_shared<vector<ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListOnCallSchedulesResponseBodyPageBean() = default;
};
class ListOnCallSchedulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListOnCallSchedulesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListOnCallSchedulesResponseBody() {}

  explicit ListOnCallSchedulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListOnCallSchedulesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListOnCallSchedulesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListOnCallSchedulesResponseBody() = default;
};
class ListOnCallSchedulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOnCallSchedulesResponseBody> body{};

  ListOnCallSchedulesResponse() {}

  explicit ListOnCallSchedulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOnCallSchedulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOnCallSchedulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListOnCallSchedulesResponse() = default;
};
class ListPrometheusAlertRulesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListPrometheusAlertRulesRequestTags() {}

  explicit ListPrometheusAlertRulesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertRulesRequestTags() = default;
};
class ListPrometheusAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> matchExpressions{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};
  shared_ptr<vector<ListPrometheusAlertRulesRequestTags>> tags{};
  shared_ptr<string> type{};

  ListPrometheusAlertRulesRequest() {}

  explicit ListPrometheusAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (matchExpressions) {
      res["MatchExpressions"] = boost::any(*matchExpressions);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MatchExpressions") != m.end() && !m["MatchExpressions"].empty()) {
      matchExpressions = make_shared<string>(boost::any_cast<string>(m["MatchExpressions"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListPrometheusAlertRulesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertRulesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListPrometheusAlertRulesRequestTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPrometheusAlertRulesRequest() = default;
};
class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations() {}

  explicit ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations() = default;
};
class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels() {}

  explicit ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels() = default;
};
class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags() {}

  explicit ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags() = default;
};
class ListPrometheusAlertRulesResponseBodyPrometheusAlertRules : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations>> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels>> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> status{};
  shared_ptr<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags>> tags{};
  shared_ptr<string> type{};

  ListPrometheusAlertRulesResponseBodyPrometheusAlertRules() {}

  explicit ListPrometheusAlertRulesResponseBodyPrometheusAlertRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations>>(expect1);
      }
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPrometheusAlertRulesResponseBodyPrometheusAlertRules() = default;
};
class ListPrometheusAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRules>> prometheusAlertRules{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListPrometheusAlertRulesResponseBody() {}

  explicit ListPrometheusAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (prometheusAlertRules) {
      vector<boost::any> temp1;
      for(auto item1:*prometheusAlertRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrometheusAlertRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PrometheusAlertRules") != m.end() && !m["PrometheusAlertRules"].empty()) {
      if (typeid(vector<boost::any>) == m["PrometheusAlertRules"].type()) {
        vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrometheusAlertRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertRulesResponseBodyPrometheusAlertRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prometheusAlertRules = make_shared<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListPrometheusAlertRulesResponseBody() = default;
};
class ListPrometheusAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusAlertRulesResponseBody> body{};

  ListPrometheusAlertRulesResponse() {}

  explicit ListPrometheusAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusAlertRulesResponse() = default;
};
class ListPrometheusAlertTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  ListPrometheusAlertTemplatesRequest() {}

  explicit ListPrometheusAlertTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListPrometheusAlertTemplatesRequest() = default;
};
class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations() {}

  explicit ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations() = default;
};
class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels() {}

  explicit ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels() = default;
};
class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations>> annotations{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels>> labels{};
  shared_ptr<string> type{};
  shared_ptr<string> version{};

  ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates() {}

  explicit ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates() = default;
};
class ListPrometheusAlertTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates>> prometheusAlertTemplates{};
  shared_ptr<string> requestId{};

  ListPrometheusAlertTemplatesResponseBody() {}

  explicit ListPrometheusAlertTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prometheusAlertTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*prometheusAlertTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrometheusAlertTemplates"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrometheusAlertTemplates") != m.end() && !m["PrometheusAlertTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["PrometheusAlertTemplates"].type()) {
        vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrometheusAlertTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prometheusAlertTemplates = make_shared<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusAlertTemplatesResponseBody() = default;
};
class ListPrometheusAlertTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusAlertTemplatesResponseBody> body{};

  ListPrometheusAlertTemplatesResponse() {}

  explicit ListPrometheusAlertTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusAlertTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusAlertTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusAlertTemplatesResponse() = default;
};
class ListPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  ListPrometheusGlobalViewRequest() {}

  explicit ListPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListPrometheusGlobalViewRequest() = default;
};
class ListPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrometheusGlobalViewResponseBody() {}

  explicit ListPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusGlobalViewResponseBody() = default;
};
class ListPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusGlobalViewResponseBody> body{};

  ListPrometheusGlobalViewResponse() {}

  explicit ListPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusGlobalViewResponse() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListPrometheusInstanceByTagAndResourceGroupIdRequestTag() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdRequestTag() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListPrometheusInstanceByTagAndResourceGroupIdRequestTag>> tag{};

  ListPrometheusInstanceByTagAndResourceGroupIdRequest() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListPrometheusInstanceByTagAndResourceGroupIdRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusInstanceByTagAndResourceGroupIdRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListPrometheusInstanceByTagAndResourceGroupIdRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdRequest() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances : public Darabonba::Model {
public:
  shared_ptr<string> authToken{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> grafanaInstanceId{};
  shared_ptr<string> httpApiInterUrl{};
  shared_ptr<string> httpApiIntraUrl{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> pushGatewayInterUrl{};
  shared_ptr<string> pushGatewayIntraUrl{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteReadInterUrl{};
  shared_ptr<string> remoteReadIntraUrl{};
  shared_ptr<string> remoteWriteInterUrl{};
  shared_ptr<string> remoteWriteIntraUrl{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> subClustersJson{};
  shared_ptr<vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags>> tags{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (grafanaInstanceId) {
      res["GrafanaInstanceId"] = boost::any(*grafanaInstanceId);
    }
    if (httpApiInterUrl) {
      res["HttpApiInterUrl"] = boost::any(*httpApiInterUrl);
    }
    if (httpApiIntraUrl) {
      res["HttpApiIntraUrl"] = boost::any(*httpApiIntraUrl);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (pushGatewayInterUrl) {
      res["PushGatewayInterUrl"] = boost::any(*pushGatewayInterUrl);
    }
    if (pushGatewayIntraUrl) {
      res["PushGatewayIntraUrl"] = boost::any(*pushGatewayIntraUrl);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteReadInterUrl) {
      res["RemoteReadInterUrl"] = boost::any(*remoteReadInterUrl);
    }
    if (remoteReadIntraUrl) {
      res["RemoteReadIntraUrl"] = boost::any(*remoteReadIntraUrl);
    }
    if (remoteWriteInterUrl) {
      res["RemoteWriteInterUrl"] = boost::any(*remoteWriteInterUrl);
    }
    if (remoteWriteIntraUrl) {
      res["RemoteWriteIntraUrl"] = boost::any(*remoteWriteIntraUrl);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (subClustersJson) {
      res["SubClustersJson"] = boost::any(*subClustersJson);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<string>(boost::any_cast<string>(m["AuthToken"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("GrafanaInstanceId") != m.end() && !m["GrafanaInstanceId"].empty()) {
      grafanaInstanceId = make_shared<string>(boost::any_cast<string>(m["GrafanaInstanceId"]));
    }
    if (m.find("HttpApiInterUrl") != m.end() && !m["HttpApiInterUrl"].empty()) {
      httpApiInterUrl = make_shared<string>(boost::any_cast<string>(m["HttpApiInterUrl"]));
    }
    if (m.find("HttpApiIntraUrl") != m.end() && !m["HttpApiIntraUrl"].empty()) {
      httpApiIntraUrl = make_shared<string>(boost::any_cast<string>(m["HttpApiIntraUrl"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("PushGatewayInterUrl") != m.end() && !m["PushGatewayInterUrl"].empty()) {
      pushGatewayInterUrl = make_shared<string>(boost::any_cast<string>(m["PushGatewayInterUrl"]));
    }
    if (m.find("PushGatewayIntraUrl") != m.end() && !m["PushGatewayIntraUrl"].empty()) {
      pushGatewayIntraUrl = make_shared<string>(boost::any_cast<string>(m["PushGatewayIntraUrl"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteReadInterUrl") != m.end() && !m["RemoteReadInterUrl"].empty()) {
      remoteReadInterUrl = make_shared<string>(boost::any_cast<string>(m["RemoteReadInterUrl"]));
    }
    if (m.find("RemoteReadIntraUrl") != m.end() && !m["RemoteReadIntraUrl"].empty()) {
      remoteReadIntraUrl = make_shared<string>(boost::any_cast<string>(m["RemoteReadIntraUrl"]));
    }
    if (m.find("RemoteWriteInterUrl") != m.end() && !m["RemoteWriteInterUrl"].empty()) {
      remoteWriteInterUrl = make_shared<string>(boost::any_cast<string>(m["RemoteWriteInterUrl"]));
    }
    if (m.find("RemoteWriteIntraUrl") != m.end() && !m["RemoteWriteIntraUrl"].empty()) {
      remoteWriteIntraUrl = make_shared<string>(boost::any_cast<string>(m["RemoteWriteIntraUrl"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SubClustersJson") != m.end() && !m["SubClustersJson"].empty()) {
      subClustersJson = make_shared<string>(boost::any_cast<string>(m["SubClustersJson"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances>> prometheusInstances{};

  ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prometheusInstances) {
      vector<boost::any> temp1;
      for(auto item1:*prometheusInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrometheusInstances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrometheusInstances") != m.end() && !m["PrometheusInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["PrometheusInstances"].type()) {
        vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrometheusInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prometheusInstances = make_shared<vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances>>(expect1);
      }
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrometheusInstanceByTagAndResourceGroupIdResponseBody() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdResponseBody() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusInstanceByTagAndResourceGroupIdResponseBody> body{};

  ListPrometheusInstanceByTagAndResourceGroupIdResponse() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusInstanceByTagAndResourceGroupIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusInstanceByTagAndResourceGroupIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdResponse() = default;
};
class ListPrometheusInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> showGlobalView{};

  ListPrometheusInstancesRequest() {}

  explicit ListPrometheusInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showGlobalView) {
      res["ShowGlobalView"] = boost::any(*showGlobalView);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowGlobalView") != m.end() && !m["ShowGlobalView"].empty()) {
      showGlobalView = make_shared<bool>(boost::any_cast<bool>(m["ShowGlobalView"]));
    }
  }


  virtual ~ListPrometheusInstancesRequest() = default;
};
class ListPrometheusInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrometheusInstancesResponseBody() {}

  explicit ListPrometheusInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusInstancesResponseBody() = default;
};
class ListPrometheusInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusInstancesResponseBody> body{};

  ListPrometheusInstancesResponse() {}

  explicit ListPrometheusInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusInstancesResponse() = default;
};
class ListPrometheusIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> regionId{};

  ListPrometheusIntegrationRequest() {}

  explicit ListPrometheusIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListPrometheusIntegrationRequest() = default;
};
class ListPrometheusIntegrationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> canDelete{};
  shared_ptr<bool> canEditor{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerName{};
  shared_ptr<string> describe{};
  shared_ptr<string> exporterType{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> namespace_{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> param{};
  shared_ptr<string> podName{};
  shared_ptr<bool> showDescribe{};
  shared_ptr<bool> showLog{};
  shared_ptr<string> status{};
  shared_ptr<string> target{};
  shared_ptr<string> version{};

  ListPrometheusIntegrationResponseBodyData() {}

  explicit ListPrometheusIntegrationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canDelete) {
      res["CanDelete"] = boost::any(*canDelete);
    }
    if (canEditor) {
      res["CanEditor"] = boost::any(*canEditor);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (exporterType) {
      res["ExporterType"] = boost::any(*exporterType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (showDescribe) {
      res["ShowDescribe"] = boost::any(*showDescribe);
    }
    if (showLog) {
      res["ShowLog"] = boost::any(*showLog);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanDelete") != m.end() && !m["CanDelete"].empty()) {
      canDelete = make_shared<bool>(boost::any_cast<bool>(m["CanDelete"]));
    }
    if (m.find("CanEditor") != m.end() && !m["CanEditor"].empty()) {
      canEditor = make_shared<bool>(boost::any_cast<bool>(m["CanEditor"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("ExporterType") != m.end() && !m["ExporterType"].empty()) {
      exporterType = make_shared<string>(boost::any_cast<string>(m["ExporterType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("ShowDescribe") != m.end() && !m["ShowDescribe"].empty()) {
      showDescribe = make_shared<bool>(boost::any_cast<bool>(m["ShowDescribe"]));
    }
    if (m.find("ShowLog") != m.end() && !m["ShowLog"].empty()) {
      showLog = make_shared<bool>(boost::any_cast<bool>(m["ShowLog"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListPrometheusIntegrationResponseBodyData() = default;
};
class ListPrometheusIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListPrometheusIntegrationResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrometheusIntegrationResponseBody() {}

  explicit ListPrometheusIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListPrometheusIntegrationResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusIntegrationResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListPrometheusIntegrationResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusIntegrationResponseBody() = default;
};
class ListPrometheusIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusIntegrationResponseBody> body{};

  ListPrometheusIntegrationResponse() {}

  explicit ListPrometheusIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusIntegrationResponse() = default;
};
class ListPrometheusMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  ListPrometheusMonitoringRequest() {}

  explicit ListPrometheusMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPrometheusMonitoringRequest() = default;
};
class ListPrometheusMonitoringResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListPrometheusMonitoringResponseBodyData() {}

  explicit ListPrometheusMonitoringResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPrometheusMonitoringResponseBodyData() = default;
};
class ListPrometheusMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListPrometheusMonitoringResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrometheusMonitoringResponseBody() {}

  explicit ListPrometheusMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListPrometheusMonitoringResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusMonitoringResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListPrometheusMonitoringResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusMonitoringResponseBody() = default;
};
class ListPrometheusMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusMonitoringResponseBody> body{};

  ListPrometheusMonitoringResponse() {}

  explicit ListPrometheusMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusMonitoringResponse() = default;
};
class ListRetcodeAppsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListRetcodeAppsRequestTags() {}

  explicit ListRetcodeAppsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListRetcodeAppsRequestTags() = default;
};
class ListRetcodeAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListRetcodeAppsRequestTags>> tags{};

  ListRetcodeAppsRequest() {}

  explicit ListRetcodeAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListRetcodeAppsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRetcodeAppsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListRetcodeAppsRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListRetcodeAppsRequest() = default;
};
class ListRetcodeAppsResponseBodyRetcodeAppsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListRetcodeAppsResponseBodyRetcodeAppsTags() {}

  explicit ListRetcodeAppsResponseBodyRetcodeAppsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListRetcodeAppsResponseBodyRetcodeAppsTags() = default;
};
class ListRetcodeAppsResponseBodyRetcodeApps : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> nickName{};
  shared_ptr<string> pid{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> retcodeAppType{};
  shared_ptr<vector<ListRetcodeAppsResponseBodyRetcodeAppsTags>> tags{};

  ListRetcodeAppsResponseBodyRetcodeApps() {}

  explicit ListRetcodeAppsResponseBodyRetcodeApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retcodeAppType) {
      res["RetcodeAppType"] = boost::any(*retcodeAppType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetcodeAppType") != m.end() && !m["RetcodeAppType"].empty()) {
      retcodeAppType = make_shared<string>(boost::any_cast<string>(m["RetcodeAppType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListRetcodeAppsResponseBodyRetcodeAppsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRetcodeAppsResponseBodyRetcodeAppsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListRetcodeAppsResponseBodyRetcodeAppsTags>>(expect1);
      }
    }
  }


  virtual ~ListRetcodeAppsResponseBodyRetcodeApps() = default;
};
class ListRetcodeAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRetcodeAppsResponseBodyRetcodeApps>> retcodeApps{};

  ListRetcodeAppsResponseBody() {}

  explicit ListRetcodeAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retcodeApps) {
      vector<boost::any> temp1;
      for(auto item1:*retcodeApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RetcodeApps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetcodeApps") != m.end() && !m["RetcodeApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RetcodeApps"].type()) {
        vector<ListRetcodeAppsResponseBodyRetcodeApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RetcodeApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRetcodeAppsResponseBodyRetcodeApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        retcodeApps = make_shared<vector<ListRetcodeAppsResponseBodyRetcodeApps>>(expect1);
      }
    }
  }


  virtual ~ListRetcodeAppsResponseBody() = default;
};
class ListRetcodeAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRetcodeAppsResponseBody> body{};

  ListRetcodeAppsResponse() {}

  explicit ListRetcodeAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRetcodeAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRetcodeAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRetcodeAppsResponse() = default;
};
class ListScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scenario{};
  shared_ptr<string> sign{};

  ListScenarioRequest() {}

  explicit ListScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
  }


  virtual ~ListScenarioRequest() = default;
};
class ListScenarioResponseBodyArmsScenarios : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> extensions{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sign{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> userId{};

  ListScenarioResponseBodyArmsScenarios() {}

  explicit ListScenarioResponseBodyArmsScenarios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extensions) {
      res["Extensions"] = boost::any(*extensions);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Extensions") != m.end() && !m["Extensions"].empty()) {
      extensions = make_shared<string>(boost::any_cast<string>(m["Extensions"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListScenarioResponseBodyArmsScenarios() = default;
};
class ListScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListScenarioResponseBodyArmsScenarios>> armsScenarios{};
  shared_ptr<string> requestId{};

  ListScenarioResponseBody() {}

  explicit ListScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsScenarios) {
      vector<boost::any> temp1;
      for(auto item1:*armsScenarios){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ArmsScenarios"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmsScenarios") != m.end() && !m["ArmsScenarios"].empty()) {
      if (typeid(vector<boost::any>) == m["ArmsScenarios"].type()) {
        vector<ListScenarioResponseBodyArmsScenarios> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ArmsScenarios"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenarioResponseBodyArmsScenarios model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        armsScenarios = make_shared<vector<ListScenarioResponseBodyArmsScenarios>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListScenarioResponseBody() = default;
};
class ListScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScenarioResponseBody> body{};

  ListScenarioResponse() {}

  explicit ListScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~ListScenarioResponse() = default;
};
class ListSilencePoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> isDetail{};
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};

  ListSilencePoliciesRequest() {}

  explicit ListSilencePoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isDetail) {
      res["IsDetail"] = boost::any(*isDetail);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsDetail") != m.end() && !m["IsDetail"].empty()) {
      isDetail = make_shared<bool>(boost::any_cast<bool>(m["IsDetail"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListSilencePoliciesRequest() = default;
};
class ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions() {}

  explicit ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions() = default;
};
class ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions>> matchingConditions{};

  ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules() {}

  explicit ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchingConditions) {
      vector<boost::any> temp1;
      for(auto item1:*matchingConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchingConditions") != m.end() && !m["MatchingConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingConditions"].type()) {
        vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingConditions = make_shared<vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions>>(expect1);
      }
    }
  }


  virtual ~ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules() = default;
};
class ListSilencePoliciesResponseBodyPageBeanSilencePolicies : public Darabonba::Model {
public:
  shared_ptr<string> effectiveTimeType{};
  shared_ptr<long> id{};
  shared_ptr<vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules>> matchingRules{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> timePeriod{};
  shared_ptr<string> timeSlots{};

  ListSilencePoliciesResponseBodyPageBeanSilencePolicies() {}

  explicit ListSilencePoliciesResponseBodyPageBeanSilencePolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveTimeType) {
      res["EffectiveTimeType"] = boost::any(*effectiveTimeType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchingRules) {
      vector<boost::any> temp1;
      for(auto item1:*matchingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingRules"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timePeriod) {
      res["TimePeriod"] = boost::any(*timePeriod);
    }
    if (timeSlots) {
      res["TimeSlots"] = boost::any(*timeSlots);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveTimeType") != m.end() && !m["EffectiveTimeType"].empty()) {
      effectiveTimeType = make_shared<string>(boost::any_cast<string>(m["EffectiveTimeType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingRules"].type()) {
        vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingRules = make_shared<vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TimePeriod") != m.end() && !m["TimePeriod"].empty()) {
      timePeriod = make_shared<string>(boost::any_cast<string>(m["TimePeriod"]));
    }
    if (m.find("TimeSlots") != m.end() && !m["TimeSlots"].empty()) {
      timeSlots = make_shared<string>(boost::any_cast<string>(m["TimeSlots"]));
    }
  }


  virtual ~ListSilencePoliciesResponseBodyPageBeanSilencePolicies() = default;
};
class ListSilencePoliciesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<vector<ListSilencePoliciesResponseBodyPageBeanSilencePolicies>> silencePolicies{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListSilencePoliciesResponseBodyPageBean() {}

  explicit ListSilencePoliciesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (silencePolicies) {
      vector<boost::any> temp1;
      for(auto item1:*silencePolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SilencePolicies"] = boost::any(temp1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("SilencePolicies") != m.end() && !m["SilencePolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["SilencePolicies"].type()) {
        vector<ListSilencePoliciesResponseBodyPageBeanSilencePolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SilencePolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSilencePoliciesResponseBodyPageBeanSilencePolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        silencePolicies = make_shared<vector<ListSilencePoliciesResponseBodyPageBeanSilencePolicies>>(expect1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSilencePoliciesResponseBodyPageBean() = default;
};
class ListSilencePoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSilencePoliciesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListSilencePoliciesResponseBody() {}

  explicit ListSilencePoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListSilencePoliciesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListSilencePoliciesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSilencePoliciesResponseBody() = default;
};
class ListSilencePoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSilencePoliciesResponseBody> body{};

  ListSilencePoliciesResponse() {}

  explicit ListSilencePoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSilencePoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSilencePoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSilencePoliciesResponse() = default;
};
class ListSyntheticDetailRequestAdvancedFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opType{};
  shared_ptr<boost::any> value{};

  ListSyntheticDetailRequestAdvancedFilters() {}

  explicit ListSyntheticDetailRequestAdvancedFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<boost::any>(boost::any_cast<boost::any>(m["Value"]));
    }
  }


  virtual ~ListSyntheticDetailRequestAdvancedFilters() = default;
};
class ListSyntheticDetailRequestExactFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opType{};
  shared_ptr<boost::any> value{};

  ListSyntheticDetailRequestExactFilters() {}

  explicit ListSyntheticDetailRequestExactFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<boost::any>(boost::any_cast<boost::any>(m["Value"]));
    }
  }


  virtual ~ListSyntheticDetailRequestExactFilters() = default;
};
class ListSyntheticDetailRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ListSyntheticDetailRequestAdvancedFilters>> advancedFilters{};
  shared_ptr<string> category{};
  shared_ptr<string> detail{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<ListSyntheticDetailRequestExactFilters>> exactFilters{};
  shared_ptr<map<string, string>> filters{};
  shared_ptr<string> order{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> syntheticType{};

  ListSyntheticDetailRequest() {}

  explicit ListSyntheticDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedFilters) {
      vector<boost::any> temp1;
      for(auto item1:*advancedFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdvancedFilters"] = boost::any(temp1);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (exactFilters) {
      vector<boost::any> temp1;
      for(auto item1:*exactFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExactFilters"] = boost::any(temp1);
    }
    if (filters) {
      res["Filters"] = boost::any(*filters);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (syntheticType) {
      res["SyntheticType"] = boost::any(*syntheticType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvancedFilters") != m.end() && !m["AdvancedFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["AdvancedFilters"].type()) {
        vector<ListSyntheticDetailRequestAdvancedFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdvancedFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSyntheticDetailRequestAdvancedFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        advancedFilters = make_shared<vector<ListSyntheticDetailRequestAdvancedFilters>>(expect1);
      }
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExactFilters") != m.end() && !m["ExactFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["ExactFilters"].type()) {
        vector<ListSyntheticDetailRequestExactFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExactFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSyntheticDetailRequestExactFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        exactFilters = make_shared<vector<ListSyntheticDetailRequestExactFilters>>(expect1);
      }
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Filters"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      filters = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("SyntheticType") != m.end() && !m["SyntheticType"].empty()) {
      syntheticType = make_shared<long>(boost::any_cast<long>(m["SyntheticType"]));
    }
  }


  virtual ~ListSyntheticDetailRequest() = default;
};
class ListSyntheticDetailShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> advancedFiltersShrink{};
  shared_ptr<string> category{};
  shared_ptr<string> detail{};
  shared_ptr<long> endTime{};
  shared_ptr<string> exactFiltersShrink{};
  shared_ptr<string> filtersShrink{};
  shared_ptr<string> order{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> syntheticType{};

  ListSyntheticDetailShrinkRequest() {}

  explicit ListSyntheticDetailShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedFiltersShrink) {
      res["AdvancedFilters"] = boost::any(*advancedFiltersShrink);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (exactFiltersShrink) {
      res["ExactFilters"] = boost::any(*exactFiltersShrink);
    }
    if (filtersShrink) {
      res["Filters"] = boost::any(*filtersShrink);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (syntheticType) {
      res["SyntheticType"] = boost::any(*syntheticType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvancedFilters") != m.end() && !m["AdvancedFilters"].empty()) {
      advancedFiltersShrink = make_shared<string>(boost::any_cast<string>(m["AdvancedFilters"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExactFilters") != m.end() && !m["ExactFilters"].empty()) {
      exactFiltersShrink = make_shared<string>(boost::any_cast<string>(m["ExactFilters"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      filtersShrink = make_shared<string>(boost::any_cast<string>(m["Filters"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("SyntheticType") != m.end() && !m["SyntheticType"].empty()) {
      syntheticType = make_shared<long>(boost::any_cast<long>(m["SyntheticType"]));
    }
  }


  virtual ~ListSyntheticDetailShrinkRequest() = default;
};
class ListSyntheticDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> items{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> taskCreateTime{};
  shared_ptr<long> total{};

  ListSyntheticDetailResponseBodyData() {}

  explicit ListSyntheticDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskCreateTime) {
      res["TaskCreateTime"] = boost::any(*taskCreateTime);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      items = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskCreateTime") != m.end() && !m["TaskCreateTime"].empty()) {
      taskCreateTime = make_shared<long>(boost::any_cast<long>(m["TaskCreateTime"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSyntheticDetailResponseBodyData() = default;
};
class ListSyntheticDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListSyntheticDetailResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListSyntheticDetailResponseBody() {}

  explicit ListSyntheticDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListSyntheticDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListSyntheticDetailResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSyntheticDetailResponseBody() = default;
};
class ListSyntheticDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSyntheticDetailResponseBody> body{};

  ListSyntheticDetailResponse() {}

  explicit ListSyntheticDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSyntheticDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSyntheticDetailResponseBody>(model1);
      }
    }
  }


  virtual ~ListSyntheticDetailResponse() = default;
};
class ListTimingSyntheticTasksRequestSearch : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> order{};
  shared_ptr<string> orderField{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> taskIds{};
  shared_ptr<vector<long>> taskTypes{};

  ListTimingSyntheticTasksRequestSearch() {}

  explicit ListTimingSyntheticTasksRequestSearch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (taskTypes) {
      res["TaskTypes"] = boost::any(*taskTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["Order"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TaskTypes") != m.end() && !m["TaskTypes"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskTypes = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListTimingSyntheticTasksRequestSearch() = default;
};
class ListTimingSyntheticTasksRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTimingSyntheticTasksRequestTags() {}

  explicit ListTimingSyntheticTasksRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTimingSyntheticTasksRequestTags() = default;
};
class ListTimingSyntheticTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<ListTimingSyntheticTasksRequestSearch> search{};
  shared_ptr<vector<ListTimingSyntheticTasksRequestTags>> tags{};

  ListTimingSyntheticTasksRequest() {}

  explicit ListTimingSyntheticTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (search) {
      res["Search"] = search ? boost::any(search->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Search") != m.end() && !m["Search"].empty()) {
      if (typeid(map<string, boost::any>) == m["Search"].type()) {
        ListTimingSyntheticTasksRequestSearch model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Search"]));
        search = make_shared<ListTimingSyntheticTasksRequestSearch>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTimingSyntheticTasksRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTimingSyntheticTasksRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTimingSyntheticTasksRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListTimingSyntheticTasksRequest() = default;
};
class ListTimingSyntheticTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> searchShrink{};
  shared_ptr<string> tagsShrink{};

  ListTimingSyntheticTasksShrinkRequest() {}

  explicit ListTimingSyntheticTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (searchShrink) {
      res["Search"] = boost::any(*searchShrink);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Search") != m.end() && !m["Search"].empty()) {
      searchShrink = make_shared<string>(boost::any_cast<string>(m["Search"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ListTimingSyntheticTasksShrinkRequest() = default;
};
class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ipType{};
  shared_ptr<vector<string>> ips{};

  ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts() {}

  explicit ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts() = default;
};
class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost : public Darabonba::Model {
public:
  shared_ptr<vector<ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts>> hosts{};
  shared_ptr<long> selectType{};

  ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost() {}

  explicit ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (selectType) {
      res["SelectType"] = boost::any(*selectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts>>(expect1);
      }
    }
    if (m.find("SelectType") != m.end() && !m["SelectType"].empty()) {
      selectType = make_shared<long>(boost::any_cast<long>(m["SelectType"]));
    }
  }


  virtual ~ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost() = default;
};
class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting : public Darabonba::Model {
public:
  shared_ptr<string> prometheusClusterId{};
  shared_ptr<string> prometheusClusterRegion{};
  shared_ptr<map<string, string>> prometheusLabels{};

  ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting() {}

  explicit ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prometheusClusterId) {
      res["PrometheusClusterId"] = boost::any(*prometheusClusterId);
    }
    if (prometheusClusterRegion) {
      res["PrometheusClusterRegion"] = boost::any(*prometheusClusterRegion);
    }
    if (prometheusLabels) {
      res["PrometheusLabels"] = boost::any(*prometheusLabels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrometheusClusterId") != m.end() && !m["PrometheusClusterId"].empty()) {
      prometheusClusterId = make_shared<string>(boost::any_cast<string>(m["PrometheusClusterId"]));
    }
    if (m.find("PrometheusClusterRegion") != m.end() && !m["PrometheusClusterRegion"].empty()) {
      prometheusClusterRegion = make_shared<string>(boost::any_cast<string>(m["PrometheusClusterRegion"]));
    }
    if (m.find("PrometheusLabels") != m.end() && !m["PrometheusLabels"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["PrometheusLabels"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      prometheusLabels = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting() = default;
};
class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> secureGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting() {}

  explicit ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (secureGroupId) {
      res["SecureGroupId"] = boost::any(*secureGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecureGroupId") != m.end() && !m["SecureGroupId"].empty()) {
      secureGroupId = make_shared<string>(boost::any_cast<string>(m["SecureGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting() = default;
};
class ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting : public Darabonba::Model {
public:
  shared_ptr<ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost> customHost{};
  shared_ptr<ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting> customPrometheusSetting{};
  shared_ptr<ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting> customVPCSetting{};
  shared_ptr<long> ipType{};
  shared_ptr<bool> isOpenTrace{};
  shared_ptr<long> monitorSamples{};
  shared_ptr<long> traceClientType{};
  shared_ptr<string> xtraceRegion{};

  ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting() {}

  explicit ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customHost) {
      res["CustomHost"] = customHost ? boost::any(customHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customPrometheusSetting) {
      res["CustomPrometheusSetting"] = customPrometheusSetting ? boost::any(customPrometheusSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customVPCSetting) {
      res["CustomVPCSetting"] = customVPCSetting ? boost::any(customVPCSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (isOpenTrace) {
      res["IsOpenTrace"] = boost::any(*isOpenTrace);
    }
    if (monitorSamples) {
      res["MonitorSamples"] = boost::any(*monitorSamples);
    }
    if (traceClientType) {
      res["TraceClientType"] = boost::any(*traceClientType);
    }
    if (xtraceRegion) {
      res["XtraceRegion"] = boost::any(*xtraceRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomHost") != m.end() && !m["CustomHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomHost"].type()) {
        ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomHost"]));
        customHost = make_shared<ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost>(model1);
      }
    }
    if (m.find("CustomPrometheusSetting") != m.end() && !m["CustomPrometheusSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomPrometheusSetting"].type()) {
        ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomPrometheusSetting"]));
        customPrometheusSetting = make_shared<ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting>(model1);
      }
    }
    if (m.find("CustomVPCSetting") != m.end() && !m["CustomVPCSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomVPCSetting"].type()) {
        ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomVPCSetting"]));
        customVPCSetting = make_shared<ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting>(model1);
      }
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("IsOpenTrace") != m.end() && !m["IsOpenTrace"].empty()) {
      isOpenTrace = make_shared<bool>(boost::any_cast<bool>(m["IsOpenTrace"]));
    }
    if (m.find("MonitorSamples") != m.end() && !m["MonitorSamples"].empty()) {
      monitorSamples = make_shared<long>(boost::any_cast<long>(m["MonitorSamples"]));
    }
    if (m.find("TraceClientType") != m.end() && !m["TraceClientType"].empty()) {
      traceClientType = make_shared<long>(boost::any_cast<long>(m["TraceClientType"]));
    }
    if (m.find("XtraceRegion") != m.end() && !m["XtraceRegion"].empty()) {
      xtraceRegion = make_shared<string>(boost::any_cast<string>(m["XtraceRegion"]));
    }
  }


  virtual ~ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting() = default;
};
class ListTimingSyntheticTasksResponseBodyDataItemsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTimingSyntheticTasksResponseBodyDataItemsTags() {}

  explicit ListTimingSyntheticTasksResponseBodyDataItemsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTimingSyntheticTasksResponseBodyDataItemsTags() = default;
};
class ListTimingSyntheticTasksResponseBodyDataItems : public Darabonba::Model {
public:
  shared_ptr<ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting> commonSetting{};
  shared_ptr<string> frequency{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> monitorCategory{};
  shared_ptr<string> monitorNum{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListTimingSyntheticTasksResponseBodyDataItemsTags>> tags{};
  shared_ptr<string> taskId{};
  shared_ptr<long> taskType{};
  shared_ptr<string> url{};

  ListTimingSyntheticTasksResponseBodyDataItems() {}

  explicit ListTimingSyntheticTasksResponseBodyDataItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonSetting) {
      res["CommonSetting"] = commonSetting ? boost::any(commonSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (monitorCategory) {
      res["MonitorCategory"] = boost::any(*monitorCategory);
    }
    if (monitorNum) {
      res["MonitorNum"] = boost::any(*monitorNum);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonSetting") != m.end() && !m["CommonSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonSetting"].type()) {
        ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonSetting"]));
        commonSetting = make_shared<ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting>(model1);
      }
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("MonitorCategory") != m.end() && !m["MonitorCategory"].empty()) {
      monitorCategory = make_shared<long>(boost::any_cast<long>(m["MonitorCategory"]));
    }
    if (m.find("MonitorNum") != m.end() && !m["MonitorNum"].empty()) {
      monitorNum = make_shared<string>(boost::any_cast<string>(m["MonitorNum"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTimingSyntheticTasksResponseBodyDataItemsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTimingSyntheticTasksResponseBodyDataItemsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTimingSyntheticTasksResponseBodyDataItemsTags>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListTimingSyntheticTasksResponseBodyDataItems() = default;
};
class ListTimingSyntheticTasksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListTimingSyntheticTasksResponseBodyDataItems>> items{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  ListTimingSyntheticTasksResponseBodyData() {}

  explicit ListTimingSyntheticTasksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<ListTimingSyntheticTasksResponseBodyDataItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTimingSyntheticTasksResponseBodyDataItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListTimingSyntheticTasksResponseBodyDataItems>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListTimingSyntheticTasksResponseBodyData() = default;
};
class ListTimingSyntheticTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListTimingSyntheticTasksResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListTimingSyntheticTasksResponseBody() {}

  explicit ListTimingSyntheticTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTimingSyntheticTasksResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTimingSyntheticTasksResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTimingSyntheticTasksResponseBody() = default;
};
class ListTimingSyntheticTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTimingSyntheticTasksResponseBody> body{};

  ListTimingSyntheticTasksResponse() {}

  explicit ListTimingSyntheticTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTimingSyntheticTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTimingSyntheticTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListTimingSyntheticTasksResponse() = default;
};
class ListTraceAppsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTraceAppsRequestTags() {}

  explicit ListTraceAppsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTraceAppsRequestTags() = default;
};
class ListTraceAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListTraceAppsRequestTags>> tags{};

  ListTraceAppsRequest() {}

  explicit ListTraceAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTraceAppsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTraceAppsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTraceAppsRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListTraceAppsRequest() = default;
};
class ListTraceAppsResponseBodyTraceAppsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTraceAppsResponseBodyTraceAppsTags() {}

  explicit ListTraceAppsResponseBodyTraceAppsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTraceAppsResponseBodyTraceAppsTags() = default;
};
class ListTraceAppsResponseBodyTraceApps : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> language{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> show{};
  shared_ptr<string> source{};
  shared_ptr<vector<ListTraceAppsResponseBodyTraceAppsTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> workloadKind{};
  shared_ptr<string> workloadName{};

  ListTraceAppsResponseBodyTraceApps() {}

  explicit ListTraceAppsResponseBodyTraceApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workloadKind) {
      res["WorkloadKind"] = boost::any(*workloadKind);
    }
    if (workloadName) {
      res["WorkloadName"] = boost::any(*workloadName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTraceAppsResponseBodyTraceAppsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTraceAppsResponseBodyTraceAppsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTraceAppsResponseBodyTraceAppsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkloadKind") != m.end() && !m["WorkloadKind"].empty()) {
      workloadKind = make_shared<string>(boost::any_cast<string>(m["WorkloadKind"]));
    }
    if (m.find("WorkloadName") != m.end() && !m["WorkloadName"].empty()) {
      workloadName = make_shared<string>(boost::any_cast<string>(m["WorkloadName"]));
    }
  }


  virtual ~ListTraceAppsResponseBodyTraceApps() = default;
};
class ListTraceAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListTraceAppsResponseBodyTraceApps>> traceApps{};

  ListTraceAppsResponseBody() {}

  explicit ListTraceAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceApps) {
      vector<boost::any> temp1;
      for(auto item1:*traceApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TraceApps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceApps") != m.end() && !m["TraceApps"].empty()) {
      if (typeid(vector<boost::any>) == m["TraceApps"].type()) {
        vector<ListTraceAppsResponseBodyTraceApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TraceApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTraceAppsResponseBodyTraceApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traceApps = make_shared<vector<ListTraceAppsResponseBodyTraceApps>>(expect1);
      }
    }
  }


  virtual ~ListTraceAppsResponseBody() = default;
};
class ListTraceAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTraceAppsResponseBody> body{};

  ListTraceAppsResponse() {}

  explicit ListTraceAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTraceAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTraceAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTraceAppsResponse() = default;
};
class ManageGetRecordingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> queryUserId{};
  shared_ptr<string> regionId{};

  ManageGetRecordingRuleRequest() {}

  explicit ManageGetRecordingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (queryUserId) {
      res["QueryUserId"] = boost::any(*queryUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("QueryUserId") != m.end() && !m["QueryUserId"].empty()) {
      queryUserId = make_shared<string>(boost::any_cast<string>(m["QueryUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ManageGetRecordingRuleRequest() = default;
};
class ManageGetRecordingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ManageGetRecordingRuleResponseBody() {}

  explicit ManageGetRecordingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ManageGetRecordingRuleResponseBody() = default;
};
class ManageGetRecordingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ManageGetRecordingRuleResponseBody> body{};

  ManageGetRecordingRuleResponse() {}

  explicit ManageGetRecordingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ManageGetRecordingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ManageGetRecordingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ManageGetRecordingRuleResponse() = default;
};
class ManageRecordingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> queryUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleYaml{};

  ManageRecordingRuleRequest() {}

  explicit ManageRecordingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (queryUserId) {
      res["QueryUserId"] = boost::any(*queryUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleYaml) {
      res["RuleYaml"] = boost::any(*ruleYaml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("QueryUserId") != m.end() && !m["QueryUserId"].empty()) {
      queryUserId = make_shared<string>(boost::any_cast<string>(m["QueryUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleYaml") != m.end() && !m["RuleYaml"].empty()) {
      ruleYaml = make_shared<string>(boost::any_cast<string>(m["RuleYaml"]));
    }
  }


  virtual ~ManageRecordingRuleRequest() = default;
};
class ManageRecordingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ManageRecordingRuleResponseBody() {}

  explicit ManageRecordingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ManageRecordingRuleResponseBody() = default;
};
class ManageRecordingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ManageRecordingRuleResponseBody> body{};

  ManageRecordingRuleResponse() {}

  explicit ManageRecordingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ManageRecordingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ManageRecordingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ManageRecordingRuleResponse() = default;
};
class OpenArmsDefaultSLRRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  OpenArmsDefaultSLRRequest() {}

  explicit OpenArmsDefaultSLRRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~OpenArmsDefaultSLRRequest() = default;
};
class OpenArmsDefaultSLRResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  OpenArmsDefaultSLRResponseBody() {}

  explicit OpenArmsDefaultSLRResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenArmsDefaultSLRResponseBody() = default;
};
class OpenArmsDefaultSLRResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenArmsDefaultSLRResponseBody> body{};

  OpenArmsDefaultSLRResponse() {}

  explicit OpenArmsDefaultSLRResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenArmsDefaultSLRResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenArmsDefaultSLRResponseBody>(model1);
      }
    }
  }


  virtual ~OpenArmsDefaultSLRResponse() = default;
};
class OpenArmsServiceSecondVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  OpenArmsServiceSecondVersionRequest() {}

  explicit OpenArmsServiceSecondVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~OpenArmsServiceSecondVersionRequest() = default;
};
class OpenArmsServiceSecondVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  OpenArmsServiceSecondVersionResponseBody() {}

  explicit OpenArmsServiceSecondVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenArmsServiceSecondVersionResponseBody() = default;
};
class OpenArmsServiceSecondVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenArmsServiceSecondVersionResponseBody> body{};

  OpenArmsServiceSecondVersionResponse() {}

  explicit OpenArmsServiceSecondVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenArmsServiceSecondVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenArmsServiceSecondVersionResponseBody>(model1);
      }
    }
  }


  virtual ~OpenArmsServiceSecondVersionResponse() = default;
};
class OpenVClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<long> length{};
  shared_ptr<string> product{};
  shared_ptr<bool> recreateSwitch{};
  shared_ptr<string> regionId{};

  OpenVClusterRequest() {}

  explicit OpenVClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (recreateSwitch) {
      res["RecreateSwitch"] = boost::any(*recreateSwitch);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RecreateSwitch") != m.end() && !m["RecreateSwitch"].empty()) {
      recreateSwitch = make_shared<bool>(boost::any_cast<bool>(m["RecreateSwitch"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~OpenVClusterRequest() = default;
};
class OpenVClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  OpenVClusterResponseBody() {}

  explicit OpenVClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenVClusterResponseBody() = default;
};
class OpenVClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenVClusterResponseBody> body{};

  OpenVClusterResponse() {}

  explicit OpenVClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenVClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenVClusterResponseBody>(model1);
      }
    }
  }


  virtual ~OpenVClusterResponse() = default;
};
class OpenXtraceDefaultSLRRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  OpenXtraceDefaultSLRRequest() {}

  explicit OpenXtraceDefaultSLRRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~OpenXtraceDefaultSLRRequest() = default;
};
class OpenXtraceDefaultSLRResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  OpenXtraceDefaultSLRResponseBody() {}

  explicit OpenXtraceDefaultSLRResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenXtraceDefaultSLRResponseBody() = default;
};
class OpenXtraceDefaultSLRResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenXtraceDefaultSLRResponseBody> body{};

  OpenXtraceDefaultSLRResponse() {}

  explicit OpenXtraceDefaultSLRResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenXtraceDefaultSLRResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenXtraceDefaultSLRResponseBody>(model1);
      }
    }
  }


  virtual ~OpenXtraceDefaultSLRResponse() = default;
};
class QueryAppMetadataRequest : public Darabonba::Model {
public:
  shared_ptr<string> metaIds{};
  shared_ptr<string> metaType{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};

  QueryAppMetadataRequest() {}

  explicit QueryAppMetadataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metaIds) {
      res["MetaIds"] = boost::any(*metaIds);
    }
    if (metaType) {
      res["MetaType"] = boost::any(*metaType);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetaIds") != m.end() && !m["MetaIds"].empty()) {
      metaIds = make_shared<string>(boost::any_cast<string>(m["MetaIds"]));
    }
    if (m.find("MetaType") != m.end() && !m["MetaType"].empty()) {
      metaType = make_shared<string>(boost::any_cast<string>(m["MetaType"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~QueryAppMetadataRequest() = default;
};
class QueryAppMetadataResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryAppMetadataResponseBody() {}

  explicit QueryAppMetadataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryAppMetadataResponseBody() = default;
};
class QueryAppMetadataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAppMetadataResponseBody> body{};

  QueryAppMetadataResponse() {}

  explicit QueryAppMetadataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAppMetadataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAppMetadataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAppMetadataResponse() = default;
};
class QueryAppTopologyRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> db{};
  shared_ptr<string> dbName{};
  shared_ptr<long> endTime{};
  shared_ptr<map<string, string>> filters{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> rpc{};
  shared_ptr<long> startTime{};
  shared_ptr<string> type{};

  QueryAppTopologyRequest() {}

  explicit QueryAppTopologyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filters) {
      res["Filters"] = boost::any(*filters);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rpc) {
      res["Rpc"] = boost::any(*rpc);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<string>(boost::any_cast<string>(m["Db"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Filters"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      filters = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Rpc") != m.end() && !m["Rpc"].empty()) {
      rpc = make_shared<string>(boost::any_cast<string>(m["Rpc"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryAppTopologyRequest() = default;
};
class QueryAppTopologyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> db{};
  shared_ptr<string> dbName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> filtersShrink{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> rpc{};
  shared_ptr<long> startTime{};
  shared_ptr<string> type{};

  QueryAppTopologyShrinkRequest() {}

  explicit QueryAppTopologyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (db) {
      res["Db"] = boost::any(*db);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filtersShrink) {
      res["Filters"] = boost::any(*filtersShrink);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rpc) {
      res["Rpc"] = boost::any(*rpc);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Db") != m.end() && !m["Db"].empty()) {
      db = make_shared<string>(boost::any_cast<string>(m["Db"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      filtersShrink = make_shared<string>(boost::any_cast<string>(m["Filters"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Rpc") != m.end() && !m["Rpc"].empty()) {
      rpc = make_shared<string>(boost::any_cast<string>(m["Rpc"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryAppTopologyShrinkRequest() = default;
};
class QueryAppTopologyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryAppTopologyResponseBody() {}

  explicit QueryAppTopologyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryAppTopologyResponseBody() = default;
};
class QueryAppTopologyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAppTopologyResponseBody> body{};

  QueryAppTopologyResponse() {}

  explicit QueryAppTopologyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAppTopologyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAppTopologyResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAppTopologyResponse() = default;
};
class QueryCommercialUsageRequestAdvancedFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opType{};
  shared_ptr<string> value{};

  QueryCommercialUsageRequestAdvancedFilters() {}

  explicit QueryCommercialUsageRequestAdvancedFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryCommercialUsageRequestAdvancedFilters() = default;
};
class QueryCommercialUsageRequest : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCommercialUsageRequestAdvancedFilters>> advancedFilters{};
  shared_ptr<vector<string>> dimensions{};
  shared_ptr<long> endTime{};
  shared_ptr<long> intervalInSec{};
  shared_ptr<vector<string>> measures{};
  shared_ptr<string> metric{};
  shared_ptr<string> order{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> queryType{};
  shared_ptr<long> startTime{};

  QueryCommercialUsageRequest() {}

  explicit QueryCommercialUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedFilters) {
      vector<boost::any> temp1;
      for(auto item1:*advancedFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdvancedFilters"] = boost::any(temp1);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (intervalInSec) {
      res["IntervalInSec"] = boost::any(*intervalInSec);
    }
    if (measures) {
      res["Measures"] = boost::any(*measures);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvancedFilters") != m.end() && !m["AdvancedFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["AdvancedFilters"].type()) {
        vector<QueryCommercialUsageRequestAdvancedFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdvancedFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCommercialUsageRequestAdvancedFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        advancedFilters = make_shared<vector<QueryCommercialUsageRequestAdvancedFilters>>(expect1);
      }
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Dimensions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dimensions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("IntervalInSec") != m.end() && !m["IntervalInSec"].empty()) {
      intervalInSec = make_shared<long>(boost::any_cast<long>(m["IntervalInSec"]));
    }
    if (m.find("Measures") != m.end() && !m["Measures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Measures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Measures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      measures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryCommercialUsageRequest() = default;
};
class QueryCommercialUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> complete{};
  shared_ptr<vector<map<string, boost::any>>> items{};

  QueryCommercialUsageResponseBodyData() {}

  explicit QueryCommercialUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complete) {
      res["Complete"] = boost::any(*complete);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Complete") != m.end() && !m["Complete"].empty()) {
      complete = make_shared<bool>(boost::any_cast<bool>(m["Complete"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      items = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~QueryCommercialUsageResponseBodyData() = default;
};
class QueryCommercialUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<QueryCommercialUsageResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryCommercialUsageResponseBody() {}

  explicit QueryCommercialUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryCommercialUsageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryCommercialUsageResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryCommercialUsageResponseBody() = default;
};
class QueryCommercialUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCommercialUsageResponseBody> body{};

  QueryCommercialUsageResponse() {}

  explicit QueryCommercialUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCommercialUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCommercialUsageResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCommercialUsageResponse() = default;
};
class QueryMetricByPageRequestFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  QueryMetricByPageRequestFilters() {}

  explicit QueryMetricByPageRequestFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryMetricByPageRequestFilters() = default;
};
class QueryMetricByPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<string>> customFilters{};
  shared_ptr<vector<string>> dimensions{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<QueryMetricByPageRequestFilters>> filters{};
  shared_ptr<long> intervalInSec{};
  shared_ptr<vector<string>> measures{};
  shared_ptr<string> metric{};
  shared_ptr<string> order{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  QueryMetricByPageRequest() {}

  explicit QueryMetricByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (customFilters) {
      res["CustomFilters"] = boost::any(*customFilters);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (intervalInSec) {
      res["IntervalInSec"] = boost::any(*intervalInSec);
    }
    if (measures) {
      res["Measures"] = boost::any(*measures);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("CustomFilters") != m.end() && !m["CustomFilters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomFilters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomFilters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customFilters = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Dimensions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dimensions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<QueryMetricByPageRequestFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMetricByPageRequestFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<QueryMetricByPageRequestFilters>>(expect1);
      }
    }
    if (m.find("IntervalInSec") != m.end() && !m["IntervalInSec"].empty()) {
      intervalInSec = make_shared<long>(boost::any_cast<long>(m["IntervalInSec"]));
    }
    if (m.find("Measures") != m.end() && !m["Measures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Measures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Measures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      measures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryMetricByPageRequest() = default;
};
class QueryMetricByPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> completed{};
  shared_ptr<vector<map<string, boost::any>>> items{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryMetricByPageResponseBodyData() {}

  explicit QueryMetricByPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completed) {
      res["Completed"] = boost::any(*completed);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Completed") != m.end() && !m["Completed"].empty()) {
      completed = make_shared<bool>(boost::any_cast<bool>(m["Completed"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      items = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryMetricByPageResponseBodyData() = default;
};
class QueryMetricByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryMetricByPageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryMetricByPageResponseBody() {}

  explicit QueryMetricByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryMetricByPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryMetricByPageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMetricByPageResponseBody() = default;
};
class QueryMetricByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMetricByPageResponseBody> body{};

  QueryMetricByPageResponse() {}

  explicit QueryMetricByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMetricByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMetricByPageResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMetricByPageResponse() = default;
};
class QueryPromInstallStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  QueryPromInstallStatusRequest() {}

  explicit QueryPromInstallStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~QueryPromInstallStatusRequest() = default;
};
class QueryPromInstallStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> isControllerInstalled{};

  QueryPromInstallStatusResponseBodyData() {}

  explicit QueryPromInstallStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isControllerInstalled) {
      res["isControllerInstalled"] = boost::any(*isControllerInstalled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isControllerInstalled") != m.end() && !m["isControllerInstalled"].empty()) {
      isControllerInstalled = make_shared<bool>(boost::any_cast<bool>(m["isControllerInstalled"]));
    }
  }


  virtual ~QueryPromInstallStatusResponseBodyData() = default;
};
class QueryPromInstallStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryPromInstallStatusResponseBodyData> data{};
  shared_ptr<string> requestId{};

  QueryPromInstallStatusResponseBody() {}

  explicit QueryPromInstallStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryPromInstallStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryPromInstallStatusResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryPromInstallStatusResponseBody() = default;
};
class QueryPromInstallStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPromInstallStatusResponseBody> body{};

  QueryPromInstallStatusResponse() {}

  explicit QueryPromInstallStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPromInstallStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPromInstallStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPromInstallStatusResponse() = default;
};
class QueryReleaseMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> metricType{};
  shared_ptr<string> pid{};
  shared_ptr<string> proxyUserId{};
  shared_ptr<long> releaseEndTime{};
  shared_ptr<long> releaseStartTime{};
  shared_ptr<string> service{};

  QueryReleaseMetricRequest() {}

  explicit QueryReleaseMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (proxyUserId) {
      res["ProxyUserId"] = boost::any(*proxyUserId);
    }
    if (releaseEndTime) {
      res["ReleaseEndTime"] = boost::any(*releaseEndTime);
    }
    if (releaseStartTime) {
      res["ReleaseStartTime"] = boost::any(*releaseStartTime);
    }
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("ProxyUserId") != m.end() && !m["ProxyUserId"].empty()) {
      proxyUserId = make_shared<string>(boost::any_cast<string>(m["ProxyUserId"]));
    }
    if (m.find("ReleaseEndTime") != m.end() && !m["ReleaseEndTime"].empty()) {
      releaseEndTime = make_shared<long>(boost::any_cast<long>(m["ReleaseEndTime"]));
    }
    if (m.find("ReleaseStartTime") != m.end() && !m["ReleaseStartTime"].empty()) {
      releaseStartTime = make_shared<long>(boost::any_cast<long>(m["ReleaseStartTime"]));
    }
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["Service"]));
    }
  }


  virtual ~QueryReleaseMetricRequest() = default;
};
class QueryReleaseMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  QueryReleaseMetricResponseBody() {}

  explicit QueryReleaseMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryReleaseMetricResponseBody() = default;
};
class QueryReleaseMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryReleaseMetricResponseBody> body{};

  QueryReleaseMetricResponse() {}

  explicit QueryReleaseMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryReleaseMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryReleaseMetricResponseBody>(model1);
      }
    }
  }


  virtual ~QueryReleaseMetricResponse() = default;
};
class RemoveAliClusterIdsFromPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterIds{};
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};

  RemoveAliClusterIdsFromPrometheusGlobalViewRequest() {}

  explicit RemoveAliClusterIdsFromPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      clusterIds = make_shared<string>(boost::any_cast<string>(m["ClusterIds"]));
    }
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RemoveAliClusterIdsFromPrometheusGlobalViewRequest() = default;
};
class RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData() {}

  explicit RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData() = default;
};
class RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody() {}

  explicit RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody() = default;
};
class RemoveAliClusterIdsFromPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody> body{};

  RemoveAliClusterIdsFromPrometheusGlobalViewResponse() {}

  explicit RemoveAliClusterIdsFromPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAliClusterIdsFromPrometheusGlobalViewResponse() = default;
};
class RemoveSourcesFromPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourceNames{};

  RemoveSourcesFromPrometheusGlobalViewRequest() {}

  explicit RemoveSourcesFromPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceNames) {
      res["SourceNames"] = boost::any(*sourceNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceNames") != m.end() && !m["SourceNames"].empty()) {
      sourceNames = make_shared<string>(boost::any_cast<string>(m["SourceNames"]));
    }
  }


  virtual ~RemoveSourcesFromPrometheusGlobalViewRequest() = default;
};
class RemoveSourcesFromPrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  RemoveSourcesFromPrometheusGlobalViewResponseBodyData() {}

  explicit RemoveSourcesFromPrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveSourcesFromPrometheusGlobalViewResponseBodyData() = default;
};
class RemoveSourcesFromPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<RemoveSourcesFromPrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveSourcesFromPrometheusGlobalViewResponseBody() {}

  explicit RemoveSourcesFromPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RemoveSourcesFromPrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RemoveSourcesFromPrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveSourcesFromPrometheusGlobalViewResponseBody() = default;
};
class RemoveSourcesFromPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveSourcesFromPrometheusGlobalViewResponseBody> body{};

  RemoveSourcesFromPrometheusGlobalViewResponse() {}

  explicit RemoveSourcesFromPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveSourcesFromPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveSourcesFromPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveSourcesFromPrometheusGlobalViewResponse() = default;
};
class RestartEnvironmentFeatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> environmentId{};
  shared_ptr<string> featureName{};
  shared_ptr<string> regionId{};

  RestartEnvironmentFeatureRequest() {}

  explicit RestartEnvironmentFeatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (featureName) {
      res["FeatureName"] = boost::any(*featureName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("FeatureName") != m.end() && !m["FeatureName"].empty()) {
      featureName = make_shared<string>(boost::any_cast<string>(m["FeatureName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RestartEnvironmentFeatureRequest() = default;
};
class RestartEnvironmentFeatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RestartEnvironmentFeatureResponseBody() {}

  explicit RestartEnvironmentFeatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RestartEnvironmentFeatureResponseBody() = default;
};
class RestartEnvironmentFeatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartEnvironmentFeatureResponseBody> body{};

  RestartEnvironmentFeatureResponse() {}

  explicit RestartEnvironmentFeatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartEnvironmentFeatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartEnvironmentFeatureResponseBody>(model1);
      }
    }
  }


  virtual ~RestartEnvironmentFeatureResponse() = default;
};
class SaveTraceAppConfigRequestSettings : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SaveTraceAppConfigRequestSettings() {}

  explicit SaveTraceAppConfigRequestSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SaveTraceAppConfigRequestSettings() = default;
};
class SaveTraceAppConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};
  shared_ptr<vector<SaveTraceAppConfigRequestSettings>> settings{};

  SaveTraceAppConfigRequest() {}

  explicit SaveTraceAppConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (settings) {
      vector<boost::any> temp1;
      for(auto item1:*settings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Settings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Settings") != m.end() && !m["Settings"].empty()) {
      if (typeid(vector<boost::any>) == m["Settings"].type()) {
        vector<SaveTraceAppConfigRequestSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Settings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveTraceAppConfigRequestSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        settings = make_shared<vector<SaveTraceAppConfigRequestSettings>>(expect1);
      }
    }
  }


  virtual ~SaveTraceAppConfigRequest() = default;
};
class SaveTraceAppConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveTraceAppConfigResponseBody() {}

  explicit SaveTraceAppConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveTraceAppConfigResponseBody() = default;
};
class SaveTraceAppConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveTraceAppConfigResponseBody> body{};

  SaveTraceAppConfigResponse() {}

  explicit SaveTraceAppConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveTraceAppConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveTraceAppConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SaveTraceAppConfigResponse() = default;
};
class SearchAlertContactRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactIds{};
  shared_ptr<string> contactName{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> email{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> phone{};
  shared_ptr<string> regionId{};

  SearchAlertContactRequest() {}

  explicit SearchAlertContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SearchAlertContactRequest() = default;
};
class SearchAlertContactResponseBodyPageBeanContacts : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> dingRobot{};
  shared_ptr<string> email{};
  shared_ptr<string> phone{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> systemNoc{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> webhook{};

  SearchAlertContactResponseBodyPageBeanContacts() {}

  explicit SearchAlertContactResponseBodyPageBeanContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dingRobot) {
      res["DingRobot"] = boost::any(*dingRobot);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (systemNoc) {
      res["SystemNoc"] = boost::any(*systemNoc);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DingRobot") != m.end() && !m["DingRobot"].empty()) {
      dingRobot = make_shared<string>(boost::any_cast<string>(m["DingRobot"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SystemNoc") != m.end() && !m["SystemNoc"].empty()) {
      systemNoc = make_shared<bool>(boost::any_cast<bool>(m["SystemNoc"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~SearchAlertContactResponseBodyPageBeanContacts() = default;
};
class SearchAlertContactResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<SearchAlertContactResponseBodyPageBeanContacts>> contacts{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  SearchAlertContactResponseBodyPageBean() {}

  explicit SearchAlertContactResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<SearchAlertContactResponseBodyPageBeanContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertContactResponseBodyPageBeanContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<SearchAlertContactResponseBodyPageBeanContacts>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchAlertContactResponseBodyPageBean() = default;
};
class SearchAlertContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchAlertContactResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchAlertContactResponseBody() {}

  explicit SearchAlertContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchAlertContactResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchAlertContactResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchAlertContactResponseBody() = default;
};
class SearchAlertContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchAlertContactResponseBody> body{};

  SearchAlertContactResponse() {}

  explicit SearchAlertContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchAlertContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchAlertContactResponseBody>(model1);
      }
    }
  }


  virtual ~SearchAlertContactResponse() = default;
};
class SearchAlertContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupIds{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<bool> isDetail{};
  shared_ptr<string> regionId{};

  SearchAlertContactGroupRequest() {}

  explicit SearchAlertContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupIds) {
      res["ContactGroupIds"] = boost::any(*contactGroupIds);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (isDetail) {
      res["IsDetail"] = boost::any(*isDetail);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupIds") != m.end() && !m["ContactGroupIds"].empty()) {
      contactGroupIds = make_shared<string>(boost::any_cast<string>(m["ContactGroupIds"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("IsDetail") != m.end() && !m["IsDetail"].empty()) {
      isDetail = make_shared<bool>(boost::any_cast<bool>(m["IsDetail"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SearchAlertContactGroupRequest() = default;
};
class SearchAlertContactGroupResponseBodyContactGroupsContacts : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> dingRobot{};
  shared_ptr<string> email{};
  shared_ptr<string> phone{};
  shared_ptr<bool> systemNoc{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchAlertContactGroupResponseBodyContactGroupsContacts() {}

  explicit SearchAlertContactGroupResponseBodyContactGroupsContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dingRobot) {
      res["DingRobot"] = boost::any(*dingRobot);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (systemNoc) {
      res["SystemNoc"] = boost::any(*systemNoc);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DingRobot") != m.end() && !m["DingRobot"].empty()) {
      dingRobot = make_shared<string>(boost::any_cast<string>(m["DingRobot"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("SystemNoc") != m.end() && !m["SystemNoc"].empty()) {
      systemNoc = make_shared<bool>(boost::any_cast<bool>(m["SystemNoc"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchAlertContactGroupResponseBodyContactGroupsContacts() = default;
};
class SearchAlertContactGroupResponseBodyContactGroups : public Darabonba::Model {
public:
  shared_ptr<long> contactGroupId{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<vector<SearchAlertContactGroupResponseBodyContactGroupsContacts>> contacts{};
  shared_ptr<long> createTime{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchAlertContactGroupResponseBodyContactGroups() {}

  explicit SearchAlertContactGroupResponseBodyContactGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<long>(boost::any_cast<long>(m["ContactGroupId"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<SearchAlertContactGroupResponseBodyContactGroupsContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertContactGroupResponseBodyContactGroupsContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<SearchAlertContactGroupResponseBodyContactGroupsContacts>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchAlertContactGroupResponseBodyContactGroups() = default;
};
class SearchAlertContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SearchAlertContactGroupResponseBodyContactGroups>> contactGroups{};
  shared_ptr<string> requestId{};

  SearchAlertContactGroupResponseBody() {}

  explicit SearchAlertContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroups) {
      vector<boost::any> temp1;
      for(auto item1:*contactGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactGroups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactGroups"].type()) {
        vector<SearchAlertContactGroupResponseBodyContactGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertContactGroupResponseBodyContactGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactGroups = make_shared<vector<SearchAlertContactGroupResponseBodyContactGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchAlertContactGroupResponseBody() = default;
};
class SearchAlertContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchAlertContactGroupResponseBody> body{};

  SearchAlertContactGroupResponse() {}

  explicit SearchAlertContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchAlertContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchAlertContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SearchAlertContactGroupResponse() = default;
};
class SearchAlertHistoriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<long> alertType{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  SearchAlertHistoriesRequest() {}

  explicit SearchAlertHistoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<long>(boost::any_cast<long>(m["AlertType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~SearchAlertHistoriesRequest() = default;
};
class SearchAlertHistoriesResponseBodyPageBeanAlarmHistories : public Darabonba::Model {
public:
  shared_ptr<string> alarmContent{};
  shared_ptr<long> alarmResponseCode{};
  shared_ptr<string> alarmSources{};
  shared_ptr<long> alarmTime{};
  shared_ptr<long> alarmType{};
  shared_ptr<string> emails{};
  shared_ptr<long> id{};
  shared_ptr<string> phones{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> target{};
  shared_ptr<string> userId{};

  SearchAlertHistoriesResponseBodyPageBeanAlarmHistories() {}

  explicit SearchAlertHistoriesResponseBodyPageBeanAlarmHistories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmContent) {
      res["AlarmContent"] = boost::any(*alarmContent);
    }
    if (alarmResponseCode) {
      res["AlarmResponseCode"] = boost::any(*alarmResponseCode);
    }
    if (alarmSources) {
      res["AlarmSources"] = boost::any(*alarmSources);
    }
    if (alarmTime) {
      res["AlarmTime"] = boost::any(*alarmTime);
    }
    if (alarmType) {
      res["AlarmType"] = boost::any(*alarmType);
    }
    if (emails) {
      res["Emails"] = boost::any(*emails);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (phones) {
      res["Phones"] = boost::any(*phones);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmContent") != m.end() && !m["AlarmContent"].empty()) {
      alarmContent = make_shared<string>(boost::any_cast<string>(m["AlarmContent"]));
    }
    if (m.find("AlarmResponseCode") != m.end() && !m["AlarmResponseCode"].empty()) {
      alarmResponseCode = make_shared<long>(boost::any_cast<long>(m["AlarmResponseCode"]));
    }
    if (m.find("AlarmSources") != m.end() && !m["AlarmSources"].empty()) {
      alarmSources = make_shared<string>(boost::any_cast<string>(m["AlarmSources"]));
    }
    if (m.find("AlarmTime") != m.end() && !m["AlarmTime"].empty()) {
      alarmTime = make_shared<long>(boost::any_cast<long>(m["AlarmTime"]));
    }
    if (m.find("AlarmType") != m.end() && !m["AlarmType"].empty()) {
      alarmType = make_shared<long>(boost::any_cast<long>(m["AlarmType"]));
    }
    if (m.find("Emails") != m.end() && !m["Emails"].empty()) {
      emails = make_shared<string>(boost::any_cast<string>(m["Emails"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Phones") != m.end() && !m["Phones"].empty()) {
      phones = make_shared<string>(boost::any_cast<string>(m["Phones"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchAlertHistoriesResponseBodyPageBeanAlarmHistories() = default;
};
class SearchAlertHistoriesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<SearchAlertHistoriesResponseBodyPageBeanAlarmHistories>> alarmHistories{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  SearchAlertHistoriesResponseBodyPageBean() {}

  explicit SearchAlertHistoriesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmHistories) {
      vector<boost::any> temp1;
      for(auto item1:*alarmHistories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmHistories"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmHistories") != m.end() && !m["AlarmHistories"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmHistories"].type()) {
        vector<SearchAlertHistoriesResponseBodyPageBeanAlarmHistories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmHistories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertHistoriesResponseBodyPageBeanAlarmHistories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmHistories = make_shared<vector<SearchAlertHistoriesResponseBodyPageBeanAlarmHistories>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchAlertHistoriesResponseBodyPageBean() = default;
};
class SearchAlertHistoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchAlertHistoriesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchAlertHistoriesResponseBody() {}

  explicit SearchAlertHistoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchAlertHistoriesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchAlertHistoriesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchAlertHistoriesResponseBody() = default;
};
class SearchAlertHistoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchAlertHistoriesResponseBody> body{};

  SearchAlertHistoriesResponse() {}

  explicit SearchAlertHistoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchAlertHistoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchAlertHistoriesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchAlertHistoriesResponse() = default;
};
class SearchAlertRulesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchAlertRulesRequestTags() {}

  explicit SearchAlertRulesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchAlertRulesRequestTags() = default;
};
class SearchAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertRuleId{};
  shared_ptr<string> appType{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> systemRegionId{};
  shared_ptr<vector<SearchAlertRulesRequestTags>> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  SearchAlertRulesRequest() {}

  explicit SearchAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRuleId) {
      res["AlertRuleId"] = boost::any(*alertRuleId);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (systemRegionId) {
      res["SystemRegionId"] = boost::any(*systemRegionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRuleId") != m.end() && !m["AlertRuleId"].empty()) {
      alertRuleId = make_shared<string>(boost::any_cast<string>(m["AlertRuleId"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SystemRegionId") != m.end() && !m["SystemRegionId"].empty()) {
      systemRegionId = make_shared<string>(boost::any_cast<string>(m["SystemRegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchAlertRulesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertRulesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchAlertRulesRequestTags>>(expect1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SearchAlertRulesRequest() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext : public Darabonba::Model {
public:
  shared_ptr<string> alarmContentSubTitle{};
  shared_ptr<string> alarmContentTemplate{};
  shared_ptr<string> content{};
  shared_ptr<string> subTitle{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmContentSubTitle) {
      res["AlarmContentSubTitle"] = boost::any(*alarmContentSubTitle);
    }
    if (alarmContentTemplate) {
      res["AlarmContentTemplate"] = boost::any(*alarmContentTemplate);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (subTitle) {
      res["SubTitle"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmContentSubTitle") != m.end() && !m["AlarmContentSubTitle"].empty()) {
      alarmContentSubTitle = make_shared<string>(boost::any_cast<string>(m["AlarmContentSubTitle"]));
    }
    if (m.find("AlarmContentTemplate") != m.end() && !m["AlarmContentTemplate"].empty()) {
      alarmContentTemplate = make_shared<string>(boost::any_cast<string>(m["AlarmContentTemplate"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SubTitle") != m.end() && !m["SubTitle"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["SubTitle"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules : public Darabonba::Model {
public:
  shared_ptr<string> aggregates{};
  shared_ptr<string> alias{};
  shared_ptr<string> measure{};
  shared_ptr<long> NValue{};
  shared_ptr<string> operator_{};
  shared_ptr<double> value{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregates) {
      res["Aggregates"] = boost::any(*aggregates);
    }
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (measure) {
      res["Measure"] = boost::any(*measure);
    }
    if (NValue) {
      res["NValue"] = boost::any(*NValue);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregates") != m.end() && !m["Aggregates"].empty()) {
      aggregates = make_shared<string>(boost::any_cast<string>(m["Aggregates"]));
    }
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Measure") != m.end() && !m["Measure"].empty()) {
      measure = make_shared<string>(boost::any_cast<string>(m["Measure"]));
    }
    if (m.find("NValue") != m.end() && !m["NValue"].empty()) {
      NValue = make_shared<long>(boost::any_cast<long>(m["NValue"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<vector<SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules>> rules{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules>>(expect1);
      }
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam : public Darabonba::Model {
public:
  shared_ptr<string> appGroupId{};
  shared_ptr<string> appId{};
  shared_ptr<vector<SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions>> dimensions{};
  shared_ptr<string> pid{};
  shared_ptr<string> type{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGroupId) {
      res["AppGroupId"] = boost::any(*appGroupId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGroupId") != m.end() && !m["AppGroupId"].empty()) {
      appGroupId = make_shared<string>(boost::any_cast<string>(m["AppGroupId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions>>(expect1);
      }
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesNotice : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> noticeEndTime{};
  shared_ptr<long> noticeStartTime{};
  shared_ptr<long> startTime{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesNotice() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesNotice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (noticeEndTime) {
      res["NoticeEndTime"] = boost::any(*noticeEndTime);
    }
    if (noticeStartTime) {
      res["NoticeStartTime"] = boost::any(*noticeStartTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("NoticeEndTime") != m.end() && !m["NoticeEndTime"].empty()) {
      noticeEndTime = make_shared<long>(boost::any_cast<long>(m["NoticeEndTime"]));
    }
    if (m.find("NoticeStartTime") != m.end() && !m["NoticeStartTime"].empty()) {
      noticeStartTime = make_shared<long>(boost::any_cast<long>(m["NoticeStartTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesNotice() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRules : public Darabonba::Model {
public:
  shared_ptr<SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext> alarmContext{};
  shared_ptr<string> alertLevel{};
  shared_ptr<SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule> alertRule{};
  shared_ptr<string> alertTitle{};
  shared_ptr<long> alertType{};
  shared_ptr<long> alertVersion{};
  shared_ptr<vector<string>> alertWays{};
  shared_ptr<string> config{};
  shared_ptr<string> contactGroupIdList{};
  shared_ptr<string> contactGroupIds{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> hostByAlertManager{};
  shared_ptr<long> id{};
  shared_ptr<SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam> metricParam{};
  shared_ptr<SearchAlertRulesResponseBodyPageBeanAlertRulesNotice> notice{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> title{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchAlertRulesResponseBodyPageBeanAlertRules() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmContext) {
      res["AlarmContext"] = alarmContext ? boost::any(alarmContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertLevel) {
      res["AlertLevel"] = boost::any(*alertLevel);
    }
    if (alertRule) {
      res["AlertRule"] = alertRule ? boost::any(alertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertTitle) {
      res["AlertTitle"] = boost::any(*alertTitle);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (alertVersion) {
      res["AlertVersion"] = boost::any(*alertVersion);
    }
    if (alertWays) {
      res["AlertWays"] = boost::any(*alertWays);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (contactGroupIdList) {
      res["ContactGroupIdList"] = boost::any(*contactGroupIdList);
    }
    if (contactGroupIds) {
      res["ContactGroupIds"] = boost::any(*contactGroupIds);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hostByAlertManager) {
      res["HostByAlertManager"] = boost::any(*hostByAlertManager);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricParam) {
      res["MetricParam"] = metricParam ? boost::any(metricParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notice) {
      res["Notice"] = notice ? boost::any(notice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmContext") != m.end() && !m["AlarmContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlarmContext"].type()) {
        SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlarmContext"]));
        alarmContext = make_shared<SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext>(model1);
      }
    }
    if (m.find("AlertLevel") != m.end() && !m["AlertLevel"].empty()) {
      alertLevel = make_shared<string>(boost::any_cast<string>(m["AlertLevel"]));
    }
    if (m.find("AlertRule") != m.end() && !m["AlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRule"].type()) {
        SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRule"]));
        alertRule = make_shared<SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule>(model1);
      }
    }
    if (m.find("AlertTitle") != m.end() && !m["AlertTitle"].empty()) {
      alertTitle = make_shared<string>(boost::any_cast<string>(m["AlertTitle"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<long>(boost::any_cast<long>(m["AlertType"]));
    }
    if (m.find("AlertVersion") != m.end() && !m["AlertVersion"].empty()) {
      alertVersion = make_shared<long>(boost::any_cast<long>(m["AlertVersion"]));
    }
    if (m.find("AlertWays") != m.end() && !m["AlertWays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertWays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertWays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertWays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("ContactGroupIdList") != m.end() && !m["ContactGroupIdList"].empty()) {
      contactGroupIdList = make_shared<string>(boost::any_cast<string>(m["ContactGroupIdList"]));
    }
    if (m.find("ContactGroupIds") != m.end() && !m["ContactGroupIds"].empty()) {
      contactGroupIds = make_shared<string>(boost::any_cast<string>(m["ContactGroupIds"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("HostByAlertManager") != m.end() && !m["HostByAlertManager"].empty()) {
      hostByAlertManager = make_shared<bool>(boost::any_cast<bool>(m["HostByAlertManager"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MetricParam") != m.end() && !m["MetricParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricParam"].type()) {
        SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricParam"]));
        metricParam = make_shared<SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam>(model1);
      }
    }
    if (m.find("Notice") != m.end() && !m["Notice"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notice"].type()) {
        SearchAlertRulesResponseBodyPageBeanAlertRulesNotice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notice"]));
        notice = make_shared<SearchAlertRulesResponseBodyPageBeanAlertRulesNotice>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRules() = default;
};
class SearchAlertRulesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<SearchAlertRulesResponseBodyPageBeanAlertRules>> alertRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  SearchAlertRulesResponseBodyPageBean() {}

  explicit SearchAlertRulesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRules) {
      vector<boost::any> temp1;
      for(auto item1:*alertRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertRules"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRules") != m.end() && !m["AlertRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertRules"].type()) {
        vector<SearchAlertRulesResponseBodyPageBeanAlertRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertRulesResponseBodyPageBeanAlertRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertRules = make_shared<vector<SearchAlertRulesResponseBodyPageBeanAlertRules>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBean() = default;
};
class SearchAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchAlertRulesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchAlertRulesResponseBody() {}

  explicit SearchAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchAlertRulesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchAlertRulesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchAlertRulesResponseBody() = default;
};
class SearchAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchAlertRulesResponseBody> body{};

  SearchAlertRulesResponse() {}

  explicit SearchAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchAlertRulesResponse() = default;
};
class SearchEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<long> alertType{};
  shared_ptr<string> appType{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<long> isTrigger{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  SearchEventsRequest() {}

  explicit SearchEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (isTrigger) {
      res["IsTrigger"] = boost::any(*isTrigger);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<long>(boost::any_cast<long>(m["AlertType"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("IsTrigger") != m.end() && !m["IsTrigger"].empty()) {
      isTrigger = make_shared<long>(boost::any_cast<long>(m["IsTrigger"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~SearchEventsRequest() = default;
};
class SearchEventsResponseBodyPageBeanEvent : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<string> alertRule{};
  shared_ptr<long> alertType{};
  shared_ptr<string> eventLevel{};
  shared_ptr<long> eventTime{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> links{};
  shared_ptr<string> message{};

  SearchEventsResponseBodyPageBeanEvent() {}

  explicit SearchEventsResponseBodyPageBeanEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertRule) {
      res["AlertRule"] = boost::any(*alertRule);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (eventLevel) {
      res["EventLevel"] = boost::any(*eventLevel);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (links) {
      res["Links"] = boost::any(*links);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertRule") != m.end() && !m["AlertRule"].empty()) {
      alertRule = make_shared<string>(boost::any_cast<string>(m["AlertRule"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<long>(boost::any_cast<long>(m["AlertType"]));
    }
    if (m.find("EventLevel") != m.end() && !m["EventLevel"].empty()) {
      eventLevel = make_shared<string>(boost::any_cast<string>(m["EventLevel"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Links") != m.end() && !m["Links"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Links"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Links"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      links = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~SearchEventsResponseBodyPageBeanEvent() = default;
};
class SearchEventsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<SearchEventsResponseBodyPageBeanEvent>> event{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  SearchEventsResponseBodyPageBean() {}

  explicit SearchEventsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      vector<boost::any> temp1;
      for(auto item1:*event){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Event"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      if (typeid(vector<boost::any>) == m["Event"].type()) {
        vector<SearchEventsResponseBodyPageBeanEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Event"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchEventsResponseBodyPageBeanEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        event = make_shared<vector<SearchEventsResponseBodyPageBeanEvent>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchEventsResponseBodyPageBean() = default;
};
class SearchEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> isTrigger{};
  shared_ptr<SearchEventsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchEventsResponseBody() {}

  explicit SearchEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isTrigger) {
      res["IsTrigger"] = boost::any(*isTrigger);
    }
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsTrigger") != m.end() && !m["IsTrigger"].empty()) {
      isTrigger = make_shared<long>(boost::any_cast<long>(m["IsTrigger"]));
    }
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchEventsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchEventsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchEventsResponseBody() = default;
};
class SearchEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchEventsResponseBody> body{};

  SearchEventsResponse() {}

  explicit SearchEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchEventsResponseBody>(model1);
      }
    }
  }


  virtual ~SearchEventsResponse() = default;
};
class SearchRetcodeAppByPageRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchRetcodeAppByPageRequestTags() {}

  explicit SearchRetcodeAppByPageRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchRetcodeAppByPageRequestTags() = default;
};
class SearchRetcodeAppByPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> retcodeAppId{};
  shared_ptr<string> retcodeAppName{};
  shared_ptr<vector<SearchRetcodeAppByPageRequestTags>> tags{};

  SearchRetcodeAppByPageRequest() {}

  explicit SearchRetcodeAppByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retcodeAppId) {
      res["RetcodeAppId"] = boost::any(*retcodeAppId);
    }
    if (retcodeAppName) {
      res["RetcodeAppName"] = boost::any(*retcodeAppName);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetcodeAppId") != m.end() && !m["RetcodeAppId"].empty()) {
      retcodeAppId = make_shared<string>(boost::any_cast<string>(m["RetcodeAppId"]));
    }
    if (m.find("RetcodeAppName") != m.end() && !m["RetcodeAppName"].empty()) {
      retcodeAppName = make_shared<string>(boost::any_cast<string>(m["RetcodeAppName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchRetcodeAppByPageRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchRetcodeAppByPageRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchRetcodeAppByPageRequestTags>>(expect1);
      }
    }
  }


  virtual ~SearchRetcodeAppByPageRequest() = default;
};
class SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags() {}

  explicit SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags() = default;
};
class SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> nickName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> retcodeAppType{};
  shared_ptr<vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps() {}

  explicit SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retcodeAppType) {
      res["RetcodeAppType"] = boost::any(*retcodeAppType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetcodeAppType") != m.end() && !m["RetcodeAppType"].empty()) {
      retcodeAppType = make_shared<string>(boost::any_cast<string>(m["RetcodeAppType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps() = default;
};
class SearchRetcodeAppByPageResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps>> retcodeApps{};
  shared_ptr<long> totalCount{};

  SearchRetcodeAppByPageResponseBodyPageBean() {}

  explicit SearchRetcodeAppByPageResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (retcodeApps) {
      vector<boost::any> temp1;
      for(auto item1:*retcodeApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RetcodeApps"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RetcodeApps") != m.end() && !m["RetcodeApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RetcodeApps"].type()) {
        vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RetcodeApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        retcodeApps = make_shared<vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchRetcodeAppByPageResponseBodyPageBean() = default;
};
class SearchRetcodeAppByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchRetcodeAppByPageResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchRetcodeAppByPageResponseBody() {}

  explicit SearchRetcodeAppByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchRetcodeAppByPageResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchRetcodeAppByPageResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchRetcodeAppByPageResponseBody() = default;
};
class SearchRetcodeAppByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchRetcodeAppByPageResponseBody> body{};

  SearchRetcodeAppByPageResponse() {}

  explicit SearchRetcodeAppByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchRetcodeAppByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchRetcodeAppByPageResponseBody>(model1);
      }
    }
  }


  virtual ~SearchRetcodeAppByPageResponse() = default;
};
class SearchTraceAppByNameRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTraceAppByNameRequestTags() {}

  explicit SearchTraceAppByNameRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTraceAppByNameRequestTags() = default;
};
class SearchTraceAppByNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<SearchTraceAppByNameRequestTags>> tags{};
  shared_ptr<string> traceAppName{};

  SearchTraceAppByNameRequest() {}

  explicit SearchTraceAppByNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (traceAppName) {
      res["TraceAppName"] = boost::any(*traceAppName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchTraceAppByNameRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByNameRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchTraceAppByNameRequestTags>>(expect1);
      }
    }
    if (m.find("TraceAppName") != m.end() && !m["TraceAppName"].empty()) {
      traceAppName = make_shared<string>(boost::any_cast<string>(m["TraceAppName"]));
    }
  }


  virtual ~SearchTraceAppByNameRequest() = default;
};
class SearchTraceAppByNameResponseBodyTraceAppsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTraceAppByNameResponseBodyTraceAppsTags() {}

  explicit SearchTraceAppByNameResponseBodyTraceAppsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTraceAppByNameResponseBodyTraceAppsTags() = default;
};
class SearchTraceAppByNameResponseBodyTraceApps : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> show{};
  shared_ptr<vector<SearchTraceAppByNameResponseBodyTraceAppsTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchTraceAppByNameResponseBodyTraceApps() {}

  explicit SearchTraceAppByNameResponseBodyTraceApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchTraceAppByNameResponseBodyTraceAppsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByNameResponseBodyTraceAppsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchTraceAppByNameResponseBodyTraceAppsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchTraceAppByNameResponseBodyTraceApps() = default;
};
class SearchTraceAppByNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<SearchTraceAppByNameResponseBodyTraceApps>> traceApps{};

  SearchTraceAppByNameResponseBody() {}

  explicit SearchTraceAppByNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceApps) {
      vector<boost::any> temp1;
      for(auto item1:*traceApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TraceApps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceApps") != m.end() && !m["TraceApps"].empty()) {
      if (typeid(vector<boost::any>) == m["TraceApps"].type()) {
        vector<SearchTraceAppByNameResponseBodyTraceApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TraceApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByNameResponseBodyTraceApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traceApps = make_shared<vector<SearchTraceAppByNameResponseBodyTraceApps>>(expect1);
      }
    }
  }


  virtual ~SearchTraceAppByNameResponseBody() = default;
};
class SearchTraceAppByNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTraceAppByNameResponseBody> body{};

  SearchTraceAppByNameResponse() {}

  explicit SearchTraceAppByNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTraceAppByNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTraceAppByNameResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTraceAppByNameResponse() = default;
};
class SearchTraceAppByPageRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTraceAppByPageRequestTags() {}

  explicit SearchTraceAppByPageRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTraceAppByPageRequestTags() = default;
};
class SearchTraceAppByPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<SearchTraceAppByPageRequestTags>> tags{};
  shared_ptr<string> traceAppName{};

  SearchTraceAppByPageRequest() {}

  explicit SearchTraceAppByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (traceAppName) {
      res["TraceAppName"] = boost::any(*traceAppName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchTraceAppByPageRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByPageRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchTraceAppByPageRequestTags>>(expect1);
      }
    }
    if (m.find("TraceAppName") != m.end() && !m["TraceAppName"].empty()) {
      traceAppName = make_shared<string>(boost::any_cast<string>(m["TraceAppName"]));
    }
  }


  virtual ~SearchTraceAppByPageRequest() = default;
};
class SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags() {}

  explicit SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags() = default;
};
class SearchTraceAppByPageResponseBodyPageBeanTraceApps : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> show{};
  shared_ptr<vector<SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchTraceAppByPageResponseBodyPageBeanTraceApps() {}

  explicit SearchTraceAppByPageResponseBodyPageBeanTraceApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchTraceAppByPageResponseBodyPageBeanTraceApps() = default;
};
class SearchTraceAppByPageResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<SearchTraceAppByPageResponseBodyPageBeanTraceApps>> traceApps{};

  SearchTraceAppByPageResponseBodyPageBean() {}

  explicit SearchTraceAppByPageResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (traceApps) {
      vector<boost::any> temp1;
      for(auto item1:*traceApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TraceApps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TraceApps") != m.end() && !m["TraceApps"].empty()) {
      if (typeid(vector<boost::any>) == m["TraceApps"].type()) {
        vector<SearchTraceAppByPageResponseBodyPageBeanTraceApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TraceApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByPageResponseBodyPageBeanTraceApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traceApps = make_shared<vector<SearchTraceAppByPageResponseBodyPageBeanTraceApps>>(expect1);
      }
    }
  }


  virtual ~SearchTraceAppByPageResponseBodyPageBean() = default;
};
class SearchTraceAppByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchTraceAppByPageResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchTraceAppByPageResponseBody() {}

  explicit SearchTraceAppByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchTraceAppByPageResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchTraceAppByPageResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchTraceAppByPageResponseBody() = default;
};
class SearchTraceAppByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTraceAppByPageResponseBody> body{};

  SearchTraceAppByPageResponse() {}

  explicit SearchTraceAppByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTraceAppByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTraceAppByPageResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTraceAppByPageResponse() = default;
};
class SearchTracesRequestExclusionFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTracesRequestExclusionFilters() {}

  explicit SearchTracesRequestExclusionFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTracesRequestExclusionFilters() = default;
};
class SearchTracesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTracesRequestTag() {}

  explicit SearchTracesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTracesRequestTag() = default;
};
class SearchTracesRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<SearchTracesRequestExclusionFilters>> exclusionFilters{};
  shared_ptr<long> minDuration{};
  shared_ptr<string> operationName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> reverse{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<SearchTracesRequestTag>> tag{};

  SearchTracesRequest() {}

  explicit SearchTracesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (exclusionFilters) {
      vector<boost::any> temp1;
      for(auto item1:*exclusionFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExclusionFilters"] = boost::any(temp1);
    }
    if (minDuration) {
      res["MinDuration"] = boost::any(*minDuration);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExclusionFilters") != m.end() && !m["ExclusionFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["ExclusionFilters"].type()) {
        vector<SearchTracesRequestExclusionFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExclusionFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesRequestExclusionFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        exclusionFilters = make_shared<vector<SearchTracesRequestExclusionFilters>>(expect1);
      }
    }
    if (m.find("MinDuration") != m.end() && !m["MinDuration"].empty()) {
      minDuration = make_shared<long>(boost::any_cast<long>(m["MinDuration"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<SearchTracesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<SearchTracesRequestTag>>(expect1);
      }
    }
  }


  virtual ~SearchTracesRequest() = default;
};
class SearchTracesResponseBodyTraceInfos : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> operationName{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> spanID{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> traceID{};

  SearchTracesResponseBodyTraceInfos() {}

  explicit SearchTracesResponseBodyTraceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (spanID) {
      res["SpanID"] = boost::any(*spanID);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("SpanID") != m.end() && !m["SpanID"].empty()) {
      spanID = make_shared<string>(boost::any_cast<string>(m["SpanID"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~SearchTracesResponseBodyTraceInfos() = default;
};
class SearchTracesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<SearchTracesResponseBodyTraceInfos>> traceInfos{};

  SearchTracesResponseBody() {}

  explicit SearchTracesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*traceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TraceInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceInfos") != m.end() && !m["TraceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["TraceInfos"].type()) {
        vector<SearchTracesResponseBodyTraceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TraceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesResponseBodyTraceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traceInfos = make_shared<vector<SearchTracesResponseBodyTraceInfos>>(expect1);
      }
    }
  }


  virtual ~SearchTracesResponseBody() = default;
};
class SearchTracesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTracesResponseBody> body{};

  SearchTracesResponse() {}

  explicit SearchTracesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTracesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTracesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTracesResponse() = default;
};
class SearchTracesByPageRequestExclusionFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTracesByPageRequestExclusionFilters() {}

  explicit SearchTracesByPageRequestExclusionFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTracesByPageRequestExclusionFilters() = default;
};
class SearchTracesByPageRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTracesByPageRequestTags() {}

  explicit SearchTracesByPageRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTracesByPageRequestTags() = default;
};
class SearchTracesByPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<SearchTracesByPageRequestExclusionFilters>> exclusionFilters{};
  shared_ptr<bool> isError{};
  shared_ptr<long> minDuration{};
  shared_ptr<string> operationName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> reverse{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<SearchTracesByPageRequestTags>> tags{};

  SearchTracesByPageRequest() {}

  explicit SearchTracesByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (exclusionFilters) {
      vector<boost::any> temp1;
      for(auto item1:*exclusionFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExclusionFilters"] = boost::any(temp1);
    }
    if (isError) {
      res["IsError"] = boost::any(*isError);
    }
    if (minDuration) {
      res["MinDuration"] = boost::any(*minDuration);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExclusionFilters") != m.end() && !m["ExclusionFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["ExclusionFilters"].type()) {
        vector<SearchTracesByPageRequestExclusionFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExclusionFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesByPageRequestExclusionFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        exclusionFilters = make_shared<vector<SearchTracesByPageRequestExclusionFilters>>(expect1);
      }
    }
    if (m.find("IsError") != m.end() && !m["IsError"].empty()) {
      isError = make_shared<bool>(boost::any_cast<bool>(m["IsError"]));
    }
    if (m.find("MinDuration") != m.end() && !m["MinDuration"].empty()) {
      minDuration = make_shared<long>(boost::any_cast<long>(m["MinDuration"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchTracesByPageRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesByPageRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchTracesByPageRequestTags>>(expect1);
      }
    }
  }


  virtual ~SearchTracesByPageRequest() = default;
};
class SearchTracesByPageResponseBodyPageBeanTraceInfos : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> operationName{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> spanID{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> traceID{};

  SearchTracesByPageResponseBodyPageBeanTraceInfos() {}

  explicit SearchTracesByPageResponseBodyPageBeanTraceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (spanID) {
      res["SpanID"] = boost::any(*spanID);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("SpanID") != m.end() && !m["SpanID"].empty()) {
      spanID = make_shared<string>(boost::any_cast<string>(m["SpanID"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~SearchTracesByPageResponseBodyPageBeanTraceInfos() = default;
};
class SearchTracesByPageResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<vector<SearchTracesByPageResponseBodyPageBeanTraceInfos>> traceInfos{};

  SearchTracesByPageResponseBodyPageBean() {}

  explicit SearchTracesByPageResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (traceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*traceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TraceInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TraceInfos") != m.end() && !m["TraceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["TraceInfos"].type()) {
        vector<SearchTracesByPageResponseBodyPageBeanTraceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TraceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesByPageResponseBodyPageBeanTraceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traceInfos = make_shared<vector<SearchTracesByPageResponseBodyPageBeanTraceInfos>>(expect1);
      }
    }
  }


  virtual ~SearchTracesByPageResponseBodyPageBean() = default;
};
class SearchTracesByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchTracesByPageResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchTracesByPageResponseBody() {}

  explicit SearchTracesByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchTracesByPageResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchTracesByPageResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchTracesByPageResponseBody() = default;
};
class SearchTracesByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTracesByPageResponseBody> body{};

  SearchTracesByPageResponse() {}

  explicit SearchTracesByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTracesByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTracesByPageResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTracesByPageResponse() = default;
};
class SendTTSVerifyLinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> phone{};

  SendTTSVerifyLinkRequest() {}

  explicit SendTTSVerifyLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~SendTTSVerifyLinkRequest() = default;
};
class SendTTSVerifyLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  SendTTSVerifyLinkResponseBody() {}

  explicit SendTTSVerifyLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendTTSVerifyLinkResponseBody() = default;
};
class SendTTSVerifyLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendTTSVerifyLinkResponseBody> body{};

  SendTTSVerifyLinkResponse() {}

  explicit SendTTSVerifyLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendTTSVerifyLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendTTSVerifyLinkResponseBody>(model1);
      }
    }
  }


  virtual ~SendTTSVerifyLinkResponse() = default;
};
class SetRetcodeShareStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> pid{};
  shared_ptr<bool> status{};

  SetRetcodeShareStatusRequest() {}

  explicit SetRetcodeShareStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~SetRetcodeShareStatusRequest() = default;
};
class SetRetcodeShareStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  SetRetcodeShareStatusResponseBody() {}

  explicit SetRetcodeShareStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetRetcodeShareStatusResponseBody() = default;
};
class SetRetcodeShareStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetRetcodeShareStatusResponseBody> body{};

  SetRetcodeShareStatusResponse() {}

  explicit SetRetcodeShareStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetRetcodeShareStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetRetcodeShareStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetRetcodeShareStatusResponse() = default;
};
class StartAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertId{};
  shared_ptr<string> regionId{};

  StartAlertRequest() {}

  explicit StartAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<string>(boost::any_cast<string>(m["AlertId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StartAlertRequest() = default;
};
class StartAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  StartAlertResponseBody() {}

  explicit StartAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartAlertResponseBody() = default;
};
class StartAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartAlertResponseBody> body{};

  StartAlertResponse() {}

  explicit StartAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartAlertResponseBody>(model1);
      }
    }
  }


  virtual ~StartAlertResponse() = default;
};
class StartTimingSyntheticTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> taskIds{};

  StartTimingSyntheticTaskRequest() {}

  explicit StartTimingSyntheticTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StartTimingSyntheticTaskRequest() = default;
};
class StartTimingSyntheticTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> taskIdsShrink{};

  StartTimingSyntheticTaskShrinkRequest() {}

  explicit StartTimingSyntheticTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskIdsShrink) {
      res["TaskIds"] = boost::any(*taskIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIdsShrink = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
  }


  virtual ~StartTimingSyntheticTaskShrinkRequest() = default;
};
class StartTimingSyntheticTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  StartTimingSyntheticTaskResponseBody() {}

  explicit StartTimingSyntheticTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartTimingSyntheticTaskResponseBody() = default;
};
class StartTimingSyntheticTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartTimingSyntheticTaskResponseBody> body{};

  StartTimingSyntheticTaskResponse() {}

  explicit StartTimingSyntheticTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartTimingSyntheticTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartTimingSyntheticTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StartTimingSyntheticTaskResponse() = default;
};
class StopAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertId{};
  shared_ptr<string> regionId{};

  StopAlertRequest() {}

  explicit StopAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<string>(boost::any_cast<string>(m["AlertId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopAlertRequest() = default;
};
class StopAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  StopAlertResponseBody() {}

  explicit StopAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopAlertResponseBody() = default;
};
class StopAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopAlertResponseBody> body{};

  StopAlertResponse() {}

  explicit StopAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopAlertResponseBody>(model1);
      }
    }
  }


  virtual ~StopAlertResponse() = default;
};
class StopTimingSyntheticTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> taskIds{};

  StopTimingSyntheticTaskRequest() {}

  explicit StopTimingSyntheticTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StopTimingSyntheticTaskRequest() = default;
};
class StopTimingSyntheticTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> taskIdsShrink{};

  StopTimingSyntheticTaskShrinkRequest() {}

  explicit StopTimingSyntheticTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskIdsShrink) {
      res["TaskIds"] = boost::any(*taskIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIdsShrink = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
  }


  virtual ~StopTimingSyntheticTaskShrinkRequest() = default;
};
class StopTimingSyntheticTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  StopTimingSyntheticTaskResponseBody() {}

  explicit StopTimingSyntheticTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopTimingSyntheticTaskResponseBody() = default;
};
class StopTimingSyntheticTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopTimingSyntheticTaskResponseBody> body{};

  StopTimingSyntheticTaskResponse() {}

  explicit StopTimingSyntheticTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopTimingSyntheticTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopTimingSyntheticTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StopTimingSyntheticTaskResponse() = default;
};
class SwitchSyntheticTaskStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> switchStatus{};
  shared_ptr<vector<long>> taskIds{};

  SwitchSyntheticTaskStatusRequest() {}

  explicit SwitchSyntheticTaskStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (switchStatus) {
      res["SwitchStatus"] = boost::any(*switchStatus);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SwitchStatus") != m.end() && !m["SwitchStatus"].empty()) {
      switchStatus = make_shared<long>(boost::any_cast<long>(m["SwitchStatus"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~SwitchSyntheticTaskStatusRequest() = default;
};
class SwitchSyntheticTaskStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  SwitchSyntheticTaskStatusResponseBody() {}

  explicit SwitchSyntheticTaskStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~SwitchSyntheticTaskStatusResponseBody() = default;
};
class SwitchSyntheticTaskStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchSyntheticTaskStatusResponseBody> body{};

  SwitchSyntheticTaskStatusResponse() {}

  explicit SwitchSyntheticTaskStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchSyntheticTaskStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchSyntheticTaskStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchSyntheticTaskStatusResponse() = default;
};
class SyncRecordingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> targetClusters{};

  SyncRecordingRulesRequest() {}

  explicit SyncRecordingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetClusters) {
      res["TargetClusters"] = boost::any(*targetClusters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetClusters") != m.end() && !m["TargetClusters"].empty()) {
      targetClusters = make_shared<string>(boost::any_cast<string>(m["TargetClusters"]));
    }
  }


  virtual ~SyncRecordingRulesRequest() = default;
};
class SyncRecordingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  SyncRecordingRulesResponseBody() {}

  explicit SyncRecordingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SyncRecordingRulesResponseBody() = default;
};
class SyncRecordingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncRecordingRulesResponseBody> body{};

  SyncRecordingRulesResponse() {}

  explicit SyncRecordingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncRecordingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncRecordingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~SyncRecordingRulesResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UninstallManagedPrometheusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vpcId{};

  UninstallManagedPrometheusRequest() {}

  explicit UninstallManagedPrometheusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~UninstallManagedPrometheusRequest() = default;
};
class UninstallManagedPrometheusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UninstallManagedPrometheusResponseBody() {}

  explicit UninstallManagedPrometheusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UninstallManagedPrometheusResponseBody() = default;
};
class UninstallManagedPrometheusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallManagedPrometheusResponseBody> body{};

  UninstallManagedPrometheusResponse() {}

  explicit UninstallManagedPrometheusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallManagedPrometheusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallManagedPrometheusResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallManagedPrometheusResponse() = default;
};
class UninstallPromClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  UninstallPromClusterRequest() {}

  explicit UninstallPromClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UninstallPromClusterRequest() = default;
};
class UninstallPromClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UninstallPromClusterResponseBody() {}

  explicit UninstallPromClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UninstallPromClusterResponseBody() = default;
};
class UninstallPromClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallPromClusterResponseBody> body{};

  UninstallPromClusterResponse() {}

  explicit UninstallPromClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallPromClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallPromClusterResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallPromClusterResponse() = default;
};
class UntagResourcesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UntagResourcesRequestTags() {}

  explicit UntagResourcesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UntagResourcesRequestTags() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};
  shared_ptr<vector<UntagResourcesRequestTags>> tags{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UntagResourcesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UntagResourcesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UntagResourcesRequestTags>>(expect1);
      }
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAlertContactRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> dingRobotWebhookUrl{};
  shared_ptr<string> email{};
  shared_ptr<string> phoneNum{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> systemNoc{};

  UpdateAlertContactRequest() {}

  explicit UpdateAlertContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (dingRobotWebhookUrl) {
      res["DingRobotWebhookUrl"] = boost::any(*dingRobotWebhookUrl);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (systemNoc) {
      res["SystemNoc"] = boost::any(*systemNoc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("DingRobotWebhookUrl") != m.end() && !m["DingRobotWebhookUrl"].empty()) {
      dingRobotWebhookUrl = make_shared<string>(boost::any_cast<string>(m["DingRobotWebhookUrl"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SystemNoc") != m.end() && !m["SystemNoc"].empty()) {
      systemNoc = make_shared<bool>(boost::any_cast<bool>(m["SystemNoc"]));
    }
  }


  virtual ~UpdateAlertContactRequest() = default;
};
class UpdateAlertContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  UpdateAlertContactResponseBody() {}

  explicit UpdateAlertContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAlertContactResponseBody() = default;
};
class UpdateAlertContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAlertContactResponseBody> body{};

  UpdateAlertContactResponse() {}

  explicit UpdateAlertContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAlertContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAlertContactResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAlertContactResponse() = default;
};
class UpdateAlertContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactGroupId{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> contactIds{};
  shared_ptr<string> regionId{};

  UpdateAlertContactGroupRequest() {}

  explicit UpdateAlertContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<long>(boost::any_cast<long>(m["ContactGroupId"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateAlertContactGroupRequest() = default;
};
class UpdateAlertContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  UpdateAlertContactGroupResponseBody() {}

  explicit UpdateAlertContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAlertContactGroupResponseBody() = default;
};
class UpdateAlertContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAlertContactGroupResponseBody> body{};

  UpdateAlertContactGroupResponse() {}

  explicit UpdateAlertContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAlertContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAlertContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAlertContactGroupResponse() = default;
};
class UpdateAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> contactGroupIds{};
  shared_ptr<bool> isAutoStart{};
  shared_ptr<string> regionId{};
  shared_ptr<string> templageAlertConfig{};

  UpdateAlertRuleRequest() {}

  explicit UpdateAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (contactGroupIds) {
      res["ContactGroupIds"] = boost::any(*contactGroupIds);
    }
    if (isAutoStart) {
      res["IsAutoStart"] = boost::any(*isAutoStart);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templageAlertConfig) {
      res["TemplageAlertConfig"] = boost::any(*templageAlertConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("ContactGroupIds") != m.end() && !m["ContactGroupIds"].empty()) {
      contactGroupIds = make_shared<string>(boost::any_cast<string>(m["ContactGroupIds"]));
    }
    if (m.find("IsAutoStart") != m.end() && !m["IsAutoStart"].empty()) {
      isAutoStart = make_shared<bool>(boost::any_cast<bool>(m["IsAutoStart"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplageAlertConfig") != m.end() && !m["TemplageAlertConfig"].empty()) {
      templageAlertConfig = make_shared<string>(boost::any_cast<string>(m["TemplageAlertConfig"]));
    }
  }


  virtual ~UpdateAlertRuleRequest() = default;
};
class UpdateAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  UpdateAlertRuleResponseBody() {}

  explicit UpdateAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAlertRuleResponseBody() = default;
};
class UpdateAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAlertRuleResponseBody> body{};

  UpdateAlertRuleResponse() {}

  explicit UpdateAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAlertRuleResponse() = default;
};
class UpdateDispatchRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> dispatchRule{};
  shared_ptr<string> regionId{};

  UpdateDispatchRuleRequest() {}

  explicit UpdateDispatchRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchRule) {
      res["DispatchRule"] = boost::any(*dispatchRule);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchRule") != m.end() && !m["DispatchRule"].empty()) {
      dispatchRule = make_shared<string>(boost::any_cast<string>(m["DispatchRule"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateDispatchRuleRequest() = default;
};
class UpdateDispatchRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDispatchRuleResponseBody() {}

  explicit UpdateDispatchRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDispatchRuleResponseBody() = default;
};
class UpdateDispatchRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDispatchRuleResponseBody> body{};

  UpdateDispatchRuleResponse() {}

  explicit UpdateDispatchRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDispatchRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDispatchRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDispatchRuleResponse() = default;
};
class UpdateEnvCustomJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> customJobName{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  UpdateEnvCustomJobRequest() {}

  explicit UpdateEnvCustomJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (customJobName) {
      res["CustomJobName"] = boost::any(*customJobName);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("CustomJobName") != m.end() && !m["CustomJobName"].empty()) {
      customJobName = make_shared<string>(boost::any_cast<string>(m["CustomJobName"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateEnvCustomJobRequest() = default;
};
class UpdateEnvCustomJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateEnvCustomJobResponseBody() {}

  explicit UpdateEnvCustomJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEnvCustomJobResponseBody() = default;
};
class UpdateEnvCustomJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEnvCustomJobResponseBody> body{};

  UpdateEnvCustomJobResponse() {}

  explicit UpdateEnvCustomJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEnvCustomJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEnvCustomJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEnvCustomJobResponse() = default;
};
class UpdateEnvPodMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> configYaml{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> podMonitorName{};
  shared_ptr<string> regionId{};

  UpdateEnvPodMonitorRequest() {}

  explicit UpdateEnvPodMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (podMonitorName) {
      res["PodMonitorName"] = boost::any(*podMonitorName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PodMonitorName") != m.end() && !m["PodMonitorName"].empty()) {
      podMonitorName = make_shared<string>(boost::any_cast<string>(m["PodMonitorName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateEnvPodMonitorRequest() = default;
};
class UpdateEnvPodMonitorResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> matchedMsg{};
  shared_ptr<string> matchedTargetCount{};

  UpdateEnvPodMonitorResponseBodyData() {}

  explicit UpdateEnvPodMonitorResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchedMsg) {
      res["MatchedMsg"] = boost::any(*matchedMsg);
    }
    if (matchedTargetCount) {
      res["MatchedTargetCount"] = boost::any(*matchedTargetCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchedMsg") != m.end() && !m["MatchedMsg"].empty()) {
      matchedMsg = make_shared<string>(boost::any_cast<string>(m["MatchedMsg"]));
    }
    if (m.find("MatchedTargetCount") != m.end() && !m["MatchedTargetCount"].empty()) {
      matchedTargetCount = make_shared<string>(boost::any_cast<string>(m["MatchedTargetCount"]));
    }
  }


  virtual ~UpdateEnvPodMonitorResponseBodyData() = default;
};
class UpdateEnvPodMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdateEnvPodMonitorResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateEnvPodMonitorResponseBody() {}

  explicit UpdateEnvPodMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateEnvPodMonitorResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateEnvPodMonitorResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEnvPodMonitorResponseBody() = default;
};
class UpdateEnvPodMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEnvPodMonitorResponseBody> body{};

  UpdateEnvPodMonitorResponse() {}

  explicit UpdateEnvPodMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEnvPodMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEnvPodMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEnvPodMonitorResponse() = default;
};
class UpdateEnvServiceMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> configYaml{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceMonitorName{};

  UpdateEnvServiceMonitorRequest() {}

  explicit UpdateEnvServiceMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceMonitorName) {
      res["ServiceMonitorName"] = boost::any(*serviceMonitorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceMonitorName") != m.end() && !m["ServiceMonitorName"].empty()) {
      serviceMonitorName = make_shared<string>(boost::any_cast<string>(m["ServiceMonitorName"]));
    }
  }


  virtual ~UpdateEnvServiceMonitorRequest() = default;
};
class UpdateEnvServiceMonitorResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> matchedMsg{};
  shared_ptr<string> matchedTargetCount{};

  UpdateEnvServiceMonitorResponseBodyData() {}

  explicit UpdateEnvServiceMonitorResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchedMsg) {
      res["MatchedMsg"] = boost::any(*matchedMsg);
    }
    if (matchedTargetCount) {
      res["MatchedTargetCount"] = boost::any(*matchedTargetCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchedMsg") != m.end() && !m["MatchedMsg"].empty()) {
      matchedMsg = make_shared<string>(boost::any_cast<string>(m["MatchedMsg"]));
    }
    if (m.find("MatchedTargetCount") != m.end() && !m["MatchedTargetCount"].empty()) {
      matchedTargetCount = make_shared<string>(boost::any_cast<string>(m["MatchedTargetCount"]));
    }
  }


  virtual ~UpdateEnvServiceMonitorResponseBodyData() = default;
};
class UpdateEnvServiceMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdateEnvServiceMonitorResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateEnvServiceMonitorResponseBody() {}

  explicit UpdateEnvServiceMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateEnvServiceMonitorResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateEnvServiceMonitorResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEnvServiceMonitorResponseBody() = default;
};
class UpdateEnvServiceMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEnvServiceMonitorResponseBody> body{};

  UpdateEnvServiceMonitorResponse() {}

  explicit UpdateEnvServiceMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEnvServiceMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEnvServiceMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEnvServiceMonitorResponse() = default;
};
class UpdateEnvironmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> environmentName{};
  shared_ptr<string> feePackage{};
  shared_ptr<string> regionId{};

  UpdateEnvironmentRequest() {}

  explicit UpdateEnvironmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (environmentName) {
      res["EnvironmentName"] = boost::any(*environmentName);
    }
    if (feePackage) {
      res["FeePackage"] = boost::any(*feePackage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("EnvironmentName") != m.end() && !m["EnvironmentName"].empty()) {
      environmentName = make_shared<string>(boost::any_cast<string>(m["EnvironmentName"]));
    }
    if (m.find("FeePackage") != m.end() && !m["FeePackage"].empty()) {
      feePackage = make_shared<string>(boost::any_cast<string>(m["FeePackage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateEnvironmentRequest() = default;
};
class UpdateEnvironmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateEnvironmentResponseBody() {}

  explicit UpdateEnvironmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEnvironmentResponseBody() = default;
};
class UpdateEnvironmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEnvironmentResponseBody> body{};

  UpdateEnvironmentResponse() {}

  explicit UpdateEnvironmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEnvironmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEnvironmentResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEnvironmentResponse() = default;
};
class UpdateGrafanaWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> description{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<string> grafanaWorkspaceName{};
  shared_ptr<string> regionId{};

  UpdateGrafanaWorkspaceRequest() {}

  explicit UpdateGrafanaWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (grafanaWorkspaceId) {
      res["GrafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (grafanaWorkspaceName) {
      res["GrafanaWorkspaceName"] = boost::any(*grafanaWorkspaceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GrafanaWorkspaceId") != m.end() && !m["GrafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceId"]));
    }
    if (m.find("GrafanaWorkspaceName") != m.end() && !m["GrafanaWorkspaceName"].empty()) {
      grafanaWorkspaceName = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateGrafanaWorkspaceRequest() = default;
};
class UpdateGrafanaWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateGrafanaWorkspaceResponseBody() {}

  explicit UpdateGrafanaWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateGrafanaWorkspaceResponseBody() = default;
};
class UpdateGrafanaWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGrafanaWorkspaceResponseBody> body{};

  UpdateGrafanaWorkspaceResponse() {}

  explicit UpdateGrafanaWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGrafanaWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGrafanaWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGrafanaWorkspaceResponse() = default;
};
class UpdateGrafanaWorkspaceVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> grafanaVersion{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<string> regionId{};

  UpdateGrafanaWorkspaceVersionRequest() {}

  explicit UpdateGrafanaWorkspaceVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (grafanaVersion) {
      res["GrafanaVersion"] = boost::any(*grafanaVersion);
    }
    if (grafanaWorkspaceId) {
      res["GrafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("GrafanaVersion") != m.end() && !m["GrafanaVersion"].empty()) {
      grafanaVersion = make_shared<string>(boost::any_cast<string>(m["GrafanaVersion"]));
    }
    if (m.find("GrafanaWorkspaceId") != m.end() && !m["GrafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["GrafanaWorkspaceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateGrafanaWorkspaceVersionRequest() = default;
};
class UpdateGrafanaWorkspaceVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UpdateGrafanaWorkspaceVersionResponseBody() {}

  explicit UpdateGrafanaWorkspaceVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~UpdateGrafanaWorkspaceVersionResponseBody() = default;
};
class UpdateGrafanaWorkspaceVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGrafanaWorkspaceVersionResponseBody> body{};

  UpdateGrafanaWorkspaceVersionResponse() {}

  explicit UpdateGrafanaWorkspaceVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGrafanaWorkspaceVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGrafanaWorkspaceVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGrafanaWorkspaceVersionResponse() = default;
};
class UpdateIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRecover{};
  shared_ptr<string> description{};
  shared_ptr<string> duplicateKey{};
  shared_ptr<string> extendedFieldRedefineRules{};
  shared_ptr<string> fieldRedefineRules{};
  shared_ptr<string> initiativeRecoverField{};
  shared_ptr<string> initiativeRecoverValue{};
  shared_ptr<long> integrationId{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<string> liveness{};
  shared_ptr<long> recoverTime{};
  shared_ptr<string> stat{};
  shared_ptr<bool> state{};

  UpdateIntegrationRequest() {}

  explicit UpdateIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRecover) {
      res["AutoRecover"] = boost::any(*autoRecover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duplicateKey) {
      res["DuplicateKey"] = boost::any(*duplicateKey);
    }
    if (extendedFieldRedefineRules) {
      res["ExtendedFieldRedefineRules"] = boost::any(*extendedFieldRedefineRules);
    }
    if (fieldRedefineRules) {
      res["FieldRedefineRules"] = boost::any(*fieldRedefineRules);
    }
    if (initiativeRecoverField) {
      res["InitiativeRecoverField"] = boost::any(*initiativeRecoverField);
    }
    if (initiativeRecoverValue) {
      res["InitiativeRecoverValue"] = boost::any(*initiativeRecoverValue);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    if (stat) {
      res["Stat"] = boost::any(*stat);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRecover") != m.end() && !m["AutoRecover"].empty()) {
      autoRecover = make_shared<bool>(boost::any_cast<bool>(m["AutoRecover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DuplicateKey") != m.end() && !m["DuplicateKey"].empty()) {
      duplicateKey = make_shared<string>(boost::any_cast<string>(m["DuplicateKey"]));
    }
    if (m.find("ExtendedFieldRedefineRules") != m.end() && !m["ExtendedFieldRedefineRules"].empty()) {
      extendedFieldRedefineRules = make_shared<string>(boost::any_cast<string>(m["ExtendedFieldRedefineRules"]));
    }
    if (m.find("FieldRedefineRules") != m.end() && !m["FieldRedefineRules"].empty()) {
      fieldRedefineRules = make_shared<string>(boost::any_cast<string>(m["FieldRedefineRules"]));
    }
    if (m.find("InitiativeRecoverField") != m.end() && !m["InitiativeRecoverField"].empty()) {
      initiativeRecoverField = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverField"]));
    }
    if (m.find("InitiativeRecoverValue") != m.end() && !m["InitiativeRecoverValue"].empty()) {
      initiativeRecoverValue = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverValue"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
    if (m.find("Stat") != m.end() && !m["Stat"].empty()) {
      stat = make_shared<string>(boost::any_cast<string>(m["Stat"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<bool>(boost::any_cast<bool>(m["State"]));
    }
  }


  virtual ~UpdateIntegrationRequest() = default;
};
class UpdateIntegrationResponseBodyIntegration : public Darabonba::Model {
public:
  shared_ptr<string> apiEndpoint{};
  shared_ptr<bool> autoRecover{};
  shared_ptr<string> description{};
  shared_ptr<string> duplicateKey{};
  shared_ptr<vector<map<string, boost::any>>> extendedFieldRedefineRules{};
  shared_ptr<vector<map<string, boost::any>>> fieldRedefineRules{};
  shared_ptr<string> initiativeRecoverField{};
  shared_ptr<string> initiativeRecoverValue{};
  shared_ptr<long> integrationId{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<string> liveness{};
  shared_ptr<long> recoverTime{};
  shared_ptr<string> shortToken{};
  shared_ptr<vector<long>> stat{};
  shared_ptr<bool> state{};

  UpdateIntegrationResponseBodyIntegration() {}

  explicit UpdateIntegrationResponseBodyIntegration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiEndpoint) {
      res["ApiEndpoint"] = boost::any(*apiEndpoint);
    }
    if (autoRecover) {
      res["AutoRecover"] = boost::any(*autoRecover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duplicateKey) {
      res["DuplicateKey"] = boost::any(*duplicateKey);
    }
    if (extendedFieldRedefineRules) {
      res["ExtendedFieldRedefineRules"] = boost::any(*extendedFieldRedefineRules);
    }
    if (fieldRedefineRules) {
      res["FieldRedefineRules"] = boost::any(*fieldRedefineRules);
    }
    if (initiativeRecoverField) {
      res["InitiativeRecoverField"] = boost::any(*initiativeRecoverField);
    }
    if (initiativeRecoverValue) {
      res["InitiativeRecoverValue"] = boost::any(*initiativeRecoverValue);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    if (shortToken) {
      res["ShortToken"] = boost::any(*shortToken);
    }
    if (stat) {
      res["Stat"] = boost::any(*stat);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiEndpoint") != m.end() && !m["ApiEndpoint"].empty()) {
      apiEndpoint = make_shared<string>(boost::any_cast<string>(m["ApiEndpoint"]));
    }
    if (m.find("AutoRecover") != m.end() && !m["AutoRecover"].empty()) {
      autoRecover = make_shared<bool>(boost::any_cast<bool>(m["AutoRecover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DuplicateKey") != m.end() && !m["DuplicateKey"].empty()) {
      duplicateKey = make_shared<string>(boost::any_cast<string>(m["DuplicateKey"]));
    }
    if (m.find("ExtendedFieldRedefineRules") != m.end() && !m["ExtendedFieldRedefineRules"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["ExtendedFieldRedefineRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExtendedFieldRedefineRules"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      extendedFieldRedefineRules = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("FieldRedefineRules") != m.end() && !m["FieldRedefineRules"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["FieldRedefineRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldRedefineRules"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      fieldRedefineRules = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("InitiativeRecoverField") != m.end() && !m["InitiativeRecoverField"].empty()) {
      initiativeRecoverField = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverField"]));
    }
    if (m.find("InitiativeRecoverValue") != m.end() && !m["InitiativeRecoverValue"].empty()) {
      initiativeRecoverValue = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverValue"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
    if (m.find("ShortToken") != m.end() && !m["ShortToken"].empty()) {
      shortToken = make_shared<string>(boost::any_cast<string>(m["ShortToken"]));
    }
    if (m.find("Stat") != m.end() && !m["Stat"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Stat"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Stat"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      stat = make_shared<vector<long>>(toVec1);
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<bool>(boost::any_cast<bool>(m["State"]));
    }
  }


  virtual ~UpdateIntegrationResponseBodyIntegration() = default;
};
class UpdateIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateIntegrationResponseBodyIntegration> integration{};
  shared_ptr<string> requestId{};

  UpdateIntegrationResponseBody() {}

  explicit UpdateIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integration) {
      res["Integration"] = integration ? boost::any(integration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      if (typeid(map<string, boost::any>) == m["Integration"].type()) {
        UpdateIntegrationResponseBodyIntegration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Integration"]));
        integration = make_shared<UpdateIntegrationResponseBodyIntegration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateIntegrationResponseBody() = default;
};
class UpdateIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIntegrationResponseBody> body{};

  UpdateIntegrationResponse() {}

  explicit UpdateIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIntegrationResponse() = default;
};
class UpdateMetricDropRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> metricDrop{};
  shared_ptr<string> regionId{};

  UpdateMetricDropRequest() {}

  explicit UpdateMetricDropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (metricDrop) {
      res["MetricDrop"] = boost::any(*metricDrop);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MetricDrop") != m.end() && !m["MetricDrop"].empty()) {
      metricDrop = make_shared<string>(boost::any_cast<string>(m["MetricDrop"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateMetricDropRequest() = default;
};
class UpdateMetricDropResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateMetricDropResponseBody() {}

  explicit UpdateMetricDropResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMetricDropResponseBody() = default;
};
class UpdateMetricDropResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMetricDropResponseBody> body{};

  UpdateMetricDropResponse() {}

  explicit UpdateMetricDropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMetricDropResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMetricDropResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMetricDropResponse() = default;
};
class UpdatePrometheusAlertRuleRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdatePrometheusAlertRuleRequestTags() {}

  explicit UpdatePrometheusAlertRuleRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleRequestTags() = default;
};
class UpdatePrometheusAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<string> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<string> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<UpdatePrometheusAlertRuleRequestTags>> tags{};
  shared_ptr<string> type{};

  UpdatePrometheusAlertRuleRequest() {}

  explicit UpdatePrometheusAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UpdatePrometheusAlertRuleRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePrometheusAlertRuleRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UpdatePrometheusAlertRuleRequestTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleRequest() = default;
};
class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() {}

  explicit UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() = default;
};
class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() {}

  explicit UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() = default;
};
class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule() {}

  explicit UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>>(expect1);
      }
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule() = default;
};
class UpdatePrometheusAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule> prometheusAlertRule{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdatePrometheusAlertRuleResponseBody() {}

  explicit UpdatePrometheusAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (prometheusAlertRule) {
      res["PrometheusAlertRule"] = prometheusAlertRule ? boost::any(prometheusAlertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PrometheusAlertRule") != m.end() && !m["PrometheusAlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrometheusAlertRule"].type()) {
        UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrometheusAlertRule"]));
        prometheusAlertRule = make_shared<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleResponseBody() = default;
};
class UpdatePrometheusAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusAlertRuleResponseBody> body{};

  UpdatePrometheusAlertRuleResponse() {}

  explicit UpdatePrometheusAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusAlertRuleResponse() = default;
};
class UpdatePrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allSubClustersSuccess{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> mostRegionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> subClustersJson{};

  UpdatePrometheusGlobalViewRequest() {}

  explicit UpdatePrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allSubClustersSuccess) {
      res["AllSubClustersSuccess"] = boost::any(*allSubClustersSuccess);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (mostRegionId) {
      res["MostRegionId"] = boost::any(*mostRegionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (subClustersJson) {
      res["SubClustersJson"] = boost::any(*subClustersJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllSubClustersSuccess") != m.end() && !m["AllSubClustersSuccess"].empty()) {
      allSubClustersSuccess = make_shared<bool>(boost::any_cast<bool>(m["AllSubClustersSuccess"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("MostRegionId") != m.end() && !m["MostRegionId"].empty()) {
      mostRegionId = make_shared<string>(boost::any_cast<string>(m["MostRegionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SubClustersJson") != m.end() && !m["SubClustersJson"].empty()) {
      subClustersJson = make_shared<string>(boost::any_cast<string>(m["SubClustersJson"]));
    }
  }


  virtual ~UpdatePrometheusGlobalViewRequest() = default;
};
class UpdatePrometheusGlobalViewResponseBodyDataFailedInstances : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> userId{};

  UpdatePrometheusGlobalViewResponseBodyDataFailedInstances() {}

  explicit UpdatePrometheusGlobalViewResponseBodyDataFailedInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdatePrometheusGlobalViewResponseBodyDataFailedInstances() = default;
};
class UpdatePrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<UpdatePrometheusGlobalViewResponseBodyDataFailedInstances>> failedInstances{};
  shared_ptr<bool> success{};

  UpdatePrometheusGlobalViewResponseBodyData() {}

  explicit UpdatePrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedInstances) {
      vector<boost::any> temp1;
      for(auto item1:*failedInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedInstances"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedInstances") != m.end() && !m["FailedInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedInstances"].type()) {
        vector<UpdatePrometheusGlobalViewResponseBodyDataFailedInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePrometheusGlobalViewResponseBodyDataFailedInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedInstances = make_shared<vector<UpdatePrometheusGlobalViewResponseBodyDataFailedInstances>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdatePrometheusGlobalViewResponseBodyData() = default;
};
class UpdatePrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdatePrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdatePrometheusGlobalViewResponseBody() {}

  explicit UpdatePrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdatePrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdatePrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePrometheusGlobalViewResponseBody() = default;
};
class UpdatePrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusGlobalViewResponseBody> body{};

  UpdatePrometheusGlobalViewResponse() {}

  explicit UpdatePrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusGlobalViewResponse() = default;
};
class UpdatePrometheusInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> archiveDuration{};
  shared_ptr<string> authFreeReadPolicy{};
  shared_ptr<string> authFreeWritePolicy{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> enableAuthFreeRead{};
  shared_ptr<bool> enableAuthFreeWrite{};
  shared_ptr<bool> enableAuthToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> storageDuration{};

  UpdatePrometheusInstanceRequest() {}

  explicit UpdatePrometheusInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archiveDuration) {
      res["ArchiveDuration"] = boost::any(*archiveDuration);
    }
    if (authFreeReadPolicy) {
      res["AuthFreeReadPolicy"] = boost::any(*authFreeReadPolicy);
    }
    if (authFreeWritePolicy) {
      res["AuthFreeWritePolicy"] = boost::any(*authFreeWritePolicy);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (enableAuthFreeRead) {
      res["EnableAuthFreeRead"] = boost::any(*enableAuthFreeRead);
    }
    if (enableAuthFreeWrite) {
      res["EnableAuthFreeWrite"] = boost::any(*enableAuthFreeWrite);
    }
    if (enableAuthToken) {
      res["EnableAuthToken"] = boost::any(*enableAuthToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (storageDuration) {
      res["StorageDuration"] = boost::any(*storageDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchiveDuration") != m.end() && !m["ArchiveDuration"].empty()) {
      archiveDuration = make_shared<long>(boost::any_cast<long>(m["ArchiveDuration"]));
    }
    if (m.find("AuthFreeReadPolicy") != m.end() && !m["AuthFreeReadPolicy"].empty()) {
      authFreeReadPolicy = make_shared<string>(boost::any_cast<string>(m["AuthFreeReadPolicy"]));
    }
    if (m.find("AuthFreeWritePolicy") != m.end() && !m["AuthFreeWritePolicy"].empty()) {
      authFreeWritePolicy = make_shared<string>(boost::any_cast<string>(m["AuthFreeWritePolicy"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EnableAuthFreeRead") != m.end() && !m["EnableAuthFreeRead"].empty()) {
      enableAuthFreeRead = make_shared<bool>(boost::any_cast<bool>(m["EnableAuthFreeRead"]));
    }
    if (m.find("EnableAuthFreeWrite") != m.end() && !m["EnableAuthFreeWrite"].empty()) {
      enableAuthFreeWrite = make_shared<bool>(boost::any_cast<bool>(m["EnableAuthFreeWrite"]));
    }
    if (m.find("EnableAuthToken") != m.end() && !m["EnableAuthToken"].empty()) {
      enableAuthToken = make_shared<bool>(boost::any_cast<bool>(m["EnableAuthToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StorageDuration") != m.end() && !m["StorageDuration"].empty()) {
      storageDuration = make_shared<long>(boost::any_cast<long>(m["StorageDuration"]));
    }
  }


  virtual ~UpdatePrometheusInstanceRequest() = default;
};
class UpdatePrometheusInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdatePrometheusInstanceResponseBody() {}

  explicit UpdatePrometheusInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePrometheusInstanceResponseBody() = default;
};
class UpdatePrometheusInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusInstanceResponseBody> body{};

  UpdatePrometheusInstanceResponse() {}

  explicit UpdatePrometheusInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusInstanceResponse() = default;
};
class UpdatePrometheusIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> param{};
  shared_ptr<string> regionId{};

  UpdatePrometheusIntegrationRequest() {}

  explicit UpdatePrometheusIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdatePrometheusIntegrationRequest() = default;
};
class UpdatePrometheusIntegrationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};

  UpdatePrometheusIntegrationResponseBodyData() {}

  explicit UpdatePrometheusIntegrationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~UpdatePrometheusIntegrationResponseBodyData() = default;
};
class UpdatePrometheusIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdatePrometheusIntegrationResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdatePrometheusIntegrationResponseBody() {}

  explicit UpdatePrometheusIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdatePrometheusIntegrationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdatePrometheusIntegrationResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePrometheusIntegrationResponseBody() = default;
};
class UpdatePrometheusIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusIntegrationResponseBody> body{};

  UpdatePrometheusIntegrationResponse() {}

  explicit UpdatePrometheusIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusIntegrationResponse() = default;
};
class UpdatePrometheusMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  UpdatePrometheusMonitoringRequest() {}

  explicit UpdatePrometheusMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdatePrometheusMonitoringRequest() = default;
};
class UpdatePrometheusMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdatePrometheusMonitoringResponseBody() {}

  explicit UpdatePrometheusMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePrometheusMonitoringResponseBody() = default;
};
class UpdatePrometheusMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusMonitoringResponseBody> body{};

  UpdatePrometheusMonitoringResponse() {}

  explicit UpdatePrometheusMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusMonitoringResponse() = default;
};
class UpdatePrometheusMonitoringStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  UpdatePrometheusMonitoringStatusRequest() {}

  explicit UpdatePrometheusMonitoringStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdatePrometheusMonitoringStatusRequest() = default;
};
class UpdatePrometheusMonitoringStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdatePrometheusMonitoringStatusResponseBody() {}

  explicit UpdatePrometheusMonitoringStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePrometheusMonitoringStatusResponseBody() = default;
};
class UpdatePrometheusMonitoringStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusMonitoringStatusResponseBody> body{};

  UpdatePrometheusMonitoringStatusResponse() {}

  explicit UpdatePrometheusMonitoringStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusMonitoringStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusMonitoringStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusMonitoringStatusResponse() = default;
};
class UpdateRumAppRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRestart{};
  shared_ptr<string> backendServiceTraceRegion{};
  shared_ptr<string> bonreeSDKConfigJson{};
  shared_ptr<string> description{};
  shared_ptr<bool> isSubscribe{};
  shared_ptr<string> nickname{};
  shared_ptr<string> pid{};
  shared_ptr<string> realRegionId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> restart{};
  shared_ptr<string> serviceDomainOperationJson{};
  shared_ptr<bool> stop{};

  UpdateRumAppRequest() {}

  explicit UpdateRumAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRestart) {
      res["AutoRestart"] = boost::any(*autoRestart);
    }
    if (backendServiceTraceRegion) {
      res["BackendServiceTraceRegion"] = boost::any(*backendServiceTraceRegion);
    }
    if (bonreeSDKConfigJson) {
      res["BonreeSDKConfigJson"] = boost::any(*bonreeSDKConfigJson);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (isSubscribe) {
      res["IsSubscribe"] = boost::any(*isSubscribe);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (realRegionId) {
      res["RealRegionId"] = boost::any(*realRegionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (restart) {
      res["Restart"] = boost::any(*restart);
    }
    if (serviceDomainOperationJson) {
      res["ServiceDomainOperationJson"] = boost::any(*serviceDomainOperationJson);
    }
    if (stop) {
      res["Stop"] = boost::any(*stop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRestart") != m.end() && !m["AutoRestart"].empty()) {
      autoRestart = make_shared<bool>(boost::any_cast<bool>(m["AutoRestart"]));
    }
    if (m.find("BackendServiceTraceRegion") != m.end() && !m["BackendServiceTraceRegion"].empty()) {
      backendServiceTraceRegion = make_shared<string>(boost::any_cast<string>(m["BackendServiceTraceRegion"]));
    }
    if (m.find("BonreeSDKConfigJson") != m.end() && !m["BonreeSDKConfigJson"].empty()) {
      bonreeSDKConfigJson = make_shared<string>(boost::any_cast<string>(m["BonreeSDKConfigJson"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IsSubscribe") != m.end() && !m["IsSubscribe"].empty()) {
      isSubscribe = make_shared<bool>(boost::any_cast<bool>(m["IsSubscribe"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RealRegionId") != m.end() && !m["RealRegionId"].empty()) {
      realRegionId = make_shared<string>(boost::any_cast<string>(m["RealRegionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Restart") != m.end() && !m["Restart"].empty()) {
      restart = make_shared<bool>(boost::any_cast<bool>(m["Restart"]));
    }
    if (m.find("ServiceDomainOperationJson") != m.end() && !m["ServiceDomainOperationJson"].empty()) {
      serviceDomainOperationJson = make_shared<string>(boost::any_cast<string>(m["ServiceDomainOperationJson"]));
    }
    if (m.find("Stop") != m.end() && !m["Stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["Stop"]));
    }
  }


  virtual ~UpdateRumAppRequest() = default;
};
class UpdateRumAppResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<long> limit{};
  shared_ptr<bool> limited{};
  shared_ptr<long> usage{};

  UpdateRumAppResponseBodyData() {}

  explicit UpdateRumAppResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (limited) {
      res["Limited"] = boost::any(*limited);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Limited") != m.end() && !m["Limited"].empty()) {
      limited = make_shared<bool>(boost::any_cast<bool>(m["Limited"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
  }


  virtual ~UpdateRumAppResponseBodyData() = default;
};
class UpdateRumAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateRumAppResponseBodyData> data{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  UpdateRumAppResponseBody() {}

  explicit UpdateRumAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateRumAppResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateRumAppResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~UpdateRumAppResponseBody() = default;
};
class UpdateRumAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRumAppResponseBody> body{};

  UpdateRumAppResponse() {}

  explicit UpdateRumAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRumAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRumAppResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRumAppResponse() = default;
};
class UpdateRumFileStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> size{};
  shared_ptr<string> status{};
  shared_ptr<string> uuid{};
  shared_ptr<string> versionId{};

  UpdateRumFileStatusRequest() {}

  explicit UpdateRumFileStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~UpdateRumFileStatusRequest() = default;
};
class UpdateRumFileStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateRumFileStatusResponseBody() {}

  explicit UpdateRumFileStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateRumFileStatusResponseBody() = default;
};
class UpdateRumFileStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRumFileStatusResponseBody> body{};

  UpdateRumFileStatusResponse() {}

  explicit UpdateRumFileStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRumFileStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRumFileStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRumFileStatusResponse() = default;
};
class UpdateTimingSyntheticTaskRequestAvailableAssertions : public Darabonba::Model {
public:
  shared_ptr<string> expect{};
  shared_ptr<string> operator_{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  UpdateTimingSyntheticTaskRequestAvailableAssertions() {}

  explicit UpdateTimingSyntheticTaskRequestAvailableAssertions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expect) {
      res["Expect"] = boost::any(*expect);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expect") != m.end() && !m["Expect"].empty()) {
      expect = make_shared<string>(boost::any_cast<string>(m["Expect"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestAvailableAssertions() = default;
};
class UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ipType{};
  shared_ptr<vector<string>> ips{};

  UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts() {}

  explicit UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts() = default;
};
class UpdateTimingSyntheticTaskRequestCommonSettingCustomHost : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts>> hosts{};
  shared_ptr<long> selectType{};

  UpdateTimingSyntheticTaskRequestCommonSettingCustomHost() {}

  explicit UpdateTimingSyntheticTaskRequestCommonSettingCustomHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (selectType) {
      res["SelectType"] = boost::any(*selectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts>>(expect1);
      }
    }
    if (m.find("SelectType") != m.end() && !m["SelectType"].empty()) {
      selectType = make_shared<long>(boost::any_cast<long>(m["SelectType"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestCommonSettingCustomHost() = default;
};
class UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting : public Darabonba::Model {
public:
  shared_ptr<string> prometheusClusterId{};
  shared_ptr<string> prometheusClusterRegion{};
  shared_ptr<map<string, string>> prometheusLabels{};

  UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting() {}

  explicit UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prometheusClusterId) {
      res["PrometheusClusterId"] = boost::any(*prometheusClusterId);
    }
    if (prometheusClusterRegion) {
      res["PrometheusClusterRegion"] = boost::any(*prometheusClusterRegion);
    }
    if (prometheusLabels) {
      res["PrometheusLabels"] = boost::any(*prometheusLabels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrometheusClusterId") != m.end() && !m["PrometheusClusterId"].empty()) {
      prometheusClusterId = make_shared<string>(boost::any_cast<string>(m["PrometheusClusterId"]));
    }
    if (m.find("PrometheusClusterRegion") != m.end() && !m["PrometheusClusterRegion"].empty()) {
      prometheusClusterRegion = make_shared<string>(boost::any_cast<string>(m["PrometheusClusterRegion"]));
    }
    if (m.find("PrometheusLabels") != m.end() && !m["PrometheusLabels"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["PrometheusLabels"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      prometheusLabels = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting() = default;
};
class UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> secureGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting() {}

  explicit UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (secureGroupId) {
      res["SecureGroupId"] = boost::any(*secureGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecureGroupId") != m.end() && !m["SecureGroupId"].empty()) {
      secureGroupId = make_shared<string>(boost::any_cast<string>(m["SecureGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting() = default;
};
class UpdateTimingSyntheticTaskRequestCommonSetting : public Darabonba::Model {
public:
  shared_ptr<UpdateTimingSyntheticTaskRequestCommonSettingCustomHost> customHost{};
  shared_ptr<UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting> customPrometheusSetting{};
  shared_ptr<UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting> customVPCSetting{};
  shared_ptr<long> ipType{};
  shared_ptr<bool> isOpenTrace{};
  shared_ptr<long> monitorSamples{};
  shared_ptr<long> traceClientType{};
  shared_ptr<string> xtraceRegion{};

  UpdateTimingSyntheticTaskRequestCommonSetting() {}

  explicit UpdateTimingSyntheticTaskRequestCommonSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customHost) {
      res["CustomHost"] = customHost ? boost::any(customHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customPrometheusSetting) {
      res["CustomPrometheusSetting"] = customPrometheusSetting ? boost::any(customPrometheusSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customVPCSetting) {
      res["CustomVPCSetting"] = customVPCSetting ? boost::any(customVPCSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (isOpenTrace) {
      res["IsOpenTrace"] = boost::any(*isOpenTrace);
    }
    if (monitorSamples) {
      res["MonitorSamples"] = boost::any(*monitorSamples);
    }
    if (traceClientType) {
      res["TraceClientType"] = boost::any(*traceClientType);
    }
    if (xtraceRegion) {
      res["XtraceRegion"] = boost::any(*xtraceRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomHost") != m.end() && !m["CustomHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomHost"].type()) {
        UpdateTimingSyntheticTaskRequestCommonSettingCustomHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomHost"]));
        customHost = make_shared<UpdateTimingSyntheticTaskRequestCommonSettingCustomHost>(model1);
      }
    }
    if (m.find("CustomPrometheusSetting") != m.end() && !m["CustomPrometheusSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomPrometheusSetting"].type()) {
        UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomPrometheusSetting"]));
        customPrometheusSetting = make_shared<UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting>(model1);
      }
    }
    if (m.find("CustomVPCSetting") != m.end() && !m["CustomVPCSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomVPCSetting"].type()) {
        UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomVPCSetting"]));
        customVPCSetting = make_shared<UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting>(model1);
      }
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("IsOpenTrace") != m.end() && !m["IsOpenTrace"].empty()) {
      isOpenTrace = make_shared<bool>(boost::any_cast<bool>(m["IsOpenTrace"]));
    }
    if (m.find("MonitorSamples") != m.end() && !m["MonitorSamples"].empty()) {
      monitorSamples = make_shared<long>(boost::any_cast<long>(m["MonitorSamples"]));
    }
    if (m.find("TraceClientType") != m.end() && !m["TraceClientType"].empty()) {
      traceClientType = make_shared<long>(boost::any_cast<long>(m["TraceClientType"]));
    }
    if (m.find("XtraceRegion") != m.end() && !m["XtraceRegion"].empty()) {
      xtraceRegion = make_shared<string>(boost::any_cast<string>(m["XtraceRegion"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestCommonSetting() = default;
};
class UpdateTimingSyntheticTaskRequestCustomPeriod : public Darabonba::Model {
public:
  shared_ptr<long> endHour{};
  shared_ptr<long> startHour{};

  UpdateTimingSyntheticTaskRequestCustomPeriod() {}

  explicit UpdateTimingSyntheticTaskRequestCustomPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endHour) {
      res["EndHour"] = boost::any(*endHour);
    }
    if (startHour) {
      res["StartHour"] = boost::any(*startHour);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndHour") != m.end() && !m["EndHour"].empty()) {
      endHour = make_shared<long>(boost::any_cast<long>(m["EndHour"]));
    }
    if (m.find("StartHour") != m.end() && !m["StartHour"].empty()) {
      startHour = make_shared<long>(boost::any_cast<long>(m["StartHour"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestCustomPeriod() = default;
};
class UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> type{};

  UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody() {}

  explicit UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody() = default;
};
class UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP : public Darabonba::Model {
public:
  shared_ptr<bool> checkCert{};
  shared_ptr<long> connectTimeout{};
  shared_ptr<string> method{};
  shared_ptr<long> protocolAlpnProtocol{};
  shared_ptr<UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody> requestBody{};
  shared_ptr<map<string, string>> requestHeaders{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};

  UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP() {}

  explicit UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkCert) {
      res["CheckCert"] = boost::any(*checkCert);
    }
    if (connectTimeout) {
      res["ConnectTimeout"] = boost::any(*connectTimeout);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (protocolAlpnProtocol) {
      res["ProtocolAlpnProtocol"] = boost::any(*protocolAlpnProtocol);
    }
    if (requestBody) {
      res["RequestBody"] = requestBody ? boost::any(requestBody->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestHeaders) {
      res["RequestHeaders"] = boost::any(*requestHeaders);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckCert") != m.end() && !m["CheckCert"].empty()) {
      checkCert = make_shared<bool>(boost::any_cast<bool>(m["CheckCert"]));
    }
    if (m.find("ConnectTimeout") != m.end() && !m["ConnectTimeout"].empty()) {
      connectTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectTimeout"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("ProtocolAlpnProtocol") != m.end() && !m["ProtocolAlpnProtocol"].empty()) {
      protocolAlpnProtocol = make_shared<long>(boost::any_cast<long>(m["ProtocolAlpnProtocol"]));
    }
    if (m.find("RequestBody") != m.end() && !m["RequestBody"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestBody"].type()) {
        UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestBody"]));
        requestBody = make_shared<UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody>(model1);
      }
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["RequestHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      requestHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP() = default;
};
class UpdateTimingSyntheticTaskRequestMonitorConfFileDownload : public Darabonba::Model {
public:
  shared_ptr<long> connectionTimeout{};
  shared_ptr<map<string, string>> customHeaderContent{};
  shared_ptr<long> downloadKernel{};
  shared_ptr<long> ignoreCertificateAuthError{};
  shared_ptr<long> ignoreCertificateCanceledError{};
  shared_ptr<long> ignoreCertificateOutOfDateError{};
  shared_ptr<long> ignoreCertificateStatusError{};
  shared_ptr<long> ignoreCertificateUntrustworthyError{};
  shared_ptr<long> ignoreCertificateUsingError{};
  shared_ptr<long> ignoreInvalidHostError{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<long> quickProtocol{};
  shared_ptr<long> redirection{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> transmissionSize{};
  shared_ptr<string> validateKeywords{};
  shared_ptr<long> verifyWay{};
  shared_ptr<string> whiteList{};

  UpdateTimingSyntheticTaskRequestMonitorConfFileDownload() {}

  explicit UpdateTimingSyntheticTaskRequestMonitorConfFileDownload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionTimeout) {
      res["ConnectionTimeout"] = boost::any(*connectionTimeout);
    }
    if (customHeaderContent) {
      res["CustomHeaderContent"] = boost::any(*customHeaderContent);
    }
    if (downloadKernel) {
      res["DownloadKernel"] = boost::any(*downloadKernel);
    }
    if (ignoreCertificateAuthError) {
      res["IgnoreCertificateAuthError"] = boost::any(*ignoreCertificateAuthError);
    }
    if (ignoreCertificateCanceledError) {
      res["IgnoreCertificateCanceledError"] = boost::any(*ignoreCertificateCanceledError);
    }
    if (ignoreCertificateOutOfDateError) {
      res["IgnoreCertificateOutOfDateError"] = boost::any(*ignoreCertificateOutOfDateError);
    }
    if (ignoreCertificateStatusError) {
      res["IgnoreCertificateStatusError"] = boost::any(*ignoreCertificateStatusError);
    }
    if (ignoreCertificateUntrustworthyError) {
      res["IgnoreCertificateUntrustworthyError"] = boost::any(*ignoreCertificateUntrustworthyError);
    }
    if (ignoreCertificateUsingError) {
      res["IgnoreCertificateUsingError"] = boost::any(*ignoreCertificateUsingError);
    }
    if (ignoreInvalidHostError) {
      res["IgnoreInvalidHostError"] = boost::any(*ignoreInvalidHostError);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (quickProtocol) {
      res["QuickProtocol"] = boost::any(*quickProtocol);
    }
    if (redirection) {
      res["Redirection"] = boost::any(*redirection);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (transmissionSize) {
      res["TransmissionSize"] = boost::any(*transmissionSize);
    }
    if (validateKeywords) {
      res["ValidateKeywords"] = boost::any(*validateKeywords);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionTimeout") != m.end() && !m["ConnectionTimeout"].empty()) {
      connectionTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectionTimeout"]));
    }
    if (m.find("CustomHeaderContent") != m.end() && !m["CustomHeaderContent"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["CustomHeaderContent"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customHeaderContent = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("DownloadKernel") != m.end() && !m["DownloadKernel"].empty()) {
      downloadKernel = make_shared<long>(boost::any_cast<long>(m["DownloadKernel"]));
    }
    if (m.find("IgnoreCertificateAuthError") != m.end() && !m["IgnoreCertificateAuthError"].empty()) {
      ignoreCertificateAuthError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateAuthError"]));
    }
    if (m.find("IgnoreCertificateCanceledError") != m.end() && !m["IgnoreCertificateCanceledError"].empty()) {
      ignoreCertificateCanceledError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateCanceledError"]));
    }
    if (m.find("IgnoreCertificateOutOfDateError") != m.end() && !m["IgnoreCertificateOutOfDateError"].empty()) {
      ignoreCertificateOutOfDateError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateOutOfDateError"]));
    }
    if (m.find("IgnoreCertificateStatusError") != m.end() && !m["IgnoreCertificateStatusError"].empty()) {
      ignoreCertificateStatusError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateStatusError"]));
    }
    if (m.find("IgnoreCertificateUntrustworthyError") != m.end() && !m["IgnoreCertificateUntrustworthyError"].empty()) {
      ignoreCertificateUntrustworthyError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateUntrustworthyError"]));
    }
    if (m.find("IgnoreCertificateUsingError") != m.end() && !m["IgnoreCertificateUsingError"].empty()) {
      ignoreCertificateUsingError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateUsingError"]));
    }
    if (m.find("IgnoreInvalidHostError") != m.end() && !m["IgnoreInvalidHostError"].empty()) {
      ignoreInvalidHostError = make_shared<long>(boost::any_cast<long>(m["IgnoreInvalidHostError"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("QuickProtocol") != m.end() && !m["QuickProtocol"].empty()) {
      quickProtocol = make_shared<long>(boost::any_cast<long>(m["QuickProtocol"]));
    }
    if (m.find("Redirection") != m.end() && !m["Redirection"].empty()) {
      redirection = make_shared<long>(boost::any_cast<long>(m["Redirection"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("TransmissionSize") != m.end() && !m["TransmissionSize"].empty()) {
      transmissionSize = make_shared<long>(boost::any_cast<long>(m["TransmissionSize"]));
    }
    if (m.find("ValidateKeywords") != m.end() && !m["ValidateKeywords"].empty()) {
      validateKeywords = make_shared<string>(boost::any_cast<string>(m["ValidateKeywords"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestMonitorConfFileDownload() = default;
};
class UpdateTimingSyntheticTaskRequestMonitorConfNetDNS : public Darabonba::Model {
public:
  shared_ptr<long> dig{};
  shared_ptr<long> dnsServerIpType{};
  shared_ptr<string> nsServer{};
  shared_ptr<long> queryMethod{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};

  UpdateTimingSyntheticTaskRequestMonitorConfNetDNS() {}

  explicit UpdateTimingSyntheticTaskRequestMonitorConfNetDNS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dig) {
      res["Dig"] = boost::any(*dig);
    }
    if (dnsServerIpType) {
      res["DnsServerIpType"] = boost::any(*dnsServerIpType);
    }
    if (nsServer) {
      res["NsServer"] = boost::any(*nsServer);
    }
    if (queryMethod) {
      res["QueryMethod"] = boost::any(*queryMethod);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dig") != m.end() && !m["Dig"].empty()) {
      dig = make_shared<long>(boost::any_cast<long>(m["Dig"]));
    }
    if (m.find("DnsServerIpType") != m.end() && !m["DnsServerIpType"].empty()) {
      dnsServerIpType = make_shared<long>(boost::any_cast<long>(m["DnsServerIpType"]));
    }
    if (m.find("NsServer") != m.end() && !m["NsServer"].empty()) {
      nsServer = make_shared<string>(boost::any_cast<string>(m["NsServer"]));
    }
    if (m.find("QueryMethod") != m.end() && !m["QueryMethod"].empty()) {
      queryMethod = make_shared<long>(boost::any_cast<long>(m["QueryMethod"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestMonitorConfNetDNS() = default;
};
class UpdateTimingSyntheticTaskRequestMonitorConfNetICMP : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<long> packageNum{};
  shared_ptr<long> packageSize{};
  shared_ptr<bool> splitPackage{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};
  shared_ptr<bool> tracertEnable{};
  shared_ptr<long> tracertNumMax{};
  shared_ptr<long> tracertTimeout{};

  UpdateTimingSyntheticTaskRequestMonitorConfNetICMP() {}

  explicit UpdateTimingSyntheticTaskRequestMonitorConfNetICMP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (packageNum) {
      res["PackageNum"] = boost::any(*packageNum);
    }
    if (packageSize) {
      res["PackageSize"] = boost::any(*packageSize);
    }
    if (splitPackage) {
      res["SplitPackage"] = boost::any(*splitPackage);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (tracertEnable) {
      res["TracertEnable"] = boost::any(*tracertEnable);
    }
    if (tracertNumMax) {
      res["TracertNumMax"] = boost::any(*tracertNumMax);
    }
    if (tracertTimeout) {
      res["TracertTimeout"] = boost::any(*tracertTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("PackageNum") != m.end() && !m["PackageNum"].empty()) {
      packageNum = make_shared<long>(boost::any_cast<long>(m["PackageNum"]));
    }
    if (m.find("PackageSize") != m.end() && !m["PackageSize"].empty()) {
      packageSize = make_shared<long>(boost::any_cast<long>(m["PackageSize"]));
    }
    if (m.find("SplitPackage") != m.end() && !m["SplitPackage"].empty()) {
      splitPackage = make_shared<bool>(boost::any_cast<bool>(m["SplitPackage"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TracertEnable") != m.end() && !m["TracertEnable"].empty()) {
      tracertEnable = make_shared<bool>(boost::any_cast<bool>(m["TracertEnable"]));
    }
    if (m.find("TracertNumMax") != m.end() && !m["TracertNumMax"].empty()) {
      tracertNumMax = make_shared<long>(boost::any_cast<long>(m["TracertNumMax"]));
    }
    if (m.find("TracertTimeout") != m.end() && !m["TracertTimeout"].empty()) {
      tracertTimeout = make_shared<long>(boost::any_cast<long>(m["TracertTimeout"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestMonitorConfNetICMP() = default;
};
class UpdateTimingSyntheticTaskRequestMonitorConfNetTCP : public Darabonba::Model {
public:
  shared_ptr<long> connectTimes{};
  shared_ptr<long> interval{};
  shared_ptr<string> targetUrl{};
  shared_ptr<long> timeout{};
  shared_ptr<bool> tracertEnable{};
  shared_ptr<long> tracertNumMax{};
  shared_ptr<long> tracertTimeout{};

  UpdateTimingSyntheticTaskRequestMonitorConfNetTCP() {}

  explicit UpdateTimingSyntheticTaskRequestMonitorConfNetTCP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectTimes) {
      res["ConnectTimes"] = boost::any(*connectTimes);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (tracertEnable) {
      res["TracertEnable"] = boost::any(*tracertEnable);
    }
    if (tracertNumMax) {
      res["TracertNumMax"] = boost::any(*tracertNumMax);
    }
    if (tracertTimeout) {
      res["TracertTimeout"] = boost::any(*tracertTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectTimes") != m.end() && !m["ConnectTimes"].empty()) {
      connectTimes = make_shared<long>(boost::any_cast<long>(m["ConnectTimes"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("TracertEnable") != m.end() && !m["TracertEnable"].empty()) {
      tracertEnable = make_shared<bool>(boost::any_cast<bool>(m["TracertEnable"]));
    }
    if (m.find("TracertNumMax") != m.end() && !m["TracertNumMax"].empty()) {
      tracertNumMax = make_shared<long>(boost::any_cast<long>(m["TracertNumMax"]));
    }
    if (m.find("TracertTimeout") != m.end() && !m["TracertTimeout"].empty()) {
      tracertTimeout = make_shared<long>(boost::any_cast<long>(m["TracertTimeout"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestMonitorConfNetTCP() = default;
};
class UpdateTimingSyntheticTaskRequestMonitorConfStream : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> customHeaderContent{};
  shared_ptr<long> playerType{};
  shared_ptr<long> streamAddressType{};
  shared_ptr<long> streamMonitorTimeout{};
  shared_ptr<long> streamType{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> whiteList{};

  UpdateTimingSyntheticTaskRequestMonitorConfStream() {}

  explicit UpdateTimingSyntheticTaskRequestMonitorConfStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customHeaderContent) {
      res["CustomHeaderContent"] = boost::any(*customHeaderContent);
    }
    if (playerType) {
      res["PlayerType"] = boost::any(*playerType);
    }
    if (streamAddressType) {
      res["StreamAddressType"] = boost::any(*streamAddressType);
    }
    if (streamMonitorTimeout) {
      res["StreamMonitorTimeout"] = boost::any(*streamMonitorTimeout);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomHeaderContent") != m.end() && !m["CustomHeaderContent"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["CustomHeaderContent"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customHeaderContent = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("PlayerType") != m.end() && !m["PlayerType"].empty()) {
      playerType = make_shared<long>(boost::any_cast<long>(m["PlayerType"]));
    }
    if (m.find("StreamAddressType") != m.end() && !m["StreamAddressType"].empty()) {
      streamAddressType = make_shared<long>(boost::any_cast<long>(m["StreamAddressType"]));
    }
    if (m.find("StreamMonitorTimeout") != m.end() && !m["StreamMonitorTimeout"].empty()) {
      streamMonitorTimeout = make_shared<long>(boost::any_cast<long>(m["StreamMonitorTimeout"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<long>(boost::any_cast<long>(m["StreamType"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestMonitorConfStream() = default;
};
class UpdateTimingSyntheticTaskRequestMonitorConfWebsite : public Darabonba::Model {
public:
  shared_ptr<long> automaticScrolling{};
  shared_ptr<long> customHeader{};
  shared_ptr<map<string, string>> customHeaderContent{};
  shared_ptr<string> DNSHijackWhitelist{};
  shared_ptr<long> disableCache{};
  shared_ptr<long> disableCompression{};
  shared_ptr<string> elementBlacklist{};
  shared_ptr<long> filterInvalidIP{};
  shared_ptr<long> flowHijackJumpTimes{};
  shared_ptr<string> flowHijackLogo{};
  shared_ptr<long> ignoreCertificateError{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<string> pageTamper{};
  shared_ptr<long> redirection{};
  shared_ptr<long> slowElementThreshold{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> verifyStringBlacklist{};
  shared_ptr<string> verifyStringWhitelist{};
  shared_ptr<long> waitCompletionTime{};

  UpdateTimingSyntheticTaskRequestMonitorConfWebsite() {}

  explicit UpdateTimingSyntheticTaskRequestMonitorConfWebsite(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (automaticScrolling) {
      res["AutomaticScrolling"] = boost::any(*automaticScrolling);
    }
    if (customHeader) {
      res["CustomHeader"] = boost::any(*customHeader);
    }
    if (customHeaderContent) {
      res["CustomHeaderContent"] = boost::any(*customHeaderContent);
    }
    if (DNSHijackWhitelist) {
      res["DNSHijackWhitelist"] = boost::any(*DNSHijackWhitelist);
    }
    if (disableCache) {
      res["DisableCache"] = boost::any(*disableCache);
    }
    if (disableCompression) {
      res["DisableCompression"] = boost::any(*disableCompression);
    }
    if (elementBlacklist) {
      res["ElementBlacklist"] = boost::any(*elementBlacklist);
    }
    if (filterInvalidIP) {
      res["FilterInvalidIP"] = boost::any(*filterInvalidIP);
    }
    if (flowHijackJumpTimes) {
      res["FlowHijackJumpTimes"] = boost::any(*flowHijackJumpTimes);
    }
    if (flowHijackLogo) {
      res["FlowHijackLogo"] = boost::any(*flowHijackLogo);
    }
    if (ignoreCertificateError) {
      res["IgnoreCertificateError"] = boost::any(*ignoreCertificateError);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (pageTamper) {
      res["PageTamper"] = boost::any(*pageTamper);
    }
    if (redirection) {
      res["Redirection"] = boost::any(*redirection);
    }
    if (slowElementThreshold) {
      res["SlowElementThreshold"] = boost::any(*slowElementThreshold);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (verifyStringBlacklist) {
      res["VerifyStringBlacklist"] = boost::any(*verifyStringBlacklist);
    }
    if (verifyStringWhitelist) {
      res["VerifyStringWhitelist"] = boost::any(*verifyStringWhitelist);
    }
    if (waitCompletionTime) {
      res["WaitCompletionTime"] = boost::any(*waitCompletionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutomaticScrolling") != m.end() && !m["AutomaticScrolling"].empty()) {
      automaticScrolling = make_shared<long>(boost::any_cast<long>(m["AutomaticScrolling"]));
    }
    if (m.find("CustomHeader") != m.end() && !m["CustomHeader"].empty()) {
      customHeader = make_shared<long>(boost::any_cast<long>(m["CustomHeader"]));
    }
    if (m.find("CustomHeaderContent") != m.end() && !m["CustomHeaderContent"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["CustomHeaderContent"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customHeaderContent = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("DNSHijackWhitelist") != m.end() && !m["DNSHijackWhitelist"].empty()) {
      DNSHijackWhitelist = make_shared<string>(boost::any_cast<string>(m["DNSHijackWhitelist"]));
    }
    if (m.find("DisableCache") != m.end() && !m["DisableCache"].empty()) {
      disableCache = make_shared<long>(boost::any_cast<long>(m["DisableCache"]));
    }
    if (m.find("DisableCompression") != m.end() && !m["DisableCompression"].empty()) {
      disableCompression = make_shared<long>(boost::any_cast<long>(m["DisableCompression"]));
    }
    if (m.find("ElementBlacklist") != m.end() && !m["ElementBlacklist"].empty()) {
      elementBlacklist = make_shared<string>(boost::any_cast<string>(m["ElementBlacklist"]));
    }
    if (m.find("FilterInvalidIP") != m.end() && !m["FilterInvalidIP"].empty()) {
      filterInvalidIP = make_shared<long>(boost::any_cast<long>(m["FilterInvalidIP"]));
    }
    if (m.find("FlowHijackJumpTimes") != m.end() && !m["FlowHijackJumpTimes"].empty()) {
      flowHijackJumpTimes = make_shared<long>(boost::any_cast<long>(m["FlowHijackJumpTimes"]));
    }
    if (m.find("FlowHijackLogo") != m.end() && !m["FlowHijackLogo"].empty()) {
      flowHijackLogo = make_shared<string>(boost::any_cast<string>(m["FlowHijackLogo"]));
    }
    if (m.find("IgnoreCertificateError") != m.end() && !m["IgnoreCertificateError"].empty()) {
      ignoreCertificateError = make_shared<long>(boost::any_cast<long>(m["IgnoreCertificateError"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("PageTamper") != m.end() && !m["PageTamper"].empty()) {
      pageTamper = make_shared<string>(boost::any_cast<string>(m["PageTamper"]));
    }
    if (m.find("Redirection") != m.end() && !m["Redirection"].empty()) {
      redirection = make_shared<long>(boost::any_cast<long>(m["Redirection"]));
    }
    if (m.find("SlowElementThreshold") != m.end() && !m["SlowElementThreshold"].empty()) {
      slowElementThreshold = make_shared<long>(boost::any_cast<long>(m["SlowElementThreshold"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("VerifyStringBlacklist") != m.end() && !m["VerifyStringBlacklist"].empty()) {
      verifyStringBlacklist = make_shared<string>(boost::any_cast<string>(m["VerifyStringBlacklist"]));
    }
    if (m.find("VerifyStringWhitelist") != m.end() && !m["VerifyStringWhitelist"].empty()) {
      verifyStringWhitelist = make_shared<string>(boost::any_cast<string>(m["VerifyStringWhitelist"]));
    }
    if (m.find("WaitCompletionTime") != m.end() && !m["WaitCompletionTime"].empty()) {
      waitCompletionTime = make_shared<long>(boost::any_cast<long>(m["WaitCompletionTime"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestMonitorConfWebsite() = default;
};
class UpdateTimingSyntheticTaskRequestMonitorConf : public Darabonba::Model {
public:
  shared_ptr<UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP> apiHTTP{};
  shared_ptr<UpdateTimingSyntheticTaskRequestMonitorConfFileDownload> fileDownload{};
  shared_ptr<UpdateTimingSyntheticTaskRequestMonitorConfNetDNS> netDNS{};
  shared_ptr<UpdateTimingSyntheticTaskRequestMonitorConfNetICMP> netICMP{};
  shared_ptr<UpdateTimingSyntheticTaskRequestMonitorConfNetTCP> netTCP{};
  shared_ptr<UpdateTimingSyntheticTaskRequestMonitorConfStream> stream{};
  shared_ptr<UpdateTimingSyntheticTaskRequestMonitorConfWebsite> website{};

  UpdateTimingSyntheticTaskRequestMonitorConf() {}

  explicit UpdateTimingSyntheticTaskRequestMonitorConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHTTP) {
      res["ApiHTTP"] = apiHTTP ? boost::any(apiHTTP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileDownload) {
      res["FileDownload"] = fileDownload ? boost::any(fileDownload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (netDNS) {
      res["NetDNS"] = netDNS ? boost::any(netDNS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (netICMP) {
      res["NetICMP"] = netICMP ? boost::any(netICMP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (netTCP) {
      res["NetTCP"] = netTCP ? boost::any(netTCP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stream) {
      res["Stream"] = stream ? boost::any(stream->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (website) {
      res["Website"] = website ? boost::any(website->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHTTP") != m.end() && !m["ApiHTTP"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiHTTP"].type()) {
        UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiHTTP"]));
        apiHTTP = make_shared<UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP>(model1);
      }
    }
    if (m.find("FileDownload") != m.end() && !m["FileDownload"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileDownload"].type()) {
        UpdateTimingSyntheticTaskRequestMonitorConfFileDownload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileDownload"]));
        fileDownload = make_shared<UpdateTimingSyntheticTaskRequestMonitorConfFileDownload>(model1);
      }
    }
    if (m.find("NetDNS") != m.end() && !m["NetDNS"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetDNS"].type()) {
        UpdateTimingSyntheticTaskRequestMonitorConfNetDNS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetDNS"]));
        netDNS = make_shared<UpdateTimingSyntheticTaskRequestMonitorConfNetDNS>(model1);
      }
    }
    if (m.find("NetICMP") != m.end() && !m["NetICMP"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetICMP"].type()) {
        UpdateTimingSyntheticTaskRequestMonitorConfNetICMP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetICMP"]));
        netICMP = make_shared<UpdateTimingSyntheticTaskRequestMonitorConfNetICMP>(model1);
      }
    }
    if (m.find("NetTCP") != m.end() && !m["NetTCP"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetTCP"].type()) {
        UpdateTimingSyntheticTaskRequestMonitorConfNetTCP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetTCP"]));
        netTCP = make_shared<UpdateTimingSyntheticTaskRequestMonitorConfNetTCP>(model1);
      }
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      if (typeid(map<string, boost::any>) == m["Stream"].type()) {
        UpdateTimingSyntheticTaskRequestMonitorConfStream model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Stream"]));
        stream = make_shared<UpdateTimingSyntheticTaskRequestMonitorConfStream>(model1);
      }
    }
    if (m.find("Website") != m.end() && !m["Website"].empty()) {
      if (typeid(map<string, boost::any>) == m["Website"].type()) {
        UpdateTimingSyntheticTaskRequestMonitorConfWebsite model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Website"]));
        website = make_shared<UpdateTimingSyntheticTaskRequestMonitorConfWebsite>(model1);
      }
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestMonitorConf() = default;
};
class UpdateTimingSyntheticTaskRequestMonitors : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<long> clientType{};
  shared_ptr<string> operatorCode{};

  UpdateTimingSyntheticTaskRequestMonitors() {}

  explicit UpdateTimingSyntheticTaskRequestMonitors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (operatorCode) {
      res["OperatorCode"] = boost::any(*operatorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["CityCode"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<long>(boost::any_cast<long>(m["ClientType"]));
    }
    if (m.find("OperatorCode") != m.end() && !m["OperatorCode"].empty()) {
      operatorCode = make_shared<string>(boost::any_cast<string>(m["OperatorCode"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestMonitors() = default;
};
class UpdateTimingSyntheticTaskRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateTimingSyntheticTaskRequestTags() {}

  explicit UpdateTimingSyntheticTaskRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequestTags() = default;
};
class UpdateTimingSyntheticTaskRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTimingSyntheticTaskRequestAvailableAssertions>> availableAssertions{};
  shared_ptr<UpdateTimingSyntheticTaskRequestCommonSetting> commonSetting{};
  shared_ptr<UpdateTimingSyntheticTaskRequestCustomPeriod> customPeriod{};
  shared_ptr<string> frequency{};
  shared_ptr<UpdateTimingSyntheticTaskRequestMonitorConf> monitorConf{};
  shared_ptr<vector<UpdateTimingSyntheticTaskRequestMonitors>> monitors{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<UpdateTimingSyntheticTaskRequestTags>> tags{};
  shared_ptr<string> taskId{};

  UpdateTimingSyntheticTaskRequest() {}

  explicit UpdateTimingSyntheticTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableAssertions) {
      vector<boost::any> temp1;
      for(auto item1:*availableAssertions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableAssertions"] = boost::any(temp1);
    }
    if (commonSetting) {
      res["CommonSetting"] = commonSetting ? boost::any(commonSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customPeriod) {
      res["CustomPeriod"] = customPeriod ? boost::any(customPeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (monitorConf) {
      res["MonitorConf"] = monitorConf ? boost::any(monitorConf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (monitors) {
      vector<boost::any> temp1;
      for(auto item1:*monitors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Monitors"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableAssertions") != m.end() && !m["AvailableAssertions"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableAssertions"].type()) {
        vector<UpdateTimingSyntheticTaskRequestAvailableAssertions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableAssertions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTimingSyntheticTaskRequestAvailableAssertions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableAssertions = make_shared<vector<UpdateTimingSyntheticTaskRequestAvailableAssertions>>(expect1);
      }
    }
    if (m.find("CommonSetting") != m.end() && !m["CommonSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonSetting"].type()) {
        UpdateTimingSyntheticTaskRequestCommonSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonSetting"]));
        commonSetting = make_shared<UpdateTimingSyntheticTaskRequestCommonSetting>(model1);
      }
    }
    if (m.find("CustomPeriod") != m.end() && !m["CustomPeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomPeriod"].type()) {
        UpdateTimingSyntheticTaskRequestCustomPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomPeriod"]));
        customPeriod = make_shared<UpdateTimingSyntheticTaskRequestCustomPeriod>(model1);
      }
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorConf"].type()) {
        UpdateTimingSyntheticTaskRequestMonitorConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorConf"]));
        monitorConf = make_shared<UpdateTimingSyntheticTaskRequestMonitorConf>(model1);
      }
    }
    if (m.find("Monitors") != m.end() && !m["Monitors"].empty()) {
      if (typeid(vector<boost::any>) == m["Monitors"].type()) {
        vector<UpdateTimingSyntheticTaskRequestMonitors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Monitors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTimingSyntheticTaskRequestMonitors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitors = make_shared<vector<UpdateTimingSyntheticTaskRequestMonitors>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UpdateTimingSyntheticTaskRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTimingSyntheticTaskRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UpdateTimingSyntheticTaskRequestTags>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskRequest() = default;
};
class UpdateTimingSyntheticTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> availableAssertionsShrink{};
  shared_ptr<string> commonSettingShrink{};
  shared_ptr<string> customPeriodShrink{};
  shared_ptr<string> frequency{};
  shared_ptr<string> monitorConfShrink{};
  shared_ptr<string> monitorsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> taskId{};

  UpdateTimingSyntheticTaskShrinkRequest() {}

  explicit UpdateTimingSyntheticTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableAssertionsShrink) {
      res["AvailableAssertions"] = boost::any(*availableAssertionsShrink);
    }
    if (commonSettingShrink) {
      res["CommonSetting"] = boost::any(*commonSettingShrink);
    }
    if (customPeriodShrink) {
      res["CustomPeriod"] = boost::any(*customPeriodShrink);
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (monitorConfShrink) {
      res["MonitorConf"] = boost::any(*monitorConfShrink);
    }
    if (monitorsShrink) {
      res["Monitors"] = boost::any(*monitorsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableAssertions") != m.end() && !m["AvailableAssertions"].empty()) {
      availableAssertionsShrink = make_shared<string>(boost::any_cast<string>(m["AvailableAssertions"]));
    }
    if (m.find("CommonSetting") != m.end() && !m["CommonSetting"].empty()) {
      commonSettingShrink = make_shared<string>(boost::any_cast<string>(m["CommonSetting"]));
    }
    if (m.find("CustomPeriod") != m.end() && !m["CustomPeriod"].empty()) {
      customPeriodShrink = make_shared<string>(boost::any_cast<string>(m["CustomPeriod"]));
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<string>(boost::any_cast<string>(m["Frequency"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConfShrink = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("Monitors") != m.end() && !m["Monitors"].empty()) {
      monitorsShrink = make_shared<string>(boost::any_cast<string>(m["Monitors"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskShrinkRequest() = default;
};
class UpdateTimingSyntheticTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  UpdateTimingSyntheticTaskResponseBodyData() {}

  explicit UpdateTimingSyntheticTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskResponseBodyData() = default;
};
class UpdateTimingSyntheticTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdateTimingSyntheticTaskResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTimingSyntheticTaskResponseBody() {}

  explicit UpdateTimingSyntheticTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateTimingSyntheticTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateTimingSyntheticTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTimingSyntheticTaskResponseBody() = default;
};
class UpdateTimingSyntheticTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTimingSyntheticTaskResponseBody> body{};

  UpdateTimingSyntheticTaskResponse() {}

  explicit UpdateTimingSyntheticTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTimingSyntheticTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTimingSyntheticTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTimingSyntheticTaskResponse() = default;
};
class UpdateWebhookRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> httpHeaders{};
  shared_ptr<string> httpParams{};
  shared_ptr<string> method{};
  shared_ptr<string> recoverBody{};
  shared_ptr<string> regionId{};
  shared_ptr<string> url{};

  UpdateWebhookRequest() {}

  explicit UpdateWebhookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (httpHeaders) {
      res["HttpHeaders"] = boost::any(*httpHeaders);
    }
    if (httpParams) {
      res["HttpParams"] = boost::any(*httpParams);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (recoverBody) {
      res["RecoverBody"] = boost::any(*recoverBody);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("HttpHeaders") != m.end() && !m["HttpHeaders"].empty()) {
      httpHeaders = make_shared<string>(boost::any_cast<string>(m["HttpHeaders"]));
    }
    if (m.find("HttpParams") != m.end() && !m["HttpParams"].empty()) {
      httpParams = make_shared<string>(boost::any_cast<string>(m["HttpParams"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("RecoverBody") != m.end() && !m["RecoverBody"].empty()) {
      recoverBody = make_shared<string>(boost::any_cast<string>(m["RecoverBody"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~UpdateWebhookRequest() = default;
};
class UpdateWebhookResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  UpdateWebhookResponseBody() {}

  explicit UpdateWebhookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateWebhookResponseBody() = default;
};
class UpdateWebhookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWebhookResponseBody> body{};

  UpdateWebhookResponse() {}

  explicit UpdateWebhookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWebhookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWebhookResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWebhookResponse() = default;
};
class UpgradeAddonReleaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> addonVersion{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseName{};
  shared_ptr<string> values{};

  UpgradeAddonReleaseRequest() {}

  explicit UpgradeAddonReleaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addonVersion) {
      res["AddonVersion"] = boost::any(*addonVersion);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseName) {
      res["ReleaseName"] = boost::any(*releaseName);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddonVersion") != m.end() && !m["AddonVersion"].empty()) {
      addonVersion = make_shared<string>(boost::any_cast<string>(m["AddonVersion"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseName") != m.end() && !m["ReleaseName"].empty()) {
      releaseName = make_shared<string>(boost::any_cast<string>(m["ReleaseName"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~UpgradeAddonReleaseRequest() = default;
};
class UpgradeAddonReleaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpgradeAddonReleaseResponseBody() {}

  explicit UpgradeAddonReleaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpgradeAddonReleaseResponseBody() = default;
};
class UpgradeAddonReleaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeAddonReleaseResponseBody> body{};

  UpgradeAddonReleaseResponse() {}

  explicit UpgradeAddonReleaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeAddonReleaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeAddonReleaseResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeAddonReleaseResponse() = default;
};
class UpgradeEnvironmentFeatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunLang{};
  shared_ptr<string> environmentId{};
  shared_ptr<string> featureName{};
  shared_ptr<string> featureVersion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> values{};

  UpgradeEnvironmentFeatureRequest() {}

  explicit UpgradeEnvironmentFeatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunLang) {
      res["AliyunLang"] = boost::any(*aliyunLang);
    }
    if (environmentId) {
      res["EnvironmentId"] = boost::any(*environmentId);
    }
    if (featureName) {
      res["FeatureName"] = boost::any(*featureName);
    }
    if (featureVersion) {
      res["FeatureVersion"] = boost::any(*featureVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunLang") != m.end() && !m["AliyunLang"].empty()) {
      aliyunLang = make_shared<string>(boost::any_cast<string>(m["AliyunLang"]));
    }
    if (m.find("EnvironmentId") != m.end() && !m["EnvironmentId"].empty()) {
      environmentId = make_shared<string>(boost::any_cast<string>(m["EnvironmentId"]));
    }
    if (m.find("FeatureName") != m.end() && !m["FeatureName"].empty()) {
      featureName = make_shared<string>(boost::any_cast<string>(m["FeatureName"]));
    }
    if (m.find("FeatureVersion") != m.end() && !m["FeatureVersion"].empty()) {
      featureVersion = make_shared<string>(boost::any_cast<string>(m["FeatureVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~UpgradeEnvironmentFeatureRequest() = default;
};
class UpgradeEnvironmentFeatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<map<string, string>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpgradeEnvironmentFeatureResponseBody() {}

  explicit UpgradeEnvironmentFeatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Data"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpgradeEnvironmentFeatureResponseBody() = default;
};
class UpgradeEnvironmentFeatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeEnvironmentFeatureResponseBody> body{};

  UpgradeEnvironmentFeatureResponse() {}

  explicit UpgradeEnvironmentFeatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeEnvironmentFeatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeEnvironmentFeatureResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeEnvironmentFeatureResponse() = default;
};
class UploadRequest : public Darabonba::Model {
public:
  shared_ptr<string> edition{};
  shared_ptr<string> file{};
  shared_ptr<string> fileName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> version{};

  UploadRequest() {}

  explicit UploadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (file) {
      res["File"] = boost::any(*file);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<string>(boost::any_cast<string>(m["Edition"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      file = make_shared<string>(boost::any_cast<string>(m["File"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~UploadRequest() = default;
};
class UploadResponseBodyUploadResult : public Darabonba::Model {
public:
  shared_ptr<string> fid{};
  shared_ptr<string> fileName{};
  shared_ptr<string> uploadTime{};

  UploadResponseBodyUploadResult() {}

  explicit UploadResponseBodyUploadResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fid) {
      res["Fid"] = boost::any(*fid);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (uploadTime) {
      res["UploadTime"] = boost::any(*uploadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fid") != m.end() && !m["Fid"].empty()) {
      fid = make_shared<string>(boost::any_cast<string>(m["Fid"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("UploadTime") != m.end() && !m["UploadTime"].empty()) {
      uploadTime = make_shared<string>(boost::any_cast<string>(m["UploadTime"]));
    }
  }


  virtual ~UploadResponseBodyUploadResult() = default;
};
class UploadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UploadResponseBodyUploadResult> uploadResult{};

  UploadResponseBody() {}

  explicit UploadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadResult) {
      res["UploadResult"] = uploadResult ? boost::any(uploadResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadResult") != m.end() && !m["UploadResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["UploadResult"].type()) {
        UploadResponseBodyUploadResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UploadResult"]));
        uploadResult = make_shared<UploadResponseBodyUploadResult>(model1);
      }
    }
  }


  virtual ~UploadResponseBody() = default;
};
class UploadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadResponseBody> body{};

  UploadResponse() {}

  explicit UploadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadResponseBody>(model1);
      }
    }
  }


  virtual ~UploadResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddAliClusterIdsToPrometheusGlobalViewResponse addAliClusterIdsToPrometheusGlobalViewWithOptions(shared_ptr<AddAliClusterIdsToPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAliClusterIdsToPrometheusGlobalViewResponse addAliClusterIdsToPrometheusGlobalView(shared_ptr<AddAliClusterIdsToPrometheusGlobalViewRequest> request);
  AddGrafanaResponse addGrafanaWithOptions(shared_ptr<AddGrafanaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGrafanaResponse addGrafana(shared_ptr<AddGrafanaRequest> request);
  AddIntegrationResponse addIntegrationWithOptions(shared_ptr<AddIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddIntegrationResponse addIntegration(shared_ptr<AddIntegrationRequest> request);
  AddPrometheusGlobalViewResponse addPrometheusGlobalViewWithOptions(shared_ptr<AddPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPrometheusGlobalViewResponse addPrometheusGlobalView(shared_ptr<AddPrometheusGlobalViewRequest> request);
  AddPrometheusGlobalViewByAliClusterIdsResponse addPrometheusGlobalViewByAliClusterIdsWithOptions(shared_ptr<AddPrometheusGlobalViewByAliClusterIdsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPrometheusGlobalViewByAliClusterIdsResponse addPrometheusGlobalViewByAliClusterIds(shared_ptr<AddPrometheusGlobalViewByAliClusterIdsRequest> request);
  AddPrometheusInstanceResponse addPrometheusInstanceWithOptions(shared_ptr<AddPrometheusInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPrometheusInstanceResponse addPrometheusInstance(shared_ptr<AddPrometheusInstanceRequest> request);
  AddPrometheusIntegrationResponse addPrometheusIntegrationWithOptions(shared_ptr<AddPrometheusIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPrometheusIntegrationResponse addPrometheusIntegration(shared_ptr<AddPrometheusIntegrationRequest> request);
  AddRecordingRuleResponse addRecordingRuleWithOptions(shared_ptr<AddRecordingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddRecordingRuleResponse addRecordingRule(shared_ptr<AddRecordingRuleRequest> request);
  AddTagToFlinkClusterResponse addTagToFlinkClusterWithOptions(shared_ptr<AddTagToFlinkClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTagToFlinkClusterResponse addTagToFlinkCluster(shared_ptr<AddTagToFlinkClusterRequest> request);
  AppendInstancesToPrometheusGlobalViewResponse appendInstancesToPrometheusGlobalViewWithOptions(shared_ptr<AppendInstancesToPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AppendInstancesToPrometheusGlobalViewResponse appendInstancesToPrometheusGlobalView(shared_ptr<AppendInstancesToPrometheusGlobalViewRequest> request);
  ApplyScenarioResponse applyScenarioWithOptions(shared_ptr<ApplyScenarioRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyScenarioResponse applyScenario(shared_ptr<ApplyScenarioRequest> request);
  BindPrometheusGrafanaInstanceResponse bindPrometheusGrafanaInstanceWithOptions(shared_ptr<BindPrometheusGrafanaInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindPrometheusGrafanaInstanceResponse bindPrometheusGrafanaInstance(shared_ptr<BindPrometheusGrafanaInstanceRequest> request);
  BlockAlarmNotificationResponse blockAlarmNotificationWithOptions(shared_ptr<BlockAlarmNotificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BlockAlarmNotificationResponse blockAlarmNotification(shared_ptr<BlockAlarmNotificationRequest> request);
  ChangeAlarmSeverityResponse changeAlarmSeverityWithOptions(shared_ptr<ChangeAlarmSeverityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeAlarmSeverityResponse changeAlarmSeverity(shared_ptr<ChangeAlarmSeverityRequest> request);
  ChangeResourceGroupResponse changeResourceGroupWithOptions(shared_ptr<ChangeResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeResourceGroupResponse changeResourceGroup(shared_ptr<ChangeResourceGroupRequest> request);
  CheckCommercialStatusResponse checkCommercialStatusWithOptions(shared_ptr<CheckCommercialStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckCommercialStatusResponse checkCommercialStatus(shared_ptr<CheckCommercialStatusRequest> request);
  CheckServiceStatusResponse checkServiceStatusWithOptions(shared_ptr<CheckServiceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckServiceStatusResponse checkServiceStatus(shared_ptr<CheckServiceStatusRequest> request);
  ClaimAlarmResponse claimAlarmWithOptions(shared_ptr<ClaimAlarmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClaimAlarmResponse claimAlarm(shared_ptr<ClaimAlarmRequest> request);
  CloseAlarmResponse closeAlarmWithOptions(shared_ptr<CloseAlarmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseAlarmResponse closeAlarm(shared_ptr<CloseAlarmRequest> request);
  ConfigAppResponse configAppWithOptions(shared_ptr<ConfigAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigAppResponse configApp(shared_ptr<ConfigAppRequest> request);
  CreateAlertContactResponse createAlertContactWithOptions(shared_ptr<CreateAlertContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAlertContactResponse createAlertContact(shared_ptr<CreateAlertContactRequest> request);
  CreateAlertContactGroupResponse createAlertContactGroupWithOptions(shared_ptr<CreateAlertContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAlertContactGroupResponse createAlertContactGroup(shared_ptr<CreateAlertContactGroupRequest> request);
  CreateDispatchRuleResponse createDispatchRuleWithOptions(shared_ptr<CreateDispatchRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDispatchRuleResponse createDispatchRule(shared_ptr<CreateDispatchRuleRequest> request);
  CreateEnvCustomJobResponse createEnvCustomJobWithOptions(shared_ptr<CreateEnvCustomJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEnvCustomJobResponse createEnvCustomJob(shared_ptr<CreateEnvCustomJobRequest> request);
  CreateEnvPodMonitorResponse createEnvPodMonitorWithOptions(shared_ptr<CreateEnvPodMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEnvPodMonitorResponse createEnvPodMonitor(shared_ptr<CreateEnvPodMonitorRequest> request);
  CreateEnvServiceMonitorResponse createEnvServiceMonitorWithOptions(shared_ptr<CreateEnvServiceMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEnvServiceMonitorResponse createEnvServiceMonitor(shared_ptr<CreateEnvServiceMonitorRequest> request);
  CreateEnvironmentResponse createEnvironmentWithOptions(shared_ptr<CreateEnvironmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEnvironmentResponse createEnvironment(shared_ptr<CreateEnvironmentRequest> request);
  CreateGrafanaWorkspaceResponse createGrafanaWorkspaceWithOptions(shared_ptr<CreateGrafanaWorkspaceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateGrafanaWorkspaceResponse createGrafanaWorkspace(shared_ptr<CreateGrafanaWorkspaceRequest> request);
  CreateIntegrationResponse createIntegrationWithOptions(shared_ptr<CreateIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIntegrationResponse createIntegration(shared_ptr<CreateIntegrationRequest> request);
  CreateOrUpdateAlertRuleResponse createOrUpdateAlertRuleWithOptions(shared_ptr<CreateOrUpdateAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateAlertRuleResponse createOrUpdateAlertRule(shared_ptr<CreateOrUpdateAlertRuleRequest> request);
  CreateOrUpdateContactResponse createOrUpdateContactWithOptions(shared_ptr<CreateOrUpdateContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateContactResponse createOrUpdateContact(shared_ptr<CreateOrUpdateContactRequest> request);
  CreateOrUpdateContactGroupResponse createOrUpdateContactGroupWithOptions(shared_ptr<CreateOrUpdateContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateContactGroupResponse createOrUpdateContactGroup(shared_ptr<CreateOrUpdateContactGroupRequest> request);
  CreateOrUpdateEventBridgeIntegrationResponse createOrUpdateEventBridgeIntegrationWithOptions(shared_ptr<CreateOrUpdateEventBridgeIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateEventBridgeIntegrationResponse createOrUpdateEventBridgeIntegration(shared_ptr<CreateOrUpdateEventBridgeIntegrationRequest> request);
  CreateOrUpdateIMRobotResponse createOrUpdateIMRobotWithOptions(shared_ptr<CreateOrUpdateIMRobotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateIMRobotResponse createOrUpdateIMRobot(shared_ptr<CreateOrUpdateIMRobotRequest> request);
  CreateOrUpdateNotificationPolicyResponse createOrUpdateNotificationPolicyWithOptions(shared_ptr<CreateOrUpdateNotificationPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateNotificationPolicyResponse createOrUpdateNotificationPolicy(shared_ptr<CreateOrUpdateNotificationPolicyRequest> request);
  CreateOrUpdateSilencePolicyResponse createOrUpdateSilencePolicyWithOptions(shared_ptr<CreateOrUpdateSilencePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateSilencePolicyResponse createOrUpdateSilencePolicy(shared_ptr<CreateOrUpdateSilencePolicyRequest> request);
  CreateOrUpdateWebhookContactResponse createOrUpdateWebhookContactWithOptions(shared_ptr<CreateOrUpdateWebhookContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateWebhookContactResponse createOrUpdateWebhookContact(shared_ptr<CreateOrUpdateWebhookContactRequest> request);
  CreatePrometheusAlertRuleResponse createPrometheusAlertRuleWithOptions(shared_ptr<CreatePrometheusAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePrometheusAlertRuleResponse createPrometheusAlertRule(shared_ptr<CreatePrometheusAlertRuleRequest> request);
  CreatePrometheusInstanceResponse createPrometheusInstanceWithOptions(shared_ptr<CreatePrometheusInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePrometheusInstanceResponse createPrometheusInstance(shared_ptr<CreatePrometheusInstanceRequest> request);
  CreatePrometheusMonitoringResponse createPrometheusMonitoringWithOptions(shared_ptr<CreatePrometheusMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePrometheusMonitoringResponse createPrometheusMonitoring(shared_ptr<CreatePrometheusMonitoringRequest> request);
  CreateRetcodeAppResponse createRetcodeAppWithOptions(shared_ptr<CreateRetcodeAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRetcodeAppResponse createRetcodeApp(shared_ptr<CreateRetcodeAppRequest> request);
  CreateRumAppResponse createRumAppWithOptions(shared_ptr<CreateRumAppRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRumAppResponse createRumApp(shared_ptr<CreateRumAppRequest> request);
  CreateRumUploadFileUrlResponse createRumUploadFileUrlWithOptions(shared_ptr<CreateRumUploadFileUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRumUploadFileUrlResponse createRumUploadFileUrl(shared_ptr<CreateRumUploadFileUrlRequest> request);
  CreateSyntheticTaskResponse createSyntheticTaskWithOptions(shared_ptr<CreateSyntheticTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSyntheticTaskResponse createSyntheticTask(shared_ptr<CreateSyntheticTaskRequest> request);
  CreateTimingSyntheticTaskResponse createTimingSyntheticTaskWithOptions(shared_ptr<CreateTimingSyntheticTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTimingSyntheticTaskResponse createTimingSyntheticTask(shared_ptr<CreateTimingSyntheticTaskRequest> request);
  CreateWebhookResponse createWebhookWithOptions(shared_ptr<CreateWebhookRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWebhookResponse createWebhook(shared_ptr<CreateWebhookRequest> request);
  DelAuthTokenResponse delAuthTokenWithOptions(shared_ptr<DelAuthTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DelAuthTokenResponse delAuthToken(shared_ptr<DelAuthTokenRequest> request);
  DeleteAddonReleaseResponse deleteAddonReleaseWithOptions(shared_ptr<DeleteAddonReleaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAddonReleaseResponse deleteAddonRelease(shared_ptr<DeleteAddonReleaseRequest> request);
  DeleteAlertContactResponse deleteAlertContactWithOptions(shared_ptr<DeleteAlertContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertContactResponse deleteAlertContact(shared_ptr<DeleteAlertContactRequest> request);
  DeleteAlertContactGroupResponse deleteAlertContactGroupWithOptions(shared_ptr<DeleteAlertContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertContactGroupResponse deleteAlertContactGroup(shared_ptr<DeleteAlertContactGroupRequest> request);
  DeleteAlertRuleResponse deleteAlertRuleWithOptions(shared_ptr<DeleteAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertRuleResponse deleteAlertRule(shared_ptr<DeleteAlertRuleRequest> request);
  DeleteAlertRulesResponse deleteAlertRulesWithOptions(shared_ptr<DeleteAlertRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertRulesResponse deleteAlertRules(shared_ptr<DeleteAlertRulesRequest> request);
  DeleteAppListResponse deleteAppListWithOptions(shared_ptr<DeleteAppListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAppListResponse deleteAppList(shared_ptr<DeleteAppListRequest> request);
  DeleteCmsExporterResponse deleteCmsExporterWithOptions(shared_ptr<DeleteCmsExporterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCmsExporterResponse deleteCmsExporter(shared_ptr<DeleteCmsExporterRequest> request);
  DeleteContactResponse deleteContactWithOptions(shared_ptr<DeleteContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactResponse deleteContact(shared_ptr<DeleteContactRequest> request);
  DeleteContactGroupResponse deleteContactGroupWithOptions(shared_ptr<DeleteContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactGroupResponse deleteContactGroup(shared_ptr<DeleteContactGroupRequest> request);
  DeleteDispatchRuleResponse deleteDispatchRuleWithOptions(shared_ptr<DeleteDispatchRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDispatchRuleResponse deleteDispatchRule(shared_ptr<DeleteDispatchRuleRequest> request);
  DeleteEnvCustomJobResponse deleteEnvCustomJobWithOptions(shared_ptr<DeleteEnvCustomJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEnvCustomJobResponse deleteEnvCustomJob(shared_ptr<DeleteEnvCustomJobRequest> request);
  DeleteEnvPodMonitorResponse deleteEnvPodMonitorWithOptions(shared_ptr<DeleteEnvPodMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEnvPodMonitorResponse deleteEnvPodMonitor(shared_ptr<DeleteEnvPodMonitorRequest> request);
  DeleteEnvServiceMonitorResponse deleteEnvServiceMonitorWithOptions(shared_ptr<DeleteEnvServiceMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEnvServiceMonitorResponse deleteEnvServiceMonitor(shared_ptr<DeleteEnvServiceMonitorRequest> request);
  DeleteEnvironmentResponse deleteEnvironmentWithOptions(shared_ptr<DeleteEnvironmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEnvironmentResponse deleteEnvironment(shared_ptr<DeleteEnvironmentRequest> request);
  DeleteEnvironmentFeatureResponse deleteEnvironmentFeatureWithOptions(shared_ptr<DeleteEnvironmentFeatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEnvironmentFeatureResponse deleteEnvironmentFeature(shared_ptr<DeleteEnvironmentFeatureRequest> request);
  DeleteEventBridgeIntegrationResponse deleteEventBridgeIntegrationWithOptions(shared_ptr<DeleteEventBridgeIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEventBridgeIntegrationResponse deleteEventBridgeIntegration(shared_ptr<DeleteEventBridgeIntegrationRequest> request);
  DeleteGrafanaResourceResponse deleteGrafanaResourceWithOptions(shared_ptr<DeleteGrafanaResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGrafanaResourceResponse deleteGrafanaResource(shared_ptr<DeleteGrafanaResourceRequest> request);
  DeleteGrafanaWorkspaceResponse deleteGrafanaWorkspaceWithOptions(shared_ptr<DeleteGrafanaWorkspaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGrafanaWorkspaceResponse deleteGrafanaWorkspace(shared_ptr<DeleteGrafanaWorkspaceRequest> request);
  DeleteIMRobotResponse deleteIMRobotWithOptions(shared_ptr<DeleteIMRobotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIMRobotResponse deleteIMRobot(shared_ptr<DeleteIMRobotRequest> request);
  DeleteIntegrationResponse deleteIntegrationWithOptions(shared_ptr<DeleteIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIntegrationResponse deleteIntegration(shared_ptr<DeleteIntegrationRequest> request);
  DeleteIntegrationsResponse deleteIntegrationsWithOptions(shared_ptr<DeleteIntegrationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIntegrationsResponse deleteIntegrations(shared_ptr<DeleteIntegrationsRequest> request);
  DeleteNotificationPolicyResponse deleteNotificationPolicyWithOptions(shared_ptr<DeleteNotificationPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNotificationPolicyResponse deleteNotificationPolicy(shared_ptr<DeleteNotificationPolicyRequest> request);
  DeletePrometheusAlertRuleResponse deletePrometheusAlertRuleWithOptions(shared_ptr<DeletePrometheusAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrometheusAlertRuleResponse deletePrometheusAlertRule(shared_ptr<DeletePrometheusAlertRuleRequest> request);
  DeletePrometheusGlobalViewResponse deletePrometheusGlobalViewWithOptions(shared_ptr<DeletePrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrometheusGlobalViewResponse deletePrometheusGlobalView(shared_ptr<DeletePrometheusGlobalViewRequest> request);
  DeletePrometheusIntegrationResponse deletePrometheusIntegrationWithOptions(shared_ptr<DeletePrometheusIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrometheusIntegrationResponse deletePrometheusIntegration(shared_ptr<DeletePrometheusIntegrationRequest> request);
  DeletePrometheusMonitoringResponse deletePrometheusMonitoringWithOptions(shared_ptr<DeletePrometheusMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrometheusMonitoringResponse deletePrometheusMonitoring(shared_ptr<DeletePrometheusMonitoringRequest> request);
  DeleteRetcodeAppResponse deleteRetcodeAppWithOptions(shared_ptr<DeleteRetcodeAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRetcodeAppResponse deleteRetcodeApp(shared_ptr<DeleteRetcodeAppRequest> request);
  DeleteRumAppResponse deleteRumAppWithOptions(shared_ptr<DeleteRumAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRumAppResponse deleteRumApp(shared_ptr<DeleteRumAppRequest> request);
  DeleteRumUploadFileResponse deleteRumUploadFileWithOptions(shared_ptr<DeleteRumUploadFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRumUploadFileResponse deleteRumUploadFile(shared_ptr<DeleteRumUploadFileRequest> request);
  DeleteScenarioResponse deleteScenarioWithOptions(shared_ptr<DeleteScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScenarioResponse deleteScenario(shared_ptr<DeleteScenarioRequest> request);
  DeleteSilencePolicyResponse deleteSilencePolicyWithOptions(shared_ptr<DeleteSilencePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSilencePolicyResponse deleteSilencePolicy(shared_ptr<DeleteSilencePolicyRequest> request);
  DeleteSourceMapResponse deleteSourceMapWithOptions(shared_ptr<DeleteSourceMapRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSourceMapResponse deleteSourceMap(shared_ptr<DeleteSourceMapRequest> request);
  DeleteSyntheticTaskResponse deleteSyntheticTaskWithOptions(shared_ptr<DeleteSyntheticTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSyntheticTaskResponse deleteSyntheticTask(shared_ptr<DeleteSyntheticTaskRequest> request);
  DeleteTimingSyntheticTaskResponse deleteTimingSyntheticTaskWithOptions(shared_ptr<DeleteTimingSyntheticTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTimingSyntheticTaskResponse deleteTimingSyntheticTask(shared_ptr<DeleteTimingSyntheticTaskRequest> request);
  DeleteTraceAppResponse deleteTraceAppWithOptions(shared_ptr<DeleteTraceAppRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTraceAppResponse deleteTraceApp(shared_ptr<DeleteTraceAppRequest> request);
  DeleteWebhookContactResponse deleteWebhookContactWithOptions(shared_ptr<DeleteWebhookContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWebhookContactResponse deleteWebhookContact(shared_ptr<DeleteWebhookContactRequest> request);
  DescribeAddonReleaseResponse describeAddonReleaseWithOptions(shared_ptr<DescribeAddonReleaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAddonReleaseResponse describeAddonRelease(shared_ptr<DescribeAddonReleaseRequest> request);
  DescribeContactGroupsResponse describeContactGroupsWithOptions(shared_ptr<DescribeContactGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContactGroupsResponse describeContactGroups(shared_ptr<DescribeContactGroupsRequest> request);
  DescribeContactsResponse describeContactsWithOptions(shared_ptr<DescribeContactsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContactsResponse describeContacts(shared_ptr<DescribeContactsRequest> request);
  DescribeDispatchRuleResponse describeDispatchRuleWithOptions(shared_ptr<DescribeDispatchRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDispatchRuleResponse describeDispatchRule(shared_ptr<DescribeDispatchRuleRequest> request);
  DescribeEnvCustomJobResponse describeEnvCustomJobWithOptions(shared_ptr<DescribeEnvCustomJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnvCustomJobResponse describeEnvCustomJob(shared_ptr<DescribeEnvCustomJobRequest> request);
  DescribeEnvPodMonitorResponse describeEnvPodMonitorWithOptions(shared_ptr<DescribeEnvPodMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnvPodMonitorResponse describeEnvPodMonitor(shared_ptr<DescribeEnvPodMonitorRequest> request);
  DescribeEnvServiceMonitorResponse describeEnvServiceMonitorWithOptions(shared_ptr<DescribeEnvServiceMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnvServiceMonitorResponse describeEnvServiceMonitor(shared_ptr<DescribeEnvServiceMonitorRequest> request);
  DescribeEnvironmentResponse describeEnvironmentWithOptions(shared_ptr<DescribeEnvironmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnvironmentResponse describeEnvironment(shared_ptr<DescribeEnvironmentRequest> request);
  DescribeEnvironmentFeatureResponse describeEnvironmentFeatureWithOptions(shared_ptr<DescribeEnvironmentFeatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnvironmentFeatureResponse describeEnvironmentFeature(shared_ptr<DescribeEnvironmentFeatureRequest> request);
  DescribeIMRobotsResponse describeIMRobotsWithOptions(shared_ptr<DescribeIMRobotsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIMRobotsResponse describeIMRobots(shared_ptr<DescribeIMRobotsRequest> request);
  DescribePrometheusAlertRuleResponse describePrometheusAlertRuleWithOptions(shared_ptr<DescribePrometheusAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePrometheusAlertRuleResponse describePrometheusAlertRule(shared_ptr<DescribePrometheusAlertRuleRequest> request);
  DescribeTraceLicenseKeyResponse describeTraceLicenseKeyWithOptions(shared_ptr<DescribeTraceLicenseKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTraceLicenseKeyResponse describeTraceLicenseKey(shared_ptr<DescribeTraceLicenseKeyRequest> request);
  DescribeWebhookContactsResponse describeWebhookContactsWithOptions(shared_ptr<DescribeWebhookContactsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebhookContactsResponse describeWebhookContacts(shared_ptr<DescribeWebhookContactsRequest> request);
  DoInsightsActionResponse doInsightsActionWithOptions(shared_ptr<DoInsightsActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DoInsightsActionResponse doInsightsAction(shared_ptr<DoInsightsActionRequest> request);
  EnableMetricResponse enableMetricWithOptions(shared_ptr<EnableMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableMetricResponse enableMetric(shared_ptr<EnableMetricRequest> request);
  GetAgentDownloadUrlResponse getAgentDownloadUrlWithOptions(shared_ptr<GetAgentDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAgentDownloadUrlResponse getAgentDownloadUrl(shared_ptr<GetAgentDownloadUrlRequest> request);
  GetAgentDownloadUrlV2Response getAgentDownloadUrlV2WithOptions(shared_ptr<GetAgentDownloadUrlV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAgentDownloadUrlV2Response getAgentDownloadUrlV2(shared_ptr<GetAgentDownloadUrlV2Request> request);
  GetAlertRulesResponse getAlertRulesWithOptions(shared_ptr<GetAlertRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAlertRulesResponse getAlertRules(shared_ptr<GetAlertRulesRequest> request);
  GetAppApiByPageResponse getAppApiByPageWithOptions(shared_ptr<GetAppApiByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAppApiByPageResponse getAppApiByPage(shared_ptr<GetAppApiByPageRequest> request);
  GetAppJVMConfigResponse getAppJVMConfigWithOptions(shared_ptr<GetAppJVMConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAppJVMConfigResponse getAppJVMConfig(shared_ptr<GetAppJVMConfigRequest> request);
  GetAuthTokenResponse getAuthTokenWithOptions(shared_ptr<GetAuthTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAuthTokenResponse getAuthToken(shared_ptr<GetAuthTokenRequest> request);
  GetCloudClusterAllUrlResponse getCloudClusterAllUrlWithOptions(shared_ptr<GetCloudClusterAllUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCloudClusterAllUrlResponse getCloudClusterAllUrl(shared_ptr<GetCloudClusterAllUrlRequest> request);
  GetClusterAllUrlResponse getClusterAllUrlWithOptions(shared_ptr<GetClusterAllUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterAllUrlResponse getClusterAllUrl(shared_ptr<GetClusterAllUrlRequest> request);
  GetCommercialStatusResponse getCommercialStatusWithOptions(shared_ptr<GetCommercialStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCommercialStatusResponse getCommercialStatus(shared_ptr<GetCommercialStatusRequest> request);
  GetExploreUrlResponse getExploreUrlWithOptions(shared_ptr<GetExploreUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetExploreUrlResponse getExploreUrl(shared_ptr<GetExploreUrlRequest> request);
  GetGrafanaWorkspaceResponse getGrafanaWorkspaceWithOptions(shared_ptr<GetGrafanaWorkspaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGrafanaWorkspaceResponse getGrafanaWorkspace(shared_ptr<GetGrafanaWorkspaceRequest> request);
  GetIntegrationStateResponse getIntegrationStateWithOptions(shared_ptr<GetIntegrationStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIntegrationStateResponse getIntegrationState(shared_ptr<GetIntegrationStateRequest> request);
  GetManagedPrometheusStatusResponse getManagedPrometheusStatusWithOptions(shared_ptr<GetManagedPrometheusStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetManagedPrometheusStatusResponse getManagedPrometheusStatus(shared_ptr<GetManagedPrometheusStatusRequest> request);
  GetMultipleTraceResponse getMultipleTraceWithOptions(shared_ptr<GetMultipleTraceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultipleTraceResponse getMultipleTrace(shared_ptr<GetMultipleTraceRequest> request);
  GetOnCallSchedulesDetailResponse getOnCallSchedulesDetailWithOptions(shared_ptr<GetOnCallSchedulesDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOnCallSchedulesDetailResponse getOnCallSchedulesDetail(shared_ptr<GetOnCallSchedulesDetailRequest> request);
  GetPrometheusApiTokenResponse getPrometheusApiTokenWithOptions(shared_ptr<GetPrometheusApiTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusApiTokenResponse getPrometheusApiToken(shared_ptr<GetPrometheusApiTokenRequest> request);
  GetPrometheusGlobalViewResponse getPrometheusGlobalViewWithOptions(shared_ptr<GetPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusGlobalViewResponse getPrometheusGlobalView(shared_ptr<GetPrometheusGlobalViewRequest> request);
  GetPrometheusInstanceResponse getPrometheusInstanceWithOptions(shared_ptr<GetPrometheusInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusInstanceResponse getPrometheusInstance(shared_ptr<GetPrometheusInstanceRequest> request);
  GetPrometheusIntegrationResponse getPrometheusIntegrationWithOptions(shared_ptr<GetPrometheusIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusIntegrationResponse getPrometheusIntegration(shared_ptr<GetPrometheusIntegrationRequest> request);
  GetPrometheusMonitoringResponse getPrometheusMonitoringWithOptions(shared_ptr<GetPrometheusMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusMonitoringResponse getPrometheusMonitoring(shared_ptr<GetPrometheusMonitoringRequest> request);
  GetRecordingRuleResponse getRecordingRuleWithOptions(shared_ptr<GetRecordingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRecordingRuleResponse getRecordingRule(shared_ptr<GetRecordingRuleRequest> request);
  GetRetcodeAppByPidResponse getRetcodeAppByPidWithOptions(shared_ptr<GetRetcodeAppByPidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRetcodeAppByPidResponse getRetcodeAppByPid(shared_ptr<GetRetcodeAppByPidRequest> request);
  GetRetcodeDataByQueryResponse getRetcodeDataByQueryWithOptions(shared_ptr<GetRetcodeDataByQueryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRetcodeDataByQueryResponse getRetcodeDataByQuery(shared_ptr<GetRetcodeDataByQueryRequest> request);
  GetRetcodeLogstoreResponse getRetcodeLogstoreWithOptions(shared_ptr<GetRetcodeLogstoreRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRetcodeLogstoreResponse getRetcodeLogstore(shared_ptr<GetRetcodeLogstoreRequest> request);
  GetRetcodeShareUrlResponse getRetcodeShareUrlWithOptions(shared_ptr<GetRetcodeShareUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRetcodeShareUrlResponse getRetcodeShareUrl(shared_ptr<GetRetcodeShareUrlRequest> request);
  GetRumAppInfoResponse getRumAppInfoWithOptions(shared_ptr<GetRumAppInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRumAppInfoResponse getRumAppInfo(shared_ptr<GetRumAppInfoRequest> request);
  GetRumAppsResponse getRumAppsWithOptions(shared_ptr<GetRumAppsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRumAppsResponse getRumApps(shared_ptr<GetRumAppsRequest> request);
  GetRumDataForPageResponse getRumDataForPageWithOptions(shared_ptr<GetRumDataForPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRumDataForPageResponse getRumDataForPage(shared_ptr<GetRumDataForPageRequest> request);
  GetRumExceptionStackResponse getRumExceptionStackWithOptions(shared_ptr<GetRumExceptionStackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRumExceptionStackResponse getRumExceptionStack(shared_ptr<GetRumExceptionStackRequest> request);
  GetRumOcuStatisticDataResponse getRumOcuStatisticDataWithOptions(shared_ptr<GetRumOcuStatisticDataRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRumOcuStatisticDataResponse getRumOcuStatisticData(shared_ptr<GetRumOcuStatisticDataRequest> request);
  GetRumUploadFilesResponse getRumUploadFilesWithOptions(shared_ptr<GetRumUploadFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRumUploadFilesResponse getRumUploadFiles(shared_ptr<GetRumUploadFilesRequest> request);
  GetSourceMapInfoResponse getSourceMapInfoWithOptions(shared_ptr<GetSourceMapInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSourceMapInfoResponse getSourceMapInfo(shared_ptr<GetSourceMapInfoRequest> request);
  GetStackResponse getStackWithOptions(shared_ptr<GetStackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStackResponse getStack(shared_ptr<GetStackRequest> request);
  GetSyntheticMonitorsResponse getSyntheticMonitorsWithOptions(shared_ptr<GetSyntheticMonitorsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSyntheticMonitorsResponse getSyntheticMonitors(shared_ptr<GetSyntheticMonitorsRequest> request);
  GetSyntheticTaskDetailResponse getSyntheticTaskDetailWithOptions(shared_ptr<GetSyntheticTaskDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSyntheticTaskDetailResponse getSyntheticTaskDetail(shared_ptr<GetSyntheticTaskDetailRequest> request);
  GetSyntheticTaskListResponse getSyntheticTaskListWithOptions(shared_ptr<GetSyntheticTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSyntheticTaskListResponse getSyntheticTaskList(shared_ptr<GetSyntheticTaskListRequest> request);
  GetSyntheticTaskMonitorsResponse getSyntheticTaskMonitorsWithOptions(shared_ptr<GetSyntheticTaskMonitorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSyntheticTaskMonitorsResponse getSyntheticTaskMonitors(shared_ptr<GetSyntheticTaskMonitorsRequest> request);
  GetTimingSyntheticTaskResponse getTimingSyntheticTaskWithOptions(shared_ptr<GetTimingSyntheticTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTimingSyntheticTaskResponse getTimingSyntheticTask(shared_ptr<GetTimingSyntheticTaskRequest> request);
  GetTraceResponse getTraceWithOptions(shared_ptr<GetTraceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTraceResponse getTrace(shared_ptr<GetTraceRequest> request);
  GetTraceAppResponse getTraceAppWithOptions(shared_ptr<GetTraceAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTraceAppResponse getTraceApp(shared_ptr<GetTraceAppRequest> request);
  GetTraceAppConfigResponse getTraceAppConfigWithOptions(shared_ptr<GetTraceAppConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTraceAppConfigResponse getTraceAppConfig(shared_ptr<GetTraceAppConfigRequest> request);
  ImportAppAlertRulesResponse importAppAlertRulesWithOptions(shared_ptr<ImportAppAlertRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportAppAlertRulesResponse importAppAlertRules(shared_ptr<ImportAppAlertRulesRequest> request);
  InitEnvironmentResponse initEnvironmentWithOptions(shared_ptr<InitEnvironmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitEnvironmentResponse initEnvironment(shared_ptr<InitEnvironmentRequest> request);
  InstallAddonResponse installAddonWithOptions(shared_ptr<InstallAddonRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallAddonResponse installAddon(shared_ptr<InstallAddonRequest> request);
  InstallCmsExporterResponse installCmsExporterWithOptions(shared_ptr<InstallCmsExporterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallCmsExporterResponse installCmsExporter(shared_ptr<InstallCmsExporterRequest> request);
  InstallEnvironmentFeatureResponse installEnvironmentFeatureWithOptions(shared_ptr<InstallEnvironmentFeatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallEnvironmentFeatureResponse installEnvironmentFeature(shared_ptr<InstallEnvironmentFeatureRequest> request);
  InstallManagedPrometheusResponse installManagedPrometheusWithOptions(shared_ptr<InstallManagedPrometheusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallManagedPrometheusResponse installManagedPrometheus(shared_ptr<InstallManagedPrometheusRequest> request);
  ListActivatedAlertsResponse listActivatedAlertsWithOptions(shared_ptr<ListActivatedAlertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListActivatedAlertsResponse listActivatedAlerts(shared_ptr<ListActivatedAlertsRequest> request);
  ListAddonReleasesResponse listAddonReleasesWithOptions(shared_ptr<ListAddonReleasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAddonReleasesResponse listAddonReleases(shared_ptr<ListAddonReleasesRequest> request);
  ListAddonsResponse listAddonsWithOptions(shared_ptr<ListAddonsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAddonsResponse listAddons(shared_ptr<ListAddonsRequest> request);
  ListAlertEventsResponse listAlertEventsWithOptions(shared_ptr<ListAlertEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertEventsResponse listAlertEvents(shared_ptr<ListAlertEventsRequest> request);
  ListAlertsResponse listAlertsWithOptions(shared_ptr<ListAlertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertsResponse listAlerts(shared_ptr<ListAlertsRequest> request);
  ListClusterFromGrafanaResponse listClusterFromGrafanaWithOptions(shared_ptr<ListClusterFromGrafanaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterFromGrafanaResponse listClusterFromGrafana(shared_ptr<ListClusterFromGrafanaRequest> request);
  ListCmsInstancesResponse listCmsInstancesWithOptions(shared_ptr<ListCmsInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCmsInstancesResponse listCmsInstances(shared_ptr<ListCmsInstancesRequest> request);
  ListDashboardsResponse listDashboardsWithOptions(shared_ptr<ListDashboardsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDashboardsResponse listDashboards(shared_ptr<ListDashboardsRequest> request);
  ListDashboardsByNameResponse listDashboardsByNameWithOptions(shared_ptr<ListDashboardsByNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDashboardsByNameResponse listDashboardsByName(shared_ptr<ListDashboardsByNameRequest> request);
  ListDispatchRuleResponse listDispatchRuleWithOptions(shared_ptr<ListDispatchRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDispatchRuleResponse listDispatchRule(shared_ptr<ListDispatchRuleRequest> request);
  ListEnvCustomJobsResponse listEnvCustomJobsWithOptions(shared_ptr<ListEnvCustomJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEnvCustomJobsResponse listEnvCustomJobs(shared_ptr<ListEnvCustomJobsRequest> request);
  ListEnvPodMonitorsResponse listEnvPodMonitorsWithOptions(shared_ptr<ListEnvPodMonitorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEnvPodMonitorsResponse listEnvPodMonitors(shared_ptr<ListEnvPodMonitorsRequest> request);
  ListEnvServiceMonitorsResponse listEnvServiceMonitorsWithOptions(shared_ptr<ListEnvServiceMonitorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEnvServiceMonitorsResponse listEnvServiceMonitors(shared_ptr<ListEnvServiceMonitorsRequest> request);
  ListEnvironmentDashboardsResponse listEnvironmentDashboardsWithOptions(shared_ptr<ListEnvironmentDashboardsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEnvironmentDashboardsResponse listEnvironmentDashboards(shared_ptr<ListEnvironmentDashboardsRequest> request);
  ListEnvironmentFeaturesResponse listEnvironmentFeaturesWithOptions(shared_ptr<ListEnvironmentFeaturesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEnvironmentFeaturesResponse listEnvironmentFeatures(shared_ptr<ListEnvironmentFeaturesRequest> request);
  ListEnvironmentsResponse listEnvironmentsWithOptions(shared_ptr<ListEnvironmentsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEnvironmentsResponse listEnvironments(shared_ptr<ListEnvironmentsRequest> request);
  ListEscalationPoliciesResponse listEscalationPoliciesWithOptions(shared_ptr<ListEscalationPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEscalationPoliciesResponse listEscalationPolicies(shared_ptr<ListEscalationPoliciesRequest> request);
  ListEventBridgeIntegrationsResponse listEventBridgeIntegrationsWithOptions(shared_ptr<ListEventBridgeIntegrationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEventBridgeIntegrationsResponse listEventBridgeIntegrations(shared_ptr<ListEventBridgeIntegrationsRequest> request);
  ListGrafanaWorkspaceResponse listGrafanaWorkspaceWithOptions(shared_ptr<ListGrafanaWorkspaceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGrafanaWorkspaceResponse listGrafanaWorkspace(shared_ptr<ListGrafanaWorkspaceRequest> request);
  ListInsightsEventsResponse listInsightsEventsWithOptions(shared_ptr<ListInsightsEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInsightsEventsResponse listInsightsEvents(shared_ptr<ListInsightsEventsRequest> request);
  ListIntegrationResponse listIntegrationWithOptions(shared_ptr<ListIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntegrationResponse listIntegration(shared_ptr<ListIntegrationRequest> request);
  ListNotificationPoliciesResponse listNotificationPoliciesWithOptions(shared_ptr<ListNotificationPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNotificationPoliciesResponse listNotificationPolicies(shared_ptr<ListNotificationPoliciesRequest> request);
  ListOnCallSchedulesResponse listOnCallSchedulesWithOptions(shared_ptr<ListOnCallSchedulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOnCallSchedulesResponse listOnCallSchedules(shared_ptr<ListOnCallSchedulesRequest> request);
  ListPrometheusAlertRulesResponse listPrometheusAlertRulesWithOptions(shared_ptr<ListPrometheusAlertRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusAlertRulesResponse listPrometheusAlertRules(shared_ptr<ListPrometheusAlertRulesRequest> request);
  ListPrometheusAlertTemplatesResponse listPrometheusAlertTemplatesWithOptions(shared_ptr<ListPrometheusAlertTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusAlertTemplatesResponse listPrometheusAlertTemplates(shared_ptr<ListPrometheusAlertTemplatesRequest> request);
  ListPrometheusGlobalViewResponse listPrometheusGlobalViewWithOptions(shared_ptr<ListPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusGlobalViewResponse listPrometheusGlobalView(shared_ptr<ListPrometheusGlobalViewRequest> request);
  ListPrometheusInstanceByTagAndResourceGroupIdResponse listPrometheusInstanceByTagAndResourceGroupIdWithOptions(shared_ptr<ListPrometheusInstanceByTagAndResourceGroupIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusInstanceByTagAndResourceGroupIdResponse listPrometheusInstanceByTagAndResourceGroupId(shared_ptr<ListPrometheusInstanceByTagAndResourceGroupIdRequest> request);
  ListPrometheusInstancesResponse listPrometheusInstancesWithOptions(shared_ptr<ListPrometheusInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusInstancesResponse listPrometheusInstances(shared_ptr<ListPrometheusInstancesRequest> request);
  ListPrometheusIntegrationResponse listPrometheusIntegrationWithOptions(shared_ptr<ListPrometheusIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusIntegrationResponse listPrometheusIntegration(shared_ptr<ListPrometheusIntegrationRequest> request);
  ListPrometheusMonitoringResponse listPrometheusMonitoringWithOptions(shared_ptr<ListPrometheusMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusMonitoringResponse listPrometheusMonitoring(shared_ptr<ListPrometheusMonitoringRequest> request);
  ListRetcodeAppsResponse listRetcodeAppsWithOptions(shared_ptr<ListRetcodeAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRetcodeAppsResponse listRetcodeApps(shared_ptr<ListRetcodeAppsRequest> request);
  ListScenarioResponse listScenarioWithOptions(shared_ptr<ListScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScenarioResponse listScenario(shared_ptr<ListScenarioRequest> request);
  ListSilencePoliciesResponse listSilencePoliciesWithOptions(shared_ptr<ListSilencePoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSilencePoliciesResponse listSilencePolicies(shared_ptr<ListSilencePoliciesRequest> request);
  ListSyntheticDetailResponse listSyntheticDetailWithOptions(shared_ptr<ListSyntheticDetailRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSyntheticDetailResponse listSyntheticDetail(shared_ptr<ListSyntheticDetailRequest> request);
  ListTimingSyntheticTasksResponse listTimingSyntheticTasksWithOptions(shared_ptr<ListTimingSyntheticTasksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTimingSyntheticTasksResponse listTimingSyntheticTasks(shared_ptr<ListTimingSyntheticTasksRequest> request);
  ListTraceAppsResponse listTraceAppsWithOptions(shared_ptr<ListTraceAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTraceAppsResponse listTraceApps(shared_ptr<ListTraceAppsRequest> request);
  ManageGetRecordingRuleResponse manageGetRecordingRuleWithOptions(shared_ptr<ManageGetRecordingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ManageGetRecordingRuleResponse manageGetRecordingRule(shared_ptr<ManageGetRecordingRuleRequest> request);
  ManageRecordingRuleResponse manageRecordingRuleWithOptions(shared_ptr<ManageRecordingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ManageRecordingRuleResponse manageRecordingRule(shared_ptr<ManageRecordingRuleRequest> request);
  OpenArmsDefaultSLRResponse openArmsDefaultSLRWithOptions(shared_ptr<OpenArmsDefaultSLRRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenArmsDefaultSLRResponse openArmsDefaultSLR(shared_ptr<OpenArmsDefaultSLRRequest> request);
  OpenArmsServiceSecondVersionResponse openArmsServiceSecondVersionWithOptions(shared_ptr<OpenArmsServiceSecondVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenArmsServiceSecondVersionResponse openArmsServiceSecondVersion(shared_ptr<OpenArmsServiceSecondVersionRequest> request);
  OpenVClusterResponse openVClusterWithOptions(shared_ptr<OpenVClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenVClusterResponse openVCluster(shared_ptr<OpenVClusterRequest> request);
  OpenXtraceDefaultSLRResponse openXtraceDefaultSLRWithOptions(shared_ptr<OpenXtraceDefaultSLRRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenXtraceDefaultSLRResponse openXtraceDefaultSLR(shared_ptr<OpenXtraceDefaultSLRRequest> request);
  QueryAppMetadataResponse queryAppMetadataWithOptions(shared_ptr<QueryAppMetadataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAppMetadataResponse queryAppMetadata(shared_ptr<QueryAppMetadataRequest> request);
  QueryAppTopologyResponse queryAppTopologyWithOptions(shared_ptr<QueryAppTopologyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAppTopologyResponse queryAppTopology(shared_ptr<QueryAppTopologyRequest> request);
  QueryCommercialUsageResponse queryCommercialUsageWithOptions(shared_ptr<QueryCommercialUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCommercialUsageResponse queryCommercialUsage(shared_ptr<QueryCommercialUsageRequest> request);
  QueryMetricByPageResponse queryMetricByPageWithOptions(shared_ptr<QueryMetricByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMetricByPageResponse queryMetricByPage(shared_ptr<QueryMetricByPageRequest> request);
  QueryPromInstallStatusResponse queryPromInstallStatusWithOptions(shared_ptr<QueryPromInstallStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPromInstallStatusResponse queryPromInstallStatus(shared_ptr<QueryPromInstallStatusRequest> request);
  QueryReleaseMetricResponse queryReleaseMetricWithOptions(shared_ptr<QueryReleaseMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryReleaseMetricResponse queryReleaseMetric(shared_ptr<QueryReleaseMetricRequest> request);
  RemoveAliClusterIdsFromPrometheusGlobalViewResponse removeAliClusterIdsFromPrometheusGlobalViewWithOptions(shared_ptr<RemoveAliClusterIdsFromPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAliClusterIdsFromPrometheusGlobalViewResponse removeAliClusterIdsFromPrometheusGlobalView(shared_ptr<RemoveAliClusterIdsFromPrometheusGlobalViewRequest> request);
  RemoveSourcesFromPrometheusGlobalViewResponse removeSourcesFromPrometheusGlobalViewWithOptions(shared_ptr<RemoveSourcesFromPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveSourcesFromPrometheusGlobalViewResponse removeSourcesFromPrometheusGlobalView(shared_ptr<RemoveSourcesFromPrometheusGlobalViewRequest> request);
  RestartEnvironmentFeatureResponse restartEnvironmentFeatureWithOptions(shared_ptr<RestartEnvironmentFeatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartEnvironmentFeatureResponse restartEnvironmentFeature(shared_ptr<RestartEnvironmentFeatureRequest> request);
  SaveTraceAppConfigResponse saveTraceAppConfigWithOptions(shared_ptr<SaveTraceAppConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveTraceAppConfigResponse saveTraceAppConfig(shared_ptr<SaveTraceAppConfigRequest> request);
  SearchAlertContactResponse searchAlertContactWithOptions(shared_ptr<SearchAlertContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchAlertContactResponse searchAlertContact(shared_ptr<SearchAlertContactRequest> request);
  SearchAlertContactGroupResponse searchAlertContactGroupWithOptions(shared_ptr<SearchAlertContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchAlertContactGroupResponse searchAlertContactGroup(shared_ptr<SearchAlertContactGroupRequest> request);
  SearchAlertHistoriesResponse searchAlertHistoriesWithOptions(shared_ptr<SearchAlertHistoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchAlertHistoriesResponse searchAlertHistories(shared_ptr<SearchAlertHistoriesRequest> request);
  SearchAlertRulesResponse searchAlertRulesWithOptions(shared_ptr<SearchAlertRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchAlertRulesResponse searchAlertRules(shared_ptr<SearchAlertRulesRequest> request);
  SearchEventsResponse searchEventsWithOptions(shared_ptr<SearchEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchEventsResponse searchEvents(shared_ptr<SearchEventsRequest> request);
  SearchRetcodeAppByPageResponse searchRetcodeAppByPageWithOptions(shared_ptr<SearchRetcodeAppByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchRetcodeAppByPageResponse searchRetcodeAppByPage(shared_ptr<SearchRetcodeAppByPageRequest> request);
  SearchTraceAppByNameResponse searchTraceAppByNameWithOptions(shared_ptr<SearchTraceAppByNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTraceAppByNameResponse searchTraceAppByName(shared_ptr<SearchTraceAppByNameRequest> request);
  SearchTraceAppByPageResponse searchTraceAppByPageWithOptions(shared_ptr<SearchTraceAppByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTraceAppByPageResponse searchTraceAppByPage(shared_ptr<SearchTraceAppByPageRequest> request);
  SearchTracesResponse searchTracesWithOptions(shared_ptr<SearchTracesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTracesResponse searchTraces(shared_ptr<SearchTracesRequest> request);
  SearchTracesByPageResponse searchTracesByPageWithOptions(shared_ptr<SearchTracesByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTracesByPageResponse searchTracesByPage(shared_ptr<SearchTracesByPageRequest> request);
  SendTTSVerifyLinkResponse sendTTSVerifyLinkWithOptions(shared_ptr<SendTTSVerifyLinkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendTTSVerifyLinkResponse sendTTSVerifyLink(shared_ptr<SendTTSVerifyLinkRequest> request);
  SetRetcodeShareStatusResponse setRetcodeShareStatusWithOptions(shared_ptr<SetRetcodeShareStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetRetcodeShareStatusResponse setRetcodeShareStatus(shared_ptr<SetRetcodeShareStatusRequest> request);
  StartAlertResponse startAlertWithOptions(shared_ptr<StartAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartAlertResponse startAlert(shared_ptr<StartAlertRequest> request);
  StartTimingSyntheticTaskResponse startTimingSyntheticTaskWithOptions(shared_ptr<StartTimingSyntheticTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartTimingSyntheticTaskResponse startTimingSyntheticTask(shared_ptr<StartTimingSyntheticTaskRequest> request);
  StopAlertResponse stopAlertWithOptions(shared_ptr<StopAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopAlertResponse stopAlert(shared_ptr<StopAlertRequest> request);
  StopTimingSyntheticTaskResponse stopTimingSyntheticTaskWithOptions(shared_ptr<StopTimingSyntheticTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopTimingSyntheticTaskResponse stopTimingSyntheticTask(shared_ptr<StopTimingSyntheticTaskRequest> request);
  SwitchSyntheticTaskStatusResponse switchSyntheticTaskStatusWithOptions(shared_ptr<SwitchSyntheticTaskStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchSyntheticTaskStatusResponse switchSyntheticTaskStatus(shared_ptr<SwitchSyntheticTaskStatusRequest> request);
  SyncRecordingRulesResponse syncRecordingRulesWithOptions(shared_ptr<SyncRecordingRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncRecordingRulesResponse syncRecordingRules(shared_ptr<SyncRecordingRulesRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UninstallManagedPrometheusResponse uninstallManagedPrometheusWithOptions(shared_ptr<UninstallManagedPrometheusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallManagedPrometheusResponse uninstallManagedPrometheus(shared_ptr<UninstallManagedPrometheusRequest> request);
  UninstallPromClusterResponse uninstallPromClusterWithOptions(shared_ptr<UninstallPromClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallPromClusterResponse uninstallPromCluster(shared_ptr<UninstallPromClusterRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateAlertContactResponse updateAlertContactWithOptions(shared_ptr<UpdateAlertContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAlertContactResponse updateAlertContact(shared_ptr<UpdateAlertContactRequest> request);
  UpdateAlertContactGroupResponse updateAlertContactGroupWithOptions(shared_ptr<UpdateAlertContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAlertContactGroupResponse updateAlertContactGroup(shared_ptr<UpdateAlertContactGroupRequest> request);
  UpdateAlertRuleResponse updateAlertRuleWithOptions(shared_ptr<UpdateAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAlertRuleResponse updateAlertRule(shared_ptr<UpdateAlertRuleRequest> request);
  UpdateDispatchRuleResponse updateDispatchRuleWithOptions(shared_ptr<UpdateDispatchRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDispatchRuleResponse updateDispatchRule(shared_ptr<UpdateDispatchRuleRequest> request);
  UpdateEnvCustomJobResponse updateEnvCustomJobWithOptions(shared_ptr<UpdateEnvCustomJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEnvCustomJobResponse updateEnvCustomJob(shared_ptr<UpdateEnvCustomJobRequest> request);
  UpdateEnvPodMonitorResponse updateEnvPodMonitorWithOptions(shared_ptr<UpdateEnvPodMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEnvPodMonitorResponse updateEnvPodMonitor(shared_ptr<UpdateEnvPodMonitorRequest> request);
  UpdateEnvServiceMonitorResponse updateEnvServiceMonitorWithOptions(shared_ptr<UpdateEnvServiceMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEnvServiceMonitorResponse updateEnvServiceMonitor(shared_ptr<UpdateEnvServiceMonitorRequest> request);
  UpdateEnvironmentResponse updateEnvironmentWithOptions(shared_ptr<UpdateEnvironmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEnvironmentResponse updateEnvironment(shared_ptr<UpdateEnvironmentRequest> request);
  UpdateGrafanaWorkspaceResponse updateGrafanaWorkspaceWithOptions(shared_ptr<UpdateGrafanaWorkspaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGrafanaWorkspaceResponse updateGrafanaWorkspace(shared_ptr<UpdateGrafanaWorkspaceRequest> request);
  UpdateGrafanaWorkspaceVersionResponse updateGrafanaWorkspaceVersionWithOptions(shared_ptr<UpdateGrafanaWorkspaceVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGrafanaWorkspaceVersionResponse updateGrafanaWorkspaceVersion(shared_ptr<UpdateGrafanaWorkspaceVersionRequest> request);
  UpdateIntegrationResponse updateIntegrationWithOptions(shared_ptr<UpdateIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIntegrationResponse updateIntegration(shared_ptr<UpdateIntegrationRequest> request);
  UpdateMetricDropResponse updateMetricDropWithOptions(shared_ptr<UpdateMetricDropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMetricDropResponse updateMetricDrop(shared_ptr<UpdateMetricDropRequest> request);
  UpdatePrometheusAlertRuleResponse updatePrometheusAlertRuleWithOptions(shared_ptr<UpdatePrometheusAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusAlertRuleResponse updatePrometheusAlertRule(shared_ptr<UpdatePrometheusAlertRuleRequest> request);
  UpdatePrometheusGlobalViewResponse updatePrometheusGlobalViewWithOptions(shared_ptr<UpdatePrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusGlobalViewResponse updatePrometheusGlobalView(shared_ptr<UpdatePrometheusGlobalViewRequest> request);
  UpdatePrometheusInstanceResponse updatePrometheusInstanceWithOptions(shared_ptr<UpdatePrometheusInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusInstanceResponse updatePrometheusInstance(shared_ptr<UpdatePrometheusInstanceRequest> request);
  UpdatePrometheusIntegrationResponse updatePrometheusIntegrationWithOptions(shared_ptr<UpdatePrometheusIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusIntegrationResponse updatePrometheusIntegration(shared_ptr<UpdatePrometheusIntegrationRequest> request);
  UpdatePrometheusMonitoringResponse updatePrometheusMonitoringWithOptions(shared_ptr<UpdatePrometheusMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusMonitoringResponse updatePrometheusMonitoring(shared_ptr<UpdatePrometheusMonitoringRequest> request);
  UpdatePrometheusMonitoringStatusResponse updatePrometheusMonitoringStatusWithOptions(shared_ptr<UpdatePrometheusMonitoringStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusMonitoringStatusResponse updatePrometheusMonitoringStatus(shared_ptr<UpdatePrometheusMonitoringStatusRequest> request);
  UpdateRumAppResponse updateRumAppWithOptions(shared_ptr<UpdateRumAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRumAppResponse updateRumApp(shared_ptr<UpdateRumAppRequest> request);
  UpdateRumFileStatusResponse updateRumFileStatusWithOptions(shared_ptr<UpdateRumFileStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRumFileStatusResponse updateRumFileStatus(shared_ptr<UpdateRumFileStatusRequest> request);
  UpdateTimingSyntheticTaskResponse updateTimingSyntheticTaskWithOptions(shared_ptr<UpdateTimingSyntheticTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTimingSyntheticTaskResponse updateTimingSyntheticTask(shared_ptr<UpdateTimingSyntheticTaskRequest> request);
  UpdateWebhookResponse updateWebhookWithOptions(shared_ptr<UpdateWebhookRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWebhookResponse updateWebhook(shared_ptr<UpdateWebhookRequest> request);
  UpgradeAddonReleaseResponse upgradeAddonReleaseWithOptions(shared_ptr<UpgradeAddonReleaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeAddonReleaseResponse upgradeAddonRelease(shared_ptr<UpgradeAddonReleaseRequest> request);
  UpgradeEnvironmentFeatureResponse upgradeEnvironmentFeatureWithOptions(shared_ptr<UpgradeEnvironmentFeatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeEnvironmentFeatureResponse upgradeEnvironmentFeature(shared_ptr<UpgradeEnvironmentFeatureRequest> request);
  UploadResponse uploadWithOptions(shared_ptr<UploadRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadResponse upload(shared_ptr<UploadRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_ARMS20190808

#endif
