// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ARMS20190808_H_
#define ALIBABACLOUD_ARMS20190808_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_ARMS20190808 {
class CallChainInfo : public Darabonba::Model {
public:
  shared_ptr<string> additionalInfo{};
  shared_ptr<string> appName{};
  shared_ptr<string> appType{};
  shared_ptr<vector<CallChainInfo>> children{};
  shared_ptr<bool> haveSpan{};
  shared_ptr<map<string, map<string, boost::any>>> logMap{};
  shared_ptr<long> logTime{};
  shared_ptr<string> parentSpanId{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> rpc{};
  shared_ptr<string> rpcId{};
  shared_ptr<long> rpcType{};
  shared_ptr<string> serverIp{};
  shared_ptr<long> span{};
  shared_ptr<string> spanId{};
  shared_ptr<map<string, string>> tagMap{};
  shared_ptr<string> traceId{};

  CallChainInfo() {}

  explicit CallChainInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalInfo) {
      res["AdditionalInfo"] = boost::any(*additionalInfo);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Children"] = boost::any(temp1);
    }
    if (haveSpan) {
      res["HaveSpan"] = boost::any(*haveSpan);
    }
    if (logMap) {
      res["LogMap"] = boost::any(*logMap);
    }
    if (logTime) {
      res["LogTime"] = boost::any(*logTime);
    }
    if (parentSpanId) {
      res["ParentSpanId"] = boost::any(*parentSpanId);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (rpc) {
      res["Rpc"] = boost::any(*rpc);
    }
    if (rpcId) {
      res["RpcId"] = boost::any(*rpcId);
    }
    if (rpcType) {
      res["RpcType"] = boost::any(*rpcType);
    }
    if (serverIp) {
      res["ServerIp"] = boost::any(*serverIp);
    }
    if (span) {
      res["Span"] = boost::any(*span);
    }
    if (spanId) {
      res["SpanId"] = boost::any(*spanId);
    }
    if (tagMap) {
      res["TagMap"] = boost::any(*tagMap);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalInfo") != m.end() && !m["AdditionalInfo"].empty()) {
      additionalInfo = make_shared<string>(boost::any_cast<string>(m["AdditionalInfo"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<CallChainInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CallChainInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<CallChainInfo>>(expect1);
      }
    }
    if (m.find("HaveSpan") != m.end() && !m["HaveSpan"].empty()) {
      haveSpan = make_shared<bool>(boost::any_cast<bool>(m["HaveSpan"]));
    }
    if (m.find("LogMap") != m.end() && !m["LogMap"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["LogMap"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      logMap = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
    if (m.find("LogTime") != m.end() && !m["LogTime"].empty()) {
      logTime = make_shared<long>(boost::any_cast<long>(m["LogTime"]));
    }
    if (m.find("ParentSpanId") != m.end() && !m["ParentSpanId"].empty()) {
      parentSpanId = make_shared<string>(boost::any_cast<string>(m["ParentSpanId"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("Rpc") != m.end() && !m["Rpc"].empty()) {
      rpc = make_shared<string>(boost::any_cast<string>(m["Rpc"]));
    }
    if (m.find("RpcId") != m.end() && !m["RpcId"].empty()) {
      rpcId = make_shared<string>(boost::any_cast<string>(m["RpcId"]));
    }
    if (m.find("RpcType") != m.end() && !m["RpcType"].empty()) {
      rpcType = make_shared<long>(boost::any_cast<long>(m["RpcType"]));
    }
    if (m.find("ServerIp") != m.end() && !m["ServerIp"].empty()) {
      serverIp = make_shared<string>(boost::any_cast<string>(m["ServerIp"]));
    }
    if (m.find("Span") != m.end() && !m["Span"].empty()) {
      span = make_shared<long>(boost::any_cast<long>(m["Span"]));
    }
    if (m.find("SpanId") != m.end() && !m["SpanId"].empty()) {
      spanId = make_shared<string>(boost::any_cast<string>(m["SpanId"]));
    }
    if (m.find("TagMap") != m.end() && !m["TagMap"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["TagMap"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tagMap = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~CallChainInfo() = default;
};
class GrafanaWorkspaceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GrafanaWorkspaceTags() {}

  explicit GrafanaWorkspaceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GrafanaWorkspaceTags() = default;
};
class GrafanaWorkspace : public Darabonba::Model {
public:
  shared_ptr<bool> commercial{};
  shared_ptr<string> deployType{};
  shared_ptr<string> description{};
  shared_ptr<double> endTime{};
  shared_ptr<double> gmtCreate{};
  shared_ptr<string> grafanaVersion{};
  shared_ptr<string> grafanaWorkspaceDomain{};
  shared_ptr<string> grafanaWorkspaceEdition{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<string> grafanaWorkspaceIp{};
  shared_ptr<string> grafanaWorkspaceName{};
  shared_ptr<string> maxAccount{};
  shared_ptr<string> ntmId{};
  shared_ptr<string> personalDomain{};
  shared_ptr<string> personalDomainPrefix{};
  shared_ptr<string> privateDomain{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> shareSynced{};
  shared_ptr<string> snatIp{};
  shared_ptr<string> status{};
  shared_ptr<vector<GrafanaWorkspaceTags>> tags{};
  shared_ptr<vector<string>> upgradeVersion{};
  shared_ptr<string> userId{};

  GrafanaWorkspace() {}

  explicit GrafanaWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commercial) {
      res["commercial"] = boost::any(*commercial);
    }
    if (deployType) {
      res["deployType"] = boost::any(*deployType);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (grafanaVersion) {
      res["grafanaVersion"] = boost::any(*grafanaVersion);
    }
    if (grafanaWorkspaceDomain) {
      res["grafanaWorkspaceDomain"] = boost::any(*grafanaWorkspaceDomain);
    }
    if (grafanaWorkspaceEdition) {
      res["grafanaWorkspaceEdition"] = boost::any(*grafanaWorkspaceEdition);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (grafanaWorkspaceIp) {
      res["grafanaWorkspaceIp"] = boost::any(*grafanaWorkspaceIp);
    }
    if (grafanaWorkspaceName) {
      res["grafanaWorkspaceName"] = boost::any(*grafanaWorkspaceName);
    }
    if (maxAccount) {
      res["maxAccount"] = boost::any(*maxAccount);
    }
    if (ntmId) {
      res["ntmId"] = boost::any(*ntmId);
    }
    if (personalDomain) {
      res["personalDomain"] = boost::any(*personalDomain);
    }
    if (personalDomainPrefix) {
      res["personalDomainPrefix"] = boost::any(*personalDomainPrefix);
    }
    if (privateDomain) {
      res["privateDomain"] = boost::any(*privateDomain);
    }
    if (privateIp) {
      res["privateIp"] = boost::any(*privateIp);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["resourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (shareSynced) {
      res["shareSynced"] = boost::any(*shareSynced);
    }
    if (snatIp) {
      res["snatIp"] = boost::any(*snatIp);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (upgradeVersion) {
      res["upgradeVersion"] = boost::any(*upgradeVersion);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commercial") != m.end() && !m["commercial"].empty()) {
      commercial = make_shared<bool>(boost::any_cast<bool>(m["commercial"]));
    }
    if (m.find("deployType") != m.end() && !m["deployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["deployType"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<double>(boost::any_cast<double>(m["endTime"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<double>(boost::any_cast<double>(m["gmtCreate"]));
    }
    if (m.find("grafanaVersion") != m.end() && !m["grafanaVersion"].empty()) {
      grafanaVersion = make_shared<string>(boost::any_cast<string>(m["grafanaVersion"]));
    }
    if (m.find("grafanaWorkspaceDomain") != m.end() && !m["grafanaWorkspaceDomain"].empty()) {
      grafanaWorkspaceDomain = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceDomain"]));
    }
    if (m.find("grafanaWorkspaceEdition") != m.end() && !m["grafanaWorkspaceEdition"].empty()) {
      grafanaWorkspaceEdition = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceEdition"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("grafanaWorkspaceIp") != m.end() && !m["grafanaWorkspaceIp"].empty()) {
      grafanaWorkspaceIp = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceIp"]));
    }
    if (m.find("grafanaWorkspaceName") != m.end() && !m["grafanaWorkspaceName"].empty()) {
      grafanaWorkspaceName = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceName"]));
    }
    if (m.find("maxAccount") != m.end() && !m["maxAccount"].empty()) {
      maxAccount = make_shared<string>(boost::any_cast<string>(m["maxAccount"]));
    }
    if (m.find("ntmId") != m.end() && !m["ntmId"].empty()) {
      ntmId = make_shared<string>(boost::any_cast<string>(m["ntmId"]));
    }
    if (m.find("personalDomain") != m.end() && !m["personalDomain"].empty()) {
      personalDomain = make_shared<string>(boost::any_cast<string>(m["personalDomain"]));
    }
    if (m.find("personalDomainPrefix") != m.end() && !m["personalDomainPrefix"].empty()) {
      personalDomainPrefix = make_shared<string>(boost::any_cast<string>(m["personalDomainPrefix"]));
    }
    if (m.find("privateDomain") != m.end() && !m["privateDomain"].empty()) {
      privateDomain = make_shared<string>(boost::any_cast<string>(m["privateDomain"]));
    }
    if (m.find("privateIp") != m.end() && !m["privateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["privateIp"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("resourceGroupId") != m.end() && !m["resourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resourceGroupId"]));
    }
    if (m.find("shareSynced") != m.end() && !m["shareSynced"].empty()) {
      shareSynced = make_shared<bool>(boost::any_cast<bool>(m["shareSynced"]));
    }
    if (m.find("snatIp") != m.end() && !m["snatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["snatIp"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<GrafanaWorkspaceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GrafanaWorkspaceTags>>(expect1);
      }
    }
    if (m.find("upgradeVersion") != m.end() && !m["upgradeVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["upgradeVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["upgradeVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      upgradeVersion = make_shared<vector<string>>(toVec1);
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspace() = default;
};
class GrafanaWorkspaceUserOrg : public Darabonba::Model {
public:
  shared_ptr<long> orgId{};
  shared_ptr<string> orgName{};
  shared_ptr<string> role{};

  GrafanaWorkspaceUserOrg() {}

  explicit GrafanaWorkspaceUserOrg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (orgName) {
      res["orgName"] = boost::any(*orgName);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("orgName") != m.end() && !m["orgName"].empty()) {
      orgName = make_shared<string>(boost::any_cast<string>(m["orgName"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
  }


  virtual ~GrafanaWorkspaceUserOrg() = default;
};
class GrafanaWorkspaceAccount : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> accountNotes{};
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> aliyunUserName{};
  shared_ptr<double> gmtCreate{};
  shared_ptr<vector<GrafanaWorkspaceUserOrg>> orgs{};

  GrafanaWorkspaceAccount() {}

  explicit GrafanaWorkspaceAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (accountNotes) {
      res["accountNotes"] = boost::any(*accountNotes);
    }
    if (aliyunUid) {
      res["aliyunUid"] = boost::any(*aliyunUid);
    }
    if (aliyunUserName) {
      res["aliyunUserName"] = boost::any(*aliyunUserName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (orgs) {
      vector<boost::any> temp1;
      for(auto item1:*orgs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["orgs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["accountId"]));
    }
    if (m.find("accountNotes") != m.end() && !m["accountNotes"].empty()) {
      accountNotes = make_shared<string>(boost::any_cast<string>(m["accountNotes"]));
    }
    if (m.find("aliyunUid") != m.end() && !m["aliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["aliyunUid"]));
    }
    if (m.find("aliyunUserName") != m.end() && !m["aliyunUserName"].empty()) {
      aliyunUserName = make_shared<string>(boost::any_cast<string>(m["aliyunUserName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<double>(boost::any_cast<double>(m["gmtCreate"]));
    }
    if (m.find("orgs") != m.end() && !m["orgs"].empty()) {
      if (typeid(vector<boost::any>) == m["orgs"].type()) {
        vector<GrafanaWorkspaceUserOrg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["orgs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceUserOrg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        orgs = make_shared<vector<GrafanaWorkspaceUserOrg>>(expect1);
      }
    }
  }


  virtual ~GrafanaWorkspaceAccount() = default;
};
class GrafanaWorkspaceAlertNotification : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<bool> isArms{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> name{};
  shared_ptr<bool> sendReminder{};
  shared_ptr<string> settings{};
  shared_ptr<string> type{};
  shared_ptr<string> uid{};

  GrafanaWorkspaceAlertNotification() {}

  explicit GrafanaWorkspaceAlertNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isArms) {
      res["isArms"] = boost::any(*isArms);
    }
    if (isDefault) {
      res["isDefault"] = boost::any(*isDefault);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sendReminder) {
      res["sendReminder"] = boost::any(*sendReminder);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (uid) {
      res["uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("isArms") != m.end() && !m["isArms"].empty()) {
      isArms = make_shared<bool>(boost::any_cast<bool>(m["isArms"]));
    }
    if (m.find("isDefault") != m.end() && !m["isDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["isDefault"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sendReminder") != m.end() && !m["sendReminder"].empty()) {
      sendReminder = make_shared<bool>(boost::any_cast<bool>(m["sendReminder"]));
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      settings = make_shared<string>(boost::any_cast<string>(m["settings"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("uid") != m.end() && !m["uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["uid"]));
    }
  }


  virtual ~GrafanaWorkspaceAlertNotification() = default;
};
class GrafanaWorkspaceArmsAlertConfig : public Darabonba::Model {
public:
  shared_ptr<string> armsAlertsEnable{};
  shared_ptr<string> armsAlertsWebhookUrl{};

  GrafanaWorkspaceArmsAlertConfig() {}

  explicit GrafanaWorkspaceArmsAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsAlertsEnable) {
      res["armsAlertsEnable"] = boost::any(*armsAlertsEnable);
    }
    if (armsAlertsWebhookUrl) {
      res["armsAlertsWebhookUrl"] = boost::any(*armsAlertsWebhookUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("armsAlertsEnable") != m.end() && !m["armsAlertsEnable"].empty()) {
      armsAlertsEnable = make_shared<string>(boost::any_cast<string>(m["armsAlertsEnable"]));
    }
    if (m.find("armsAlertsWebhookUrl") != m.end() && !m["armsAlertsWebhookUrl"].empty()) {
      armsAlertsWebhookUrl = make_shared<string>(boost::any_cast<string>(m["armsAlertsWebhookUrl"]));
    }
  }


  virtual ~GrafanaWorkspaceArmsAlertConfig() = default;
};
class GrafanaWorkspaceCustomDomain : public Darabonba::Model {
public:
  shared_ptr<string> cert{};
  shared_ptr<long> date{};
  shared_ptr<string> domain{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> key{};
  shared_ptr<string> privateZone{};
  shared_ptr<string> protocol{};
  shared_ptr<string> status{};
  shared_ptr<string> uri{};

  GrafanaWorkspaceCustomDomain() {}

  explicit GrafanaWorkspaceCustomDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      res["cert"] = boost::any(*cert);
    }
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (domain) {
      res["domain"] = boost::any(*domain);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (privateZone) {
      res["privateZone"] = boost::any(*privateZone);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (uri) {
      res["uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cert") != m.end() && !m["cert"].empty()) {
      cert = make_shared<string>(boost::any_cast<string>(m["cert"]));
    }
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["date"]));
    }
    if (m.find("domain") != m.end() && !m["domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["domain"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("privateZone") != m.end() && !m["privateZone"].empty()) {
      privateZone = make_shared<string>(boost::any_cast<string>(m["privateZone"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("uri") != m.end() && !m["uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["uri"]));
    }
  }


  virtual ~GrafanaWorkspaceCustomDomain() = default;
};
class GrafanaWorkspaceDashboardReport : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<long> lastSendTime{};
  shared_ptr<string> msg{};
  shared_ptr<string> name{};
  shared_ptr<string> reportChannelTarget{};
  shared_ptr<string> reportChannelType{};
  shared_ptr<string> reportStyle{};
  shared_ptr<string> reportType{};
  shared_ptr<string> status{};
  shared_ptr<string> triggerDay{};
  shared_ptr<string> triggerTime{};
  shared_ptr<string> triggerType{};
  shared_ptr<string> url{};
  shared_ptr<string> userId{};

  GrafanaWorkspaceDashboardReport() {}

  explicit GrafanaWorkspaceDashboardReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastSendTime) {
      res["lastSendTime"] = boost::any(*lastSendTime);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (reportChannelTarget) {
      res["reportChannelTarget"] = boost::any(*reportChannelTarget);
    }
    if (reportChannelType) {
      res["reportChannelType"] = boost::any(*reportChannelType);
    }
    if (reportStyle) {
      res["reportStyle"] = boost::any(*reportStyle);
    }
    if (reportType) {
      res["reportType"] = boost::any(*reportType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (triggerDay) {
      res["triggerDay"] = boost::any(*triggerDay);
    }
    if (triggerTime) {
      res["triggerTime"] = boost::any(*triggerTime);
    }
    if (triggerType) {
      res["triggerType"] = boost::any(*triggerType);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastSendTime") != m.end() && !m["lastSendTime"].empty()) {
      lastSendTime = make_shared<long>(boost::any_cast<long>(m["lastSendTime"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("reportChannelTarget") != m.end() && !m["reportChannelTarget"].empty()) {
      reportChannelTarget = make_shared<string>(boost::any_cast<string>(m["reportChannelTarget"]));
    }
    if (m.find("reportChannelType") != m.end() && !m["reportChannelType"].empty()) {
      reportChannelType = make_shared<string>(boost::any_cast<string>(m["reportChannelType"]));
    }
    if (m.find("reportStyle") != m.end() && !m["reportStyle"].empty()) {
      reportStyle = make_shared<string>(boost::any_cast<string>(m["reportStyle"]));
    }
    if (m.find("reportType") != m.end() && !m["reportType"].empty()) {
      reportType = make_shared<string>(boost::any_cast<string>(m["reportType"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("triggerDay") != m.end() && !m["triggerDay"].empty()) {
      triggerDay = make_shared<string>(boost::any_cast<string>(m["triggerDay"]));
    }
    if (m.find("triggerTime") != m.end() && !m["triggerTime"].empty()) {
      triggerTime = make_shared<string>(boost::any_cast<string>(m["triggerTime"]));
    }
    if (m.find("triggerType") != m.end() && !m["triggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["triggerType"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspaceDashboardReport() = default;
};
class GrafanaWorkspaceDashboardSync : public Darabonba::Model {
public:
  shared_ptr<string> dashboardTitle{};
  shared_ptr<string> dashboardURL{};
  shared_ptr<string> dashboardUid{};
  shared_ptr<string> folderId{};
  shared_ptr<string> folderTitle{};
  shared_ptr<string> folderURL{};
  shared_ptr<string> folderUid{};
  shared_ptr<string> orgId{};
  shared_ptr<string> orgName{};
  shared_ptr<string> type{};

  GrafanaWorkspaceDashboardSync() {}

  explicit GrafanaWorkspaceDashboardSync(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboardTitle) {
      res["dashboardTitle"] = boost::any(*dashboardTitle);
    }
    if (dashboardURL) {
      res["dashboardURL"] = boost::any(*dashboardURL);
    }
    if (dashboardUid) {
      res["dashboardUid"] = boost::any(*dashboardUid);
    }
    if (folderId) {
      res["folderId"] = boost::any(*folderId);
    }
    if (folderTitle) {
      res["folderTitle"] = boost::any(*folderTitle);
    }
    if (folderURL) {
      res["folderURL"] = boost::any(*folderURL);
    }
    if (folderUid) {
      res["folderUid"] = boost::any(*folderUid);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (orgName) {
      res["orgName"] = boost::any(*orgName);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dashboardTitle") != m.end() && !m["dashboardTitle"].empty()) {
      dashboardTitle = make_shared<string>(boost::any_cast<string>(m["dashboardTitle"]));
    }
    if (m.find("dashboardURL") != m.end() && !m["dashboardURL"].empty()) {
      dashboardURL = make_shared<string>(boost::any_cast<string>(m["dashboardURL"]));
    }
    if (m.find("dashboardUid") != m.end() && !m["dashboardUid"].empty()) {
      dashboardUid = make_shared<string>(boost::any_cast<string>(m["dashboardUid"]));
    }
    if (m.find("folderId") != m.end() && !m["folderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["folderId"]));
    }
    if (m.find("folderTitle") != m.end() && !m["folderTitle"].empty()) {
      folderTitle = make_shared<string>(boost::any_cast<string>(m["folderTitle"]));
    }
    if (m.find("folderURL") != m.end() && !m["folderURL"].empty()) {
      folderURL = make_shared<string>(boost::any_cast<string>(m["folderURL"]));
    }
    if (m.find("folderUid") != m.end() && !m["folderUid"].empty()) {
      folderUid = make_shared<string>(boost::any_cast<string>(m["folderUid"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<string>(boost::any_cast<string>(m["orgId"]));
    }
    if (m.find("orgName") != m.end() && !m["orgName"].empty()) {
      orgName = make_shared<string>(boost::any_cast<string>(m["orgName"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GrafanaWorkspaceDashboardSync() = default;
};
class GrafanaWorkspaceDataBackup : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> msg{};
  shared_ptr<string> processName{};
  shared_ptr<string> processStatus{};
  shared_ptr<string> subType{};
  shared_ptr<string> userId{};

  GrafanaWorkspaceDataBackup() {}

  explicit GrafanaWorkspaceDataBackup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (processName) {
      res["processName"] = boost::any(*processName);
    }
    if (processStatus) {
      res["processStatus"] = boost::any(*processStatus);
    }
    if (subType) {
      res["subType"] = boost::any(*subType);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("processName") != m.end() && !m["processName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["processName"]));
    }
    if (m.find("processStatus") != m.end() && !m["processStatus"].empty()) {
      processStatus = make_shared<string>(boost::any_cast<string>(m["processStatus"]));
    }
    if (m.find("subType") != m.end() && !m["subType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["subType"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspaceDataBackup() = default;
};
class GrafanaWorkspaceIniBackup : public Darabonba::Model {
public:
  shared_ptr<string> ext{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> msg{};
  shared_ptr<string> processName{};
  shared_ptr<string> processStatus{};
  shared_ptr<string> subType{};
  shared_ptr<string> userId{};

  GrafanaWorkspaceIniBackup() {}

  explicit GrafanaWorkspaceIniBackup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ext) {
      res["ext"] = boost::any(*ext);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (processName) {
      res["processName"] = boost::any(*processName);
    }
    if (processStatus) {
      res["processStatus"] = boost::any(*processStatus);
    }
    if (subType) {
      res["subType"] = boost::any(*subType);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ext") != m.end() && !m["ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["ext"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("processName") != m.end() && !m["processName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["processName"]));
    }
    if (m.find("processStatus") != m.end() && !m["processStatus"].empty()) {
      processStatus = make_shared<string>(boost::any_cast<string>(m["processStatus"]));
    }
    if (m.find("subType") != m.end() && !m["subType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["subType"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspaceIniBackup() = default;
};
class GrafanaWorkspaceIniProperty : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<string> example{};
  shared_ptr<string> key{};
  shared_ptr<bool> secret{};
  shared_ptr<string> value{};

  GrafanaWorkspaceIniProperty() {}

  explicit GrafanaWorkspaceIniProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["defaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (example) {
      res["example"] = boost::any(*example);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (secret) {
      res["secret"] = boost::any(*secret);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("defaultValue") != m.end() && !m["defaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["defaultValue"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("example") != m.end() && !m["example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["example"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("secret") != m.end() && !m["secret"].empty()) {
      secret = make_shared<bool>(boost::any_cast<bool>(m["secret"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GrafanaWorkspaceIniProperty() = default;
};
class GrafanaWorkspaceIniSection : public Darabonba::Model {
public:
  shared_ptr<vector<GrafanaWorkspaceIniProperty>> propertys{};
  shared_ptr<string> section{};

  GrafanaWorkspaceIniSection() {}

  explicit GrafanaWorkspaceIniSection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["propertys"] = boost::any(temp1);
    }
    if (section) {
      res["section"] = boost::any(*section);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("propertys") != m.end() && !m["propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["propertys"].type()) {
        vector<GrafanaWorkspaceIniProperty> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceIniProperty model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<GrafanaWorkspaceIniProperty>>(expect1);
      }
    }
    if (m.find("section") != m.end() && !m["section"].empty()) {
      section = make_shared<string>(boost::any_cast<string>(m["section"]));
    }
  }


  virtual ~GrafanaWorkspaceIniSection() = default;
};
class GrafanaWorkspaceIntegrationPreview : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> image{};
  shared_ptr<string> name{};
  shared_ptr<string> thumbnail{};

  GrafanaWorkspaceIntegrationPreview() {}

  explicit GrafanaWorkspaceIntegrationPreview(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (thumbnail) {
      res["thumbnail"] = boost::any(*thumbnail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("thumbnail") != m.end() && !m["thumbnail"].empty()) {
      thumbnail = make_shared<string>(boost::any_cast<string>(m["thumbnail"]));
    }
  }


  virtual ~GrafanaWorkspaceIntegrationPreview() = default;
};
class GrafanaWorkspaceIntegration : public Darabonba::Model {
public:
  shared_ptr<long> datasourceAmount{};
  shared_ptr<string> integrationId{};
  shared_ptr<string> integrationName{};
  shared_ptr<vector<GrafanaWorkspaceIntegrationPreview>> previews{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> supportRegions{};

  GrafanaWorkspaceIntegration() {}

  explicit GrafanaWorkspaceIntegration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasourceAmount) {
      res["datasourceAmount"] = boost::any(*datasourceAmount);
    }
    if (integrationId) {
      res["integrationId"] = boost::any(*integrationId);
    }
    if (integrationName) {
      res["integrationName"] = boost::any(*integrationName);
    }
    if (previews) {
      vector<boost::any> temp1;
      for(auto item1:*previews){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["previews"] = boost::any(temp1);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (supportRegions) {
      res["supportRegions"] = boost::any(*supportRegions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("datasourceAmount") != m.end() && !m["datasourceAmount"].empty()) {
      datasourceAmount = make_shared<long>(boost::any_cast<long>(m["datasourceAmount"]));
    }
    if (m.find("integrationId") != m.end() && !m["integrationId"].empty()) {
      integrationId = make_shared<string>(boost::any_cast<string>(m["integrationId"]));
    }
    if (m.find("integrationName") != m.end() && !m["integrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["integrationName"]));
    }
    if (m.find("previews") != m.end() && !m["previews"].empty()) {
      if (typeid(vector<boost::any>) == m["previews"].type()) {
        vector<GrafanaWorkspaceIntegrationPreview> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["previews"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceIntegrationPreview model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        previews = make_shared<vector<GrafanaWorkspaceIntegrationPreview>>(expect1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("supportRegions") != m.end() && !m["supportRegions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportRegions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportRegions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportRegions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GrafanaWorkspaceIntegration() = default;
};
class GrafanaWorkspaceIntegrationDataSource : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> datasourceId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<string> datasourceUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> exploreUrl{};
  shared_ptr<string> folderUrl{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GrafanaWorkspaceIntegrationDataSource() {}

  explicit GrafanaWorkspaceIntegrationDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["clusterType"] = boost::any(*clusterType);
    }
    if (datasourceId) {
      res["datasourceId"] = boost::any(*datasourceId);
    }
    if (datasourceName) {
      res["datasourceName"] = boost::any(*datasourceName);
    }
    if (datasourceUrl) {
      res["datasourceUrl"] = boost::any(*datasourceUrl);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (exploreUrl) {
      res["exploreUrl"] = boost::any(*exploreUrl);
    }
    if (folderUrl) {
      res["folderUrl"] = boost::any(*folderUrl);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusterType") != m.end() && !m["clusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["clusterType"]));
    }
    if (m.find("datasourceId") != m.end() && !m["datasourceId"].empty()) {
      datasourceId = make_shared<string>(boost::any_cast<string>(m["datasourceId"]));
    }
    if (m.find("datasourceName") != m.end() && !m["datasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["datasourceName"]));
    }
    if (m.find("datasourceUrl") != m.end() && !m["datasourceUrl"].empty()) {
      datasourceUrl = make_shared<string>(boost::any_cast<string>(m["datasourceUrl"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("exploreUrl") != m.end() && !m["exploreUrl"].empty()) {
      exploreUrl = make_shared<string>(boost::any_cast<string>(m["exploreUrl"]));
    }
    if (m.find("folderUrl") != m.end() && !m["folderUrl"].empty()) {
      folderUrl = make_shared<string>(boost::any_cast<string>(m["folderUrl"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GrafanaWorkspaceIntegrationDataSource() = default;
};
class GrafanaWorkspaceIntegrationDetail : public Darabonba::Model {
public:
  shared_ptr<vector<GrafanaWorkspaceIntegrationDataSource>> dataSources{};
  shared_ptr<string> integrationId{};
  shared_ptr<string> status{};

  GrafanaWorkspaceIntegrationDetail() {}

  explicit GrafanaWorkspaceIntegrationDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSources) {
      vector<boost::any> temp1;
      for(auto item1:*dataSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dataSources"] = boost::any(temp1);
    }
    if (integrationId) {
      res["integrationId"] = boost::any(*integrationId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataSources") != m.end() && !m["dataSources"].empty()) {
      if (typeid(vector<boost::any>) == m["dataSources"].type()) {
        vector<GrafanaWorkspaceIntegrationDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dataSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceIntegrationDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSources = make_shared<vector<GrafanaWorkspaceIntegrationDataSource>>(expect1);
      }
    }
    if (m.find("integrationId") != m.end() && !m["integrationId"].empty()) {
      integrationId = make_shared<string>(boost::any_cast<string>(m["integrationId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~GrafanaWorkspaceIntegrationDetail() = default;
};
class GrafanaWorkspaceNews : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<string> description{};
  shared_ptr<string> image{};
  shared_ptr<string> link{};
  shared_ptr<string> title{};

  GrafanaWorkspaceNews() {}

  explicit GrafanaWorkspaceNews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (link) {
      res["link"] = boost::any(*link);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["date"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("link") != m.end() && !m["link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["link"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~GrafanaWorkspaceNews() = default;
};
class GrafanaWorkspaceOperateLog : public Darabonba::Model {
public:
  shared_ptr<double> date{};
  shared_ptr<string> detail{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> operatorId{};

  GrafanaWorkspaceOperateLog() {}

  explicit GrafanaWorkspaceOperateLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (detail) {
      res["detail"] = boost::any(*detail);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<double>(boost::any_cast<double>(m["date"]));
    }
    if (m.find("detail") != m.end() && !m["detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["detail"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
  }


  virtual ~GrafanaWorkspaceOperateLog() = default;
};
class GrafanaWorkspaceOrg : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GrafanaWorkspaceOrg() {}

  explicit GrafanaWorkspaceOrg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GrafanaWorkspaceOrg() = default;
};
class GrafanaWorkspaceTransDetail : public Darabonba::Model {
public:
  shared_ptr<long> dashboardAmount{};
  shared_ptr<long> dataSourceAmount{};
  shared_ptr<long> original{};
  shared_ptr<string> originalName{};
  shared_ptr<long> target{};
  shared_ptr<string> targetName{};

  GrafanaWorkspaceTransDetail() {}

  explicit GrafanaWorkspaceTransDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboardAmount) {
      res["dashboardAmount"] = boost::any(*dashboardAmount);
    }
    if (dataSourceAmount) {
      res["dataSourceAmount"] = boost::any(*dataSourceAmount);
    }
    if (original) {
      res["original"] = boost::any(*original);
    }
    if (originalName) {
      res["originalName"] = boost::any(*originalName);
    }
    if (target) {
      res["target"] = boost::any(*target);
    }
    if (targetName) {
      res["targetName"] = boost::any(*targetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dashboardAmount") != m.end() && !m["dashboardAmount"].empty()) {
      dashboardAmount = make_shared<long>(boost::any_cast<long>(m["dashboardAmount"]));
    }
    if (m.find("dataSourceAmount") != m.end() && !m["dataSourceAmount"].empty()) {
      dataSourceAmount = make_shared<long>(boost::any_cast<long>(m["dataSourceAmount"]));
    }
    if (m.find("original") != m.end() && !m["original"].empty()) {
      original = make_shared<long>(boost::any_cast<long>(m["original"]));
    }
    if (m.find("originalName") != m.end() && !m["originalName"].empty()) {
      originalName = make_shared<string>(boost::any_cast<string>(m["originalName"]));
    }
    if (m.find("target") != m.end() && !m["target"].empty()) {
      target = make_shared<long>(boost::any_cast<long>(m["target"]));
    }
    if (m.find("targetName") != m.end() && !m["targetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["targetName"]));
    }
  }


  virtual ~GrafanaWorkspaceTransDetail() = default;
};
class GrafanaWorkspaceTrans : public Darabonba::Model {
public:
  shared_ptr<string> apiUrl{};
  shared_ptr<string> authType{};
  shared_ptr<double> gmtCreate{};
  shared_ptr<double> gmtModified{};
  shared_ptr<string> grafanaWorkspaceId{};
  shared_ptr<long> id{};
  shared_ptr<string> msg{};
  shared_ptr<string> processStatus{};
  shared_ptr<vector<GrafanaWorkspaceTransDetail>> transDetails{};
  shared_ptr<string> userId{};

  GrafanaWorkspaceTrans() {}

  explicit GrafanaWorkspaceTrans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUrl) {
      res["apiUrl"] = boost::any(*apiUrl);
    }
    if (authType) {
      res["authType"] = boost::any(*authType);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (grafanaWorkspaceId) {
      res["grafanaWorkspaceId"] = boost::any(*grafanaWorkspaceId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (msg) {
      res["msg"] = boost::any(*msg);
    }
    if (processStatus) {
      res["processStatus"] = boost::any(*processStatus);
    }
    if (transDetails) {
      vector<boost::any> temp1;
      for(auto item1:*transDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["transDetails"] = boost::any(temp1);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apiUrl") != m.end() && !m["apiUrl"].empty()) {
      apiUrl = make_shared<string>(boost::any_cast<string>(m["apiUrl"]));
    }
    if (m.find("authType") != m.end() && !m["authType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["authType"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<double>(boost::any_cast<double>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<double>(boost::any_cast<double>(m["gmtModified"]));
    }
    if (m.find("grafanaWorkspaceId") != m.end() && !m["grafanaWorkspaceId"].empty()) {
      grafanaWorkspaceId = make_shared<string>(boost::any_cast<string>(m["grafanaWorkspaceId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("msg") != m.end() && !m["msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["msg"]));
    }
    if (m.find("processStatus") != m.end() && !m["processStatus"].empty()) {
      processStatus = make_shared<string>(boost::any_cast<string>(m["processStatus"]));
    }
    if (m.find("transDetails") != m.end() && !m["transDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["transDetails"].type()) {
        vector<GrafanaWorkspaceTransDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["transDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrafanaWorkspaceTransDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transDetails = make_shared<vector<GrafanaWorkspaceTransDetail>>(expect1);
      }
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GrafanaWorkspaceTrans() = default;
};
class GrafanaWorkspaceUserCert : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GrafanaWorkspaceUserCert() {}

  explicit GrafanaWorkspaceUserCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GrafanaWorkspaceUserCert() = default;
};
class GrafanaWorkspaceVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> fcConfig{};
  shared_ptr<long> id{};
  shared_ptr<string> installMsg{};
  shared_ptr<string> installStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  GrafanaWorkspaceVpcConfig() {}

  explicit GrafanaWorkspaceVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcConfig) {
      res["fcConfig"] = boost::any(*fcConfig);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (installMsg) {
      res["installMsg"] = boost::any(*installMsg);
    }
    if (installStatus) {
      res["installStatus"] = boost::any(*installStatus);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["securityGroupId"] = boost::any(*securityGroupId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["vSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fcConfig") != m.end() && !m["fcConfig"].empty()) {
      fcConfig = make_shared<string>(boost::any_cast<string>(m["fcConfig"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("installMsg") != m.end() && !m["installMsg"].empty()) {
      installMsg = make_shared<string>(boost::any_cast<string>(m["installMsg"]));
    }
    if (m.find("installStatus") != m.end() && !m["installStatus"].empty()) {
      installStatus = make_shared<string>(boost::any_cast<string>(m["installStatus"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("securityGroupId") != m.end() && !m["securityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["securityGroupId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
    if (m.find("vSwitchId") != m.end() && !m["vSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["vSwitchId"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~GrafanaWorkspaceVpcConfig() = default;
};
class GrafanaWorkspaceVpcRegion : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};

  GrafanaWorkspaceVpcRegion() {}

  explicit GrafanaWorkspaceVpcRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["regionName"] = boost::any(*regionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("regionName") != m.end() && !m["regionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["regionName"]));
    }
  }


  virtual ~GrafanaWorkspaceVpcRegion() = default;
};
class GrafanaWorkspaceVpcRegionDetail : public Darabonba::Model {
public:
  shared_ptr<string> fcConfig{};
  shared_ptr<long> id{};
  shared_ptr<string> installStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vpcId{};

  GrafanaWorkspaceVpcRegionDetail() {}

  explicit GrafanaWorkspaceVpcRegionDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcConfig) {
      res["fcConfig"] = boost::any(*fcConfig);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (installStatus) {
      res["installStatus"] = boost::any(*installStatus);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["securityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupIds) {
      res["securityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["vSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchIds) {
      res["vSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fcConfig") != m.end() && !m["fcConfig"].empty()) {
      fcConfig = make_shared<string>(boost::any_cast<string>(m["fcConfig"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("installStatus") != m.end() && !m["installStatus"].empty()) {
      installStatus = make_shared<string>(boost::any_cast<string>(m["installStatus"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("securityGroupId") != m.end() && !m["securityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["securityGroupId"]));
    }
    if (m.find("securityGroupIds") != m.end() && !m["securityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["securityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["securityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
    if (m.find("vSwitchId") != m.end() && !m["vSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["vSwitchId"]));
    }
    if (m.find("vSwitchIds") != m.end() && !m["vSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["vSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["vSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~GrafanaWorkspaceVpcRegionDetail() = default;
};
class QueryDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> results{};

  QueryDataResponse() {}

  explicit QueryDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (results) {
      res["results"] = boost::any(*results);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("results") != m.end() && !m["results"].empty()) {
      results = make_shared<string>(boost::any_cast<string>(m["results"]));
    }
  }


  virtual ~QueryDataResponse() = default;
};
class AddAliClusterIdsToPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterIds{};
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};

  AddAliClusterIdsToPrometheusGlobalViewRequest() {}

  explicit AddAliClusterIdsToPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      clusterIds = make_shared<string>(boost::any_cast<string>(m["ClusterIds"]));
    }
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddAliClusterIdsToPrometheusGlobalViewRequest() = default;
};
class AddAliClusterIdsToPrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  AddAliClusterIdsToPrometheusGlobalViewResponseBodyData() {}

  explicit AddAliClusterIdsToPrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddAliClusterIdsToPrometheusGlobalViewResponseBodyData() = default;
};
class AddAliClusterIdsToPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AddAliClusterIdsToPrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddAliClusterIdsToPrometheusGlobalViewResponseBody() {}

  explicit AddAliClusterIdsToPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddAliClusterIdsToPrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddAliClusterIdsToPrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddAliClusterIdsToPrometheusGlobalViewResponseBody() = default;
};
class AddAliClusterIdsToPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAliClusterIdsToPrometheusGlobalViewResponseBody> body{};

  AddAliClusterIdsToPrometheusGlobalViewResponse() {}

  explicit AddAliClusterIdsToPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAliClusterIdsToPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAliClusterIdsToPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~AddAliClusterIdsToPrometheusGlobalViewResponse() = default;
};
class AddGrafanaRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integration{};
  shared_ptr<string> regionId{};

  AddGrafanaRequest() {}

  explicit AddGrafanaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integration) {
      res["Integration"] = boost::any(*integration);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      integration = make_shared<string>(boost::any_cast<string>(m["Integration"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddGrafanaRequest() = default;
};
class AddGrafanaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  AddGrafanaResponseBody() {}

  explicit AddGrafanaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddGrafanaResponseBody() = default;
};
class AddGrafanaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGrafanaResponseBody> body{};

  AddGrafanaResponse() {}

  explicit AddGrafanaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGrafanaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGrafanaResponseBody>(model1);
      }
    }
  }


  virtual ~AddGrafanaResponse() = default;
};
class AddIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integration{};
  shared_ptr<string> regionId{};

  AddIntegrationRequest() {}

  explicit AddIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integration) {
      res["Integration"] = boost::any(*integration);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      integration = make_shared<string>(boost::any_cast<string>(m["Integration"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddIntegrationRequest() = default;
};
class AddIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddIntegrationResponseBody() {}

  explicit AddIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddIntegrationResponseBody() = default;
};
class AddIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddIntegrationResponseBody> body{};

  AddIntegrationResponse() {}

  explicit AddIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~AddIntegrationResponse() = default;
};
class AddPrometheusGlobalViewRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddPrometheusGlobalViewRequestTag() {}

  explicit AddPrometheusGlobalViewRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddPrometheusGlobalViewRequestTag() = default;
};
class AddPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusters{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<AddPrometheusGlobalViewRequestTag>> tag{};

  AddPrometheusGlobalViewRequest() {}

  explicit AddPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      res["Clusters"] = boost::any(*clusters);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      clusters = make_shared<string>(boost::any_cast<string>(m["Clusters"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddPrometheusGlobalViewRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddPrometheusGlobalViewRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddPrometheusGlobalViewRequestTag>>(expect1);
      }
    }
  }


  virtual ~AddPrometheusGlobalViewRequest() = default;
};
class AddPrometheusGlobalViewResponseBodyDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> failedInstances{};
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> regionId{};

  AddPrometheusGlobalViewResponseBodyDataInfo() {}

  explicit AddPrometheusGlobalViewResponseBodyDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedInstances) {
      res["FailedInstances"] = boost::any(*failedInstances);
    }
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedInstances") != m.end() && !m["FailedInstances"].empty()) {
      failedInstances = make_shared<string>(boost::any_cast<string>(m["FailedInstances"]));
    }
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddPrometheusGlobalViewResponseBodyDataInfo() = default;
};
class AddPrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<AddPrometheusGlobalViewResponseBodyDataInfo> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  AddPrometheusGlobalViewResponseBodyData() {}

  explicit AddPrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        AddPrometheusGlobalViewResponseBodyDataInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<AddPrometheusGlobalViewResponseBodyDataInfo>(model1);
      }
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddPrometheusGlobalViewResponseBodyData() = default;
};
class AddPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AddPrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPrometheusGlobalViewResponseBody() {}

  explicit AddPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddPrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddPrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPrometheusGlobalViewResponseBody() = default;
};
class AddPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPrometheusGlobalViewResponseBody> body{};

  AddPrometheusGlobalViewResponse() {}

  explicit AddPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~AddPrometheusGlobalViewResponse() = default;
};
class AddPrometheusGlobalViewByAliClusterIdsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterIds{};
  shared_ptr<string> groupName{};
  shared_ptr<string> productCode{};
  shared_ptr<string> regionId{};

  AddPrometheusGlobalViewByAliClusterIdsRequest() {}

  explicit AddPrometheusGlobalViewByAliClusterIdsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      clusterIds = make_shared<string>(boost::any_cast<string>(m["ClusterIds"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddPrometheusGlobalViewByAliClusterIdsRequest() = default;
};
class AddPrometheusGlobalViewByAliClusterIdsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  AddPrometheusGlobalViewByAliClusterIdsResponseBodyData() {}

  explicit AddPrometheusGlobalViewByAliClusterIdsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddPrometheusGlobalViewByAliClusterIdsResponseBodyData() = default;
};
class AddPrometheusGlobalViewByAliClusterIdsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AddPrometheusGlobalViewByAliClusterIdsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPrometheusGlobalViewByAliClusterIdsResponseBody() {}

  explicit AddPrometheusGlobalViewByAliClusterIdsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddPrometheusGlobalViewByAliClusterIdsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddPrometheusGlobalViewByAliClusterIdsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPrometheusGlobalViewByAliClusterIdsResponseBody() = default;
};
class AddPrometheusGlobalViewByAliClusterIdsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPrometheusGlobalViewByAliClusterIdsResponseBody> body{};

  AddPrometheusGlobalViewByAliClusterIdsResponse() {}

  explicit AddPrometheusGlobalViewByAliClusterIdsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPrometheusGlobalViewByAliClusterIdsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPrometheusGlobalViewByAliClusterIdsResponseBody>(model1);
      }
    }
  }


  virtual ~AddPrometheusGlobalViewByAliClusterIdsResponse() = default;
};
class AddPrometheusInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  AddPrometheusInstanceRequest() {}

  explicit AddPrometheusInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddPrometheusInstanceRequest() = default;
};
class AddPrometheusInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddPrometheusInstanceResponseBody() {}

  explicit AddPrometheusInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddPrometheusInstanceResponseBody() = default;
};
class AddPrometheusInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPrometheusInstanceResponseBody> body{};

  AddPrometheusInstanceResponse() {}

  explicit AddPrometheusInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPrometheusInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPrometheusInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~AddPrometheusInstanceResponse() = default;
};
class AddPrometheusIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> param{};
  shared_ptr<string> regionId{};

  AddPrometheusIntegrationRequest() {}

  explicit AddPrometheusIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddPrometheusIntegrationRequest() = default;
};
class AddPrometheusIntegrationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};

  AddPrometheusIntegrationResponseBodyData() {}

  explicit AddPrometheusIntegrationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~AddPrometheusIntegrationResponseBodyData() = default;
};
class AddPrometheusIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AddPrometheusIntegrationResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPrometheusIntegrationResponseBody() {}

  explicit AddPrometheusIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddPrometheusIntegrationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddPrometheusIntegrationResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPrometheusIntegrationResponseBody() = default;
};
class AddPrometheusIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPrometheusIntegrationResponseBody> body{};

  AddPrometheusIntegrationResponse() {}

  explicit AddPrometheusIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPrometheusIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPrometheusIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~AddPrometheusIntegrationResponse() = default;
};
class AddPrometheusRemoteWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteWriteYaml{};

  AddPrometheusRemoteWriteRequest() {}

  explicit AddPrometheusRemoteWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteWriteYaml) {
      res["RemoteWriteYaml"] = boost::any(*remoteWriteYaml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteWriteYaml") != m.end() && !m["RemoteWriteYaml"].empty()) {
      remoteWriteYaml = make_shared<string>(boost::any_cast<string>(m["RemoteWriteYaml"]));
    }
  }


  virtual ~AddPrometheusRemoteWriteRequest() = default;
};
class AddPrometheusRemoteWriteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddPrometheusRemoteWriteResponseBody() {}

  explicit AddPrometheusRemoteWriteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddPrometheusRemoteWriteResponseBody() = default;
};
class AddPrometheusRemoteWriteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPrometheusRemoteWriteResponseBody> body{};

  AddPrometheusRemoteWriteResponse() {}

  explicit AddPrometheusRemoteWriteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPrometheusRemoteWriteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPrometheusRemoteWriteResponseBody>(model1);
      }
    }
  }


  virtual ~AddPrometheusRemoteWriteResponse() = default;
};
class AddRecordingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleYaml{};

  AddRecordingRuleRequest() {}

  explicit AddRecordingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleYaml) {
      res["RuleYaml"] = boost::any(*ruleYaml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleYaml") != m.end() && !m["RuleYaml"].empty()) {
      ruleYaml = make_shared<string>(boost::any_cast<string>(m["RuleYaml"]));
    }
  }


  virtual ~AddRecordingRuleRequest() = default;
};
class AddRecordingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddRecordingRuleResponseBody() {}

  explicit AddRecordingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddRecordingRuleResponseBody() = default;
};
class AddRecordingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddRecordingRuleResponseBody> body{};

  AddRecordingRuleResponse() {}

  explicit AddRecordingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddRecordingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddRecordingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddRecordingRuleResponse() = default;
};
class AppendInstancesToPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusters{};
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};

  AppendInstancesToPrometheusGlobalViewRequest() {}

  explicit AppendInstancesToPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      res["Clusters"] = boost::any(*clusters);
    }
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      clusters = make_shared<string>(boost::any_cast<string>(m["Clusters"]));
    }
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AppendInstancesToPrometheusGlobalViewRequest() = default;
};
class AppendInstancesToPrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  AppendInstancesToPrometheusGlobalViewResponseBodyData() {}

  explicit AppendInstancesToPrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AppendInstancesToPrometheusGlobalViewResponseBodyData() = default;
};
class AppendInstancesToPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AppendInstancesToPrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AppendInstancesToPrometheusGlobalViewResponseBody() {}

  explicit AppendInstancesToPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AppendInstancesToPrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AppendInstancesToPrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AppendInstancesToPrometheusGlobalViewResponseBody() = default;
};
class AppendInstancesToPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AppendInstancesToPrometheusGlobalViewResponseBody> body{};

  AppendInstancesToPrometheusGlobalViewResponse() {}

  explicit AppendInstancesToPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AppendInstancesToPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AppendInstancesToPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~AppendInstancesToPrometheusGlobalViewResponse() = default;
};
class ApplyScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<map<string, boost::any>> config{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scenario{};
  shared_ptr<string> sign{};
  shared_ptr<bool> snDump{};
  shared_ptr<bool> snForce{};
  shared_ptr<bool> snStat{};
  shared_ptr<bool> snTransfer{};
  shared_ptr<bool> updateOption{};

  ApplyScenarioRequest() {}

  explicit ApplyScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    if (snDump) {
      res["SnDump"] = boost::any(*snDump);
    }
    if (snForce) {
      res["SnForce"] = boost::any(*snForce);
    }
    if (snStat) {
      res["SnStat"] = boost::any(*snStat);
    }
    if (snTransfer) {
      res["SnTransfer"] = boost::any(*snTransfer);
    }
    if (updateOption) {
      res["UpdateOption"] = boost::any(*updateOption);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Config"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      config = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
    if (m.find("SnDump") != m.end() && !m["SnDump"].empty()) {
      snDump = make_shared<bool>(boost::any_cast<bool>(m["SnDump"]));
    }
    if (m.find("SnForce") != m.end() && !m["SnForce"].empty()) {
      snForce = make_shared<bool>(boost::any_cast<bool>(m["SnForce"]));
    }
    if (m.find("SnStat") != m.end() && !m["SnStat"].empty()) {
      snStat = make_shared<bool>(boost::any_cast<bool>(m["SnStat"]));
    }
    if (m.find("SnTransfer") != m.end() && !m["SnTransfer"].empty()) {
      snTransfer = make_shared<bool>(boost::any_cast<bool>(m["SnTransfer"]));
    }
    if (m.find("UpdateOption") != m.end() && !m["UpdateOption"].empty()) {
      updateOption = make_shared<bool>(boost::any_cast<bool>(m["UpdateOption"]));
    }
  }


  virtual ~ApplyScenarioRequest() = default;
};
class ApplyScenarioShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> configShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scenario{};
  shared_ptr<string> sign{};
  shared_ptr<bool> snDump{};
  shared_ptr<bool> snForce{};
  shared_ptr<bool> snStat{};
  shared_ptr<bool> snTransfer{};
  shared_ptr<bool> updateOption{};

  ApplyScenarioShrinkRequest() {}

  explicit ApplyScenarioShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (configShrink) {
      res["Config"] = boost::any(*configShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    if (snDump) {
      res["SnDump"] = boost::any(*snDump);
    }
    if (snForce) {
      res["SnForce"] = boost::any(*snForce);
    }
    if (snStat) {
      res["SnStat"] = boost::any(*snStat);
    }
    if (snTransfer) {
      res["SnTransfer"] = boost::any(*snTransfer);
    }
    if (updateOption) {
      res["UpdateOption"] = boost::any(*updateOption);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      configShrink = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
    if (m.find("SnDump") != m.end() && !m["SnDump"].empty()) {
      snDump = make_shared<bool>(boost::any_cast<bool>(m["SnDump"]));
    }
    if (m.find("SnForce") != m.end() && !m["SnForce"].empty()) {
      snForce = make_shared<bool>(boost::any_cast<bool>(m["SnForce"]));
    }
    if (m.find("SnStat") != m.end() && !m["SnStat"].empty()) {
      snStat = make_shared<bool>(boost::any_cast<bool>(m["SnStat"]));
    }
    if (m.find("SnTransfer") != m.end() && !m["SnTransfer"].empty()) {
      snTransfer = make_shared<bool>(boost::any_cast<bool>(m["SnTransfer"]));
    }
    if (m.find("UpdateOption") != m.end() && !m["UpdateOption"].empty()) {
      updateOption = make_shared<bool>(boost::any_cast<bool>(m["UpdateOption"]));
    }
  }


  virtual ~ApplyScenarioShrinkRequest() = default;
};
class ApplyScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ApplyScenarioResponseBody() {}

  explicit ApplyScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ApplyScenarioResponseBody() = default;
};
class ApplyScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyScenarioResponseBody> body{};

  ApplyScenarioResponse() {}

  explicit ApplyScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyScenarioResponse() = default;
};
class BindPrometheusGrafanaInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> grafanaInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  BindPrometheusGrafanaInstanceRequest() {}

  explicit BindPrometheusGrafanaInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (grafanaInstanceId) {
      res["GrafanaInstanceId"] = boost::any(*grafanaInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("GrafanaInstanceId") != m.end() && !m["GrafanaInstanceId"].empty()) {
      grafanaInstanceId = make_shared<string>(boost::any_cast<string>(m["GrafanaInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~BindPrometheusGrafanaInstanceRequest() = default;
};
class BindPrometheusGrafanaInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  BindPrometheusGrafanaInstanceResponseBody() {}

  explicit BindPrometheusGrafanaInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindPrometheusGrafanaInstanceResponseBody() = default;
};
class BindPrometheusGrafanaInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindPrometheusGrafanaInstanceResponseBody> body{};

  BindPrometheusGrafanaInstanceResponse() {}

  explicit BindPrometheusGrafanaInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindPrometheusGrafanaInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindPrometheusGrafanaInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindPrometheusGrafanaInstanceResponse() = default;
};
class ChangeResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  ChangeResourceGroupRequest() {}

  explicit ChangeResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ChangeResourceGroupRequest() = default;
};
class ChangeResourceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};

  ChangeResourceGroupResponseBodyData() {}

  explicit ChangeResourceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ChangeResourceGroupResponseBodyData() = default;
};
class ChangeResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ChangeResourceGroupResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ChangeResourceGroupResponseBody() {}

  explicit ChangeResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ChangeResourceGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ChangeResourceGroupResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeResourceGroupResponseBody() = default;
};
class ChangeResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeResourceGroupResponseBody> body{};

  ChangeResourceGroupResponse() {}

  explicit ChangeResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeResourceGroupResponse() = default;
};
class CheckServiceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> svcCode{};

  CheckServiceStatusRequest() {}

  explicit CheckServiceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (svcCode) {
      res["SvcCode"] = boost::any(*svcCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SvcCode") != m.end() && !m["SvcCode"].empty()) {
      svcCode = make_shared<string>(boost::any_cast<string>(m["SvcCode"]));
    }
  }


  virtual ~CheckServiceStatusRequest() = default;
};
class CheckServiceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  CheckServiceStatusResponseBody() {}

  explicit CheckServiceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckServiceStatusResponseBody() = default;
};
class CheckServiceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckServiceStatusResponseBody> body{};

  CheckServiceStatusResponse() {}

  explicit CheckServiceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckServiceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckServiceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~CheckServiceStatusResponse() = default;
};
class ConfigAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};
  shared_ptr<string> enable{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  ConfigAppRequest() {}

  explicit ConfigAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ConfigAppRequest() = default;
};
class ConfigAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  ConfigAppResponseBody() {}

  explicit ConfigAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigAppResponseBody() = default;
};
class ConfigAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigAppResponseBody> body{};

  ConfigAppResponse() {}

  explicit ConfigAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigAppResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigAppResponse() = default;
};
class CreateAlertContactRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactName{};
  shared_ptr<string> dingRobotWebhookUrl{};
  shared_ptr<string> email{};
  shared_ptr<string> phoneNum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> systemNoc{};

  CreateAlertContactRequest() {}

  explicit CreateAlertContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (dingRobotWebhookUrl) {
      res["DingRobotWebhookUrl"] = boost::any(*dingRobotWebhookUrl);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (systemNoc) {
      res["SystemNoc"] = boost::any(*systemNoc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("DingRobotWebhookUrl") != m.end() && !m["DingRobotWebhookUrl"].empty()) {
      dingRobotWebhookUrl = make_shared<string>(boost::any_cast<string>(m["DingRobotWebhookUrl"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SystemNoc") != m.end() && !m["SystemNoc"].empty()) {
      systemNoc = make_shared<bool>(boost::any_cast<bool>(m["SystemNoc"]));
    }
  }


  virtual ~CreateAlertContactRequest() = default;
};
class CreateAlertContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> requestId{};

  CreateAlertContactResponseBody() {}

  explicit CreateAlertContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAlertContactResponseBody() = default;
};
class CreateAlertContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAlertContactResponseBody> body{};

  CreateAlertContactResponse() {}

  explicit CreateAlertContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAlertContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAlertContactResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAlertContactResponse() = default;
};
class CreateAlertContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> contactIds{};
  shared_ptr<string> regionId{};

  CreateAlertContactGroupRequest() {}

  explicit CreateAlertContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateAlertContactGroupRequest() = default;
};
class CreateAlertContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupId{};
  shared_ptr<string> requestId{};

  CreateAlertContactGroupResponseBody() {}

  explicit CreateAlertContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<string>(boost::any_cast<string>(m["ContactGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAlertContactGroupResponseBody() = default;
};
class CreateAlertContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAlertContactGroupResponseBody> body{};

  CreateAlertContactGroupResponse() {}

  explicit CreateAlertContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAlertContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAlertContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAlertContactGroupResponse() = default;
};
class CreateDispatchRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> dispatchRule{};
  shared_ptr<string> regionId{};

  CreateDispatchRuleRequest() {}

  explicit CreateDispatchRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchRule) {
      res["DispatchRule"] = boost::any(*dispatchRule);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchRule") != m.end() && !m["DispatchRule"].empty()) {
      dispatchRule = make_shared<string>(boost::any_cast<string>(m["DispatchRule"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateDispatchRuleRequest() = default;
};
class CreateDispatchRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> requestId{};

  CreateDispatchRuleResponseBody() {}

  explicit CreateDispatchRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDispatchRuleResponseBody() = default;
};
class CreateDispatchRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDispatchRuleResponseBody> body{};

  CreateDispatchRuleResponse() {}

  explicit CreateDispatchRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDispatchRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDispatchRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDispatchRuleResponse() = default;
};
class CreateIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRecover{};
  shared_ptr<string> description{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<long> recoverTime{};

  CreateIntegrationRequest() {}

  explicit CreateIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRecover) {
      res["AutoRecover"] = boost::any(*autoRecover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRecover") != m.end() && !m["AutoRecover"].empty()) {
      autoRecover = make_shared<bool>(boost::any_cast<bool>(m["AutoRecover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
  }


  virtual ~CreateIntegrationRequest() = default;
};
class CreateIntegrationResponseBodyIntegration : public Darabonba::Model {
public:
  shared_ptr<bool> autoRecover{};
  shared_ptr<string> description{};
  shared_ptr<long> integrationId{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<long> recoverTime{};

  CreateIntegrationResponseBodyIntegration() {}

  explicit CreateIntegrationResponseBodyIntegration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRecover) {
      res["AutoRecover"] = boost::any(*autoRecover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRecover") != m.end() && !m["AutoRecover"].empty()) {
      autoRecover = make_shared<bool>(boost::any_cast<bool>(m["AutoRecover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
  }


  virtual ~CreateIntegrationResponseBodyIntegration() = default;
};
class CreateIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateIntegrationResponseBodyIntegration> integration{};
  shared_ptr<string> requestId{};

  CreateIntegrationResponseBody() {}

  explicit CreateIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integration) {
      res["Integration"] = integration ? boost::any(integration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      if (typeid(map<string, boost::any>) == m["Integration"].type()) {
        CreateIntegrationResponseBodyIntegration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Integration"]));
        integration = make_shared<CreateIntegrationResponseBodyIntegration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIntegrationResponseBody() = default;
};
class CreateIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIntegrationResponseBody> body{};

  CreateIntegrationResponse() {}

  explicit CreateIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIntegrationResponse() = default;
};
class CreateOrUpdateAlertRuleRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleRequestTags() {}

  explicit CreateOrUpdateAlertRuleRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleRequestTags() = default;
};
class CreateOrUpdateAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertCheckType{};
  shared_ptr<long> alertGroup{};
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<string> alertRuleContent{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> alertType{};
  shared_ptr<string> annotations{};
  shared_ptr<bool> autoAddNewApplication{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> duration{};
  shared_ptr<string> filters{};
  shared_ptr<string> labels{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> metricsKey{};
  shared_ptr<string> metricsType{};
  shared_ptr<string> notifyStrategy{};
  shared_ptr<string> pids{};
  shared_ptr<string> promQL{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateOrUpdateAlertRuleRequestTags>> tags{};

  CreateOrUpdateAlertRuleRequest() {}

  explicit CreateOrUpdateAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertCheckType) {
      res["AlertCheckType"] = boost::any(*alertCheckType);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertRuleContent) {
      res["AlertRuleContent"] = boost::any(*alertRuleContent);
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (autoAddNewApplication) {
      res["AutoAddNewApplication"] = boost::any(*autoAddNewApplication);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (filters) {
      res["Filters"] = boost::any(*filters);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (metricsKey) {
      res["MetricsKey"] = boost::any(*metricsKey);
    }
    if (metricsType) {
      res["MetricsType"] = boost::any(*metricsType);
    }
    if (notifyStrategy) {
      res["NotifyStrategy"] = boost::any(*notifyStrategy);
    }
    if (pids) {
      res["Pids"] = boost::any(*pids);
    }
    if (promQL) {
      res["PromQL"] = boost::any(*promQL);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertCheckType") != m.end() && !m["AlertCheckType"].empty()) {
      alertCheckType = make_shared<string>(boost::any_cast<string>(m["AlertCheckType"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<long>(boost::any_cast<long>(m["AlertGroup"]));
    }
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertRuleContent") != m.end() && !m["AlertRuleContent"].empty()) {
      alertRuleContent = make_shared<string>(boost::any_cast<string>(m["AlertRuleContent"]));
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<string>(boost::any_cast<string>(m["AlertType"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("AutoAddNewApplication") != m.end() && !m["AutoAddNewApplication"].empty()) {
      autoAddNewApplication = make_shared<bool>(boost::any_cast<bool>(m["AutoAddNewApplication"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      filters = make_shared<string>(boost::any_cast<string>(m["Filters"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MetricsKey") != m.end() && !m["MetricsKey"].empty()) {
      metricsKey = make_shared<string>(boost::any_cast<string>(m["MetricsKey"]));
    }
    if (m.find("MetricsType") != m.end() && !m["MetricsType"].empty()) {
      metricsType = make_shared<string>(boost::any_cast<string>(m["MetricsType"]));
    }
    if (m.find("NotifyStrategy") != m.end() && !m["NotifyStrategy"].empty()) {
      notifyStrategy = make_shared<string>(boost::any_cast<string>(m["NotifyStrategy"]));
    }
    if (m.find("Pids") != m.end() && !m["Pids"].empty()) {
      pids = make_shared<string>(boost::any_cast<string>(m["Pids"]));
    }
    if (m.find("PromQL") != m.end() && !m["PromQL"].empty()) {
      promQL = make_shared<string>(boost::any_cast<string>(m["PromQL"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateOrUpdateAlertRuleRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateOrUpdateAlertRuleRequestTags>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateAlertRuleRequest() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems : public Darabonba::Model {
public:
  shared_ptr<string> aggregate{};
  shared_ptr<string> metricKey{};
  shared_ptr<double> n{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregate) {
      res["Aggregate"] = boost::any(*aggregate);
    }
    if (metricKey) {
      res["MetricKey"] = boost::any(*metricKey);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregate") != m.end() && !m["Aggregate"].empty()) {
      aggregate = make_shared<string>(boost::any_cast<string>(m["Aggregate"]));
    }
    if (m.find("MetricKey") != m.end() && !m["MetricKey"].empty()) {
      metricKey = make_shared<string>(boost::any_cast<string>(m["MetricKey"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<double>(boost::any_cast<double>(m["N"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems>> alertRuleItems{};
  shared_ptr<string> condition{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRuleItems) {
      vector<boost::any> temp1;
      for(auto item1:*alertRuleItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertRuleItems"] = boost::any(temp1);
    }
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRuleItems") != m.end() && !m["AlertRuleItems"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertRuleItems"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertRuleItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertRuleItems = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems>>(expect1);
      }
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opt{};
  shared_ptr<bool> show{};
  shared_ptr<string> t{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opt) {
      res["Opt"] = boost::any(*opt);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (t) {
      res["T"] = boost::any(*t);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Opt") != m.end() && !m["Opt"].empty()) {
      opt = make_shared<string>(boost::any_cast<string>(m["Opt"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("T") != m.end() && !m["T"].empty()) {
      t = make_shared<string>(boost::any_cast<string>(m["T"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters : public Darabonba::Model {
public:
  shared_ptr<string> filterKey{};
  shared_ptr<string> filterOpt{};
  shared_ptr<vector<string>> filterValues{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterKey) {
      res["FilterKey"] = boost::any(*filterKey);
    }
    if (filterOpt) {
      res["FilterOpt"] = boost::any(*filterOpt);
    }
    if (filterValues) {
      res["FilterValues"] = boost::any(*filterValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterKey") != m.end() && !m["FilterKey"].empty()) {
      filterKey = make_shared<string>(boost::any_cast<string>(m["FilterKey"]));
    }
    if (m.find("FilterOpt") != m.end() && !m["FilterOpt"].empty()) {
      filterOpt = make_shared<string>(boost::any_cast<string>(m["FilterOpt"]));
    }
    if (m.find("FilterValues") != m.end() && !m["FilterValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters>> customSLSFilters{};
  shared_ptr<vector<string>> customSLSGroupByDimensions{};
  shared_ptr<vector<string>> customSLSWheres{};
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters>> dimFilters{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSLSFilters) {
      vector<boost::any> temp1;
      for(auto item1:*customSLSFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSLSFilters"] = boost::any(temp1);
    }
    if (customSLSGroupByDimensions) {
      res["CustomSLSGroupByDimensions"] = boost::any(*customSLSGroupByDimensions);
    }
    if (customSLSWheres) {
      res["CustomSLSWheres"] = boost::any(*customSLSWheres);
    }
    if (dimFilters) {
      vector<boost::any> temp1;
      for(auto item1:*dimFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DimFilters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSLSFilters") != m.end() && !m["CustomSLSFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSLSFilters"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSLSFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSLSFilters = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters>>(expect1);
      }
    }
    if (m.find("CustomSLSGroupByDimensions") != m.end() && !m["CustomSLSGroupByDimensions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomSLSGroupByDimensions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomSLSGroupByDimensions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customSLSGroupByDimensions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomSLSWheres") != m.end() && !m["CustomSLSWheres"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomSLSWheres"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomSLSWheres"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customSLSWheres = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DimFilters") != m.end() && !m["DimFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["DimFilters"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DimFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimFilters = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRuleTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOrUpdateAlertRuleResponseBodyAlertRuleTags() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRuleTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRuleTags() = default;
};
class CreateOrUpdateAlertRuleResponseBodyAlertRule : public Darabonba::Model {
public:
  shared_ptr<string> alertCheckType{};
  shared_ptr<long> alertGroup{};
  shared_ptr<double> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent> alertRuleContent{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> alertType{};
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations>> annotations{};
  shared_ptr<bool> autoAddNewApplication{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> extend{};
  shared_ptr<CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters> filters{};
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels>> labels{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> metricsType{};
  shared_ptr<string> notifyStrategy{};
  shared_ptr<vector<string>> pids{};
  shared_ptr<string> promQL{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleTags>> tags{};
  shared_ptr<long> updatedTime{};
  shared_ptr<string> userId{};

  CreateOrUpdateAlertRuleResponseBodyAlertRule() {}

  explicit CreateOrUpdateAlertRuleResponseBodyAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertCheckType) {
      res["AlertCheckType"] = boost::any(*alertCheckType);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertRuleContent) {
      res["AlertRuleContent"] = alertRuleContent ? boost::any(alertRuleContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (autoAddNewApplication) {
      res["AutoAddNewApplication"] = boost::any(*autoAddNewApplication);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (filters) {
      res["Filters"] = filters ? boost::any(filters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (metricsType) {
      res["MetricsType"] = boost::any(*metricsType);
    }
    if (notifyStrategy) {
      res["NotifyStrategy"] = boost::any(*notifyStrategy);
    }
    if (pids) {
      res["Pids"] = boost::any(*pids);
    }
    if (promQL) {
      res["PromQL"] = boost::any(*promQL);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertCheckType") != m.end() && !m["AlertCheckType"].empty()) {
      alertCheckType = make_shared<string>(boost::any_cast<string>(m["AlertCheckType"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<long>(boost::any_cast<long>(m["AlertGroup"]));
    }
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<double>(boost::any_cast<double>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertRuleContent") != m.end() && !m["AlertRuleContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRuleContent"].type()) {
        CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRuleContent"]));
        alertRuleContent = make_shared<CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent>(model1);
      }
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<string>(boost::any_cast<string>(m["AlertType"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations>>(expect1);
      }
    }
    if (m.find("AutoAddNewApplication") != m.end() && !m["AutoAddNewApplication"].empty()) {
      autoAddNewApplication = make_shared<bool>(boost::any_cast<bool>(m["AutoAddNewApplication"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filters"].type()) {
        CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filters"]));
        filters = make_shared<CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters>(model1);
      }
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels>>(expect1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MetricsType") != m.end() && !m["MetricsType"].empty()) {
      metricsType = make_shared<string>(boost::any_cast<string>(m["MetricsType"]));
    }
    if (m.find("NotifyStrategy") != m.end() && !m["NotifyStrategy"].empty()) {
      notifyStrategy = make_shared<string>(boost::any_cast<string>(m["NotifyStrategy"]));
    }
    if (m.find("Pids") != m.end() && !m["Pids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Pids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Pids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PromQL") != m.end() && !m["PromQL"].empty()) {
      promQL = make_shared<string>(boost::any_cast<string>(m["PromQL"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateAlertRuleResponseBodyAlertRuleTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateOrUpdateAlertRuleResponseBodyAlertRuleTags>>(expect1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBodyAlertRule() = default;
};
class CreateOrUpdateAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateAlertRuleResponseBodyAlertRule> alertRule{};
  shared_ptr<string> requestId{};

  CreateOrUpdateAlertRuleResponseBody() {}

  explicit CreateOrUpdateAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRule) {
      res["AlertRule"] = alertRule ? boost::any(alertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRule") != m.end() && !m["AlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRule"].type()) {
        CreateOrUpdateAlertRuleResponseBodyAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRule"]));
        alertRule = make_shared<CreateOrUpdateAlertRuleResponseBodyAlertRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponseBody() = default;
};
class CreateOrUpdateAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateAlertRuleResponseBody> body{};

  CreateOrUpdateAlertRuleResponse() {}

  explicit CreateOrUpdateAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateAlertRuleResponse() = default;
};
class CreateOrUpdateContactRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> dingRobotUrl{};
  shared_ptr<string> email{};
  shared_ptr<bool> isEmailVerify{};
  shared_ptr<string> phone{};
  shared_ptr<long> reissueSendNotice{};
  shared_ptr<string> resourceGroupId{};

  CreateOrUpdateContactRequest() {}

  explicit CreateOrUpdateContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (dingRobotUrl) {
      res["DingRobotUrl"] = boost::any(*dingRobotUrl);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (isEmailVerify) {
      res["IsEmailVerify"] = boost::any(*isEmailVerify);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (reissueSendNotice) {
      res["ReissueSendNotice"] = boost::any(*reissueSendNotice);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("DingRobotUrl") != m.end() && !m["DingRobotUrl"].empty()) {
      dingRobotUrl = make_shared<string>(boost::any_cast<string>(m["DingRobotUrl"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("IsEmailVerify") != m.end() && !m["IsEmailVerify"].empty()) {
      isEmailVerify = make_shared<bool>(boost::any_cast<bool>(m["IsEmailVerify"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ReissueSendNotice") != m.end() && !m["ReissueSendNotice"].empty()) {
      reissueSendNotice = make_shared<long>(boost::any_cast<long>(m["ReissueSendNotice"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateOrUpdateContactRequest() = default;
};
class CreateOrUpdateContactResponseBodyAlertContact : public Darabonba::Model {
public:
  shared_ptr<double> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> dingRobotUrl{};
  shared_ptr<string> email{};
  shared_ptr<bool> isVerify{};
  shared_ptr<string> phone{};
  shared_ptr<long> reissueSendNotice{};
  shared_ptr<bool> isEmailVerify{};

  CreateOrUpdateContactResponseBodyAlertContact() {}

  explicit CreateOrUpdateContactResponseBodyAlertContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (dingRobotUrl) {
      res["DingRobotUrl"] = boost::any(*dingRobotUrl);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (isVerify) {
      res["IsVerify"] = boost::any(*isVerify);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (reissueSendNotice) {
      res["ReissueSendNotice"] = boost::any(*reissueSendNotice);
    }
    if (isEmailVerify) {
      res["isEmailVerify"] = boost::any(*isEmailVerify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<double>(boost::any_cast<double>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("DingRobotUrl") != m.end() && !m["DingRobotUrl"].empty()) {
      dingRobotUrl = make_shared<string>(boost::any_cast<string>(m["DingRobotUrl"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("IsVerify") != m.end() && !m["IsVerify"].empty()) {
      isVerify = make_shared<bool>(boost::any_cast<bool>(m["IsVerify"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ReissueSendNotice") != m.end() && !m["ReissueSendNotice"].empty()) {
      reissueSendNotice = make_shared<long>(boost::any_cast<long>(m["ReissueSendNotice"]));
    }
    if (m.find("isEmailVerify") != m.end() && !m["isEmailVerify"].empty()) {
      isEmailVerify = make_shared<bool>(boost::any_cast<bool>(m["isEmailVerify"]));
    }
  }


  virtual ~CreateOrUpdateContactResponseBodyAlertContact() = default;
};
class CreateOrUpdateContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateContactResponseBodyAlertContact> alertContact{};
  shared_ptr<string> requestId{};

  CreateOrUpdateContactResponseBody() {}

  explicit CreateOrUpdateContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertContact) {
      res["AlertContact"] = alertContact ? boost::any(alertContact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertContact") != m.end() && !m["AlertContact"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertContact"].type()) {
        CreateOrUpdateContactResponseBodyAlertContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertContact"]));
        alertContact = make_shared<CreateOrUpdateContactResponseBodyAlertContact>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateContactResponseBody() = default;
};
class CreateOrUpdateContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateContactResponseBody> body{};

  CreateOrUpdateContactResponse() {}

  explicit CreateOrUpdateContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateContactResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateContactResponse() = default;
};
class CreateOrUpdateContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactGroupId{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> contactIds{};

  CreateOrUpdateContactGroupRequest() {}

  explicit CreateOrUpdateContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<long>(boost::any_cast<long>(m["ContactGroupId"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
  }


  virtual ~CreateOrUpdateContactGroupRequest() = default;
};
class CreateOrUpdateContactGroupResponseBodyAlertContactGroup : public Darabonba::Model {
public:
  shared_ptr<double> contactGroupId{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> contactIds{};

  CreateOrUpdateContactGroupResponseBodyAlertContactGroup() {}

  explicit CreateOrUpdateContactGroupResponseBodyAlertContactGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<double>(boost::any_cast<double>(m["ContactGroupId"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
  }


  virtual ~CreateOrUpdateContactGroupResponseBodyAlertContactGroup() = default;
};
class CreateOrUpdateContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateContactGroupResponseBodyAlertContactGroup> alertContactGroup{};
  shared_ptr<string> requestId{};

  CreateOrUpdateContactGroupResponseBody() {}

  explicit CreateOrUpdateContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertContactGroup) {
      res["AlertContactGroup"] = alertContactGroup ? boost::any(alertContactGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertContactGroup") != m.end() && !m["AlertContactGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertContactGroup"].type()) {
        CreateOrUpdateContactGroupResponseBodyAlertContactGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertContactGroup"]));
        alertContactGroup = make_shared<CreateOrUpdateContactGroupResponseBodyAlertContactGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateContactGroupResponseBody() = default;
};
class CreateOrUpdateContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateContactGroupResponseBody> body{};

  CreateOrUpdateContactGroupResponse() {}

  explicit CreateOrUpdateContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateContactGroupResponse() = default;
};
class CreateOrUpdateEventBridgeIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> accessSecret{};
  shared_ptr<string> description{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> eventBusName{};
  shared_ptr<string> eventBusRegionId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};

  CreateOrUpdateEventBridgeIntegrationRequest() {}

  explicit CreateOrUpdateEventBridgeIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (accessSecret) {
      res["AccessSecret"] = boost::any(*accessSecret);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (eventBusName) {
      res["EventBusName"] = boost::any(*eventBusName);
    }
    if (eventBusRegionId) {
      res["EventBusRegionId"] = boost::any(*eventBusRegionId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AccessSecret") != m.end() && !m["AccessSecret"].empty()) {
      accessSecret = make_shared<string>(boost::any_cast<string>(m["AccessSecret"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EventBusName") != m.end() && !m["EventBusName"].empty()) {
      eventBusName = make_shared<string>(boost::any_cast<string>(m["EventBusName"]));
    }
    if (m.find("EventBusRegionId") != m.end() && !m["EventBusRegionId"].empty()) {
      eventBusRegionId = make_shared<string>(boost::any_cast<string>(m["EventBusRegionId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~CreateOrUpdateEventBridgeIntegrationRequest() = default;
};
class CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> accessSecret{};
  shared_ptr<string> description{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> eventBusName{};
  shared_ptr<string> eventBusRegionId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};

  CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration() {}

  explicit CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (accessSecret) {
      res["AccessSecret"] = boost::any(*accessSecret);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (eventBusName) {
      res["EventBusName"] = boost::any(*eventBusName);
    }
    if (eventBusRegionId) {
      res["EventBusRegionId"] = boost::any(*eventBusRegionId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AccessSecret") != m.end() && !m["AccessSecret"].empty()) {
      accessSecret = make_shared<string>(boost::any_cast<string>(m["AccessSecret"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EventBusName") != m.end() && !m["EventBusName"].empty()) {
      eventBusName = make_shared<string>(boost::any_cast<string>(m["EventBusName"]));
    }
    if (m.find("EventBusRegionId") != m.end() && !m["EventBusRegionId"].empty()) {
      eventBusRegionId = make_shared<string>(boost::any_cast<string>(m["EventBusRegionId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration() = default;
};
class CreateOrUpdateEventBridgeIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration> eventBridgeIntegration{};
  shared_ptr<string> requestId{};

  CreateOrUpdateEventBridgeIntegrationResponseBody() {}

  explicit CreateOrUpdateEventBridgeIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventBridgeIntegration) {
      res["EventBridgeIntegration"] = eventBridgeIntegration ? boost::any(eventBridgeIntegration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventBridgeIntegration") != m.end() && !m["EventBridgeIntegration"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventBridgeIntegration"].type()) {
        CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventBridgeIntegration"]));
        eventBridgeIntegration = make_shared<CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateEventBridgeIntegrationResponseBody() = default;
};
class CreateOrUpdateEventBridgeIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateEventBridgeIntegrationResponseBody> body{};

  CreateOrUpdateEventBridgeIntegrationResponse() {}

  explicit CreateOrUpdateEventBridgeIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateEventBridgeIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateEventBridgeIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateEventBridgeIntegrationResponse() = default;
};
class CreateOrUpdateIMRobotRequest : public Darabonba::Model {
public:
  shared_ptr<string> cardTemplate{};
  shared_ptr<bool> dailyNoc{};
  shared_ptr<string> dailyNocTime{};
  shared_ptr<string> dingSignKey{};
  shared_ptr<bool> enableOutgoing{};
  shared_ptr<string> robotAddress{};
  shared_ptr<long> robotId{};
  shared_ptr<string> robotName{};
  shared_ptr<string> token{};
  shared_ptr<string> type{};

  CreateOrUpdateIMRobotRequest() {}

  explicit CreateOrUpdateIMRobotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardTemplate) {
      res["CardTemplate"] = boost::any(*cardTemplate);
    }
    if (dailyNoc) {
      res["DailyNoc"] = boost::any(*dailyNoc);
    }
    if (dailyNocTime) {
      res["DailyNocTime"] = boost::any(*dailyNocTime);
    }
    if (dingSignKey) {
      res["DingSignKey"] = boost::any(*dingSignKey);
    }
    if (enableOutgoing) {
      res["EnableOutgoing"] = boost::any(*enableOutgoing);
    }
    if (robotAddress) {
      res["RobotAddress"] = boost::any(*robotAddress);
    }
    if (robotId) {
      res["RobotId"] = boost::any(*robotId);
    }
    if (robotName) {
      res["RobotName"] = boost::any(*robotName);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CardTemplate") != m.end() && !m["CardTemplate"].empty()) {
      cardTemplate = make_shared<string>(boost::any_cast<string>(m["CardTemplate"]));
    }
    if (m.find("DailyNoc") != m.end() && !m["DailyNoc"].empty()) {
      dailyNoc = make_shared<bool>(boost::any_cast<bool>(m["DailyNoc"]));
    }
    if (m.find("DailyNocTime") != m.end() && !m["DailyNocTime"].empty()) {
      dailyNocTime = make_shared<string>(boost::any_cast<string>(m["DailyNocTime"]));
    }
    if (m.find("DingSignKey") != m.end() && !m["DingSignKey"].empty()) {
      dingSignKey = make_shared<string>(boost::any_cast<string>(m["DingSignKey"]));
    }
    if (m.find("EnableOutgoing") != m.end() && !m["EnableOutgoing"].empty()) {
      enableOutgoing = make_shared<bool>(boost::any_cast<bool>(m["EnableOutgoing"]));
    }
    if (m.find("RobotAddress") != m.end() && !m["RobotAddress"].empty()) {
      robotAddress = make_shared<string>(boost::any_cast<string>(m["RobotAddress"]));
    }
    if (m.find("RobotId") != m.end() && !m["RobotId"].empty()) {
      robotId = make_shared<long>(boost::any_cast<long>(m["RobotId"]));
    }
    if (m.find("RobotName") != m.end() && !m["RobotName"].empty()) {
      robotName = make_shared<string>(boost::any_cast<string>(m["RobotName"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateOrUpdateIMRobotRequest() = default;
};
class CreateOrUpdateIMRobotResponseBodyAlertRobot : public Darabonba::Model {
public:
  shared_ptr<string> cardTemplate{};
  shared_ptr<bool> dailyNoc{};
  shared_ptr<string> dailyNocTime{};
  shared_ptr<bool> enableOutgoing{};
  shared_ptr<string> robotAddress{};
  shared_ptr<double> robotId{};
  shared_ptr<string> robotName{};
  shared_ptr<string> token{};
  shared_ptr<string> type{};

  CreateOrUpdateIMRobotResponseBodyAlertRobot() {}

  explicit CreateOrUpdateIMRobotResponseBodyAlertRobot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardTemplate) {
      res["CardTemplate"] = boost::any(*cardTemplate);
    }
    if (dailyNoc) {
      res["DailyNoc"] = boost::any(*dailyNoc);
    }
    if (dailyNocTime) {
      res["DailyNocTime"] = boost::any(*dailyNocTime);
    }
    if (enableOutgoing) {
      res["EnableOutgoing"] = boost::any(*enableOutgoing);
    }
    if (robotAddress) {
      res["RobotAddress"] = boost::any(*robotAddress);
    }
    if (robotId) {
      res["RobotId"] = boost::any(*robotId);
    }
    if (robotName) {
      res["RobotName"] = boost::any(*robotName);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CardTemplate") != m.end() && !m["CardTemplate"].empty()) {
      cardTemplate = make_shared<string>(boost::any_cast<string>(m["CardTemplate"]));
    }
    if (m.find("DailyNoc") != m.end() && !m["DailyNoc"].empty()) {
      dailyNoc = make_shared<bool>(boost::any_cast<bool>(m["DailyNoc"]));
    }
    if (m.find("DailyNocTime") != m.end() && !m["DailyNocTime"].empty()) {
      dailyNocTime = make_shared<string>(boost::any_cast<string>(m["DailyNocTime"]));
    }
    if (m.find("EnableOutgoing") != m.end() && !m["EnableOutgoing"].empty()) {
      enableOutgoing = make_shared<bool>(boost::any_cast<bool>(m["EnableOutgoing"]));
    }
    if (m.find("RobotAddress") != m.end() && !m["RobotAddress"].empty()) {
      robotAddress = make_shared<string>(boost::any_cast<string>(m["RobotAddress"]));
    }
    if (m.find("RobotId") != m.end() && !m["RobotId"].empty()) {
      robotId = make_shared<double>(boost::any_cast<double>(m["RobotId"]));
    }
    if (m.find("RobotName") != m.end() && !m["RobotName"].empty()) {
      robotName = make_shared<string>(boost::any_cast<string>(m["RobotName"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateOrUpdateIMRobotResponseBodyAlertRobot() = default;
};
class CreateOrUpdateIMRobotResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateIMRobotResponseBodyAlertRobot> alertRobot{};
  shared_ptr<string> requestId{};

  CreateOrUpdateIMRobotResponseBody() {}

  explicit CreateOrUpdateIMRobotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRobot) {
      res["AlertRobot"] = alertRobot ? boost::any(alertRobot->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRobot") != m.end() && !m["AlertRobot"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRobot"].type()) {
        CreateOrUpdateIMRobotResponseBodyAlertRobot model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRobot"]));
        alertRobot = make_shared<CreateOrUpdateIMRobotResponseBodyAlertRobot>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateIMRobotResponseBody() = default;
};
class CreateOrUpdateIMRobotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateIMRobotResponseBody> body{};

  CreateOrUpdateIMRobotResponse() {}

  explicit CreateOrUpdateIMRobotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateIMRobotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateIMRobotResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateIMRobotResponse() = default;
};
class CreateOrUpdateNotificationPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> escalationPolicyId{};
  shared_ptr<string> groupRule{};
  shared_ptr<long> id{};
  shared_ptr<long> integrationId{};
  shared_ptr<string> matchingRules{};
  shared_ptr<string> name{};
  shared_ptr<string> notifyRule{};
  shared_ptr<string> notifyTemplate{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> repeat{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<bool> sendRecoverMessage{};

  CreateOrUpdateNotificationPolicyRequest() {}

  explicit CreateOrUpdateNotificationPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPolicyId) {
      res["EscalationPolicyId"] = boost::any(*escalationPolicyId);
    }
    if (groupRule) {
      res["GroupRule"] = boost::any(*groupRule);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (matchingRules) {
      res["MatchingRules"] = boost::any(*matchingRules);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyRule) {
      res["NotifyRule"] = boost::any(*notifyRule);
    }
    if (notifyTemplate) {
      res["NotifyTemplate"] = boost::any(*notifyTemplate);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeat) {
      res["Repeat"] = boost::any(*repeat);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (sendRecoverMessage) {
      res["SendRecoverMessage"] = boost::any(*sendRecoverMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EscalationPolicyId") != m.end() && !m["EscalationPolicyId"].empty()) {
      escalationPolicyId = make_shared<long>(boost::any_cast<long>(m["EscalationPolicyId"]));
    }
    if (m.find("GroupRule") != m.end() && !m["GroupRule"].empty()) {
      groupRule = make_shared<string>(boost::any_cast<string>(m["GroupRule"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      matchingRules = make_shared<string>(boost::any_cast<string>(m["MatchingRules"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyRule") != m.end() && !m["NotifyRule"].empty()) {
      notifyRule = make_shared<string>(boost::any_cast<string>(m["NotifyRule"]));
    }
    if (m.find("NotifyTemplate") != m.end() && !m["NotifyTemplate"].empty()) {
      notifyTemplate = make_shared<string>(boost::any_cast<string>(m["NotifyTemplate"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Repeat") != m.end() && !m["Repeat"].empty()) {
      repeat = make_shared<bool>(boost::any_cast<bool>(m["Repeat"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("SendRecoverMessage") != m.end() && !m["SendRecoverMessage"].empty()) {
      sendRecoverMessage = make_shared<bool>(boost::any_cast<bool>(m["SendRecoverMessage"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyRequest() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule : public Darabonba::Model {
public:
  shared_ptr<long> groupInterval{};
  shared_ptr<long> groupWait{};
  shared_ptr<vector<string>> groupingFields{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInterval) {
      res["GroupInterval"] = boost::any(*groupInterval);
    }
    if (groupWait) {
      res["GroupWait"] = boost::any(*groupWait);
    }
    if (groupingFields) {
      res["GroupingFields"] = boost::any(*groupingFields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInterval") != m.end() && !m["GroupInterval"].empty()) {
      groupInterval = make_shared<long>(boost::any_cast<long>(m["GroupInterval"]));
    }
    if (m.find("GroupWait") != m.end() && !m["GroupWait"].empty()) {
      groupWait = make_shared<long>(boost::any_cast<long>(m["GroupWait"]));
    }
    if (m.find("GroupingFields") != m.end() && !m["GroupingFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupingFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupingFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupingFields = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions>> matchingConditions{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchingConditions) {
      vector<boost::any> temp1;
      for(auto item1:*matchingConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchingConditions") != m.end() && !m["MatchingConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingConditions"].type()) {
        vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingConditions = make_shared<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<long> notifyObjectId{};
  shared_ptr<string> notifyObjectName{};
  shared_ptr<string> notifyObjectType{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyChannels) {
      res["NotifyChannels"] = boost::any(*notifyChannels);
    }
    if (notifyObjectId) {
      res["NotifyObjectId"] = boost::any(*notifyObjectId);
    }
    if (notifyObjectName) {
      res["NotifyObjectName"] = boost::any(*notifyObjectName);
    }
    if (notifyObjectType) {
      res["NotifyObjectType"] = boost::any(*notifyObjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyChannels") != m.end() && !m["NotifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyObjectId") != m.end() && !m["NotifyObjectId"].empty()) {
      notifyObjectId = make_shared<long>(boost::any_cast<long>(m["NotifyObjectId"]));
    }
    if (m.find("NotifyObjectName") != m.end() && !m["NotifyObjectName"].empty()) {
      notifyObjectName = make_shared<string>(boost::any_cast<string>(m["NotifyObjectName"]));
    }
    if (m.find("NotifyObjectType") != m.end() && !m["NotifyObjectType"].empty()) {
      notifyObjectType = make_shared<string>(boost::any_cast<string>(m["NotifyObjectType"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<string> notifyEndTime{};
  shared_ptr<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects>> notifyObjects{};
  shared_ptr<string> notifyStartTime{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyChannels) {
      res["NotifyChannels"] = boost::any(*notifyChannels);
    }
    if (notifyEndTime) {
      res["NotifyEndTime"] = boost::any(*notifyEndTime);
    }
    if (notifyObjects) {
      vector<boost::any> temp1;
      for(auto item1:*notifyObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotifyObjects"] = boost::any(temp1);
    }
    if (notifyStartTime) {
      res["NotifyStartTime"] = boost::any(*notifyStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyChannels") != m.end() && !m["NotifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyEndTime") != m.end() && !m["NotifyEndTime"].empty()) {
      notifyEndTime = make_shared<string>(boost::any_cast<string>(m["NotifyEndTime"]));
    }
    if (m.find("NotifyObjects") != m.end() && !m["NotifyObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["NotifyObjects"].type()) {
        vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotifyObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyObjects = make_shared<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects>>(expect1);
      }
    }
    if (m.find("NotifyStartTime") != m.end() && !m["NotifyStartTime"].empty()) {
      notifyStartTime = make_shared<string>(boost::any_cast<string>(m["NotifyStartTime"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> emailContent{};
  shared_ptr<string> emailRecoverContent{};
  shared_ptr<string> emailRecoverTitle{};
  shared_ptr<string> emailTitle{};
  shared_ptr<string> robotContent{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> smsRecoverContent{};
  shared_ptr<string> ttsContent{};
  shared_ptr<string> ttsRecoverContent{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emailContent) {
      res["EmailContent"] = boost::any(*emailContent);
    }
    if (emailRecoverContent) {
      res["EmailRecoverContent"] = boost::any(*emailRecoverContent);
    }
    if (emailRecoverTitle) {
      res["EmailRecoverTitle"] = boost::any(*emailRecoverTitle);
    }
    if (emailTitle) {
      res["EmailTitle"] = boost::any(*emailTitle);
    }
    if (robotContent) {
      res["RobotContent"] = boost::any(*robotContent);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (smsRecoverContent) {
      res["SmsRecoverContent"] = boost::any(*smsRecoverContent);
    }
    if (ttsContent) {
      res["TtsContent"] = boost::any(*ttsContent);
    }
    if (ttsRecoverContent) {
      res["TtsRecoverContent"] = boost::any(*ttsRecoverContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmailContent") != m.end() && !m["EmailContent"].empty()) {
      emailContent = make_shared<string>(boost::any_cast<string>(m["EmailContent"]));
    }
    if (m.find("EmailRecoverContent") != m.end() && !m["EmailRecoverContent"].empty()) {
      emailRecoverContent = make_shared<string>(boost::any_cast<string>(m["EmailRecoverContent"]));
    }
    if (m.find("EmailRecoverTitle") != m.end() && !m["EmailRecoverTitle"].empty()) {
      emailRecoverTitle = make_shared<string>(boost::any_cast<string>(m["EmailRecoverTitle"]));
    }
    if (m.find("EmailTitle") != m.end() && !m["EmailTitle"].empty()) {
      emailTitle = make_shared<string>(boost::any_cast<string>(m["EmailTitle"]));
    }
    if (m.find("RobotContent") != m.end() && !m["RobotContent"].empty()) {
      robotContent = make_shared<string>(boost::any_cast<string>(m["RobotContent"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SmsRecoverContent") != m.end() && !m["SmsRecoverContent"].empty()) {
      smsRecoverContent = make_shared<string>(boost::any_cast<string>(m["SmsRecoverContent"]));
    }
    if (m.find("TtsContent") != m.end() && !m["TtsContent"].empty()) {
      ttsContent = make_shared<string>(boost::any_cast<string>(m["TtsContent"]));
    }
    if (m.find("TtsRecoverContent") != m.end() && !m["TtsRecoverContent"].empty()) {
      ttsRecoverContent = make_shared<string>(boost::any_cast<string>(m["TtsRecoverContent"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate() = default;
};
class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy : public Darabonba::Model {
public:
  shared_ptr<long> escalationPolicyId{};
  shared_ptr<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule> groupRule{};
  shared_ptr<long> id{};
  shared_ptr<long> integrationId{};
  shared_ptr<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules>> matchingRules{};
  shared_ptr<string> name{};
  shared_ptr<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule> notifyRule{};
  shared_ptr<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate> notifyTemplate{};
  shared_ptr<bool> repeat{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<bool> sendRecoverMessage{};

  CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy() {}

  explicit CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPolicyId) {
      res["EscalationPolicyId"] = boost::any(*escalationPolicyId);
    }
    if (groupRule) {
      res["GroupRule"] = groupRule ? boost::any(groupRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (matchingRules) {
      vector<boost::any> temp1;
      for(auto item1:*matchingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingRules"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyRule) {
      res["NotifyRule"] = notifyRule ? boost::any(notifyRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyTemplate) {
      res["NotifyTemplate"] = notifyTemplate ? boost::any(notifyTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (repeat) {
      res["Repeat"] = boost::any(*repeat);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (sendRecoverMessage) {
      res["SendRecoverMessage"] = boost::any(*sendRecoverMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EscalationPolicyId") != m.end() && !m["EscalationPolicyId"].empty()) {
      escalationPolicyId = make_shared<long>(boost::any_cast<long>(m["EscalationPolicyId"]));
    }
    if (m.find("GroupRule") != m.end() && !m["GroupRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupRule"].type()) {
        CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupRule"]));
        groupRule = make_shared<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingRules"].type()) {
        vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingRules = make_shared<vector<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyRule") != m.end() && !m["NotifyRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyRule"].type()) {
        CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyRule"]));
        notifyRule = make_shared<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule>(model1);
      }
    }
    if (m.find("NotifyTemplate") != m.end() && !m["NotifyTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyTemplate"].type()) {
        CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyTemplate"]));
        notifyTemplate = make_shared<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate>(model1);
      }
    }
    if (m.find("Repeat") != m.end() && !m["Repeat"].empty()) {
      repeat = make_shared<bool>(boost::any_cast<bool>(m["Repeat"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("SendRecoverMessage") != m.end() && !m["SendRecoverMessage"].empty()) {
      sendRecoverMessage = make_shared<bool>(boost::any_cast<bool>(m["SendRecoverMessage"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy() = default;
};
class CreateOrUpdateNotificationPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy> notificationPolicy{};
  shared_ptr<string> requestId{};

  CreateOrUpdateNotificationPolicyResponseBody() {}

  explicit CreateOrUpdateNotificationPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationPolicy) {
      res["NotificationPolicy"] = notificationPolicy ? boost::any(notificationPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationPolicy") != m.end() && !m["NotificationPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotificationPolicy"].type()) {
        CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotificationPolicy"]));
        notificationPolicy = make_shared<CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponseBody() = default;
};
class CreateOrUpdateNotificationPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateNotificationPolicyResponseBody> body{};

  CreateOrUpdateNotificationPolicyResponse() {}

  explicit CreateOrUpdateNotificationPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateNotificationPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateNotificationPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateNotificationPolicyResponse() = default;
};
class CreateOrUpdateSilencePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> matchingRules{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  CreateOrUpdateSilencePolicyRequest() {}

  explicit CreateOrUpdateSilencePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchingRules) {
      res["MatchingRules"] = boost::any(*matchingRules);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      matchingRules = make_shared<string>(boost::any_cast<string>(m["MatchingRules"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateOrUpdateSilencePolicyRequest() = default;
};
class CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions() {}

  explicit CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions() = default;
};
class CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions>> matchingConditions{};

  CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules() {}

  explicit CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchingConditions) {
      vector<boost::any> temp1;
      for(auto item1:*matchingConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchingConditions") != m.end() && !m["MatchingConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingConditions"].type()) {
        vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingConditions = make_shared<vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules() = default;
};
class CreateOrUpdateSilencePolicyResponseBodySilencePolicy : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules>> matchingRules{};
  shared_ptr<string> name{};

  CreateOrUpdateSilencePolicyResponseBodySilencePolicy() {}

  explicit CreateOrUpdateSilencePolicyResponseBodySilencePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchingRules) {
      vector<boost::any> temp1;
      for(auto item1:*matchingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingRules"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingRules"].type()) {
        vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingRules = make_shared<vector<CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateOrUpdateSilencePolicyResponseBodySilencePolicy() = default;
};
class CreateOrUpdateSilencePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateOrUpdateSilencePolicyResponseBodySilencePolicy> silencePolicy{};

  CreateOrUpdateSilencePolicyResponseBody() {}

  explicit CreateOrUpdateSilencePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (silencePolicy) {
      res["SilencePolicy"] = silencePolicy ? boost::any(silencePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SilencePolicy") != m.end() && !m["SilencePolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["SilencePolicy"].type()) {
        CreateOrUpdateSilencePolicyResponseBodySilencePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SilencePolicy"]));
        silencePolicy = make_shared<CreateOrUpdateSilencePolicyResponseBodySilencePolicy>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateSilencePolicyResponseBody() = default;
};
class CreateOrUpdateSilencePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateSilencePolicyResponseBody> body{};

  CreateOrUpdateSilencePolicyResponse() {}

  explicit CreateOrUpdateSilencePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateSilencePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateSilencePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateSilencePolicyResponse() = default;
};
class CreateOrUpdateWebhookContactRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizHeaders{};
  shared_ptr<string> bizParams{};
  shared_ptr<string> body{};
  shared_ptr<string> method{};
  shared_ptr<string> recoverBody{};
  shared_ptr<string> url{};
  shared_ptr<long> webhookId{};
  shared_ptr<string> webhookName{};

  CreateOrUpdateWebhookContactRequest() {}

  explicit CreateOrUpdateWebhookContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizHeaders) {
      res["BizHeaders"] = boost::any(*bizHeaders);
    }
    if (bizParams) {
      res["BizParams"] = boost::any(*bizParams);
    }
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (recoverBody) {
      res["RecoverBody"] = boost::any(*recoverBody);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (webhookId) {
      res["WebhookId"] = boost::any(*webhookId);
    }
    if (webhookName) {
      res["WebhookName"] = boost::any(*webhookName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizHeaders") != m.end() && !m["BizHeaders"].empty()) {
      bizHeaders = make_shared<string>(boost::any_cast<string>(m["BizHeaders"]));
    }
    if (m.find("BizParams") != m.end() && !m["BizParams"].empty()) {
      bizParams = make_shared<string>(boost::any_cast<string>(m["BizParams"]));
    }
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("RecoverBody") != m.end() && !m["RecoverBody"].empty()) {
      recoverBody = make_shared<string>(boost::any_cast<string>(m["RecoverBody"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WebhookId") != m.end() && !m["WebhookId"].empty()) {
      webhookId = make_shared<long>(boost::any_cast<long>(m["WebhookId"]));
    }
    if (m.find("WebhookName") != m.end() && !m["WebhookName"].empty()) {
      webhookName = make_shared<string>(boost::any_cast<string>(m["WebhookName"]));
    }
  }


  virtual ~CreateOrUpdateWebhookContactRequest() = default;
};
class CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook : public Darabonba::Model {
public:
  shared_ptr<string> bizHeaders{};
  shared_ptr<string> bizParams{};
  shared_ptr<string> body{};
  shared_ptr<string> method{};
  shared_ptr<string> recoverBody{};
  shared_ptr<string> url{};

  CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook() {}

  explicit CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizHeaders) {
      res["BizHeaders"] = boost::any(*bizHeaders);
    }
    if (bizParams) {
      res["BizParams"] = boost::any(*bizParams);
    }
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (recoverBody) {
      res["RecoverBody"] = boost::any(*recoverBody);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizHeaders") != m.end() && !m["BizHeaders"].empty()) {
      bizHeaders = make_shared<string>(boost::any_cast<string>(m["BizHeaders"]));
    }
    if (m.find("BizParams") != m.end() && !m["BizParams"].empty()) {
      bizParams = make_shared<string>(boost::any_cast<string>(m["BizParams"]));
    }
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("RecoverBody") != m.end() && !m["RecoverBody"].empty()) {
      recoverBody = make_shared<string>(boost::any_cast<string>(m["RecoverBody"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook() = default;
};
class CreateOrUpdateWebhookContactResponseBodyWebhookContact : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook> webhook{};
  shared_ptr<double> webhookId{};
  shared_ptr<string> webhookName{};

  CreateOrUpdateWebhookContactResponseBodyWebhookContact() {}

  explicit CreateOrUpdateWebhookContactResponseBodyWebhookContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webhook) {
      res["Webhook"] = webhook ? boost::any(webhook->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webhookId) {
      res["WebhookId"] = boost::any(*webhookId);
    }
    if (webhookName) {
      res["WebhookName"] = boost::any(*webhookName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webhook"].type()) {
        CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webhook"]));
        webhook = make_shared<CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook>(model1);
      }
    }
    if (m.find("WebhookId") != m.end() && !m["WebhookId"].empty()) {
      webhookId = make_shared<double>(boost::any_cast<double>(m["WebhookId"]));
    }
    if (m.find("WebhookName") != m.end() && !m["WebhookName"].empty()) {
      webhookName = make_shared<string>(boost::any_cast<string>(m["WebhookName"]));
    }
  }


  virtual ~CreateOrUpdateWebhookContactResponseBodyWebhookContact() = default;
};
class CreateOrUpdateWebhookContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateOrUpdateWebhookContactResponseBodyWebhookContact> webhookContact{};

  CreateOrUpdateWebhookContactResponseBody() {}

  explicit CreateOrUpdateWebhookContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (webhookContact) {
      res["WebhookContact"] = webhookContact ? boost::any(webhookContact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WebhookContact") != m.end() && !m["WebhookContact"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebhookContact"].type()) {
        CreateOrUpdateWebhookContactResponseBodyWebhookContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebhookContact"]));
        webhookContact = make_shared<CreateOrUpdateWebhookContactResponseBodyWebhookContact>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateWebhookContactResponseBody() = default;
};
class CreateOrUpdateWebhookContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateWebhookContactResponseBody> body{};

  CreateOrUpdateWebhookContactResponse() {}

  explicit CreateOrUpdateWebhookContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateWebhookContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateWebhookContactResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateWebhookContactResponse() = default;
};
class CreatePrometheusAlertRuleRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreatePrometheusAlertRuleRequestTags() {}

  explicit CreatePrometheusAlertRuleRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleRequestTags() = default;
};
class CreatePrometheusAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<string> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<string> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreatePrometheusAlertRuleRequestTags>> tags{};
  shared_ptr<string> type{};

  CreatePrometheusAlertRuleRequest() {}

  explicit CreatePrometheusAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreatePrometheusAlertRuleRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePrometheusAlertRuleRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreatePrometheusAlertRuleRequestTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleRequest() = default;
};
class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() {}

  explicit CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() = default;
};
class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() {}

  explicit CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() = default;
};
class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule() {}

  explicit CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>>(expect1);
      }
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule() = default;
};
class CreatePrometheusAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule> prometheusAlertRule{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreatePrometheusAlertRuleResponseBody() {}

  explicit CreatePrometheusAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (prometheusAlertRule) {
      res["PrometheusAlertRule"] = prometheusAlertRule ? boost::any(prometheusAlertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PrometheusAlertRule") != m.end() && !m["PrometheusAlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrometheusAlertRule"].type()) {
        CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrometheusAlertRule"]));
        prometheusAlertRule = make_shared<CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreatePrometheusAlertRuleResponseBody() = default;
};
class CreatePrometheusAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePrometheusAlertRuleResponseBody> body{};

  CreatePrometheusAlertRuleResponse() {}

  explicit CreatePrometheusAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePrometheusAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePrometheusAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePrometheusAlertRuleResponse() = default;
};
class CreatePrometheusInstanceRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreatePrometheusInstanceRequestTags() {}

  explicit CreatePrometheusInstanceRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePrometheusInstanceRequestTags() = default;
};
class CreatePrometheusInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allSubClustersSuccess{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> grafanaInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> subClustersJson{};
  shared_ptr<vector<CreatePrometheusInstanceRequestTags>> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  CreatePrometheusInstanceRequest() {}

  explicit CreatePrometheusInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allSubClustersSuccess) {
      res["AllSubClustersSuccess"] = boost::any(*allSubClustersSuccess);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (grafanaInstanceId) {
      res["GrafanaInstanceId"] = boost::any(*grafanaInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (subClustersJson) {
      res["SubClustersJson"] = boost::any(*subClustersJson);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllSubClustersSuccess") != m.end() && !m["AllSubClustersSuccess"].empty()) {
      allSubClustersSuccess = make_shared<bool>(boost::any_cast<bool>(m["AllSubClustersSuccess"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("GrafanaInstanceId") != m.end() && !m["GrafanaInstanceId"].empty()) {
      grafanaInstanceId = make_shared<string>(boost::any_cast<string>(m["GrafanaInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SubClustersJson") != m.end() && !m["SubClustersJson"].empty()) {
      subClustersJson = make_shared<string>(boost::any_cast<string>(m["SubClustersJson"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreatePrometheusInstanceRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePrometheusInstanceRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreatePrometheusInstanceRequestTags>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreatePrometheusInstanceRequest() = default;
};
class CreatePrometheusInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreatePrometheusInstanceResponseBody() {}

  explicit CreatePrometheusInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePrometheusInstanceResponseBody() = default;
};
class CreatePrometheusInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePrometheusInstanceResponseBody> body{};

  CreatePrometheusInstanceResponse() {}

  explicit CreatePrometheusInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePrometheusInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePrometheusInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePrometheusInstanceResponse() = default;
};
class CreatePrometheusMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  CreatePrometheusMonitoringRequest() {}

  explicit CreatePrometheusMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreatePrometheusMonitoringRequest() = default;
};
class CreatePrometheusMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreatePrometheusMonitoringResponseBody() {}

  explicit CreatePrometheusMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePrometheusMonitoringResponseBody() = default;
};
class CreatePrometheusMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePrometheusMonitoringResponseBody> body{};

  CreatePrometheusMonitoringResponse() {}

  explicit CreatePrometheusMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePrometheusMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePrometheusMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePrometheusMonitoringResponse() = default;
};
class CreateRetcodeAppRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateRetcodeAppRequestTags() {}

  explicit CreateRetcodeAppRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateRetcodeAppRequestTags() = default;
};
class CreateRetcodeAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> retcodeAppName{};
  shared_ptr<string> retcodeAppType{};
  shared_ptr<vector<CreateRetcodeAppRequestTags>> tags{};

  CreateRetcodeAppRequest() {}

  explicit CreateRetcodeAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retcodeAppName) {
      res["RetcodeAppName"] = boost::any(*retcodeAppName);
    }
    if (retcodeAppType) {
      res["RetcodeAppType"] = boost::any(*retcodeAppType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetcodeAppName") != m.end() && !m["RetcodeAppName"].empty()) {
      retcodeAppName = make_shared<string>(boost::any_cast<string>(m["RetcodeAppName"]));
    }
    if (m.find("RetcodeAppType") != m.end() && !m["RetcodeAppType"].empty()) {
      retcodeAppType = make_shared<string>(boost::any_cast<string>(m["RetcodeAppType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateRetcodeAppRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRetcodeAppRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateRetcodeAppRequestTags>>(expect1);
      }
    }
  }


  virtual ~CreateRetcodeAppRequest() = default;
};
class CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags() {}

  explicit CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags() = default;
};
class CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags : public Darabonba::Model {
public:
  shared_ptr<vector<CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags>> tags{};

  CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags() {}

  explicit CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags>>(expect1);
      }
    }
  }


  virtual ~CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags() = default;
};
class CreateRetcodeAppResponseBodyRetcodeAppDataBean : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> pid{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags> tags{};

  CreateRetcodeAppResponseBodyRetcodeAppDataBean() {}

  explicit CreateRetcodeAppResponseBodyRetcodeAppDataBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags>(model1);
      }
    }
  }


  virtual ~CreateRetcodeAppResponseBodyRetcodeAppDataBean() = default;
};
class CreateRetcodeAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateRetcodeAppResponseBodyRetcodeAppDataBean> retcodeAppDataBean{};
  shared_ptr<bool> success{};

  CreateRetcodeAppResponseBody() {}

  explicit CreateRetcodeAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retcodeAppDataBean) {
      res["RetcodeAppDataBean"] = retcodeAppDataBean ? boost::any(retcodeAppDataBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetcodeAppDataBean") != m.end() && !m["RetcodeAppDataBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetcodeAppDataBean"].type()) {
        CreateRetcodeAppResponseBodyRetcodeAppDataBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetcodeAppDataBean"]));
        retcodeAppDataBean = make_shared<CreateRetcodeAppResponseBodyRetcodeAppDataBean>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateRetcodeAppResponseBody() = default;
};
class CreateRetcodeAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRetcodeAppResponseBody> body{};

  CreateRetcodeAppResponse() {}

  explicit CreateRetcodeAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRetcodeAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRetcodeAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRetcodeAppResponse() = default;
};
class CreateSyntheticTaskRequestCommonParamAlertList : public Darabonba::Model {
public:
  shared_ptr<long> isCritical{};
  shared_ptr<string> name{};
  shared_ptr<long> symbols{};

  CreateSyntheticTaskRequestCommonParamAlertList() {}

  explicit CreateSyntheticTaskRequestCommonParamAlertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isCritical) {
      res["IsCritical"] = boost::any(*isCritical);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (symbols) {
      res["Symbols"] = boost::any(*symbols);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsCritical") != m.end() && !m["IsCritical"].empty()) {
      isCritical = make_shared<long>(boost::any_cast<long>(m["IsCritical"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Symbols") != m.end() && !m["Symbols"].empty()) {
      symbols = make_shared<long>(boost::any_cast<long>(m["Symbols"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestCommonParamAlertList() = default;
};
class CreateSyntheticTaskRequestCommonParam : public Darabonba::Model {
public:
  shared_ptr<string> alarmFlag{};
  shared_ptr<vector<CreateSyntheticTaskRequestCommonParamAlertList>> alertList{};
  shared_ptr<string> alertNotifierId{};
  shared_ptr<string> alertPolicyId{};
  shared_ptr<long> monitorSamples{};
  shared_ptr<long> startExecutionTime{};

  CreateSyntheticTaskRequestCommonParam() {}

  explicit CreateSyntheticTaskRequestCommonParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmFlag) {
      res["AlarmFlag"] = boost::any(*alarmFlag);
    }
    if (alertList) {
      vector<boost::any> temp1;
      for(auto item1:*alertList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertList"] = boost::any(temp1);
    }
    if (alertNotifierId) {
      res["AlertNotifierId"] = boost::any(*alertNotifierId);
    }
    if (alertPolicyId) {
      res["AlertPolicyId"] = boost::any(*alertPolicyId);
    }
    if (monitorSamples) {
      res["MonitorSamples"] = boost::any(*monitorSamples);
    }
    if (startExecutionTime) {
      res["StartExecutionTime"] = boost::any(*startExecutionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmFlag") != m.end() && !m["AlarmFlag"].empty()) {
      alarmFlag = make_shared<string>(boost::any_cast<string>(m["AlarmFlag"]));
    }
    if (m.find("AlertList") != m.end() && !m["AlertList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertList"].type()) {
        vector<CreateSyntheticTaskRequestCommonParamAlertList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSyntheticTaskRequestCommonParamAlertList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertList = make_shared<vector<CreateSyntheticTaskRequestCommonParamAlertList>>(expect1);
      }
    }
    if (m.find("AlertNotifierId") != m.end() && !m["AlertNotifierId"].empty()) {
      alertNotifierId = make_shared<string>(boost::any_cast<string>(m["AlertNotifierId"]));
    }
    if (m.find("AlertPolicyId") != m.end() && !m["AlertPolicyId"].empty()) {
      alertPolicyId = make_shared<string>(boost::any_cast<string>(m["AlertPolicyId"]));
    }
    if (m.find("MonitorSamples") != m.end() && !m["MonitorSamples"].empty()) {
      monitorSamples = make_shared<long>(boost::any_cast<long>(m["MonitorSamples"]));
    }
    if (m.find("StartExecutionTime") != m.end() && !m["StartExecutionTime"].empty()) {
      startExecutionTime = make_shared<long>(boost::any_cast<long>(m["StartExecutionTime"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestCommonParam() = default;
};
class CreateSyntheticTaskRequestDownload : public Darabonba::Model {
public:
  shared_ptr<double> connectionTimeout{};
  shared_ptr<string> downloadCustomHeaderContent{};
  shared_ptr<long> downloadCustomHost{};
  shared_ptr<string> downloadCustomHostIp{};
  shared_ptr<string> downloadIgnoreCertificateError{};
  shared_ptr<long> downloadKernel{};
  shared_ptr<long> downloadRedirection{};
  shared_ptr<long> downloadTransmissionSize{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<string> quickProtocol{};
  shared_ptr<string> validateKeywords{};
  shared_ptr<long> verifyWay{};
  shared_ptr<string> whiteList{};

  CreateSyntheticTaskRequestDownload() {}

  explicit CreateSyntheticTaskRequestDownload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionTimeout) {
      res["ConnectionTimeout"] = boost::any(*connectionTimeout);
    }
    if (downloadCustomHeaderContent) {
      res["DownloadCustomHeaderContent"] = boost::any(*downloadCustomHeaderContent);
    }
    if (downloadCustomHost) {
      res["DownloadCustomHost"] = boost::any(*downloadCustomHost);
    }
    if (downloadCustomHostIp) {
      res["DownloadCustomHostIp"] = boost::any(*downloadCustomHostIp);
    }
    if (downloadIgnoreCertificateError) {
      res["DownloadIgnoreCertificateError"] = boost::any(*downloadIgnoreCertificateError);
    }
    if (downloadKernel) {
      res["DownloadKernel"] = boost::any(*downloadKernel);
    }
    if (downloadRedirection) {
      res["DownloadRedirection"] = boost::any(*downloadRedirection);
    }
    if (downloadTransmissionSize) {
      res["DownloadTransmissionSize"] = boost::any(*downloadTransmissionSize);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (quickProtocol) {
      res["QuickProtocol"] = boost::any(*quickProtocol);
    }
    if (validateKeywords) {
      res["ValidateKeywords"] = boost::any(*validateKeywords);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionTimeout") != m.end() && !m["ConnectionTimeout"].empty()) {
      connectionTimeout = make_shared<double>(boost::any_cast<double>(m["ConnectionTimeout"]));
    }
    if (m.find("DownloadCustomHeaderContent") != m.end() && !m["DownloadCustomHeaderContent"].empty()) {
      downloadCustomHeaderContent = make_shared<string>(boost::any_cast<string>(m["DownloadCustomHeaderContent"]));
    }
    if (m.find("DownloadCustomHost") != m.end() && !m["DownloadCustomHost"].empty()) {
      downloadCustomHost = make_shared<long>(boost::any_cast<long>(m["DownloadCustomHost"]));
    }
    if (m.find("DownloadCustomHostIp") != m.end() && !m["DownloadCustomHostIp"].empty()) {
      downloadCustomHostIp = make_shared<string>(boost::any_cast<string>(m["DownloadCustomHostIp"]));
    }
    if (m.find("DownloadIgnoreCertificateError") != m.end() && !m["DownloadIgnoreCertificateError"].empty()) {
      downloadIgnoreCertificateError = make_shared<string>(boost::any_cast<string>(m["DownloadIgnoreCertificateError"]));
    }
    if (m.find("DownloadKernel") != m.end() && !m["DownloadKernel"].empty()) {
      downloadKernel = make_shared<long>(boost::any_cast<long>(m["DownloadKernel"]));
    }
    if (m.find("DownloadRedirection") != m.end() && !m["DownloadRedirection"].empty()) {
      downloadRedirection = make_shared<long>(boost::any_cast<long>(m["DownloadRedirection"]));
    }
    if (m.find("DownloadTransmissionSize") != m.end() && !m["DownloadTransmissionSize"].empty()) {
      downloadTransmissionSize = make_shared<long>(boost::any_cast<long>(m["DownloadTransmissionSize"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("QuickProtocol") != m.end() && !m["QuickProtocol"].empty()) {
      quickProtocol = make_shared<string>(boost::any_cast<string>(m["QuickProtocol"]));
    }
    if (m.find("ValidateKeywords") != m.end() && !m["ValidateKeywords"].empty()) {
      validateKeywords = make_shared<string>(boost::any_cast<string>(m["ValidateKeywords"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestDownload() = default;
};
class CreateSyntheticTaskRequestExtendInterval : public Darabonba::Model {
public:
  shared_ptr<vector<long>> days{};
  shared_ptr<long> endHour{};
  shared_ptr<long> endMinute{};
  shared_ptr<string> endTime{};
  shared_ptr<long> startHour{};
  shared_ptr<long> startMinute{};
  shared_ptr<string> startTime{};

  CreateSyntheticTaskRequestExtendInterval() {}

  explicit CreateSyntheticTaskRequestExtendInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (endHour) {
      res["EndHour"] = boost::any(*endHour);
    }
    if (endMinute) {
      res["EndMinute"] = boost::any(*endMinute);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startHour) {
      res["StartHour"] = boost::any(*startHour);
    }
    if (startMinute) {
      res["StartMinute"] = boost::any(*startMinute);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Days"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Days"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      days = make_shared<vector<long>>(toVec1);
    }
    if (m.find("EndHour") != m.end() && !m["EndHour"].empty()) {
      endHour = make_shared<long>(boost::any_cast<long>(m["EndHour"]));
    }
    if (m.find("EndMinute") != m.end() && !m["EndMinute"].empty()) {
      endMinute = make_shared<long>(boost::any_cast<long>(m["EndMinute"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartHour") != m.end() && !m["StartHour"].empty()) {
      startHour = make_shared<long>(boost::any_cast<long>(m["StartHour"]));
    }
    if (m.find("StartMinute") != m.end() && !m["StartMinute"].empty()) {
      startMinute = make_shared<long>(boost::any_cast<long>(m["StartMinute"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestExtendInterval() = default;
};
class CreateSyntheticTaskRequestMonitorList : public Darabonba::Model {
public:
  shared_ptr<long> cityCode{};
  shared_ptr<long> monitorType{};
  shared_ptr<long> netServiceId{};

  CreateSyntheticTaskRequestMonitorList() {}

  explicit CreateSyntheticTaskRequestMonitorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (monitorType) {
      res["MonitorType"] = boost::any(*monitorType);
    }
    if (netServiceId) {
      res["NetServiceId"] = boost::any(*netServiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("MonitorType") != m.end() && !m["MonitorType"].empty()) {
      monitorType = make_shared<long>(boost::any_cast<long>(m["MonitorType"]));
    }
    if (m.find("NetServiceId") != m.end() && !m["NetServiceId"].empty()) {
      netServiceId = make_shared<long>(boost::any_cast<long>(m["NetServiceId"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestMonitorList() = default;
};
class CreateSyntheticTaskRequestNavigation : public Darabonba::Model {
public:
  shared_ptr<string> DNSHijackWhiteList{};
  shared_ptr<string> elementBlacklist{};
  shared_ptr<long> executeActiveX{};
  shared_ptr<long> executeApplication{};
  shared_ptr<long> executeScript{};
  shared_ptr<long> filterInvalidIP{};
  shared_ptr<long> flowHijackJumpTimes{};
  shared_ptr<string> flowHijackLogo{};
  shared_ptr<string> monitorTimeout{};
  shared_ptr<string> navAutomaticScrolling{};
  shared_ptr<string> navCustomHeader{};
  shared_ptr<string> navCustomHeaderContent{};
  shared_ptr<long> navCustomHost{};
  shared_ptr<string> navCustomHostIp{};
  shared_ptr<long> navDisableCache{};
  shared_ptr<string> navDisableCompression{};
  shared_ptr<long> navIgnoreCertificateError{};
  shared_ptr<long> navRedirection{};
  shared_ptr<long> navReturnElement{};
  shared_ptr<string> pageTamper{};
  shared_ptr<string> processName{};
  shared_ptr<string> QUICDomain{};
  shared_ptr<long> QUICVersion{};
  shared_ptr<long> requestHeader{};
  shared_ptr<long> responseHeader{};
  shared_ptr<double> slowElementThreshold{};
  shared_ptr<string> verifyStringBlacklist{};
  shared_ptr<string> verifyStringWhiteList{};
  shared_ptr<double> waitCompletionTime{};

  CreateSyntheticTaskRequestNavigation() {}

  explicit CreateSyntheticTaskRequestNavigation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DNSHijackWhiteList) {
      res["DNSHijackWhiteList"] = boost::any(*DNSHijackWhiteList);
    }
    if (elementBlacklist) {
      res["ElementBlacklist"] = boost::any(*elementBlacklist);
    }
    if (executeActiveX) {
      res["ExecuteActiveX"] = boost::any(*executeActiveX);
    }
    if (executeApplication) {
      res["ExecuteApplication"] = boost::any(*executeApplication);
    }
    if (executeScript) {
      res["ExecuteScript"] = boost::any(*executeScript);
    }
    if (filterInvalidIP) {
      res["FilterInvalidIP"] = boost::any(*filterInvalidIP);
    }
    if (flowHijackJumpTimes) {
      res["FlowHijackJumpTimes"] = boost::any(*flowHijackJumpTimes);
    }
    if (flowHijackLogo) {
      res["FlowHijackLogo"] = boost::any(*flowHijackLogo);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (navAutomaticScrolling) {
      res["NavAutomaticScrolling"] = boost::any(*navAutomaticScrolling);
    }
    if (navCustomHeader) {
      res["NavCustomHeader"] = boost::any(*navCustomHeader);
    }
    if (navCustomHeaderContent) {
      res["NavCustomHeaderContent"] = boost::any(*navCustomHeaderContent);
    }
    if (navCustomHost) {
      res["NavCustomHost"] = boost::any(*navCustomHost);
    }
    if (navCustomHostIp) {
      res["NavCustomHostIp"] = boost::any(*navCustomHostIp);
    }
    if (navDisableCache) {
      res["NavDisableCache"] = boost::any(*navDisableCache);
    }
    if (navDisableCompression) {
      res["NavDisableCompression"] = boost::any(*navDisableCompression);
    }
    if (navIgnoreCertificateError) {
      res["NavIgnoreCertificateError"] = boost::any(*navIgnoreCertificateError);
    }
    if (navRedirection) {
      res["NavRedirection"] = boost::any(*navRedirection);
    }
    if (navReturnElement) {
      res["NavReturnElement"] = boost::any(*navReturnElement);
    }
    if (pageTamper) {
      res["PageTamper"] = boost::any(*pageTamper);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (QUICDomain) {
      res["QUICDomain"] = boost::any(*QUICDomain);
    }
    if (QUICVersion) {
      res["QUICVersion"] = boost::any(*QUICVersion);
    }
    if (requestHeader) {
      res["RequestHeader"] = boost::any(*requestHeader);
    }
    if (responseHeader) {
      res["ResponseHeader"] = boost::any(*responseHeader);
    }
    if (slowElementThreshold) {
      res["SlowElementThreshold"] = boost::any(*slowElementThreshold);
    }
    if (verifyStringBlacklist) {
      res["VerifyStringBlacklist"] = boost::any(*verifyStringBlacklist);
    }
    if (verifyStringWhiteList) {
      res["VerifyStringWhiteList"] = boost::any(*verifyStringWhiteList);
    }
    if (waitCompletionTime) {
      res["WaitCompletionTime"] = boost::any(*waitCompletionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DNSHijackWhiteList") != m.end() && !m["DNSHijackWhiteList"].empty()) {
      DNSHijackWhiteList = make_shared<string>(boost::any_cast<string>(m["DNSHijackWhiteList"]));
    }
    if (m.find("ElementBlacklist") != m.end() && !m["ElementBlacklist"].empty()) {
      elementBlacklist = make_shared<string>(boost::any_cast<string>(m["ElementBlacklist"]));
    }
    if (m.find("ExecuteActiveX") != m.end() && !m["ExecuteActiveX"].empty()) {
      executeActiveX = make_shared<long>(boost::any_cast<long>(m["ExecuteActiveX"]));
    }
    if (m.find("ExecuteApplication") != m.end() && !m["ExecuteApplication"].empty()) {
      executeApplication = make_shared<long>(boost::any_cast<long>(m["ExecuteApplication"]));
    }
    if (m.find("ExecuteScript") != m.end() && !m["ExecuteScript"].empty()) {
      executeScript = make_shared<long>(boost::any_cast<long>(m["ExecuteScript"]));
    }
    if (m.find("FilterInvalidIP") != m.end() && !m["FilterInvalidIP"].empty()) {
      filterInvalidIP = make_shared<long>(boost::any_cast<long>(m["FilterInvalidIP"]));
    }
    if (m.find("FlowHijackJumpTimes") != m.end() && !m["FlowHijackJumpTimes"].empty()) {
      flowHijackJumpTimes = make_shared<long>(boost::any_cast<long>(m["FlowHijackJumpTimes"]));
    }
    if (m.find("FlowHijackLogo") != m.end() && !m["FlowHijackLogo"].empty()) {
      flowHijackLogo = make_shared<string>(boost::any_cast<string>(m["FlowHijackLogo"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<string>(boost::any_cast<string>(m["MonitorTimeout"]));
    }
    if (m.find("NavAutomaticScrolling") != m.end() && !m["NavAutomaticScrolling"].empty()) {
      navAutomaticScrolling = make_shared<string>(boost::any_cast<string>(m["NavAutomaticScrolling"]));
    }
    if (m.find("NavCustomHeader") != m.end() && !m["NavCustomHeader"].empty()) {
      navCustomHeader = make_shared<string>(boost::any_cast<string>(m["NavCustomHeader"]));
    }
    if (m.find("NavCustomHeaderContent") != m.end() && !m["NavCustomHeaderContent"].empty()) {
      navCustomHeaderContent = make_shared<string>(boost::any_cast<string>(m["NavCustomHeaderContent"]));
    }
    if (m.find("NavCustomHost") != m.end() && !m["NavCustomHost"].empty()) {
      navCustomHost = make_shared<long>(boost::any_cast<long>(m["NavCustomHost"]));
    }
    if (m.find("NavCustomHostIp") != m.end() && !m["NavCustomHostIp"].empty()) {
      navCustomHostIp = make_shared<string>(boost::any_cast<string>(m["NavCustomHostIp"]));
    }
    if (m.find("NavDisableCache") != m.end() && !m["NavDisableCache"].empty()) {
      navDisableCache = make_shared<long>(boost::any_cast<long>(m["NavDisableCache"]));
    }
    if (m.find("NavDisableCompression") != m.end() && !m["NavDisableCompression"].empty()) {
      navDisableCompression = make_shared<string>(boost::any_cast<string>(m["NavDisableCompression"]));
    }
    if (m.find("NavIgnoreCertificateError") != m.end() && !m["NavIgnoreCertificateError"].empty()) {
      navIgnoreCertificateError = make_shared<long>(boost::any_cast<long>(m["NavIgnoreCertificateError"]));
    }
    if (m.find("NavRedirection") != m.end() && !m["NavRedirection"].empty()) {
      navRedirection = make_shared<long>(boost::any_cast<long>(m["NavRedirection"]));
    }
    if (m.find("NavReturnElement") != m.end() && !m["NavReturnElement"].empty()) {
      navReturnElement = make_shared<long>(boost::any_cast<long>(m["NavReturnElement"]));
    }
    if (m.find("PageTamper") != m.end() && !m["PageTamper"].empty()) {
      pageTamper = make_shared<string>(boost::any_cast<string>(m["PageTamper"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("QUICDomain") != m.end() && !m["QUICDomain"].empty()) {
      QUICDomain = make_shared<string>(boost::any_cast<string>(m["QUICDomain"]));
    }
    if (m.find("QUICVersion") != m.end() && !m["QUICVersion"].empty()) {
      QUICVersion = make_shared<long>(boost::any_cast<long>(m["QUICVersion"]));
    }
    if (m.find("RequestHeader") != m.end() && !m["RequestHeader"].empty()) {
      requestHeader = make_shared<long>(boost::any_cast<long>(m["RequestHeader"]));
    }
    if (m.find("ResponseHeader") != m.end() && !m["ResponseHeader"].empty()) {
      responseHeader = make_shared<long>(boost::any_cast<long>(m["ResponseHeader"]));
    }
    if (m.find("SlowElementThreshold") != m.end() && !m["SlowElementThreshold"].empty()) {
      slowElementThreshold = make_shared<double>(boost::any_cast<double>(m["SlowElementThreshold"]));
    }
    if (m.find("VerifyStringBlacklist") != m.end() && !m["VerifyStringBlacklist"].empty()) {
      verifyStringBlacklist = make_shared<string>(boost::any_cast<string>(m["VerifyStringBlacklist"]));
    }
    if (m.find("VerifyStringWhiteList") != m.end() && !m["VerifyStringWhiteList"].empty()) {
      verifyStringWhiteList = make_shared<string>(boost::any_cast<string>(m["VerifyStringWhiteList"]));
    }
    if (m.find("WaitCompletionTime") != m.end() && !m["WaitCompletionTime"].empty()) {
      waitCompletionTime = make_shared<double>(boost::any_cast<double>(m["WaitCompletionTime"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestNavigation() = default;
};
class CreateSyntheticTaskRequestNet : public Darabonba::Model {
public:
  shared_ptr<string> netDNSNs{};
  shared_ptr<long> netDNSQueryMethod{};
  shared_ptr<long> netDNSServer{};
  shared_ptr<long> netDNSSwitch{};
  shared_ptr<long> netDNSTimeout{};
  shared_ptr<long> netDigSwitch{};
  shared_ptr<long> netICMPActive{};
  shared_ptr<long> netICMPDataCut{};
  shared_ptr<long> netICMPInterval{};
  shared_ptr<long> netICMPNum{};
  shared_ptr<long> netICMPSize{};
  shared_ptr<long> netICMPSwitch{};
  shared_ptr<long> netICMPTimeout{};
  shared_ptr<long> netTraceRouteNum{};
  shared_ptr<long> netTraceRouteSwitch{};
  shared_ptr<long> netTraceRouteTimeout{};
  shared_ptr<string> whiteList{};

  CreateSyntheticTaskRequestNet() {}

  explicit CreateSyntheticTaskRequestNet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (netDNSNs) {
      res["NetDNSNs"] = boost::any(*netDNSNs);
    }
    if (netDNSQueryMethod) {
      res["NetDNSQueryMethod"] = boost::any(*netDNSQueryMethod);
    }
    if (netDNSServer) {
      res["NetDNSServer"] = boost::any(*netDNSServer);
    }
    if (netDNSSwitch) {
      res["NetDNSSwitch"] = boost::any(*netDNSSwitch);
    }
    if (netDNSTimeout) {
      res["NetDNSTimeout"] = boost::any(*netDNSTimeout);
    }
    if (netDigSwitch) {
      res["NetDigSwitch"] = boost::any(*netDigSwitch);
    }
    if (netICMPActive) {
      res["NetICMPActive"] = boost::any(*netICMPActive);
    }
    if (netICMPDataCut) {
      res["NetICMPDataCut"] = boost::any(*netICMPDataCut);
    }
    if (netICMPInterval) {
      res["NetICMPInterval"] = boost::any(*netICMPInterval);
    }
    if (netICMPNum) {
      res["NetICMPNum"] = boost::any(*netICMPNum);
    }
    if (netICMPSize) {
      res["NetICMPSize"] = boost::any(*netICMPSize);
    }
    if (netICMPSwitch) {
      res["NetICMPSwitch"] = boost::any(*netICMPSwitch);
    }
    if (netICMPTimeout) {
      res["NetICMPTimeout"] = boost::any(*netICMPTimeout);
    }
    if (netTraceRouteNum) {
      res["NetTraceRouteNum"] = boost::any(*netTraceRouteNum);
    }
    if (netTraceRouteSwitch) {
      res["NetTraceRouteSwitch"] = boost::any(*netTraceRouteSwitch);
    }
    if (netTraceRouteTimeout) {
      res["NetTraceRouteTimeout"] = boost::any(*netTraceRouteTimeout);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetDNSNs") != m.end() && !m["NetDNSNs"].empty()) {
      netDNSNs = make_shared<string>(boost::any_cast<string>(m["NetDNSNs"]));
    }
    if (m.find("NetDNSQueryMethod") != m.end() && !m["NetDNSQueryMethod"].empty()) {
      netDNSQueryMethod = make_shared<long>(boost::any_cast<long>(m["NetDNSQueryMethod"]));
    }
    if (m.find("NetDNSServer") != m.end() && !m["NetDNSServer"].empty()) {
      netDNSServer = make_shared<long>(boost::any_cast<long>(m["NetDNSServer"]));
    }
    if (m.find("NetDNSSwitch") != m.end() && !m["NetDNSSwitch"].empty()) {
      netDNSSwitch = make_shared<long>(boost::any_cast<long>(m["NetDNSSwitch"]));
    }
    if (m.find("NetDNSTimeout") != m.end() && !m["NetDNSTimeout"].empty()) {
      netDNSTimeout = make_shared<long>(boost::any_cast<long>(m["NetDNSTimeout"]));
    }
    if (m.find("NetDigSwitch") != m.end() && !m["NetDigSwitch"].empty()) {
      netDigSwitch = make_shared<long>(boost::any_cast<long>(m["NetDigSwitch"]));
    }
    if (m.find("NetICMPActive") != m.end() && !m["NetICMPActive"].empty()) {
      netICMPActive = make_shared<long>(boost::any_cast<long>(m["NetICMPActive"]));
    }
    if (m.find("NetICMPDataCut") != m.end() && !m["NetICMPDataCut"].empty()) {
      netICMPDataCut = make_shared<long>(boost::any_cast<long>(m["NetICMPDataCut"]));
    }
    if (m.find("NetICMPInterval") != m.end() && !m["NetICMPInterval"].empty()) {
      netICMPInterval = make_shared<long>(boost::any_cast<long>(m["NetICMPInterval"]));
    }
    if (m.find("NetICMPNum") != m.end() && !m["NetICMPNum"].empty()) {
      netICMPNum = make_shared<long>(boost::any_cast<long>(m["NetICMPNum"]));
    }
    if (m.find("NetICMPSize") != m.end() && !m["NetICMPSize"].empty()) {
      netICMPSize = make_shared<long>(boost::any_cast<long>(m["NetICMPSize"]));
    }
    if (m.find("NetICMPSwitch") != m.end() && !m["NetICMPSwitch"].empty()) {
      netICMPSwitch = make_shared<long>(boost::any_cast<long>(m["NetICMPSwitch"]));
    }
    if (m.find("NetICMPTimeout") != m.end() && !m["NetICMPTimeout"].empty()) {
      netICMPTimeout = make_shared<long>(boost::any_cast<long>(m["NetICMPTimeout"]));
    }
    if (m.find("NetTraceRouteNum") != m.end() && !m["NetTraceRouteNum"].empty()) {
      netTraceRouteNum = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteNum"]));
    }
    if (m.find("NetTraceRouteSwitch") != m.end() && !m["NetTraceRouteSwitch"].empty()) {
      netTraceRouteSwitch = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteSwitch"]));
    }
    if (m.find("NetTraceRouteTimeout") != m.end() && !m["NetTraceRouteTimeout"].empty()) {
      netTraceRouteTimeout = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteTimeout"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestNet() = default;
};
class CreateSyntheticTaskRequestProtocolRequestContentBodyFormData : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateSyntheticTaskRequestProtocolRequestContentBodyFormData() {}

  explicit CreateSyntheticTaskRequestProtocolRequestContentBodyFormData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocolRequestContentBodyFormData() = default;
};
class CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding() {}

  explicit CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding() = default;
};
class CreateSyntheticTaskRequestProtocolRequestContentBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateSyntheticTaskRequestProtocolRequestContentBodyFormData>> formData{};
  shared_ptr<string> language{};
  shared_ptr<string> mode{};
  shared_ptr<string> raw{};
  shared_ptr<vector<CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding>> urlEncoding{};

  CreateSyntheticTaskRequestProtocolRequestContentBody() {}

  explicit CreateSyntheticTaskRequestProtocolRequestContentBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formData) {
      vector<boost::any> temp1;
      for(auto item1:*formData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FormData"] = boost::any(temp1);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (raw) {
      res["Raw"] = boost::any(*raw);
    }
    if (urlEncoding) {
      vector<boost::any> temp1;
      for(auto item1:*urlEncoding){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlEncoding"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FormData") != m.end() && !m["FormData"].empty()) {
      if (typeid(vector<boost::any>) == m["FormData"].type()) {
        vector<CreateSyntheticTaskRequestProtocolRequestContentBodyFormData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FormData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSyntheticTaskRequestProtocolRequestContentBodyFormData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        formData = make_shared<vector<CreateSyntheticTaskRequestProtocolRequestContentBodyFormData>>(expect1);
      }
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Raw") != m.end() && !m["Raw"].empty()) {
      raw = make_shared<string>(boost::any_cast<string>(m["Raw"]));
    }
    if (m.find("UrlEncoding") != m.end() && !m["UrlEncoding"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlEncoding"].type()) {
        vector<CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlEncoding"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlEncoding = make_shared<vector<CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding>>(expect1);
      }
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocolRequestContentBody() = default;
};
class CreateSyntheticTaskRequestProtocolRequestContentHeader : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateSyntheticTaskRequestProtocolRequestContentHeader() {}

  explicit CreateSyntheticTaskRequestProtocolRequestContentHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocolRequestContentHeader() = default;
};
class CreateSyntheticTaskRequestProtocolRequestContent : public Darabonba::Model {
public:
  shared_ptr<CreateSyntheticTaskRequestProtocolRequestContentBody> body{};
  shared_ptr<vector<CreateSyntheticTaskRequestProtocolRequestContentHeader>> header{};
  shared_ptr<string> method{};

  CreateSyntheticTaskRequestProtocolRequestContent() {}

  explicit CreateSyntheticTaskRequestProtocolRequestContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (header) {
      vector<boost::any> temp1;
      for(auto item1:*header){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Header"] = boost::any(temp1);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      if (typeid(map<string, boost::any>) == m["Body"].type()) {
        CreateSyntheticTaskRequestProtocolRequestContentBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Body"]));
        body = make_shared<CreateSyntheticTaskRequestProtocolRequestContentBody>(model1);
      }
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(vector<boost::any>) == m["Header"].type()) {
        vector<CreateSyntheticTaskRequestProtocolRequestContentHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Header"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSyntheticTaskRequestProtocolRequestContentHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        header = make_shared<vector<CreateSyntheticTaskRequestProtocolRequestContentHeader>>(expect1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocolRequestContent() = default;
};
class CreateSyntheticTaskRequestProtocol : public Darabonba::Model {
public:
  shared_ptr<long> characterEncoding{};
  shared_ptr<long> customHost{};
  shared_ptr<string> customHostIp{};
  shared_ptr<long> protocolConnectionTime{};
  shared_ptr<string> protocolMonitorTimeout{};
  shared_ptr<long> receivedDataSize{};
  shared_ptr<CreateSyntheticTaskRequestProtocolRequestContent> requestContent{};
  shared_ptr<string> verifyContent{};
  shared_ptr<long> verifyWay{};

  CreateSyntheticTaskRequestProtocol() {}

  explicit CreateSyntheticTaskRequestProtocol(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (characterEncoding) {
      res["CharacterEncoding"] = boost::any(*characterEncoding);
    }
    if (customHost) {
      res["CustomHost"] = boost::any(*customHost);
    }
    if (customHostIp) {
      res["CustomHostIp"] = boost::any(*customHostIp);
    }
    if (protocolConnectionTime) {
      res["ProtocolConnectionTime"] = boost::any(*protocolConnectionTime);
    }
    if (protocolMonitorTimeout) {
      res["ProtocolMonitorTimeout"] = boost::any(*protocolMonitorTimeout);
    }
    if (receivedDataSize) {
      res["ReceivedDataSize"] = boost::any(*receivedDataSize);
    }
    if (requestContent) {
      res["RequestContent"] = requestContent ? boost::any(requestContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (verifyContent) {
      res["VerifyContent"] = boost::any(*verifyContent);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharacterEncoding") != m.end() && !m["CharacterEncoding"].empty()) {
      characterEncoding = make_shared<long>(boost::any_cast<long>(m["CharacterEncoding"]));
    }
    if (m.find("CustomHost") != m.end() && !m["CustomHost"].empty()) {
      customHost = make_shared<long>(boost::any_cast<long>(m["CustomHost"]));
    }
    if (m.find("CustomHostIp") != m.end() && !m["CustomHostIp"].empty()) {
      customHostIp = make_shared<string>(boost::any_cast<string>(m["CustomHostIp"]));
    }
    if (m.find("ProtocolConnectionTime") != m.end() && !m["ProtocolConnectionTime"].empty()) {
      protocolConnectionTime = make_shared<long>(boost::any_cast<long>(m["ProtocolConnectionTime"]));
    }
    if (m.find("ProtocolMonitorTimeout") != m.end() && !m["ProtocolMonitorTimeout"].empty()) {
      protocolMonitorTimeout = make_shared<string>(boost::any_cast<string>(m["ProtocolMonitorTimeout"]));
    }
    if (m.find("ReceivedDataSize") != m.end() && !m["ReceivedDataSize"].empty()) {
      receivedDataSize = make_shared<long>(boost::any_cast<long>(m["ReceivedDataSize"]));
    }
    if (m.find("RequestContent") != m.end() && !m["RequestContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestContent"].type()) {
        CreateSyntheticTaskRequestProtocolRequestContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestContent"]));
        requestContent = make_shared<CreateSyntheticTaskRequestProtocolRequestContent>(model1);
      }
    }
    if (m.find("VerifyContent") != m.end() && !m["VerifyContent"].empty()) {
      verifyContent = make_shared<string>(boost::any_cast<string>(m["VerifyContent"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
  }


  virtual ~CreateSyntheticTaskRequestProtocol() = default;
};
class CreateSyntheticTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CreateSyntheticTaskRequestCommonParam> commonParam{};
  shared_ptr<CreateSyntheticTaskRequestDownload> download{};
  shared_ptr<CreateSyntheticTaskRequestExtendInterval> extendInterval{};
  shared_ptr<string> intervalTime{};
  shared_ptr<string> intervalType{};
  shared_ptr<long> ipType{};
  shared_ptr<vector<CreateSyntheticTaskRequestMonitorList>> monitorList{};
  shared_ptr<CreateSyntheticTaskRequestNavigation> navigation{};
  shared_ptr<CreateSyntheticTaskRequestNet> net{};
  shared_ptr<CreateSyntheticTaskRequestProtocol> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskType{};
  shared_ptr<bool> updateTask{};
  shared_ptr<string> url{};

  CreateSyntheticTaskRequest() {}

  explicit CreateSyntheticTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonParam) {
      res["CommonParam"] = commonParam ? boost::any(commonParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (download) {
      res["Download"] = download ? boost::any(download->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendInterval) {
      res["ExtendInterval"] = extendInterval ? boost::any(extendInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (intervalTime) {
      res["IntervalTime"] = boost::any(*intervalTime);
    }
    if (intervalType) {
      res["IntervalType"] = boost::any(*intervalType);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (monitorList) {
      vector<boost::any> temp1;
      for(auto item1:*monitorList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorList"] = boost::any(temp1);
    }
    if (navigation) {
      res["Navigation"] = navigation ? boost::any(navigation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (net) {
      res["Net"] = net ? boost::any(net->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocol) {
      res["Protocol"] = protocol ? boost::any(protocol->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (updateTask) {
      res["UpdateTask"] = boost::any(*updateTask);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonParam") != m.end() && !m["CommonParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonParam"].type()) {
        CreateSyntheticTaskRequestCommonParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonParam"]));
        commonParam = make_shared<CreateSyntheticTaskRequestCommonParam>(model1);
      }
    }
    if (m.find("Download") != m.end() && !m["Download"].empty()) {
      if (typeid(map<string, boost::any>) == m["Download"].type()) {
        CreateSyntheticTaskRequestDownload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Download"]));
        download = make_shared<CreateSyntheticTaskRequestDownload>(model1);
      }
    }
    if (m.find("ExtendInterval") != m.end() && !m["ExtendInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendInterval"].type()) {
        CreateSyntheticTaskRequestExtendInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendInterval"]));
        extendInterval = make_shared<CreateSyntheticTaskRequestExtendInterval>(model1);
      }
    }
    if (m.find("IntervalTime") != m.end() && !m["IntervalTime"].empty()) {
      intervalTime = make_shared<string>(boost::any_cast<string>(m["IntervalTime"]));
    }
    if (m.find("IntervalType") != m.end() && !m["IntervalType"].empty()) {
      intervalType = make_shared<string>(boost::any_cast<string>(m["IntervalType"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("MonitorList") != m.end() && !m["MonitorList"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorList"].type()) {
        vector<CreateSyntheticTaskRequestMonitorList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSyntheticTaskRequestMonitorList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorList = make_shared<vector<CreateSyntheticTaskRequestMonitorList>>(expect1);
      }
    }
    if (m.find("Navigation") != m.end() && !m["Navigation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Navigation"].type()) {
        CreateSyntheticTaskRequestNavigation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Navigation"]));
        navigation = make_shared<CreateSyntheticTaskRequestNavigation>(model1);
      }
    }
    if (m.find("Net") != m.end() && !m["Net"].empty()) {
      if (typeid(map<string, boost::any>) == m["Net"].type()) {
        CreateSyntheticTaskRequestNet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Net"]));
        net = make_shared<CreateSyntheticTaskRequestNet>(model1);
      }
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      if (typeid(map<string, boost::any>) == m["Protocol"].type()) {
        CreateSyntheticTaskRequestProtocol model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Protocol"]));
        protocol = make_shared<CreateSyntheticTaskRequestProtocol>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("UpdateTask") != m.end() && !m["UpdateTask"].empty()) {
      updateTask = make_shared<bool>(boost::any_cast<bool>(m["UpdateTask"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateSyntheticTaskRequest() = default;
};
class CreateSyntheticTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> commonParamShrink{};
  shared_ptr<string> downloadShrink{};
  shared_ptr<string> extendIntervalShrink{};
  shared_ptr<string> intervalTime{};
  shared_ptr<string> intervalType{};
  shared_ptr<long> ipType{};
  shared_ptr<string> monitorListShrink{};
  shared_ptr<string> navigationShrink{};
  shared_ptr<string> netShrink{};
  shared_ptr<string> protocolShrink{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskType{};
  shared_ptr<bool> updateTask{};
  shared_ptr<string> url{};

  CreateSyntheticTaskShrinkRequest() {}

  explicit CreateSyntheticTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonParamShrink) {
      res["CommonParam"] = boost::any(*commonParamShrink);
    }
    if (downloadShrink) {
      res["Download"] = boost::any(*downloadShrink);
    }
    if (extendIntervalShrink) {
      res["ExtendInterval"] = boost::any(*extendIntervalShrink);
    }
    if (intervalTime) {
      res["IntervalTime"] = boost::any(*intervalTime);
    }
    if (intervalType) {
      res["IntervalType"] = boost::any(*intervalType);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (monitorListShrink) {
      res["MonitorList"] = boost::any(*monitorListShrink);
    }
    if (navigationShrink) {
      res["Navigation"] = boost::any(*navigationShrink);
    }
    if (netShrink) {
      res["Net"] = boost::any(*netShrink);
    }
    if (protocolShrink) {
      res["Protocol"] = boost::any(*protocolShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (updateTask) {
      res["UpdateTask"] = boost::any(*updateTask);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonParam") != m.end() && !m["CommonParam"].empty()) {
      commonParamShrink = make_shared<string>(boost::any_cast<string>(m["CommonParam"]));
    }
    if (m.find("Download") != m.end() && !m["Download"].empty()) {
      downloadShrink = make_shared<string>(boost::any_cast<string>(m["Download"]));
    }
    if (m.find("ExtendInterval") != m.end() && !m["ExtendInterval"].empty()) {
      extendIntervalShrink = make_shared<string>(boost::any_cast<string>(m["ExtendInterval"]));
    }
    if (m.find("IntervalTime") != m.end() && !m["IntervalTime"].empty()) {
      intervalTime = make_shared<string>(boost::any_cast<string>(m["IntervalTime"]));
    }
    if (m.find("IntervalType") != m.end() && !m["IntervalType"].empty()) {
      intervalType = make_shared<string>(boost::any_cast<string>(m["IntervalType"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("MonitorList") != m.end() && !m["MonitorList"].empty()) {
      monitorListShrink = make_shared<string>(boost::any_cast<string>(m["MonitorList"]));
    }
    if (m.find("Navigation") != m.end() && !m["Navigation"].empty()) {
      navigationShrink = make_shared<string>(boost::any_cast<string>(m["Navigation"]));
    }
    if (m.find("Net") != m.end() && !m["Net"].empty()) {
      netShrink = make_shared<string>(boost::any_cast<string>(m["Net"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocolShrink = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("UpdateTask") != m.end() && !m["UpdateTask"].empty()) {
      updateTask = make_shared<bool>(boost::any_cast<bool>(m["UpdateTask"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateSyntheticTaskShrinkRequest() = default;
};
class CreateSyntheticTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> taskId{};

  CreateSyntheticTaskResponseBodyData() {}

  explicit CreateSyntheticTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~CreateSyntheticTaskResponseBodyData() = default;
};
class CreateSyntheticTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateSyntheticTaskResponseBodyData> data{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  CreateSyntheticTaskResponseBody() {}

  explicit CreateSyntheticTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateSyntheticTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateSyntheticTaskResponseBodyData>(model1);
      }
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSyntheticTaskResponseBody() = default;
};
class CreateSyntheticTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSyntheticTaskResponseBody> body{};

  CreateSyntheticTaskResponse() {}

  explicit CreateSyntheticTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSyntheticTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSyntheticTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSyntheticTaskResponse() = default;
};
class CreateWebhookRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> contactName{};
  shared_ptr<string> httpHeaders{};
  shared_ptr<string> httpParams{};
  shared_ptr<string> method{};
  shared_ptr<string> recoverBody{};
  shared_ptr<string> regionId{};
  shared_ptr<string> url{};

  CreateWebhookRequest() {}

  explicit CreateWebhookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (httpHeaders) {
      res["HttpHeaders"] = boost::any(*httpHeaders);
    }
    if (httpParams) {
      res["HttpParams"] = boost::any(*httpParams);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (recoverBody) {
      res["RecoverBody"] = boost::any(*recoverBody);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("HttpHeaders") != m.end() && !m["HttpHeaders"].empty()) {
      httpHeaders = make_shared<string>(boost::any_cast<string>(m["HttpHeaders"]));
    }
    if (m.find("HttpParams") != m.end() && !m["HttpParams"].empty()) {
      httpParams = make_shared<string>(boost::any_cast<string>(m["HttpParams"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("RecoverBody") != m.end() && !m["RecoverBody"].empty()) {
      recoverBody = make_shared<string>(boost::any_cast<string>(m["RecoverBody"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateWebhookRequest() = default;
};
class CreateWebhookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> requestId{};

  CreateWebhookResponseBody() {}

  explicit CreateWebhookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateWebhookResponseBody() = default;
};
class CreateWebhookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWebhookResponseBody> body{};

  CreateWebhookResponse() {}

  explicit CreateWebhookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWebhookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWebhookResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWebhookResponse() = default;
};
class DelAuthTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  DelAuthTokenRequest() {}

  explicit DelAuthTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DelAuthTokenRequest() = default;
};
class DelAuthTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DelAuthTokenResponseBody() {}

  explicit DelAuthTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DelAuthTokenResponseBody() = default;
};
class DelAuthTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DelAuthTokenResponseBody> body{};

  DelAuthTokenResponse() {}

  explicit DelAuthTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DelAuthTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DelAuthTokenResponseBody>(model1);
      }
    }
  }


  virtual ~DelAuthTokenResponse() = default;
};
class DeleteAlertContactRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> regionId{};

  DeleteAlertContactRequest() {}

  explicit DeleteAlertContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteAlertContactRequest() = default;
};
class DeleteAlertContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteAlertContactResponseBody() {}

  explicit DeleteAlertContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAlertContactResponseBody() = default;
};
class DeleteAlertContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertContactResponseBody> body{};

  DeleteAlertContactResponse() {}

  explicit DeleteAlertContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertContactResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertContactResponse() = default;
};
class DeleteAlertContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactGroupId{};
  shared_ptr<string> regionId{};

  DeleteAlertContactGroupRequest() {}

  explicit DeleteAlertContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<long>(boost::any_cast<long>(m["ContactGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteAlertContactGroupRequest() = default;
};
class DeleteAlertContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteAlertContactGroupResponseBody() {}

  explicit DeleteAlertContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAlertContactGroupResponseBody() = default;
};
class DeleteAlertContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertContactGroupResponseBody> body{};

  DeleteAlertContactGroupResponse() {}

  explicit DeleteAlertContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertContactGroupResponse() = default;
};
class DeleteAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};

  DeleteAlertRuleRequest() {}

  explicit DeleteAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
  }


  virtual ~DeleteAlertRuleRequest() = default;
};
class DeleteAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteAlertRuleResponseBody() {}

  explicit DeleteAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAlertRuleResponseBody() = default;
};
class DeleteAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertRuleResponseBody> body{};

  DeleteAlertRuleResponse() {}

  explicit DeleteAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertRuleResponse() = default;
};
class DeleteAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertIds{};
  shared_ptr<string> regionId{};

  DeleteAlertRulesRequest() {}

  explicit DeleteAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertIds) {
      res["AlertIds"] = boost::any(*alertIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertIds") != m.end() && !m["AlertIds"].empty()) {
      alertIds = make_shared<string>(boost::any_cast<string>(m["AlertIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteAlertRulesRequest() = default;
};
class DeleteAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteAlertRulesResponseBody() {}

  explicit DeleteAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAlertRulesResponseBody() = default;
};
class DeleteAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAlertRulesResponseBody> body{};

  DeleteAlertRulesResponse() {}

  explicit DeleteAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAlertRulesResponse() = default;
};
class DeleteCmsExporterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  DeleteCmsExporterRequest() {}

  explicit DeleteCmsExporterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCmsExporterRequest() = default;
};
class DeleteCmsExporterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DeleteCmsExporterResponseBody() {}

  explicit DeleteCmsExporterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCmsExporterResponseBody() = default;
};
class DeleteCmsExporterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCmsExporterResponseBody> body{};

  DeleteCmsExporterResponse() {}

  explicit DeleteCmsExporterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCmsExporterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCmsExporterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCmsExporterResponse() = default;
};
class DeleteContactRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};

  DeleteContactRequest() {}

  explicit DeleteContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
  }


  virtual ~DeleteContactRequest() = default;
};
class DeleteContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteContactResponseBody() {}

  explicit DeleteContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteContactResponseBody() = default;
};
class DeleteContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactResponseBody> body{};

  DeleteContactResponse() {}

  explicit DeleteContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactResponse() = default;
};
class DeleteContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactGroupId{};

  DeleteContactGroupRequest() {}

  explicit DeleteContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<long>(boost::any_cast<long>(m["ContactGroupId"]));
    }
  }


  virtual ~DeleteContactGroupRequest() = default;
};
class DeleteContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteContactGroupResponseBody() {}

  explicit DeleteContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteContactGroupResponseBody() = default;
};
class DeleteContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactGroupResponseBody> body{};

  DeleteContactGroupResponse() {}

  explicit DeleteContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactGroupResponse() = default;
};
class DeleteDispatchRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  DeleteDispatchRuleRequest() {}

  explicit DeleteDispatchRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDispatchRuleRequest() = default;
};
class DeleteDispatchRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDispatchRuleResponseBody() {}

  explicit DeleteDispatchRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDispatchRuleResponseBody() = default;
};
class DeleteDispatchRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDispatchRuleResponseBody> body{};

  DeleteDispatchRuleResponse() {}

  explicit DeleteDispatchRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDispatchRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDispatchRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDispatchRuleResponse() = default;
};
class DeleteEventBridgeIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteEventBridgeIntegrationRequest() {}

  explicit DeleteEventBridgeIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteEventBridgeIntegrationRequest() = default;
};
class DeleteEventBridgeIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteEventBridgeIntegrationResponseBody() {}

  explicit DeleteEventBridgeIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEventBridgeIntegrationResponseBody() = default;
};
class DeleteEventBridgeIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEventBridgeIntegrationResponseBody> body{};

  DeleteEventBridgeIntegrationResponse() {}

  explicit DeleteEventBridgeIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEventBridgeIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEventBridgeIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEventBridgeIntegrationResponse() = default;
};
class DeleteGrafanaResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> regionId{};

  DeleteGrafanaResourceRequest() {}

  explicit DeleteGrafanaResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteGrafanaResourceRequest() = default;
};
class DeleteGrafanaResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteGrafanaResourceResponseBody() {}

  explicit DeleteGrafanaResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteGrafanaResourceResponseBody() = default;
};
class DeleteGrafanaResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGrafanaResourceResponseBody> body{};

  DeleteGrafanaResourceResponse() {}

  explicit DeleteGrafanaResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGrafanaResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGrafanaResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGrafanaResourceResponse() = default;
};
class DeleteIMRobotRequest : public Darabonba::Model {
public:
  shared_ptr<long> robotId{};

  DeleteIMRobotRequest() {}

  explicit DeleteIMRobotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (robotId) {
      res["RobotId"] = boost::any(*robotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RobotId") != m.end() && !m["RobotId"].empty()) {
      robotId = make_shared<long>(boost::any_cast<long>(m["RobotId"]));
    }
  }


  virtual ~DeleteIMRobotRequest() = default;
};
class DeleteIMRobotResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteIMRobotResponseBody() {}

  explicit DeleteIMRobotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIMRobotResponseBody() = default;
};
class DeleteIMRobotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIMRobotResponseBody> body{};

  DeleteIMRobotResponse() {}

  explicit DeleteIMRobotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIMRobotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIMRobotResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIMRobotResponse() = default;
};
class DeleteIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integration{};
  shared_ptr<string> regionId{};

  DeleteIntegrationRequest() {}

  explicit DeleteIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integration) {
      res["Integration"] = boost::any(*integration);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      integration = make_shared<string>(boost::any_cast<string>(m["Integration"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteIntegrationRequest() = default;
};
class DeleteIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteIntegrationResponseBody() {}

  explicit DeleteIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIntegrationResponseBody() = default;
};
class DeleteIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIntegrationResponseBody> body{};

  DeleteIntegrationResponse() {}

  explicit DeleteIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIntegrationResponse() = default;
};
class DeleteIntegrationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> integrationId{};

  DeleteIntegrationsRequest() {}

  explicit DeleteIntegrationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
  }


  virtual ~DeleteIntegrationsRequest() = default;
};
class DeleteIntegrationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteIntegrationsResponseBody() {}

  explicit DeleteIntegrationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIntegrationsResponseBody() = default;
};
class DeleteIntegrationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIntegrationsResponseBody> body{};

  DeleteIntegrationsResponse() {}

  explicit DeleteIntegrationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIntegrationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIntegrationsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIntegrationsResponse() = default;
};
class DeleteNotificationPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteNotificationPolicyRequest() {}

  explicit DeleteNotificationPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteNotificationPolicyRequest() = default;
};
class DeleteNotificationPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteNotificationPolicyResponseBody() {}

  explicit DeleteNotificationPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNotificationPolicyResponseBody() = default;
};
class DeleteNotificationPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNotificationPolicyResponseBody> body{};

  DeleteNotificationPolicyResponse() {}

  explicit DeleteNotificationPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNotificationPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNotificationPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNotificationPolicyResponse() = default;
};
class DeletePrometheusAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> clusterId{};

  DeletePrometheusAlertRuleRequest() {}

  explicit DeletePrometheusAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DeletePrometheusAlertRuleRequest() = default;
};
class DeletePrometheusAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeletePrometheusAlertRuleResponseBody() {}

  explicit DeletePrometheusAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeletePrometheusAlertRuleResponseBody() = default;
};
class DeletePrometheusAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePrometheusAlertRuleResponseBody> body{};

  DeletePrometheusAlertRuleResponse() {}

  explicit DeletePrometheusAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrometheusAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrometheusAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrometheusAlertRuleResponse() = default;
};
class DeletePrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> regionId{};

  DeletePrometheusGlobalViewRequest() {}

  explicit DeletePrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeletePrometheusGlobalViewRequest() = default;
};
class DeletePrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeletePrometheusGlobalViewResponseBody() {}

  explicit DeletePrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePrometheusGlobalViewResponseBody() = default;
};
class DeletePrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePrometheusGlobalViewResponseBody> body{};

  DeletePrometheusGlobalViewResponse() {}

  explicit DeletePrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrometheusGlobalViewResponse() = default;
};
class DeletePrometheusIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> regionId{};

  DeletePrometheusIntegrationRequest() {}

  explicit DeletePrometheusIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeletePrometheusIntegrationRequest() = default;
};
class DeletePrometheusIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeletePrometheusIntegrationResponseBody() {}

  explicit DeletePrometheusIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePrometheusIntegrationResponseBody() = default;
};
class DeletePrometheusIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePrometheusIntegrationResponseBody> body{};

  DeletePrometheusIntegrationResponse() {}

  explicit DeletePrometheusIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrometheusIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrometheusIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrometheusIntegrationResponse() = default;
};
class DeletePrometheusMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  DeletePrometheusMonitoringRequest() {}

  explicit DeletePrometheusMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeletePrometheusMonitoringRequest() = default;
};
class DeletePrometheusMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeletePrometheusMonitoringResponseBody() {}

  explicit DeletePrometheusMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePrometheusMonitoringResponseBody() = default;
};
class DeletePrometheusMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePrometheusMonitoringResponseBody> body{};

  DeletePrometheusMonitoringResponse() {}

  explicit DeletePrometheusMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrometheusMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrometheusMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrometheusMonitoringResponse() = default;
};
class DeletePrometheusRemoteWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteWriteNames{};

  DeletePrometheusRemoteWriteRequest() {}

  explicit DeletePrometheusRemoteWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteWriteNames) {
      res["RemoteWriteNames"] = boost::any(*remoteWriteNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteWriteNames") != m.end() && !m["RemoteWriteNames"].empty()) {
      remoteWriteNames = make_shared<string>(boost::any_cast<string>(m["RemoteWriteNames"]));
    }
  }


  virtual ~DeletePrometheusRemoteWriteRequest() = default;
};
class DeletePrometheusRemoteWriteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeletePrometheusRemoteWriteResponseBody() {}

  explicit DeletePrometheusRemoteWriteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeletePrometheusRemoteWriteResponseBody() = default;
};
class DeletePrometheusRemoteWriteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePrometheusRemoteWriteResponseBody> body{};

  DeletePrometheusRemoteWriteResponse() {}

  explicit DeletePrometheusRemoteWriteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrometheusRemoteWriteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrometheusRemoteWriteResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrometheusRemoteWriteResponse() = default;
};
class DeleteRetcodeAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};

  DeleteRetcodeAppRequest() {}

  explicit DeleteRetcodeAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteRetcodeAppRequest() = default;
};
class DeleteRetcodeAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteRetcodeAppResponseBody() {}

  explicit DeleteRetcodeAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteRetcodeAppResponseBody() = default;
};
class DeleteRetcodeAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRetcodeAppResponseBody> body{};

  DeleteRetcodeAppResponse() {}

  explicit DeleteRetcodeAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRetcodeAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRetcodeAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRetcodeAppResponse() = default;
};
class DeleteScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<long> scenarioId{};

  DeleteScenarioRequest() {}

  explicit DeleteScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<long>(boost::any_cast<long>(m["ScenarioId"]));
    }
  }


  virtual ~DeleteScenarioRequest() = default;
};
class DeleteScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteScenarioResponseBody() {}

  explicit DeleteScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteScenarioResponseBody() = default;
};
class DeleteScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScenarioResponseBody> body{};

  DeleteScenarioResponse() {}

  explicit DeleteScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScenarioResponse() = default;
};
class DeleteSilencePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteSilencePolicyRequest() {}

  explicit DeleteSilencePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteSilencePolicyRequest() = default;
};
class DeleteSilencePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteSilencePolicyResponseBody() {}

  explicit DeleteSilencePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSilencePolicyResponseBody() = default;
};
class DeleteSilencePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSilencePolicyResponseBody> body{};

  DeleteSilencePolicyResponse() {}

  explicit DeleteSilencePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSilencePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSilencePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSilencePolicyResponse() = default;
};
class DeleteSourceMapRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fidList{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};

  DeleteSourceMapRequest() {}

  explicit DeleteSourceMapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fidList) {
      res["FidList"] = boost::any(*fidList);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FidList") != m.end() && !m["FidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fidList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteSourceMapRequest() = default;
};
class DeleteSourceMapShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> fidListShrink{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};

  DeleteSourceMapShrinkRequest() {}

  explicit DeleteSourceMapShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fidListShrink) {
      res["FidList"] = boost::any(*fidListShrink);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FidList") != m.end() && !m["FidList"].empty()) {
      fidListShrink = make_shared<string>(boost::any_cast<string>(m["FidList"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteSourceMapShrinkRequest() = default;
};
class DeleteSourceMapResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DeleteSourceMapResponseBody() {}

  explicit DeleteSourceMapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSourceMapResponseBody() = default;
};
class DeleteSourceMapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSourceMapResponseBody> body{};

  DeleteSourceMapResponse() {}

  explicit DeleteSourceMapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSourceMapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSourceMapResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSourceMapResponse() = default;
};
class DeleteSyntheticTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> taskIds{};

  DeleteSyntheticTaskRequest() {}

  explicit DeleteSyntheticTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteSyntheticTaskRequest() = default;
};
class DeleteSyntheticTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteSyntheticTaskResponseBody() {}

  explicit DeleteSyntheticTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteSyntheticTaskResponseBody() = default;
};
class DeleteSyntheticTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSyntheticTaskResponseBody> body{};

  DeleteSyntheticTaskResponse() {}

  explicit DeleteSyntheticTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSyntheticTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSyntheticTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSyntheticTaskResponse() = default;
};
class DeleteTraceAppRequestDeleteReasonReasonIds : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  DeleteTraceAppRequestDeleteReasonReasonIds() {}

  explicit DeleteTraceAppRequestDeleteReasonReasonIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteTraceAppRequestDeleteReasonReasonIds() = default;
};
class DeleteTraceAppRequestDeleteReason : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteTraceAppRequestDeleteReasonReasonIds>> reasonIds{};
  shared_ptr<string> remark{};

  DeleteTraceAppRequestDeleteReason() {}

  explicit DeleteTraceAppRequestDeleteReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reasonIds) {
      vector<boost::any> temp1;
      for(auto item1:*reasonIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReasonIds"] = boost::any(temp1);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReasonIds") != m.end() && !m["ReasonIds"].empty()) {
      if (typeid(vector<boost::any>) == m["ReasonIds"].type()) {
        vector<DeleteTraceAppRequestDeleteReasonReasonIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReasonIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteTraceAppRequestDeleteReasonReasonIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reasonIds = make_shared<vector<DeleteTraceAppRequestDeleteReasonReasonIds>>(expect1);
      }
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~DeleteTraceAppRequestDeleteReason() = default;
};
class DeleteTraceAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<DeleteTraceAppRequestDeleteReason> deleteReason{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  DeleteTraceAppRequest() {}

  explicit DeleteTraceAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deleteReason) {
      res["DeleteReason"] = deleteReason ? boost::any(deleteReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeleteReason") != m.end() && !m["DeleteReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeleteReason"].type()) {
        DeleteTraceAppRequestDeleteReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeleteReason"]));
        deleteReason = make_shared<DeleteTraceAppRequestDeleteReason>(model1);
      }
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteTraceAppRequest() = default;
};
class DeleteTraceAppShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> deleteReasonShrink{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  DeleteTraceAppShrinkRequest() {}

  explicit DeleteTraceAppShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deleteReasonShrink) {
      res["DeleteReason"] = boost::any(*deleteReasonShrink);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeleteReason") != m.end() && !m["DeleteReason"].empty()) {
      deleteReasonShrink = make_shared<string>(boost::any_cast<string>(m["DeleteReason"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteTraceAppShrinkRequest() = default;
};
class DeleteTraceAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTraceAppResponseBody() {}

  explicit DeleteTraceAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTraceAppResponseBody() = default;
};
class DeleteTraceAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTraceAppResponseBody> body{};

  DeleteTraceAppResponse() {}

  explicit DeleteTraceAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTraceAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTraceAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTraceAppResponse() = default;
};
class DeleteWebhookContactRequest : public Darabonba::Model {
public:
  shared_ptr<long> webhookId{};

  DeleteWebhookContactRequest() {}

  explicit DeleteWebhookContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webhookId) {
      res["WebhookId"] = boost::any(*webhookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WebhookId") != m.end() && !m["WebhookId"].empty()) {
      webhookId = make_shared<long>(boost::any_cast<long>(m["WebhookId"]));
    }
  }


  virtual ~DeleteWebhookContactRequest() = default;
};
class DeleteWebhookContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  DeleteWebhookContactResponseBody() {}

  explicit DeleteWebhookContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWebhookContactResponseBody() = default;
};
class DeleteWebhookContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWebhookContactResponseBody> body{};

  DeleteWebhookContactResponse() {}

  explicit DeleteWebhookContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWebhookContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWebhookContactResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWebhookContactResponse() = default;
};
class DescribeContactGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> groupIds{};
  shared_ptr<bool> isDetail{};
  shared_ptr<long> page{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};

  DescribeContactGroupsRequest() {}

  explicit DescribeContactGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (isDetail) {
      res["IsDetail"] = boost::any(*isDetail);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      groupIds = make_shared<string>(boost::any_cast<string>(m["GroupIds"]));
    }
    if (m.find("IsDetail") != m.end() && !m["IsDetail"].empty()) {
      isDetail = make_shared<bool>(boost::any_cast<bool>(m["IsDetail"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeContactGroupsRequest() = default;
};
class DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts : public Darabonba::Model {
public:
  shared_ptr<long> armsContactId{};
  shared_ptr<double> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> email{};
  shared_ptr<string> phone{};

  DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts() {}

  explicit DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsContactId) {
      res["ArmsContactId"] = boost::any(*armsContactId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmsContactId") != m.end() && !m["ArmsContactId"].empty()) {
      armsContactId = make_shared<long>(boost::any_cast<long>(m["ArmsContactId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<double>(boost::any_cast<double>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts() = default;
};
class DescribeContactGroupsResponseBodyPageBeanAlertContactGroups : public Darabonba::Model {
public:
  shared_ptr<long> armsContactGroupId{};
  shared_ptr<double> contactGroupId{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts>> contacts{};

  DescribeContactGroupsResponseBodyPageBeanAlertContactGroups() {}

  explicit DescribeContactGroupsResponseBodyPageBeanAlertContactGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsContactGroupId) {
      res["ArmsContactGroupId"] = boost::any(*armsContactGroupId);
    }
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmsContactGroupId") != m.end() && !m["ArmsContactGroupId"].empty()) {
      armsContactGroupId = make_shared<long>(boost::any_cast<long>(m["ArmsContactGroupId"]));
    }
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<double>(boost::any_cast<double>(m["ContactGroupId"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts>>(expect1);
      }
    }
  }


  virtual ~DescribeContactGroupsResponseBodyPageBeanAlertContactGroups() = default;
};
class DescribeContactGroupsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroups>> alertContactGroups{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  DescribeContactGroupsResponseBodyPageBean() {}

  explicit DescribeContactGroupsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertContactGroups) {
      vector<boost::any> temp1;
      for(auto item1:*alertContactGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertContactGroups"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertContactGroups") != m.end() && !m["AlertContactGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertContactGroups"].type()) {
        vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertContactGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContactGroupsResponseBodyPageBeanAlertContactGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertContactGroups = make_shared<vector<DescribeContactGroupsResponseBodyPageBeanAlertContactGroups>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeContactGroupsResponseBodyPageBean() = default;
};
class DescribeContactGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeContactGroupsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  DescribeContactGroupsResponseBody() {}

  explicit DescribeContactGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        DescribeContactGroupsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<DescribeContactGroupsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeContactGroupsResponseBody() = default;
};
class DescribeContactGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContactGroupsResponseBody> body{};

  DescribeContactGroupsResponse() {}

  explicit DescribeContactGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContactGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContactGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContactGroupsResponse() = default;
};
class DescribeContactsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactIds{};
  shared_ptr<string> contactName{};
  shared_ptr<string> email{};
  shared_ptr<long> page{};
  shared_ptr<string> phone{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};
  shared_ptr<string> verbose{};

  DescribeContactsRequest() {}

  explicit DescribeContactsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (verbose) {
      res["Verbose"] = boost::any(*verbose);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Verbose") != m.end() && !m["Verbose"].empty()) {
      verbose = make_shared<string>(boost::any_cast<string>(m["Verbose"]));
    }
  }


  virtual ~DescribeContactsRequest() = default;
};
class DescribeContactsResponseBodyPageBeanAlertContacts : public Darabonba::Model {
public:
  shared_ptr<long> armsContactId{};
  shared_ptr<double> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> email{};
  shared_ptr<bool> isEmailVerify{};
  shared_ptr<bool> isVerify{};
  shared_ptr<string> phone{};
  shared_ptr<long> reissueSendNotice{};

  DescribeContactsResponseBodyPageBeanAlertContacts() {}

  explicit DescribeContactsResponseBodyPageBeanAlertContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsContactId) {
      res["ArmsContactId"] = boost::any(*armsContactId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (isEmailVerify) {
      res["IsEmailVerify"] = boost::any(*isEmailVerify);
    }
    if (isVerify) {
      res["IsVerify"] = boost::any(*isVerify);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (reissueSendNotice) {
      res["ReissueSendNotice"] = boost::any(*reissueSendNotice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmsContactId") != m.end() && !m["ArmsContactId"].empty()) {
      armsContactId = make_shared<long>(boost::any_cast<long>(m["ArmsContactId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<double>(boost::any_cast<double>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("IsEmailVerify") != m.end() && !m["IsEmailVerify"].empty()) {
      isEmailVerify = make_shared<bool>(boost::any_cast<bool>(m["IsEmailVerify"]));
    }
    if (m.find("IsVerify") != m.end() && !m["IsVerify"].empty()) {
      isVerify = make_shared<bool>(boost::any_cast<bool>(m["IsVerify"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ReissueSendNotice") != m.end() && !m["ReissueSendNotice"].empty()) {
      reissueSendNotice = make_shared<long>(boost::any_cast<long>(m["ReissueSendNotice"]));
    }
  }


  virtual ~DescribeContactsResponseBodyPageBeanAlertContacts() = default;
};
class DescribeContactsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeContactsResponseBodyPageBeanAlertContacts>> alertContacts{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  DescribeContactsResponseBodyPageBean() {}

  explicit DescribeContactsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertContacts) {
      vector<boost::any> temp1;
      for(auto item1:*alertContacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertContacts"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertContacts") != m.end() && !m["AlertContacts"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertContacts"].type()) {
        vector<DescribeContactsResponseBodyPageBeanAlertContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertContacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContactsResponseBodyPageBeanAlertContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertContacts = make_shared<vector<DescribeContactsResponseBodyPageBeanAlertContacts>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeContactsResponseBodyPageBean() = default;
};
class DescribeContactsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeContactsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  DescribeContactsResponseBody() {}

  explicit DescribeContactsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        DescribeContactsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<DescribeContactsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeContactsResponseBody() = default;
};
class DescribeContactsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContactsResponseBody> body{};

  DescribeContactsResponse() {}

  explicit DescribeContactsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContactsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContactsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContactsResponse() = default;
};
class DescribeDispatchRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  DescribeDispatchRuleRequest() {}

  explicit DescribeDispatchRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDispatchRuleRequest() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleGroupRules : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<long> groupInterval{};
  shared_ptr<long> groupWaitTime{};
  shared_ptr<vector<string>> groupingFields{};
  shared_ptr<long> repeatInterval{};

  DescribeDispatchRuleResponseBodyDispatchRuleGroupRules() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleGroupRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupInterval) {
      res["GroupInterval"] = boost::any(*groupInterval);
    }
    if (groupWaitTime) {
      res["GroupWaitTime"] = boost::any(*groupWaitTime);
    }
    if (groupingFields) {
      res["GroupingFields"] = boost::any(*groupingFields);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupInterval") != m.end() && !m["GroupInterval"].empty()) {
      groupInterval = make_shared<long>(boost::any_cast<long>(m["GroupInterval"]));
    }
    if (m.find("GroupWaitTime") != m.end() && !m["GroupWaitTime"].empty()) {
      groupWaitTime = make_shared<long>(boost::any_cast<long>(m["GroupWaitTime"]));
    }
    if (m.find("GroupingFields") != m.end() && !m["GroupingFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupingFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupingFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupingFields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleGroupRules() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions>> labelMatchExpressions{};

  DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelMatchExpressions) {
      vector<boost::any> temp1;
      for(auto item1:*labelMatchExpressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LabelMatchExpressions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LabelMatchExpressions") != m.end() && !m["LabelMatchExpressions"].empty()) {
      if (typeid(vector<boost::any>) == m["LabelMatchExpressions"].type()) {
        vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LabelMatchExpressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labelMatchExpressions = make_shared<vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions>>(expect1);
      }
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups>> labelMatchExpressionGroups{};

  DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelMatchExpressionGroups) {
      vector<boost::any> temp1;
      for(auto item1:*labelMatchExpressionGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LabelMatchExpressionGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LabelMatchExpressionGroups") != m.end() && !m["LabelMatchExpressionGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["LabelMatchExpressionGroups"].type()) {
        vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LabelMatchExpressionGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labelMatchExpressionGroups = make_shared<vector<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups>>(expect1);
      }
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> notifyObjectId{};
  shared_ptr<string> notifyType{};

  DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyObjectId) {
      res["NotifyObjectId"] = boost::any(*notifyObjectId);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyObjectId") != m.end() && !m["NotifyObjectId"].empty()) {
      notifyObjectId = make_shared<string>(boost::any_cast<string>(m["NotifyObjectId"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects>> notifyObjects{};

  DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyChannels) {
      res["NotifyChannels"] = boost::any(*notifyChannels);
    }
    if (notifyObjects) {
      vector<boost::any> temp1;
      for(auto item1:*notifyObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotifyObjects"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyChannels") != m.end() && !m["NotifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyObjects") != m.end() && !m["NotifyObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["NotifyObjects"].type()) {
        vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotifyObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyObjects = make_shared<vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects>>(expect1);
      }
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules() = default;
};
class DescribeDispatchRuleResponseBodyDispatchRule : public Darabonba::Model {
public:
  shared_ptr<string> dispatchType{};
  shared_ptr<vector<DescribeDispatchRuleResponseBodyDispatchRuleGroupRules>> groupRules{};
  shared_ptr<bool> isRecover{};
  shared_ptr<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid> labelMatchExpressionGrid{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules>> notifyRules{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> state{};

  DescribeDispatchRuleResponseBodyDispatchRule() {}

  explicit DescribeDispatchRuleResponseBodyDispatchRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchType) {
      res["DispatchType"] = boost::any(*dispatchType);
    }
    if (groupRules) {
      vector<boost::any> temp1;
      for(auto item1:*groupRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupRules"] = boost::any(temp1);
    }
    if (isRecover) {
      res["IsRecover"] = boost::any(*isRecover);
    }
    if (labelMatchExpressionGrid) {
      res["LabelMatchExpressionGrid"] = labelMatchExpressionGrid ? boost::any(labelMatchExpressionGrid->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyRules) {
      vector<boost::any> temp1;
      for(auto item1:*notifyRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotifyRules"] = boost::any(temp1);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchType") != m.end() && !m["DispatchType"].empty()) {
      dispatchType = make_shared<string>(boost::any_cast<string>(m["DispatchType"]));
    }
    if (m.find("GroupRules") != m.end() && !m["GroupRules"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupRules"].type()) {
        vector<DescribeDispatchRuleResponseBodyDispatchRuleGroupRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDispatchRuleResponseBodyDispatchRuleGroupRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupRules = make_shared<vector<DescribeDispatchRuleResponseBodyDispatchRuleGroupRules>>(expect1);
      }
    }
    if (m.find("IsRecover") != m.end() && !m["IsRecover"].empty()) {
      isRecover = make_shared<bool>(boost::any_cast<bool>(m["IsRecover"]));
    }
    if (m.find("LabelMatchExpressionGrid") != m.end() && !m["LabelMatchExpressionGrid"].empty()) {
      if (typeid(map<string, boost::any>) == m["LabelMatchExpressionGrid"].type()) {
        DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LabelMatchExpressionGrid"]));
        labelMatchExpressionGrid = make_shared<DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyRules") != m.end() && !m["NotifyRules"].empty()) {
      if (typeid(vector<boost::any>) == m["NotifyRules"].type()) {
        vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotifyRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyRules = make_shared<vector<DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules>>(expect1);
      }
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeDispatchRuleResponseBodyDispatchRule() = default;
};
class DescribeDispatchRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDispatchRuleResponseBodyDispatchRule> dispatchRule{};
  shared_ptr<string> requestId{};

  DescribeDispatchRuleResponseBody() {}

  explicit DescribeDispatchRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchRule) {
      res["DispatchRule"] = dispatchRule ? boost::any(dispatchRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchRule") != m.end() && !m["DispatchRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["DispatchRule"].type()) {
        DescribeDispatchRuleResponseBodyDispatchRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DispatchRule"]));
        dispatchRule = make_shared<DescribeDispatchRuleResponseBodyDispatchRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDispatchRuleResponseBody() = default;
};
class DescribeDispatchRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDispatchRuleResponseBody> body{};

  DescribeDispatchRuleResponse() {}

  explicit DescribeDispatchRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDispatchRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDispatchRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDispatchRuleResponse() = default;
};
class DescribeIMRobotsRequest : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<string> robotIds{};
  shared_ptr<string> robotName{};
  shared_ptr<long> size{};

  DescribeIMRobotsRequest() {}

  explicit DescribeIMRobotsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (robotIds) {
      res["RobotIds"] = boost::any(*robotIds);
    }
    if (robotName) {
      res["RobotName"] = boost::any(*robotName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("RobotIds") != m.end() && !m["RobotIds"].empty()) {
      robotIds = make_shared<string>(boost::any_cast<string>(m["RobotIds"]));
    }
    if (m.find("RobotName") != m.end() && !m["RobotName"].empty()) {
      robotName = make_shared<string>(boost::any_cast<string>(m["RobotName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeIMRobotsRequest() = default;
};
class DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules() {}

  explicit DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules() = default;
};
class DescribeIMRobotsResponseBodyPageBeanAlertIMRobots : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<bool> dailyNoc{};
  shared_ptr<string> dailyNocTime{};
  shared_ptr<string> dingSignKey{};
  shared_ptr<vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules>> dispatchRules{};
  shared_ptr<string> robotAddr{};
  shared_ptr<double> robotId{};
  shared_ptr<string> robotName{};
  shared_ptr<string> type{};

  DescribeIMRobotsResponseBodyPageBeanAlertIMRobots() {}

  explicit DescribeIMRobotsResponseBodyPageBeanAlertIMRobots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dailyNoc) {
      res["DailyNoc"] = boost::any(*dailyNoc);
    }
    if (dailyNocTime) {
      res["DailyNocTime"] = boost::any(*dailyNocTime);
    }
    if (dingSignKey) {
      res["DingSignKey"] = boost::any(*dingSignKey);
    }
    if (dispatchRules) {
      vector<boost::any> temp1;
      for(auto item1:*dispatchRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DispatchRules"] = boost::any(temp1);
    }
    if (robotAddr) {
      res["RobotAddr"] = boost::any(*robotAddr);
    }
    if (robotId) {
      res["RobotId"] = boost::any(*robotId);
    }
    if (robotName) {
      res["RobotName"] = boost::any(*robotName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DailyNoc") != m.end() && !m["DailyNoc"].empty()) {
      dailyNoc = make_shared<bool>(boost::any_cast<bool>(m["DailyNoc"]));
    }
    if (m.find("DailyNocTime") != m.end() && !m["DailyNocTime"].empty()) {
      dailyNocTime = make_shared<string>(boost::any_cast<string>(m["DailyNocTime"]));
    }
    if (m.find("DingSignKey") != m.end() && !m["DingSignKey"].empty()) {
      dingSignKey = make_shared<string>(boost::any_cast<string>(m["DingSignKey"]));
    }
    if (m.find("DispatchRules") != m.end() && !m["DispatchRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DispatchRules"].type()) {
        vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DispatchRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dispatchRules = make_shared<vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules>>(expect1);
      }
    }
    if (m.find("RobotAddr") != m.end() && !m["RobotAddr"].empty()) {
      robotAddr = make_shared<string>(boost::any_cast<string>(m["RobotAddr"]));
    }
    if (m.find("RobotId") != m.end() && !m["RobotId"].empty()) {
      robotId = make_shared<double>(boost::any_cast<double>(m["RobotId"]));
    }
    if (m.find("RobotName") != m.end() && !m["RobotName"].empty()) {
      robotName = make_shared<string>(boost::any_cast<string>(m["RobotName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeIMRobotsResponseBodyPageBeanAlertIMRobots() = default;
};
class DescribeIMRobotsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobots>> alertIMRobots{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  DescribeIMRobotsResponseBodyPageBean() {}

  explicit DescribeIMRobotsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertIMRobots) {
      vector<boost::any> temp1;
      for(auto item1:*alertIMRobots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertIMRobots"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertIMRobots") != m.end() && !m["AlertIMRobots"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertIMRobots"].type()) {
        vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertIMRobots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIMRobotsResponseBodyPageBeanAlertIMRobots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertIMRobots = make_shared<vector<DescribeIMRobotsResponseBodyPageBeanAlertIMRobots>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeIMRobotsResponseBodyPageBean() = default;
};
class DescribeIMRobotsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIMRobotsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  DescribeIMRobotsResponseBody() {}

  explicit DescribeIMRobotsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        DescribeIMRobotsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<DescribeIMRobotsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeIMRobotsResponseBody() = default;
};
class DescribeIMRobotsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIMRobotsResponseBody> body{};

  DescribeIMRobotsResponse() {}

  explicit DescribeIMRobotsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIMRobotsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIMRobotsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIMRobotsResponse() = default;
};
class DescribePrometheusAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> clusterId{};

  DescribePrometheusAlertRuleRequest() {}

  explicit DescribePrometheusAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribePrometheusAlertRuleRequest() = default;
};
class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() {}

  explicit DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() = default;
};
class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() {}

  explicit DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() = default;
};
class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule() {}

  explicit DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>>(expect1);
      }
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule() = default;
};
class DescribePrometheusAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule> prometheusAlertRule{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribePrometheusAlertRuleResponseBody() {}

  explicit DescribePrometheusAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (prometheusAlertRule) {
      res["PrometheusAlertRule"] = prometheusAlertRule ? boost::any(prometheusAlertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PrometheusAlertRule") != m.end() && !m["PrometheusAlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrometheusAlertRule"].type()) {
        DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrometheusAlertRule"]));
        prometheusAlertRule = make_shared<DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribePrometheusAlertRuleResponseBody() = default;
};
class DescribePrometheusAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePrometheusAlertRuleResponseBody> body{};

  DescribePrometheusAlertRuleResponse() {}

  explicit DescribePrometheusAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePrometheusAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePrometheusAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePrometheusAlertRuleResponse() = default;
};
class DescribeTraceLicenseKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeTraceLicenseKeyRequest() {}

  explicit DescribeTraceLicenseKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeTraceLicenseKeyRequest() = default;
};
class DescribeTraceLicenseKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> licenseKey{};
  shared_ptr<string> requestId{};

  DescribeTraceLicenseKeyResponseBody() {}

  explicit DescribeTraceLicenseKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (licenseKey) {
      res["LicenseKey"] = boost::any(*licenseKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LicenseKey") != m.end() && !m["LicenseKey"].empty()) {
      licenseKey = make_shared<string>(boost::any_cast<string>(m["LicenseKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeTraceLicenseKeyResponseBody() = default;
};
class DescribeTraceLicenseKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTraceLicenseKeyResponseBody> body{};

  DescribeTraceLicenseKeyResponse() {}

  explicit DescribeTraceLicenseKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTraceLicenseKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTraceLicenseKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTraceLicenseKeyResponse() = default;
};
class DescribeWebhookContactsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactIds{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<string> webhookName{};

  DescribeWebhookContactsRequest() {}

  explicit DescribeWebhookContactsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (webhookName) {
      res["WebhookName"] = boost::any(*webhookName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("WebhookName") != m.end() && !m["WebhookName"].empty()) {
      webhookName = make_shared<string>(boost::any_cast<string>(m["WebhookName"]));
    }
  }


  virtual ~DescribeWebhookContactsRequest() = default;
};
class DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> bizHeaders{};
  shared_ptr<map<string, boost::any>> bizParams{};
  shared_ptr<string> body{};
  shared_ptr<string> method{};
  shared_ptr<string> recoverBody{};
  shared_ptr<string> url{};

  DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook() {}

  explicit DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizHeaders) {
      res["BizHeaders"] = boost::any(*bizHeaders);
    }
    if (bizParams) {
      res["BizParams"] = boost::any(*bizParams);
    }
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (recoverBody) {
      res["RecoverBody"] = boost::any(*recoverBody);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizHeaders") != m.end() && !m["BizHeaders"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["BizHeaders"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bizHeaders = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("BizParams") != m.end() && !m["BizParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["BizParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bizParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("RecoverBody") != m.end() && !m["RecoverBody"].empty()) {
      recoverBody = make_shared<string>(boost::any_cast<string>(m["RecoverBody"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook() = default;
};
class DescribeWebhookContactsResponseBodyPageBeanWebhookContacts : public Darabonba::Model {
public:
  shared_ptr<DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook> webhook{};
  shared_ptr<double> webhookId{};
  shared_ptr<string> webhookName{};

  DescribeWebhookContactsResponseBodyPageBeanWebhookContacts() {}

  explicit DescribeWebhookContactsResponseBodyPageBeanWebhookContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webhook) {
      res["Webhook"] = webhook ? boost::any(webhook->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webhookId) {
      res["WebhookId"] = boost::any(*webhookId);
    }
    if (webhookName) {
      res["WebhookName"] = boost::any(*webhookName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webhook"].type()) {
        DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webhook"]));
        webhook = make_shared<DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook>(model1);
      }
    }
    if (m.find("WebhookId") != m.end() && !m["WebhookId"].empty()) {
      webhookId = make_shared<double>(boost::any_cast<double>(m["WebhookId"]));
    }
    if (m.find("WebhookName") != m.end() && !m["WebhookName"].empty()) {
      webhookName = make_shared<string>(boost::any_cast<string>(m["WebhookName"]));
    }
  }


  virtual ~DescribeWebhookContactsResponseBodyPageBeanWebhookContacts() = default;
};
class DescribeWebhookContactsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};
  shared_ptr<vector<DescribeWebhookContactsResponseBodyPageBeanWebhookContacts>> webhookContacts{};

  DescribeWebhookContactsResponseBodyPageBean() {}

  explicit DescribeWebhookContactsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (webhookContacts) {
      vector<boost::any> temp1;
      for(auto item1:*webhookContacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebhookContacts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("WebhookContacts") != m.end() && !m["WebhookContacts"].empty()) {
      if (typeid(vector<boost::any>) == m["WebhookContacts"].type()) {
        vector<DescribeWebhookContactsResponseBodyPageBeanWebhookContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebhookContacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebhookContactsResponseBodyPageBeanWebhookContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webhookContacts = make_shared<vector<DescribeWebhookContactsResponseBodyPageBeanWebhookContacts>>(expect1);
      }
    }
  }


  virtual ~DescribeWebhookContactsResponseBodyPageBean() = default;
};
class DescribeWebhookContactsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeWebhookContactsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  DescribeWebhookContactsResponseBody() {}

  explicit DescribeWebhookContactsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        DescribeWebhookContactsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<DescribeWebhookContactsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeWebhookContactsResponseBody() = default;
};
class DescribeWebhookContactsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebhookContactsResponseBody> body{};

  DescribeWebhookContactsResponse() {}

  explicit DescribeWebhookContactsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebhookContactsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebhookContactsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebhookContactsResponse() = default;
};
class EnableMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dropMetric{};
  shared_ptr<string> regionId{};

  EnableMetricRequest() {}

  explicit EnableMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dropMetric) {
      res["DropMetric"] = boost::any(*dropMetric);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DropMetric") != m.end() && !m["DropMetric"].empty()) {
      dropMetric = make_shared<string>(boost::any_cast<string>(m["DropMetric"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~EnableMetricRequest() = default;
};
class EnableMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableMetricResponseBody() {}

  explicit EnableMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableMetricResponseBody() = default;
};
class EnableMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableMetricResponseBody> body{};

  EnableMetricResponse() {}

  explicit EnableMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableMetricResponseBody>(model1);
      }
    }
  }


  virtual ~EnableMetricResponse() = default;
};
class GetAgentDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  GetAgentDownloadUrlRequest() {}

  explicit GetAgentDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetAgentDownloadUrlRequest() = default;
};
class GetAgentDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> armsAgentDownloadUrl{};
  shared_ptr<string> requestId{};

  GetAgentDownloadUrlResponseBody() {}

  explicit GetAgentDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsAgentDownloadUrl) {
      res["ArmsAgentDownloadUrl"] = boost::any(*armsAgentDownloadUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmsAgentDownloadUrl") != m.end() && !m["ArmsAgentDownloadUrl"].empty()) {
      armsAgentDownloadUrl = make_shared<string>(boost::any_cast<string>(m["ArmsAgentDownloadUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAgentDownloadUrlResponseBody() = default;
};
class GetAgentDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAgentDownloadUrlResponseBody> body{};

  GetAgentDownloadUrlResponse() {}

  explicit GetAgentDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAgentDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAgentDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetAgentDownloadUrlResponse() = default;
};
class GetAlertRulesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetAlertRulesRequestTags() {}

  explicit GetAlertRulesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesRequestTags() = default;
};
class GetAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertIds{};
  shared_ptr<string> alertNames{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> alertType{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> page{};
  shared_ptr<string> productCode{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};
  shared_ptr<vector<GetAlertRulesRequestTags>> tags{};

  GetAlertRulesRequest() {}

  explicit GetAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertIds) {
      res["AlertIds"] = boost::any(*alertIds);
    }
    if (alertNames) {
      res["AlertNames"] = boost::any(*alertNames);
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertIds") != m.end() && !m["AlertIds"].empty()) {
      alertIds = make_shared<string>(boost::any_cast<string>(m["AlertIds"]));
    }
    if (m.find("AlertNames") != m.end() && !m["AlertNames"].empty()) {
      alertNames = make_shared<string>(boost::any_cast<string>(m["AlertNames"]));
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<string>(boost::any_cast<string>(m["AlertType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetAlertRulesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetAlertRulesRequestTags>>(expect1);
      }
    }
  }


  virtual ~GetAlertRulesRequest() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems : public Darabonba::Model {
public:
  shared_ptr<string> aggregate{};
  shared_ptr<string> metricKey{};
  shared_ptr<double> n{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregate) {
      res["Aggregate"] = boost::any(*aggregate);
    }
    if (metricKey) {
      res["MetricKey"] = boost::any(*metricKey);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregate") != m.end() && !m["Aggregate"].empty()) {
      aggregate = make_shared<string>(boost::any_cast<string>(m["Aggregate"]));
    }
    if (m.find("MetricKey") != m.end() && !m["MetricKey"].empty()) {
      metricKey = make_shared<string>(boost::any_cast<string>(m["MetricKey"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<double>(boost::any_cast<double>(m["N"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent : public Darabonba::Model {
public:
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems>> alertRuleItems{};
  shared_ptr<string> condition{};

  GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRuleItems) {
      vector<boost::any> temp1;
      for(auto item1:*alertRuleItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertRuleItems"] = boost::any(temp1);
    }
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRuleItems") != m.end() && !m["AlertRuleItems"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertRuleItems"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertRuleItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertRuleItems = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems>>(expect1);
      }
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opt{};
  shared_ptr<bool> show{};
  shared_ptr<string> t{};
  shared_ptr<string> value{};

  GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opt) {
      res["Opt"] = boost::any(*opt);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (t) {
      res["T"] = boost::any(*t);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Opt") != m.end() && !m["Opt"].empty()) {
      opt = make_shared<string>(boost::any_cast<string>(m["Opt"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("T") != m.end() && !m["T"].empty()) {
      t = make_shared<string>(boost::any_cast<string>(m["T"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters : public Darabonba::Model {
public:
  shared_ptr<string> filterKey{};
  shared_ptr<string> filterOpt{};
  shared_ptr<vector<string>> filterValues{};

  GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterKey) {
      res["FilterKey"] = boost::any(*filterKey);
    }
    if (filterOpt) {
      res["FilterOpt"] = boost::any(*filterOpt);
    }
    if (filterValues) {
      res["FilterValues"] = boost::any(*filterValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterKey") != m.end() && !m["FilterKey"].empty()) {
      filterKey = make_shared<string>(boost::any_cast<string>(m["FilterKey"]));
    }
    if (m.find("FilterOpt") != m.end() && !m["FilterOpt"].empty()) {
      filterOpt = make_shared<string>(boost::any_cast<string>(m["FilterOpt"]));
    }
    if (m.find("FilterValues") != m.end() && !m["FilterValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesFilters : public Darabonba::Model {
public:
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters>> customSLSFilters{};
  shared_ptr<vector<string>> customSLSGroupByDimensions{};
  shared_ptr<vector<string>> customSLSWheres{};
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters>> dimFilters{};

  GetAlertRulesResponseBodyPageBeanAlertRulesFilters() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSLSFilters) {
      vector<boost::any> temp1;
      for(auto item1:*customSLSFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSLSFilters"] = boost::any(temp1);
    }
    if (customSLSGroupByDimensions) {
      res["CustomSLSGroupByDimensions"] = boost::any(*customSLSGroupByDimensions);
    }
    if (customSLSWheres) {
      res["CustomSLSWheres"] = boost::any(*customSLSWheres);
    }
    if (dimFilters) {
      vector<boost::any> temp1;
      for(auto item1:*dimFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DimFilters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSLSFilters") != m.end() && !m["CustomSLSFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSLSFilters"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSLSFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSLSFilters = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters>>(expect1);
      }
    }
    if (m.find("CustomSLSGroupByDimensions") != m.end() && !m["CustomSLSGroupByDimensions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomSLSGroupByDimensions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomSLSGroupByDimensions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customSLSGroupByDimensions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomSLSWheres") != m.end() && !m["CustomSLSWheres"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomSLSWheres"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomSLSWheres"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customSLSWheres = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DimFilters") != m.end() && !m["DimFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["DimFilters"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DimFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimFilters = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters>>(expect1);
      }
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesFilters() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  GetAlertRulesResponseBodyPageBeanAlertRulesLabels() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesLabels() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRulesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetAlertRulesResponseBodyPageBeanAlertRulesTags() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRulesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRulesTags() = default;
};
class GetAlertRulesResponseBodyPageBeanAlertRules : public Darabonba::Model {
public:
  shared_ptr<string> alertCheckType{};
  shared_ptr<long> alertGroup{};
  shared_ptr<double> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent> alertRuleContent{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> alertType{};
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations>> annotations{};
  shared_ptr<bool> autoAddNewApplication{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> extend{};
  shared_ptr<GetAlertRulesResponseBodyPageBeanAlertRulesFilters> filters{};
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesLabels>> labels{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<string> metricsType{};
  shared_ptr<string> notifyStrategy{};
  shared_ptr<vector<string>> pids{};
  shared_ptr<string> promQL{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRulesTags>> tags{};
  shared_ptr<long> updatedTime{};
  shared_ptr<string> userId{};

  GetAlertRulesResponseBodyPageBeanAlertRules() {}

  explicit GetAlertRulesResponseBodyPageBeanAlertRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertCheckType) {
      res["AlertCheckType"] = boost::any(*alertCheckType);
    }
    if (alertGroup) {
      res["AlertGroup"] = boost::any(*alertGroup);
    }
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertRuleContent) {
      res["AlertRuleContent"] = alertRuleContent ? boost::any(alertRuleContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (autoAddNewApplication) {
      res["AutoAddNewApplication"] = boost::any(*autoAddNewApplication);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (filters) {
      res["Filters"] = filters ? boost::any(filters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (metricsType) {
      res["MetricsType"] = boost::any(*metricsType);
    }
    if (notifyStrategy) {
      res["NotifyStrategy"] = boost::any(*notifyStrategy);
    }
    if (pids) {
      res["Pids"] = boost::any(*pids);
    }
    if (promQL) {
      res["PromQL"] = boost::any(*promQL);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertCheckType") != m.end() && !m["AlertCheckType"].empty()) {
      alertCheckType = make_shared<string>(boost::any_cast<string>(m["AlertCheckType"]));
    }
    if (m.find("AlertGroup") != m.end() && !m["AlertGroup"].empty()) {
      alertGroup = make_shared<long>(boost::any_cast<long>(m["AlertGroup"]));
    }
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<double>(boost::any_cast<double>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertRuleContent") != m.end() && !m["AlertRuleContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRuleContent"].type()) {
        GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRuleContent"]));
        alertRuleContent = make_shared<GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent>(model1);
      }
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<string>(boost::any_cast<string>(m["AlertType"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations>>(expect1);
      }
    }
    if (m.find("AutoAddNewApplication") != m.end() && !m["AutoAddNewApplication"].empty()) {
      autoAddNewApplication = make_shared<bool>(boost::any_cast<bool>(m["AutoAddNewApplication"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filters"].type()) {
        GetAlertRulesResponseBodyPageBeanAlertRulesFilters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filters"]));
        filters = make_shared<GetAlertRulesResponseBodyPageBeanAlertRulesFilters>(model1);
      }
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesLabels>>(expect1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MetricsType") != m.end() && !m["MetricsType"].empty()) {
      metricsType = make_shared<string>(boost::any_cast<string>(m["MetricsType"]));
    }
    if (m.find("NotifyStrategy") != m.end() && !m["NotifyStrategy"].empty()) {
      notifyStrategy = make_shared<string>(boost::any_cast<string>(m["NotifyStrategy"]));
    }
    if (m.find("Pids") != m.end() && !m["Pids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Pids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Pids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PromQL") != m.end() && !m["PromQL"].empty()) {
      promQL = make_shared<string>(boost::any_cast<string>(m["PromQL"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRulesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRulesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRulesTags>>(expect1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBeanAlertRules() = default;
};
class GetAlertRulesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<GetAlertRulesResponseBodyPageBeanAlertRules>> alertRules{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  GetAlertRulesResponseBodyPageBean() {}

  explicit GetAlertRulesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRules) {
      vector<boost::any> temp1;
      for(auto item1:*alertRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertRules"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRules") != m.end() && !m["AlertRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertRules"].type()) {
        vector<GetAlertRulesResponseBodyPageBeanAlertRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertRulesResponseBodyPageBeanAlertRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertRules = make_shared<vector<GetAlertRulesResponseBodyPageBeanAlertRules>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetAlertRulesResponseBodyPageBean() = default;
};
class GetAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAlertRulesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  GetAlertRulesResponseBody() {}

  explicit GetAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        GetAlertRulesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<GetAlertRulesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAlertRulesResponseBody() = default;
};
class GetAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAlertRulesResponseBody> body{};

  GetAlertRulesResponse() {}

  explicit GetAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~GetAlertRulesResponse() = default;
};
class GetAppApiByPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<long> intervalMills{};
  shared_ptr<string> PId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  GetAppApiByPageRequest() {}

  explicit GetAppApiByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (intervalMills) {
      res["IntervalMills"] = boost::any(*intervalMills);
    }
    if (PId) {
      res["PId"] = boost::any(*PId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("IntervalMills") != m.end() && !m["IntervalMills"].empty()) {
      intervalMills = make_shared<long>(boost::any_cast<long>(m["IntervalMills"]));
    }
    if (m.find("PId") != m.end() && !m["PId"].empty()) {
      PId = make_shared<string>(boost::any_cast<string>(m["PId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetAppApiByPageRequest() = default;
};
class GetAppApiByPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> completed{};
  shared_ptr<vector<map<string, boost::any>>> items{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> total{};

  GetAppApiByPageResponseBodyData() {}

  explicit GetAppApiByPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completed) {
      res["Completed"] = boost::any(*completed);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Completed") != m.end() && !m["Completed"].empty()) {
      completed = make_shared<bool>(boost::any_cast<bool>(m["Completed"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      items = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
  }


  virtual ~GetAppApiByPageResponseBodyData() = default;
};
class GetAppApiByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetAppApiByPageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAppApiByPageResponseBody() {}

  explicit GetAppApiByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAppApiByPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAppApiByPageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAppApiByPageResponseBody() = default;
};
class GetAppApiByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAppApiByPageResponseBody> body{};

  GetAppApiByPageResponse() {}

  explicit GetAppApiByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAppApiByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAppApiByPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetAppApiByPageResponse() = default;
};
class GetAuthTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetAuthTokenRequest() {}

  explicit GetAuthTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetAuthTokenRequest() = default;
};
class GetAuthTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAuthTokenResponseBody() {}

  explicit GetAuthTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAuthTokenResponseBody() = default;
};
class GetAuthTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAuthTokenResponseBody> body{};

  GetAuthTokenResponse() {}

  explicit GetAuthTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAuthTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAuthTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GetAuthTokenResponse() = default;
};
class GetCloudClusterAllUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetCloudClusterAllUrlRequest() {}

  explicit GetCloudClusterAllUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetCloudClusterAllUrlRequest() = default;
};
class GetCloudClusterAllUrlResponseBodyDataRemoteUrl : public Darabonba::Model {
public:
  shared_ptr<bool> authToken{};
  shared_ptr<string> grafanaUrl{};
  shared_ptr<string> internetGrafanaUrl{};
  shared_ptr<string> internetPushGatewayUrl{};
  shared_ptr<string> internetRemoteReadUrl{};
  shared_ptr<string> internetRemoteWriteUrl{};
  shared_ptr<string> pushGatewayUrl{};
  shared_ptr<string> remoteReadUrl{};
  shared_ptr<string> remoteWriteUrl{};
  shared_ptr<string> token{};

  GetCloudClusterAllUrlResponseBodyDataRemoteUrl() {}

  explicit GetCloudClusterAllUrlResponseBodyDataRemoteUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (grafanaUrl) {
      res["GrafanaUrl"] = boost::any(*grafanaUrl);
    }
    if (internetGrafanaUrl) {
      res["InternetGrafanaUrl"] = boost::any(*internetGrafanaUrl);
    }
    if (internetPushGatewayUrl) {
      res["InternetPushGatewayUrl"] = boost::any(*internetPushGatewayUrl);
    }
    if (internetRemoteReadUrl) {
      res["InternetRemoteReadUrl"] = boost::any(*internetRemoteReadUrl);
    }
    if (internetRemoteWriteUrl) {
      res["InternetRemoteWriteUrl"] = boost::any(*internetRemoteWriteUrl);
    }
    if (pushGatewayUrl) {
      res["PushGatewayUrl"] = boost::any(*pushGatewayUrl);
    }
    if (remoteReadUrl) {
      res["RemoteReadUrl"] = boost::any(*remoteReadUrl);
    }
    if (remoteWriteUrl) {
      res["RemoteWriteUrl"] = boost::any(*remoteWriteUrl);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<bool>(boost::any_cast<bool>(m["AuthToken"]));
    }
    if (m.find("GrafanaUrl") != m.end() && !m["GrafanaUrl"].empty()) {
      grafanaUrl = make_shared<string>(boost::any_cast<string>(m["GrafanaUrl"]));
    }
    if (m.find("InternetGrafanaUrl") != m.end() && !m["InternetGrafanaUrl"].empty()) {
      internetGrafanaUrl = make_shared<string>(boost::any_cast<string>(m["InternetGrafanaUrl"]));
    }
    if (m.find("InternetPushGatewayUrl") != m.end() && !m["InternetPushGatewayUrl"].empty()) {
      internetPushGatewayUrl = make_shared<string>(boost::any_cast<string>(m["InternetPushGatewayUrl"]));
    }
    if (m.find("InternetRemoteReadUrl") != m.end() && !m["InternetRemoteReadUrl"].empty()) {
      internetRemoteReadUrl = make_shared<string>(boost::any_cast<string>(m["InternetRemoteReadUrl"]));
    }
    if (m.find("InternetRemoteWriteUrl") != m.end() && !m["InternetRemoteWriteUrl"].empty()) {
      internetRemoteWriteUrl = make_shared<string>(boost::any_cast<string>(m["InternetRemoteWriteUrl"]));
    }
    if (m.find("PushGatewayUrl") != m.end() && !m["PushGatewayUrl"].empty()) {
      pushGatewayUrl = make_shared<string>(boost::any_cast<string>(m["PushGatewayUrl"]));
    }
    if (m.find("RemoteReadUrl") != m.end() && !m["RemoteReadUrl"].empty()) {
      remoteReadUrl = make_shared<string>(boost::any_cast<string>(m["RemoteReadUrl"]));
    }
    if (m.find("RemoteWriteUrl") != m.end() && !m["RemoteWriteUrl"].empty()) {
      remoteWriteUrl = make_shared<string>(boost::any_cast<string>(m["RemoteWriteUrl"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~GetCloudClusterAllUrlResponseBodyDataRemoteUrl() = default;
};
class GetCloudClusterAllUrlResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> productCode{};
  shared_ptr<string> region{};
  shared_ptr<GetCloudClusterAllUrlResponseBodyDataRemoteUrl> remoteUrl{};

  GetCloudClusterAllUrlResponseBodyData() {}

  explicit GetCloudClusterAllUrlResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (remoteUrl) {
      res["RemoteUrl"] = remoteUrl ? boost::any(remoteUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RemoteUrl") != m.end() && !m["RemoteUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["RemoteUrl"].type()) {
        GetCloudClusterAllUrlResponseBodyDataRemoteUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RemoteUrl"]));
        remoteUrl = make_shared<GetCloudClusterAllUrlResponseBodyDataRemoteUrl>(model1);
      }
    }
  }


  virtual ~GetCloudClusterAllUrlResponseBodyData() = default;
};
class GetCloudClusterAllUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetCloudClusterAllUrlResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCloudClusterAllUrlResponseBody() {}

  explicit GetCloudClusterAllUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetCloudClusterAllUrlResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCloudClusterAllUrlResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetCloudClusterAllUrlResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCloudClusterAllUrlResponseBody() = default;
};
class GetCloudClusterAllUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCloudClusterAllUrlResponseBody> body{};

  GetCloudClusterAllUrlResponse() {}

  explicit GetCloudClusterAllUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCloudClusterAllUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCloudClusterAllUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetCloudClusterAllUrlResponse() = default;
};
class GetClusterAllUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetClusterAllUrlRequest() {}

  explicit GetClusterAllUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetClusterAllUrlRequest() = default;
};
class GetClusterAllUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetClusterAllUrlResponseBody() {}

  explicit GetClusterAllUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetClusterAllUrlResponseBody() = default;
};
class GetClusterAllUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterAllUrlResponseBody> body{};

  GetClusterAllUrlResponse() {}

  explicit GetClusterAllUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterAllUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterAllUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterAllUrlResponse() = default;
};
class GetExploreUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> expression{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  GetExploreUrlRequest() {}

  explicit GetExploreUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetExploreUrlRequest() = default;
};
class GetExploreUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetExploreUrlResponseBody() {}

  explicit GetExploreUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetExploreUrlResponseBody() = default;
};
class GetExploreUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetExploreUrlResponseBody> body{};

  GetExploreUrlResponse() {}

  explicit GetExploreUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetExploreUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetExploreUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetExploreUrlResponse() = default;
};
class GetIntegrationStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integration{};
  shared_ptr<string> regionId{};

  GetIntegrationStateRequest() {}

  explicit GetIntegrationStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integration) {
      res["Integration"] = boost::any(*integration);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      integration = make_shared<string>(boost::any_cast<string>(m["Integration"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetIntegrationStateRequest() = default;
};
class GetIntegrationStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> state{};

  GetIntegrationStateResponseBody() {}

  explicit GetIntegrationStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<bool>(boost::any_cast<bool>(m["State"]));
    }
  }


  virtual ~GetIntegrationStateResponseBody() = default;
};
class GetIntegrationStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIntegrationStateResponseBody> body{};

  GetIntegrationStateResponse() {}

  explicit GetIntegrationStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIntegrationStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIntegrationStateResponseBody>(model1);
      }
    }
  }


  virtual ~GetIntegrationStateResponse() = default;
};
class GetManagedPrometheusStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vpcId{};

  GetManagedPrometheusStatusRequest() {}

  explicit GetManagedPrometheusStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetManagedPrometheusStatusRequest() = default;
};
class GetManagedPrometheusStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetManagedPrometheusStatusResponseBody() {}

  explicit GetManagedPrometheusStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetManagedPrometheusStatusResponseBody() = default;
};
class GetManagedPrometheusStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetManagedPrometheusStatusResponseBody> body{};

  GetManagedPrometheusStatusResponse() {}

  explicit GetManagedPrometheusStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetManagedPrometheusStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetManagedPrometheusStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetManagedPrometheusStatusResponse() = default;
};
class GetMultipleTraceRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<string>> traceIDs{};

  GetMultipleTraceRequest() {}

  explicit GetMultipleTraceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (traceIDs) {
      res["TraceIDs"] = boost::any(*traceIDs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TraceIDs") != m.end() && !m["TraceIDs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TraceIDs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TraceIDs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      traceIDs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetMultipleTraceRequest() = default;
};
class GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList() {}

  explicit GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList() = default;
};
class GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList : public Darabonba::Model {
public:
  shared_ptr<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList>> tagEntryList{};
  shared_ptr<long> timestamp{};

  GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList() {}

  explicit GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagEntryList) {
      vector<boost::any> temp1;
      for(auto item1:*tagEntryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagEntryList"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagEntryList") != m.end() && !m["TagEntryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagEntryList"].type()) {
        vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagEntryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagEntryList = make_shared<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList() = default;
};
class GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList() {}

  explicit GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList() = default;
};
class GetMultipleTraceResponseBodyMultiCallChainInfosSpans : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<bool> haveStack{};
  shared_ptr<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList>> logEventList{};
  shared_ptr<string> operationName{};
  shared_ptr<string> parentSpanId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> rpcId{};
  shared_ptr<long> rpcType{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> spanId{};
  shared_ptr<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList>> tagEntryList{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> traceID{};

  GetMultipleTraceResponseBodyMultiCallChainInfosSpans() {}

  explicit GetMultipleTraceResponseBodyMultiCallChainInfosSpans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (haveStack) {
      res["HaveStack"] = boost::any(*haveStack);
    }
    if (logEventList) {
      vector<boost::any> temp1;
      for(auto item1:*logEventList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogEventList"] = boost::any(temp1);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (parentSpanId) {
      res["ParentSpanId"] = boost::any(*parentSpanId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (rpcId) {
      res["RpcId"] = boost::any(*rpcId);
    }
    if (rpcType) {
      res["RpcType"] = boost::any(*rpcType);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (spanId) {
      res["SpanId"] = boost::any(*spanId);
    }
    if (tagEntryList) {
      vector<boost::any> temp1;
      for(auto item1:*tagEntryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagEntryList"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("HaveStack") != m.end() && !m["HaveStack"].empty()) {
      haveStack = make_shared<bool>(boost::any_cast<bool>(m["HaveStack"]));
    }
    if (m.find("LogEventList") != m.end() && !m["LogEventList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogEventList"].type()) {
        vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogEventList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logEventList = make_shared<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList>>(expect1);
      }
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("ParentSpanId") != m.end() && !m["ParentSpanId"].empty()) {
      parentSpanId = make_shared<string>(boost::any_cast<string>(m["ParentSpanId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("RpcId") != m.end() && !m["RpcId"].empty()) {
      rpcId = make_shared<string>(boost::any_cast<string>(m["RpcId"]));
    }
    if (m.find("RpcType") != m.end() && !m["RpcType"].empty()) {
      rpcType = make_shared<long>(boost::any_cast<long>(m["RpcType"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("SpanId") != m.end() && !m["SpanId"].empty()) {
      spanId = make_shared<string>(boost::any_cast<string>(m["SpanId"]));
    }
    if (m.find("TagEntryList") != m.end() && !m["TagEntryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagEntryList"].type()) {
        vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagEntryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagEntryList = make_shared<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~GetMultipleTraceResponseBodyMultiCallChainInfosSpans() = default;
};
class GetMultipleTraceResponseBodyMultiCallChainInfos : public Darabonba::Model {
public:
  shared_ptr<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpans>> spans{};
  shared_ptr<string> traceID{};

  GetMultipleTraceResponseBodyMultiCallChainInfos() {}

  explicit GetMultipleTraceResponseBodyMultiCallChainInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spans) {
      vector<boost::any> temp1;
      for(auto item1:*spans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Spans"] = boost::any(temp1);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Spans") != m.end() && !m["Spans"].empty()) {
      if (typeid(vector<boost::any>) == m["Spans"].type()) {
        vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Spans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipleTraceResponseBodyMultiCallChainInfosSpans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spans = make_shared<vector<GetMultipleTraceResponseBodyMultiCallChainInfosSpans>>(expect1);
      }
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~GetMultipleTraceResponseBodyMultiCallChainInfos() = default;
};
class GetMultipleTraceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetMultipleTraceResponseBodyMultiCallChainInfos>> multiCallChainInfos{};
  shared_ptr<string> requestId{};

  GetMultipleTraceResponseBody() {}

  explicit GetMultipleTraceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (multiCallChainInfos) {
      vector<boost::any> temp1;
      for(auto item1:*multiCallChainInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultiCallChainInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MultiCallChainInfos") != m.end() && !m["MultiCallChainInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MultiCallChainInfos"].type()) {
        vector<GetMultipleTraceResponseBodyMultiCallChainInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultiCallChainInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipleTraceResponseBodyMultiCallChainInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multiCallChainInfos = make_shared<vector<GetMultipleTraceResponseBodyMultiCallChainInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMultipleTraceResponseBody() = default;
};
class GetMultipleTraceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultipleTraceResponseBody> body{};

  GetMultipleTraceResponse() {}

  explicit GetMultipleTraceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultipleTraceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultipleTraceResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultipleTraceResponse() = default;
};
class GetOnCallSchedulesDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> id{};
  shared_ptr<string> startTime{};

  GetOnCallSchedulesDetailRequest() {}

  explicit GetOnCallSchedulesDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailRequest() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries : public Darabonba::Model {
public:
  shared_ptr<string> end{};
  shared_ptr<GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact> simpleContact{};
  shared_ptr<string> start{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (simpleContact) {
      res["SimpleContact"] = simpleContact ? boost::any(simpleContact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("SimpleContact") != m.end() && !m["SimpleContact"].empty()) {
      if (typeid(map<string, boost::any>) == m["SimpleContact"].type()) {
        GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SimpleContact"]));
        simpleContact = make_shared<GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact>(model1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries : public Darabonba::Model {
public:
  shared_ptr<string> start{};
  shared_ptr<string> end{};
  shared_ptr<GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact> simpleContact{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (simpleContact) {
      res["SimpleContact"] = simpleContact ? boost::any(simpleContact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("SimpleContact") != m.end() && !m["SimpleContact"].empty()) {
      if (typeid(map<string, boost::any>) == m["SimpleContact"].type()) {
        GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SimpleContact"]));
        simpleContact = make_shared<GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact>(model1);
      }
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries : public Darabonba::Model {
public:
  shared_ptr<string> end{};
  shared_ptr<GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact> simpleContact{};
  shared_ptr<string> start{};

  GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (simpleContact) {
      res["SimpleContact"] = simpleContact ? boost::any(simpleContact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("SimpleContact") != m.end() && !m["SimpleContact"].empty()) {
      if (typeid(map<string, boost::any>) == m["SimpleContact"].type()) {
        GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SimpleContact"]));
        simpleContact = make_shared<GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact>(model1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions : public Darabonba::Model {
public:
  shared_ptr<string> endTimeOfDay{};
  shared_ptr<string> restrictionType{};
  shared_ptr<string> startTimeOfDay{};

  GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimeOfDay) {
      res["EndTimeOfDay"] = boost::any(*endTimeOfDay);
    }
    if (restrictionType) {
      res["RestrictionType"] = boost::any(*restrictionType);
    }
    if (startTimeOfDay) {
      res["StartTimeOfDay"] = boost::any(*startTimeOfDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimeOfDay") != m.end() && !m["EndTimeOfDay"].empty()) {
      endTimeOfDay = make_shared<string>(boost::any_cast<string>(m["EndTimeOfDay"]));
    }
    if (m.find("RestrictionType") != m.end() && !m["RestrictionType"].empty()) {
      restrictionType = make_shared<string>(boost::any_cast<string>(m["RestrictionType"]));
    }
    if (m.find("StartTimeOfDay") != m.end() && !m["StartTimeOfDay"].empty()) {
      startTimeOfDay = make_shared<string>(boost::any_cast<string>(m["StartTimeOfDay"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions() = default;
};
class GetOnCallSchedulesDetailResponseBodyDataScheduleLayers : public Darabonba::Model {
public:
  shared_ptr<vector<long>> contactIds{};
  shared_ptr<vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions>> restrictions{};
  shared_ptr<string> rotationType{};
  shared_ptr<long> shiftLength{};
  shared_ptr<string> startTime{};

  GetOnCallSchedulesDetailResponseBodyDataScheduleLayers() {}

  explicit GetOnCallSchedulesDetailResponseBodyDataScheduleLayers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (restrictions) {
      vector<boost::any> temp1;
      for(auto item1:*restrictions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Restrictions"] = boost::any(temp1);
    }
    if (rotationType) {
      res["RotationType"] = boost::any(*rotationType);
    }
    if (shiftLength) {
      res["ShiftLength"] = boost::any(*shiftLength);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ContactIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      contactIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Restrictions") != m.end() && !m["Restrictions"].empty()) {
      if (typeid(vector<boost::any>) == m["Restrictions"].type()) {
        vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Restrictions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restrictions = make_shared<vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions>>(expect1);
      }
    }
    if (m.find("RotationType") != m.end() && !m["RotationType"].empty()) {
      rotationType = make_shared<string>(boost::any_cast<string>(m["RotationType"]));
    }
    if (m.find("ShiftLength") != m.end() && !m["ShiftLength"].empty()) {
      shiftLength = make_shared<long>(boost::any_cast<long>(m["ShiftLength"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyDataScheduleLayers() = default;
};
class GetOnCallSchedulesDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> alertRobotId{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries>> renderedFinnalEntries{};
  shared_ptr<vector<vector<undefined>>> renderedLayerEntries{};
  shared_ptr<vector<GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries>> renderedSubstitudeEntries{};
  shared_ptr<vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayers>> scheduleLayers{};

  GetOnCallSchedulesDetailResponseBodyData() {}

  explicit GetOnCallSchedulesDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRobotId) {
      res["AlertRobotId"] = boost::any(*alertRobotId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (renderedFinnalEntries) {
      vector<boost::any> temp1;
      for(auto item1:*renderedFinnalEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RenderedFinnalEntries"] = boost::any(temp1);
    }
    if (renderedLayerEntries) {
      vector<boost::any> temp1;
      for(auto item1:*renderedLayerEntries){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["RenderedLayerEntries"] = boost::any(temp1);
    }
    if (renderedSubstitudeEntries) {
      vector<boost::any> temp1;
      for(auto item1:*renderedSubstitudeEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RenderedSubstitudeEntries"] = boost::any(temp1);
    }
    if (scheduleLayers) {
      vector<boost::any> temp1;
      for(auto item1:*scheduleLayers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScheduleLayers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRobotId") != m.end() && !m["AlertRobotId"].empty()) {
      alertRobotId = make_shared<long>(boost::any_cast<long>(m["AlertRobotId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RenderedFinnalEntries") != m.end() && !m["RenderedFinnalEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["RenderedFinnalEntries"].type()) {
        vector<GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RenderedFinnalEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        renderedFinnalEntries = make_shared<vector<GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries>>(expect1);
      }
    }
    if (m.find("RenderedLayerEntries") != m.end() && !m["RenderedLayerEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["RenderedLayerEntries"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RenderedLayerEntries"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        renderedLayerEntries = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
    if (m.find("RenderedSubstitudeEntries") != m.end() && !m["RenderedSubstitudeEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["RenderedSubstitudeEntries"].type()) {
        vector<GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RenderedSubstitudeEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        renderedSubstitudeEntries = make_shared<vector<GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries>>(expect1);
      }
    }
    if (m.find("ScheduleLayers") != m.end() && !m["ScheduleLayers"].empty()) {
      if (typeid(vector<boost::any>) == m["ScheduleLayers"].type()) {
        vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScheduleLayers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOnCallSchedulesDetailResponseBodyDataScheduleLayers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scheduleLayers = make_shared<vector<GetOnCallSchedulesDetailResponseBodyDataScheduleLayers>>(expect1);
      }
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBodyData() = default;
};
class GetOnCallSchedulesDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetOnCallSchedulesDetailResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetOnCallSchedulesDetailResponseBody() {}

  explicit GetOnCallSchedulesDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetOnCallSchedulesDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetOnCallSchedulesDetailResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOnCallSchedulesDetailResponseBody() = default;
};
class GetOnCallSchedulesDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOnCallSchedulesDetailResponseBody> body{};

  GetOnCallSchedulesDetailResponse() {}

  explicit GetOnCallSchedulesDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOnCallSchedulesDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOnCallSchedulesDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetOnCallSchedulesDetailResponse() = default;
};
class GetPrometheusApiTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  GetPrometheusApiTokenRequest() {}

  explicit GetPrometheusApiTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPrometheusApiTokenRequest() = default;
};
class GetPrometheusApiTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> token{};

  GetPrometheusApiTokenResponseBody() {}

  explicit GetPrometheusApiTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~GetPrometheusApiTokenResponseBody() = default;
};
class GetPrometheusApiTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusApiTokenResponseBody> body{};

  GetPrometheusApiTokenResponse() {}

  explicit GetPrometheusApiTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusApiTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusApiTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusApiTokenResponse() = default;
};
class GetPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> regionId{};

  GetPrometheusGlobalViewRequest() {}

  explicit GetPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPrometheusGlobalViewRequest() = default;
};
class GetPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetPrometheusGlobalViewResponseBody() {}

  explicit GetPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPrometheusGlobalViewResponseBody() = default;
};
class GetPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusGlobalViewResponseBody> body{};

  GetPrometheusGlobalViewResponse() {}

  explicit GetPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusGlobalViewResponse() = default;
};
class GetPrometheusInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetPrometheusInstanceRequest() {}

  explicit GetPrometheusInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPrometheusInstanceRequest() = default;
};
class GetPrometheusInstanceResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  GetPrometheusInstanceResponseBodyDataTags() {}

  explicit GetPrometheusInstanceResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~GetPrometheusInstanceResponseBodyDataTags() = default;
};
class GetPrometheusInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> grafanaInstanceId{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> subClustersJson{};
  shared_ptr<vector<GetPrometheusInstanceResponseBodyDataTags>> tags{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  GetPrometheusInstanceResponseBodyData() {}

  explicit GetPrometheusInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (grafanaInstanceId) {
      res["GrafanaInstanceId"] = boost::any(*grafanaInstanceId);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (subClustersJson) {
      res["SubClustersJson"] = boost::any(*subClustersJson);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("GrafanaInstanceId") != m.end() && !m["GrafanaInstanceId"].empty()) {
      grafanaInstanceId = make_shared<string>(boost::any_cast<string>(m["GrafanaInstanceId"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SubClustersJson") != m.end() && !m["SubClustersJson"].empty()) {
      subClustersJson = make_shared<string>(boost::any_cast<string>(m["SubClustersJson"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetPrometheusInstanceResponseBodyDataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPrometheusInstanceResponseBodyDataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetPrometheusInstanceResponseBodyDataTags>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetPrometheusInstanceResponseBodyData() = default;
};
class GetPrometheusInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetPrometheusInstanceResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetPrometheusInstanceResponseBody() {}

  explicit GetPrometheusInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPrometheusInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPrometheusInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPrometheusInstanceResponseBody() = default;
};
class GetPrometheusInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusInstanceResponseBody> body{};

  GetPrometheusInstanceResponse() {}

  explicit GetPrometheusInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusInstanceResponse() = default;
};
class GetPrometheusIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> regionId{};

  GetPrometheusIntegrationRequest() {}

  explicit GetPrometheusIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPrometheusIntegrationRequest() = default;
};
class GetPrometheusIntegrationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> canDelete{};
  shared_ptr<bool> canEditor{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerName{};
  shared_ptr<string> describe{};
  shared_ptr<string> exporterType{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> namespace_{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> param{};
  shared_ptr<bool> showDescribe{};
  shared_ptr<string> showLog{};
  shared_ptr<string> status{};
  shared_ptr<string> target{};
  shared_ptr<string> version{};

  GetPrometheusIntegrationResponseBodyData() {}

  explicit GetPrometheusIntegrationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canDelete) {
      res["CanDelete"] = boost::any(*canDelete);
    }
    if (canEditor) {
      res["CanEditor"] = boost::any(*canEditor);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (exporterType) {
      res["ExporterType"] = boost::any(*exporterType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (showDescribe) {
      res["ShowDescribe"] = boost::any(*showDescribe);
    }
    if (showLog) {
      res["ShowLog"] = boost::any(*showLog);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanDelete") != m.end() && !m["CanDelete"].empty()) {
      canDelete = make_shared<bool>(boost::any_cast<bool>(m["CanDelete"]));
    }
    if (m.find("CanEditor") != m.end() && !m["CanEditor"].empty()) {
      canEditor = make_shared<bool>(boost::any_cast<bool>(m["CanEditor"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("ExporterType") != m.end() && !m["ExporterType"].empty()) {
      exporterType = make_shared<string>(boost::any_cast<string>(m["ExporterType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("ShowDescribe") != m.end() && !m["ShowDescribe"].empty()) {
      showDescribe = make_shared<bool>(boost::any_cast<bool>(m["ShowDescribe"]));
    }
    if (m.find("ShowLog") != m.end() && !m["ShowLog"].empty()) {
      showLog = make_shared<string>(boost::any_cast<string>(m["ShowLog"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetPrometheusIntegrationResponseBodyData() = default;
};
class GetPrometheusIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetPrometheusIntegrationResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetPrometheusIntegrationResponseBody() {}

  explicit GetPrometheusIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPrometheusIntegrationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPrometheusIntegrationResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPrometheusIntegrationResponseBody() = default;
};
class GetPrometheusIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusIntegrationResponseBody> body{};

  GetPrometheusIntegrationResponse() {}

  explicit GetPrometheusIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusIntegrationResponse() = default;
};
class GetPrometheusMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  GetPrometheusMonitoringRequest() {}

  explicit GetPrometheusMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPrometheusMonitoringRequest() = default;
};
class GetPrometheusMonitoringResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetPrometheusMonitoringResponseBodyData() {}

  explicit GetPrometheusMonitoringResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPrometheusMonitoringResponseBodyData() = default;
};
class GetPrometheusMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetPrometheusMonitoringResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetPrometheusMonitoringResponseBody() {}

  explicit GetPrometheusMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPrometheusMonitoringResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPrometheusMonitoringResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPrometheusMonitoringResponseBody() = default;
};
class GetPrometheusMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusMonitoringResponseBody> body{};

  GetPrometheusMonitoringResponse() {}

  explicit GetPrometheusMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusMonitoringResponse() = default;
};
class GetPrometheusRemoteWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteWriteName{};

  GetPrometheusRemoteWriteRequest() {}

  explicit GetPrometheusRemoteWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteWriteName) {
      res["RemoteWriteName"] = boost::any(*remoteWriteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteWriteName") != m.end() && !m["RemoteWriteName"].empty()) {
      remoteWriteName = make_shared<string>(boost::any_cast<string>(m["RemoteWriteName"]));
    }
  }


  virtual ~GetPrometheusRemoteWriteRequest() = default;
};
class GetPrometheusRemoteWriteResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> remoteWriteName{};
  shared_ptr<string> remoteWriteYaml{};

  GetPrometheusRemoteWriteResponseBodyData() {}

  explicit GetPrometheusRemoteWriteResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (remoteWriteName) {
      res["RemoteWriteName"] = boost::any(*remoteWriteName);
    }
    if (remoteWriteYaml) {
      res["RemoteWriteYaml"] = boost::any(*remoteWriteYaml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RemoteWriteName") != m.end() && !m["RemoteWriteName"].empty()) {
      remoteWriteName = make_shared<string>(boost::any_cast<string>(m["RemoteWriteName"]));
    }
    if (m.find("RemoteWriteYaml") != m.end() && !m["RemoteWriteYaml"].empty()) {
      remoteWriteYaml = make_shared<string>(boost::any_cast<string>(m["RemoteWriteYaml"]));
    }
  }


  virtual ~GetPrometheusRemoteWriteResponseBodyData() = default;
};
class GetPrometheusRemoteWriteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetPrometheusRemoteWriteResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPrometheusRemoteWriteResponseBody() {}

  explicit GetPrometheusRemoteWriteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPrometheusRemoteWriteResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPrometheusRemoteWriteResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPrometheusRemoteWriteResponseBody() = default;
};
class GetPrometheusRemoteWriteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPrometheusRemoteWriteResponseBody> body{};

  GetPrometheusRemoteWriteResponse() {}

  explicit GetPrometheusRemoteWriteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPrometheusRemoteWriteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPrometheusRemoteWriteResponseBody>(model1);
      }
    }
  }


  virtual ~GetPrometheusRemoteWriteResponse() = default;
};
class GetRecordingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetRecordingRuleRequest() {}

  explicit GetRecordingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetRecordingRuleRequest() = default;
};
class GetRecordingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetRecordingRuleResponseBody() {}

  explicit GetRecordingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRecordingRuleResponseBody() = default;
};
class GetRecordingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRecordingRuleResponseBody> body{};

  GetRecordingRuleResponse() {}

  explicit GetRecordingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRecordingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRecordingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetRecordingRuleResponse() = default;
};
class GetRetcodeAppByPidRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetRetcodeAppByPidRequestTags() {}

  explicit GetRetcodeAppByPidRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetRetcodeAppByPidRequestTags() = default;
};
class GetRetcodeAppByPidRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<GetRetcodeAppByPidRequestTags>> tags{};

  GetRetcodeAppByPidRequest() {}

  explicit GetRetcodeAppByPidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetRetcodeAppByPidRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRetcodeAppByPidRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetRetcodeAppByPidRequestTags>>(expect1);
      }
    }
  }


  virtual ~GetRetcodeAppByPidRequest() = default;
};
class GetRetcodeAppByPidResponseBodyRetcodeAppTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetRetcodeAppByPidResponseBodyRetcodeAppTags() {}

  explicit GetRetcodeAppByPidResponseBodyRetcodeAppTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetRetcodeAppByPidResponseBodyRetcodeAppTags() = default;
};
class GetRetcodeAppByPidResponseBodyRetcodeApp : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> pid{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> retcodeAppType{};
  shared_ptr<vector<GetRetcodeAppByPidResponseBodyRetcodeAppTags>> tags{};

  GetRetcodeAppByPidResponseBodyRetcodeApp() {}

  explicit GetRetcodeAppByPidResponseBodyRetcodeApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retcodeAppType) {
      res["RetcodeAppType"] = boost::any(*retcodeAppType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetcodeAppType") != m.end() && !m["RetcodeAppType"].empty()) {
      retcodeAppType = make_shared<string>(boost::any_cast<string>(m["RetcodeAppType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetRetcodeAppByPidResponseBodyRetcodeAppTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRetcodeAppByPidResponseBodyRetcodeAppTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetRetcodeAppByPidResponseBodyRetcodeAppTags>>(expect1);
      }
    }
  }


  virtual ~GetRetcodeAppByPidResponseBodyRetcodeApp() = default;
};
class GetRetcodeAppByPidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetRetcodeAppByPidResponseBodyRetcodeApp> retcodeApp{};

  GetRetcodeAppByPidResponseBody() {}

  explicit GetRetcodeAppByPidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retcodeApp) {
      res["RetcodeApp"] = retcodeApp ? boost::any(retcodeApp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetcodeApp") != m.end() && !m["RetcodeApp"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetcodeApp"].type()) {
        GetRetcodeAppByPidResponseBodyRetcodeApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetcodeApp"]));
        retcodeApp = make_shared<GetRetcodeAppByPidResponseBodyRetcodeApp>(model1);
      }
    }
  }


  virtual ~GetRetcodeAppByPidResponseBody() = default;
};
class GetRetcodeAppByPidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRetcodeAppByPidResponseBody> body{};

  GetRetcodeAppByPidResponse() {}

  explicit GetRetcodeAppByPidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRetcodeAppByPidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRetcodeAppByPidResponseBody>(model1);
      }
    }
  }


  virtual ~GetRetcodeAppByPidResponse() = default;
};
class GetRetcodeDataByQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> from{};
  shared_ptr<string> pid{};
  shared_ptr<string> query{};
  shared_ptr<string> regionId{};
  shared_ptr<long> to{};

  GetRetcodeDataByQueryRequest() {}

  explicit GetRetcodeDataByQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<long>(boost::any_cast<long>(m["From"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<long>(boost::any_cast<long>(m["To"]));
    }
  }


  virtual ~GetRetcodeDataByQueryRequest() = default;
};
class GetRetcodeDataByQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetRetcodeDataByQueryResponseBody() {}

  explicit GetRetcodeDataByQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRetcodeDataByQueryResponseBody() = default;
};
class GetRetcodeDataByQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRetcodeDataByQueryResponseBody> body{};

  GetRetcodeDataByQueryResponse() {}

  explicit GetRetcodeDataByQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRetcodeDataByQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRetcodeDataByQueryResponseBody>(model1);
      }
    }
  }


  virtual ~GetRetcodeDataByQueryResponse() = default;
};
class GetRetcodeLogstoreRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};

  GetRetcodeLogstoreRequest() {}

  explicit GetRetcodeLogstoreRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetRetcodeLogstoreRequest() = default;
};
class GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> regionId{};

  GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig() {}

  explicit GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig() = default;
};
class GetRetcodeLogstoreResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig> retcodeSLSConfig{};
  shared_ptr<string> status{};

  GetRetcodeLogstoreResponseBodyData() {}

  explicit GetRetcodeLogstoreResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (retcodeSLSConfig) {
      res["RetcodeSLSConfig"] = retcodeSLSConfig ? boost::any(retcodeSLSConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RetcodeSLSConfig") != m.end() && !m["RetcodeSLSConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetcodeSLSConfig"].type()) {
        GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetcodeSLSConfig"]));
        retcodeSLSConfig = make_shared<GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetRetcodeLogstoreResponseBodyData() = default;
};
class GetRetcodeLogstoreResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetRetcodeLogstoreResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetRetcodeLogstoreResponseBody() {}

  explicit GetRetcodeLogstoreResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRetcodeLogstoreResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRetcodeLogstoreResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRetcodeLogstoreResponseBody() = default;
};
class GetRetcodeLogstoreResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRetcodeLogstoreResponseBody> body{};

  GetRetcodeLogstoreResponse() {}

  explicit GetRetcodeLogstoreResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRetcodeLogstoreResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRetcodeLogstoreResponseBody>(model1);
      }
    }
  }


  virtual ~GetRetcodeLogstoreResponse() = default;
};
class GetRetcodeShareUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};

  GetRetcodeShareUrlRequest() {}

  explicit GetRetcodeShareUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
  }


  virtual ~GetRetcodeShareUrlRequest() = default;
};
class GetRetcodeShareUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};

  GetRetcodeShareUrlResponseBody() {}

  explicit GetRetcodeShareUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetRetcodeShareUrlResponseBody() = default;
};
class GetRetcodeShareUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRetcodeShareUrlResponseBody> body{};

  GetRetcodeShareUrlResponse() {}

  explicit GetRetcodeShareUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRetcodeShareUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRetcodeShareUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetRetcodeShareUrlResponse() = default;
};
class GetSourceMapInfoRequest : public Darabonba::Model {
public:
  shared_ptr<bool> ascendingSequence{};
  shared_ptr<string> edition{};
  shared_ptr<string> ID{};
  shared_ptr<string> keyword{};
  shared_ptr<string> orderField{};
  shared_ptr<string> regionId{};

  GetSourceMapInfoRequest() {}

  explicit GetSourceMapInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ascendingSequence) {
      res["AscendingSequence"] = boost::any(*ascendingSequence);
    }
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AscendingSequence") != m.end() && !m["AscendingSequence"].empty()) {
      ascendingSequence = make_shared<bool>(boost::any_cast<bool>(m["AscendingSequence"]));
    }
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<string>(boost::any_cast<string>(m["Edition"]));
    }
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<string>(boost::any_cast<string>(m["ID"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetSourceMapInfoRequest() = default;
};
class GetSourceMapInfoResponseBodySourceMapList : public Darabonba::Model {
public:
  shared_ptr<string> fid{};
  shared_ptr<string> fileName{};
  shared_ptr<string> size{};
  shared_ptr<string> uploadTime{};
  shared_ptr<string> version{};

  GetSourceMapInfoResponseBodySourceMapList() {}

  explicit GetSourceMapInfoResponseBodySourceMapList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fid) {
      res["Fid"] = boost::any(*fid);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (uploadTime) {
      res["UploadTime"] = boost::any(*uploadTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fid") != m.end() && !m["Fid"].empty()) {
      fid = make_shared<string>(boost::any_cast<string>(m["Fid"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("UploadTime") != m.end() && !m["UploadTime"].empty()) {
      uploadTime = make_shared<string>(boost::any_cast<string>(m["UploadTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetSourceMapInfoResponseBodySourceMapList() = default;
};
class GetSourceMapInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetSourceMapInfoResponseBodySourceMapList>> sourceMapList{};

  GetSourceMapInfoResponseBody() {}

  explicit GetSourceMapInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceMapList) {
      vector<boost::any> temp1;
      for(auto item1:*sourceMapList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceMapList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceMapList") != m.end() && !m["SourceMapList"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceMapList"].type()) {
        vector<GetSourceMapInfoResponseBodySourceMapList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceMapList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSourceMapInfoResponseBodySourceMapList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceMapList = make_shared<vector<GetSourceMapInfoResponseBodySourceMapList>>(expect1);
      }
    }
  }


  virtual ~GetSourceMapInfoResponseBody() = default;
};
class GetSourceMapInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSourceMapInfoResponseBody> body{};

  GetSourceMapInfoResponse() {}

  explicit GetSourceMapInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSourceMapInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSourceMapInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetSourceMapInfoResponse() = default;
};
class GetStackRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> rpcID{};
  shared_ptr<long> startTime{};
  shared_ptr<string> traceID{};

  GetStackRequest() {}

  explicit GetStackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rpcID) {
      res["RpcID"] = boost::any(*rpcID);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RpcID") != m.end() && !m["RpcID"].empty()) {
      rpcID = make_shared<string>(boost::any_cast<string>(m["RpcID"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~GetStackRequest() = default;
};
class GetStackResponseBodyStackInfoExtInfo : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> type{};

  GetStackResponseBodyStackInfoExtInfo() {}

  explicit GetStackResponseBodyStackInfoExtInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetStackResponseBodyStackInfoExtInfo() = default;
};
class GetStackResponseBodyStackInfo : public Darabonba::Model {
public:
  shared_ptr<string> api{};
  shared_ptr<long> duration{};
  shared_ptr<string> exception{};
  shared_ptr<GetStackResponseBodyStackInfoExtInfo> extInfo{};
  shared_ptr<string> line{};
  shared_ptr<string> rpcId{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> startTime{};

  GetStackResponseBodyStackInfo() {}

  explicit GetStackResponseBodyStackInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (api) {
      res["Api"] = boost::any(*api);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (exception) {
      res["Exception"] = boost::any(*exception);
    }
    if (extInfo) {
      res["ExtInfo"] = extInfo ? boost::any(extInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (rpcId) {
      res["RpcId"] = boost::any(*rpcId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Api") != m.end() && !m["Api"].empty()) {
      api = make_shared<string>(boost::any_cast<string>(m["Api"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Exception") != m.end() && !m["Exception"].empty()) {
      exception = make_shared<string>(boost::any_cast<string>(m["Exception"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtInfo"].type()) {
        GetStackResponseBodyStackInfoExtInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtInfo"]));
        extInfo = make_shared<GetStackResponseBodyStackInfoExtInfo>(model1);
      }
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("RpcId") != m.end() && !m["RpcId"].empty()) {
      rpcId = make_shared<string>(boost::any_cast<string>(m["RpcId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetStackResponseBodyStackInfo() = default;
};
class GetStackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetStackResponseBodyStackInfo>> stackInfo{};

  GetStackResponseBody() {}

  explicit GetStackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stackInfo) {
      vector<boost::any> temp1;
      for(auto item1:*stackInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StackInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StackInfo") != m.end() && !m["StackInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StackInfo"].type()) {
        vector<GetStackResponseBodyStackInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StackInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetStackResponseBodyStackInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stackInfo = make_shared<vector<GetStackResponseBodyStackInfo>>(expect1);
      }
    }
  }


  virtual ~GetStackResponseBody() = default;
};
class GetStackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStackResponseBody> body{};

  GetStackResponse() {}

  explicit GetStackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStackResponseBody>(model1);
      }
    }
  }


  virtual ~GetStackResponse() = default;
};
class GetSyntheticTaskDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  GetSyntheticTaskDetailRequest() {}

  explicit GetSyntheticTaskDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetSyntheticTaskDetailRequest() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList : public Darabonba::Model {
public:
  shared_ptr<string> generalAlert{};
  shared_ptr<string> isCritical{};
  shared_ptr<string> name{};
  shared_ptr<string> seriousAlert{};
  shared_ptr<string> symbols{};

  GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generalAlert) {
      res["GeneralAlert"] = boost::any(*generalAlert);
    }
    if (isCritical) {
      res["IsCritical"] = boost::any(*isCritical);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (seriousAlert) {
      res["SeriousAlert"] = boost::any(*seriousAlert);
    }
    if (symbols) {
      res["Symbols"] = boost::any(*symbols);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GeneralAlert") != m.end() && !m["GeneralAlert"].empty()) {
      generalAlert = make_shared<string>(boost::any_cast<string>(m["GeneralAlert"]));
    }
    if (m.find("IsCritical") != m.end() && !m["IsCritical"].empty()) {
      isCritical = make_shared<string>(boost::any_cast<string>(m["IsCritical"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SeriousAlert") != m.end() && !m["SeriousAlert"].empty()) {
      seriousAlert = make_shared<string>(boost::any_cast<string>(m["SeriousAlert"]));
    }
    if (m.find("Symbols") != m.end() && !m["Symbols"].empty()) {
      symbols = make_shared<string>(boost::any_cast<string>(m["Symbols"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam : public Darabonba::Model {
public:
  shared_ptr<long> alarmFlag{};
  shared_ptr<vector<GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList>> alertList{};
  shared_ptr<string> alertNotifierId{};
  shared_ptr<string> alertPolicyId{};
  shared_ptr<string> monitorSamples{};
  shared_ptr<string> startExecutionTime{};

  GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmFlag) {
      res["AlarmFlag"] = boost::any(*alarmFlag);
    }
    if (alertList) {
      vector<boost::any> temp1;
      for(auto item1:*alertList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertList"] = boost::any(temp1);
    }
    if (alertNotifierId) {
      res["AlertNotifierId"] = boost::any(*alertNotifierId);
    }
    if (alertPolicyId) {
      res["AlertPolicyId"] = boost::any(*alertPolicyId);
    }
    if (monitorSamples) {
      res["MonitorSamples"] = boost::any(*monitorSamples);
    }
    if (startExecutionTime) {
      res["StartExecutionTime"] = boost::any(*startExecutionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmFlag") != m.end() && !m["AlarmFlag"].empty()) {
      alarmFlag = make_shared<long>(boost::any_cast<long>(m["AlarmFlag"]));
    }
    if (m.find("AlertList") != m.end() && !m["AlertList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertList"].type()) {
        vector<GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertList = make_shared<vector<GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList>>(expect1);
      }
    }
    if (m.find("AlertNotifierId") != m.end() && !m["AlertNotifierId"].empty()) {
      alertNotifierId = make_shared<string>(boost::any_cast<string>(m["AlertNotifierId"]));
    }
    if (m.find("AlertPolicyId") != m.end() && !m["AlertPolicyId"].empty()) {
      alertPolicyId = make_shared<string>(boost::any_cast<string>(m["AlertPolicyId"]));
    }
    if (m.find("MonitorSamples") != m.end() && !m["MonitorSamples"].empty()) {
      monitorSamples = make_shared<string>(boost::any_cast<string>(m["MonitorSamples"]));
    }
    if (m.find("StartExecutionTime") != m.end() && !m["StartExecutionTime"].empty()) {
      startExecutionTime = make_shared<string>(boost::any_cast<string>(m["StartExecutionTime"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailDownload : public Darabonba::Model {
public:
  shared_ptr<long> connectionTimeout{};
  shared_ptr<string> downloadCustomHeaderContent{};
  shared_ptr<long> downloadCustomHost{};
  shared_ptr<string> downloadCustomHostIp{};
  shared_ptr<long> downloadKernel{};
  shared_ptr<long> downloadRedirect{};
  shared_ptr<long> downloadTransmissionSize{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<string> quickProtocol{};
  shared_ptr<string> validateKeywords{};
  shared_ptr<long> verifyWay{};
  shared_ptr<string> whiteList{};

  GetSyntheticTaskDetailResponseBodyTaskDetailDownload() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailDownload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionTimeout) {
      res["ConnectionTimeout"] = boost::any(*connectionTimeout);
    }
    if (downloadCustomHeaderContent) {
      res["DownloadCustomHeaderContent"] = boost::any(*downloadCustomHeaderContent);
    }
    if (downloadCustomHost) {
      res["DownloadCustomHost"] = boost::any(*downloadCustomHost);
    }
    if (downloadCustomHostIp) {
      res["DownloadCustomHostIp"] = boost::any(*downloadCustomHostIp);
    }
    if (downloadKernel) {
      res["DownloadKernel"] = boost::any(*downloadKernel);
    }
    if (downloadRedirect) {
      res["DownloadRedirect"] = boost::any(*downloadRedirect);
    }
    if (downloadTransmissionSize) {
      res["DownloadTransmissionSize"] = boost::any(*downloadTransmissionSize);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (quickProtocol) {
      res["QuickProtocol"] = boost::any(*quickProtocol);
    }
    if (validateKeywords) {
      res["ValidateKeywords"] = boost::any(*validateKeywords);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionTimeout") != m.end() && !m["ConnectionTimeout"].empty()) {
      connectionTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectionTimeout"]));
    }
    if (m.find("DownloadCustomHeaderContent") != m.end() && !m["DownloadCustomHeaderContent"].empty()) {
      downloadCustomHeaderContent = make_shared<string>(boost::any_cast<string>(m["DownloadCustomHeaderContent"]));
    }
    if (m.find("DownloadCustomHost") != m.end() && !m["DownloadCustomHost"].empty()) {
      downloadCustomHost = make_shared<long>(boost::any_cast<long>(m["DownloadCustomHost"]));
    }
    if (m.find("DownloadCustomHostIp") != m.end() && !m["DownloadCustomHostIp"].empty()) {
      downloadCustomHostIp = make_shared<string>(boost::any_cast<string>(m["DownloadCustomHostIp"]));
    }
    if (m.find("DownloadKernel") != m.end() && !m["DownloadKernel"].empty()) {
      downloadKernel = make_shared<long>(boost::any_cast<long>(m["DownloadKernel"]));
    }
    if (m.find("DownloadRedirect") != m.end() && !m["DownloadRedirect"].empty()) {
      downloadRedirect = make_shared<long>(boost::any_cast<long>(m["DownloadRedirect"]));
    }
    if (m.find("DownloadTransmissionSize") != m.end() && !m["DownloadTransmissionSize"].empty()) {
      downloadTransmissionSize = make_shared<long>(boost::any_cast<long>(m["DownloadTransmissionSize"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("QuickProtocol") != m.end() && !m["QuickProtocol"].empty()) {
      quickProtocol = make_shared<string>(boost::any_cast<string>(m["QuickProtocol"]));
    }
    if (m.find("ValidateKeywords") != m.end() && !m["ValidateKeywords"].empty()) {
      validateKeywords = make_shared<string>(boost::any_cast<string>(m["ValidateKeywords"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailDownload() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval : public Darabonba::Model {
public:
  shared_ptr<vector<long>> days{};
  shared_ptr<long> endMinute{};
  shared_ptr<string> endTime{};
  shared_ptr<long> endhour{};
  shared_ptr<long> startHour{};
  shared_ptr<long> startMinute{};
  shared_ptr<string> startTime{};

  GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (endMinute) {
      res["EndMinute"] = boost::any(*endMinute);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endhour) {
      res["Endhour"] = boost::any(*endhour);
    }
    if (startHour) {
      res["StartHour"] = boost::any(*startHour);
    }
    if (startMinute) {
      res["StartMinute"] = boost::any(*startMinute);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Days"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Days"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      days = make_shared<vector<long>>(toVec1);
    }
    if (m.find("EndMinute") != m.end() && !m["EndMinute"].empty()) {
      endMinute = make_shared<long>(boost::any_cast<long>(m["EndMinute"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Endhour") != m.end() && !m["Endhour"].empty()) {
      endhour = make_shared<long>(boost::any_cast<long>(m["Endhour"]));
    }
    if (m.find("StartHour") != m.end() && !m["StartHour"].empty()) {
      startHour = make_shared<long>(boost::any_cast<long>(m["StartHour"]));
    }
    if (m.find("StartMinute") != m.end() && !m["StartMinute"].empty()) {
      startMinute = make_shared<long>(boost::any_cast<long>(m["StartMinute"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList : public Darabonba::Model {
public:
  shared_ptr<long> cityCode{};
  shared_ptr<long> monitorType{};
  shared_ptr<long> netServiceId{};
  shared_ptr<long> sendCount{};

  GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (monitorType) {
      res["MonitorType"] = boost::any(*monitorType);
    }
    if (netServiceId) {
      res["NetServiceId"] = boost::any(*netServiceId);
    }
    if (sendCount) {
      res["SendCount"] = boost::any(*sendCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("MonitorType") != m.end() && !m["MonitorType"].empty()) {
      monitorType = make_shared<long>(boost::any_cast<long>(m["MonitorType"]));
    }
    if (m.find("NetServiceId") != m.end() && !m["NetServiceId"].empty()) {
      netServiceId = make_shared<long>(boost::any_cast<long>(m["NetServiceId"]));
    }
    if (m.find("SendCount") != m.end() && !m["SendCount"].empty()) {
      sendCount = make_shared<long>(boost::any_cast<long>(m["SendCount"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailNav : public Darabonba::Model {
public:
  shared_ptr<string> dnsHijackWhitelist{};
  shared_ptr<string> elementBlacklist{};
  shared_ptr<long> executeActiveX{};
  shared_ptr<long> executeApplet{};
  shared_ptr<long> executeScript{};
  shared_ptr<long> filterInvalidIP{};
  shared_ptr<long> flowHijackJumpTimes{};
  shared_ptr<string> flowHijackLogo{};
  shared_ptr<long> monitorTimeout{};
  shared_ptr<long> navAutomaticScrolling{};
  shared_ptr<string> navCustomHeader{};
  shared_ptr<string> navCustomHeaderContent{};
  shared_ptr<long> navCustomHost{};
  shared_ptr<string> navCustomHostIp{};
  shared_ptr<long> navDisableCache{};
  shared_ptr<long> navDisableCompression{};
  shared_ptr<long> navIgnoreCertificateError{};
  shared_ptr<long> navRedirect{};
  shared_ptr<long> navReturnElement{};
  shared_ptr<string> pageTampering{};
  shared_ptr<string> processName{};
  shared_ptr<string> quicDomain{};
  shared_ptr<long> quicVersion{};
  shared_ptr<long> requestHeader{};
  shared_ptr<long> slowElementThreshold{};
  shared_ptr<string> verifyStringBlacklist{};
  shared_ptr<string> verifyStringWhitelist{};
  shared_ptr<long> waitCompletionTime{};

  GetSyntheticTaskDetailResponseBodyTaskDetailNav() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailNav(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsHijackWhitelist) {
      res["DnsHijackWhitelist"] = boost::any(*dnsHijackWhitelist);
    }
    if (elementBlacklist) {
      res["ElementBlacklist"] = boost::any(*elementBlacklist);
    }
    if (executeActiveX) {
      res["ExecuteActiveX"] = boost::any(*executeActiveX);
    }
    if (executeApplet) {
      res["ExecuteApplet"] = boost::any(*executeApplet);
    }
    if (executeScript) {
      res["ExecuteScript"] = boost::any(*executeScript);
    }
    if (filterInvalidIP) {
      res["FilterInvalidIP"] = boost::any(*filterInvalidIP);
    }
    if (flowHijackJumpTimes) {
      res["FlowHijackJumpTimes"] = boost::any(*flowHijackJumpTimes);
    }
    if (flowHijackLogo) {
      res["FlowHijackLogo"] = boost::any(*flowHijackLogo);
    }
    if (monitorTimeout) {
      res["MonitorTimeout"] = boost::any(*monitorTimeout);
    }
    if (navAutomaticScrolling) {
      res["NavAutomaticScrolling"] = boost::any(*navAutomaticScrolling);
    }
    if (navCustomHeader) {
      res["NavCustomHeader"] = boost::any(*navCustomHeader);
    }
    if (navCustomHeaderContent) {
      res["NavCustomHeaderContent"] = boost::any(*navCustomHeaderContent);
    }
    if (navCustomHost) {
      res["NavCustomHost"] = boost::any(*navCustomHost);
    }
    if (navCustomHostIp) {
      res["NavCustomHostIp"] = boost::any(*navCustomHostIp);
    }
    if (navDisableCache) {
      res["NavDisableCache"] = boost::any(*navDisableCache);
    }
    if (navDisableCompression) {
      res["NavDisableCompression"] = boost::any(*navDisableCompression);
    }
    if (navIgnoreCertificateError) {
      res["NavIgnoreCertificateError"] = boost::any(*navIgnoreCertificateError);
    }
    if (navRedirect) {
      res["NavRedirect"] = boost::any(*navRedirect);
    }
    if (navReturnElement) {
      res["NavReturnElement"] = boost::any(*navReturnElement);
    }
    if (pageTampering) {
      res["PageTampering"] = boost::any(*pageTampering);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (quicDomain) {
      res["QuicDomain"] = boost::any(*quicDomain);
    }
    if (quicVersion) {
      res["QuicVersion"] = boost::any(*quicVersion);
    }
    if (requestHeader) {
      res["RequestHeader"] = boost::any(*requestHeader);
    }
    if (slowElementThreshold) {
      res["SlowElementThreshold"] = boost::any(*slowElementThreshold);
    }
    if (verifyStringBlacklist) {
      res["VerifyStringBlacklist"] = boost::any(*verifyStringBlacklist);
    }
    if (verifyStringWhitelist) {
      res["VerifyStringWhitelist"] = boost::any(*verifyStringWhitelist);
    }
    if (waitCompletionTime) {
      res["WaitCompletionTime"] = boost::any(*waitCompletionTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsHijackWhitelist") != m.end() && !m["DnsHijackWhitelist"].empty()) {
      dnsHijackWhitelist = make_shared<string>(boost::any_cast<string>(m["DnsHijackWhitelist"]));
    }
    if (m.find("ElementBlacklist") != m.end() && !m["ElementBlacklist"].empty()) {
      elementBlacklist = make_shared<string>(boost::any_cast<string>(m["ElementBlacklist"]));
    }
    if (m.find("ExecuteActiveX") != m.end() && !m["ExecuteActiveX"].empty()) {
      executeActiveX = make_shared<long>(boost::any_cast<long>(m["ExecuteActiveX"]));
    }
    if (m.find("ExecuteApplet") != m.end() && !m["ExecuteApplet"].empty()) {
      executeApplet = make_shared<long>(boost::any_cast<long>(m["ExecuteApplet"]));
    }
    if (m.find("ExecuteScript") != m.end() && !m["ExecuteScript"].empty()) {
      executeScript = make_shared<long>(boost::any_cast<long>(m["ExecuteScript"]));
    }
    if (m.find("FilterInvalidIP") != m.end() && !m["FilterInvalidIP"].empty()) {
      filterInvalidIP = make_shared<long>(boost::any_cast<long>(m["FilterInvalidIP"]));
    }
    if (m.find("FlowHijackJumpTimes") != m.end() && !m["FlowHijackJumpTimes"].empty()) {
      flowHijackJumpTimes = make_shared<long>(boost::any_cast<long>(m["FlowHijackJumpTimes"]));
    }
    if (m.find("FlowHijackLogo") != m.end() && !m["FlowHijackLogo"].empty()) {
      flowHijackLogo = make_shared<string>(boost::any_cast<string>(m["FlowHijackLogo"]));
    }
    if (m.find("MonitorTimeout") != m.end() && !m["MonitorTimeout"].empty()) {
      monitorTimeout = make_shared<long>(boost::any_cast<long>(m["MonitorTimeout"]));
    }
    if (m.find("NavAutomaticScrolling") != m.end() && !m["NavAutomaticScrolling"].empty()) {
      navAutomaticScrolling = make_shared<long>(boost::any_cast<long>(m["NavAutomaticScrolling"]));
    }
    if (m.find("NavCustomHeader") != m.end() && !m["NavCustomHeader"].empty()) {
      navCustomHeader = make_shared<string>(boost::any_cast<string>(m["NavCustomHeader"]));
    }
    if (m.find("NavCustomHeaderContent") != m.end() && !m["NavCustomHeaderContent"].empty()) {
      navCustomHeaderContent = make_shared<string>(boost::any_cast<string>(m["NavCustomHeaderContent"]));
    }
    if (m.find("NavCustomHost") != m.end() && !m["NavCustomHost"].empty()) {
      navCustomHost = make_shared<long>(boost::any_cast<long>(m["NavCustomHost"]));
    }
    if (m.find("NavCustomHostIp") != m.end() && !m["NavCustomHostIp"].empty()) {
      navCustomHostIp = make_shared<string>(boost::any_cast<string>(m["NavCustomHostIp"]));
    }
    if (m.find("NavDisableCache") != m.end() && !m["NavDisableCache"].empty()) {
      navDisableCache = make_shared<long>(boost::any_cast<long>(m["NavDisableCache"]));
    }
    if (m.find("NavDisableCompression") != m.end() && !m["NavDisableCompression"].empty()) {
      navDisableCompression = make_shared<long>(boost::any_cast<long>(m["NavDisableCompression"]));
    }
    if (m.find("NavIgnoreCertificateError") != m.end() && !m["NavIgnoreCertificateError"].empty()) {
      navIgnoreCertificateError = make_shared<long>(boost::any_cast<long>(m["NavIgnoreCertificateError"]));
    }
    if (m.find("NavRedirect") != m.end() && !m["NavRedirect"].empty()) {
      navRedirect = make_shared<long>(boost::any_cast<long>(m["NavRedirect"]));
    }
    if (m.find("NavReturnElement") != m.end() && !m["NavReturnElement"].empty()) {
      navReturnElement = make_shared<long>(boost::any_cast<long>(m["NavReturnElement"]));
    }
    if (m.find("PageTampering") != m.end() && !m["PageTampering"].empty()) {
      pageTampering = make_shared<string>(boost::any_cast<string>(m["PageTampering"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("QuicDomain") != m.end() && !m["QuicDomain"].empty()) {
      quicDomain = make_shared<string>(boost::any_cast<string>(m["QuicDomain"]));
    }
    if (m.find("QuicVersion") != m.end() && !m["QuicVersion"].empty()) {
      quicVersion = make_shared<long>(boost::any_cast<long>(m["QuicVersion"]));
    }
    if (m.find("RequestHeader") != m.end() && !m["RequestHeader"].empty()) {
      requestHeader = make_shared<long>(boost::any_cast<long>(m["RequestHeader"]));
    }
    if (m.find("SlowElementThreshold") != m.end() && !m["SlowElementThreshold"].empty()) {
      slowElementThreshold = make_shared<long>(boost::any_cast<long>(m["SlowElementThreshold"]));
    }
    if (m.find("VerifyStringBlacklist") != m.end() && !m["VerifyStringBlacklist"].empty()) {
      verifyStringBlacklist = make_shared<string>(boost::any_cast<string>(m["VerifyStringBlacklist"]));
    }
    if (m.find("VerifyStringWhitelist") != m.end() && !m["VerifyStringWhitelist"].empty()) {
      verifyStringWhitelist = make_shared<string>(boost::any_cast<string>(m["VerifyStringWhitelist"]));
    }
    if (m.find("WaitCompletionTime") != m.end() && !m["WaitCompletionTime"].empty()) {
      waitCompletionTime = make_shared<long>(boost::any_cast<long>(m["WaitCompletionTime"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailNav() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailNet : public Darabonba::Model {
public:
  shared_ptr<long> netDigSwitch{};
  shared_ptr<string> netDnsNs{};
  shared_ptr<string> netDnsQueryMethod{};
  shared_ptr<long> netDnsServer{};
  shared_ptr<long> netDnsSwitch{};
  shared_ptr<string> netDnsTimeout{};
  shared_ptr<long> netIcmpActive{};
  shared_ptr<long> netIcmpDataCut{};
  shared_ptr<long> netIcmpInterval{};
  shared_ptr<long> netIcmpNum{};
  shared_ptr<long> netIcmpSize{};
  shared_ptr<long> netIcmpSwitch{};
  shared_ptr<long> netIcmpTimeout{};
  shared_ptr<long> netTraceRouteNum{};
  shared_ptr<long> netTraceRouteSwitch{};
  shared_ptr<long> netTraceRouteTimeout{};
  shared_ptr<string> whiteList{};

  GetSyntheticTaskDetailResponseBodyTaskDetailNet() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailNet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (netDigSwitch) {
      res["NetDigSwitch"] = boost::any(*netDigSwitch);
    }
    if (netDnsNs) {
      res["NetDnsNs"] = boost::any(*netDnsNs);
    }
    if (netDnsQueryMethod) {
      res["NetDnsQueryMethod"] = boost::any(*netDnsQueryMethod);
    }
    if (netDnsServer) {
      res["NetDnsServer"] = boost::any(*netDnsServer);
    }
    if (netDnsSwitch) {
      res["NetDnsSwitch"] = boost::any(*netDnsSwitch);
    }
    if (netDnsTimeout) {
      res["NetDnsTimeout"] = boost::any(*netDnsTimeout);
    }
    if (netIcmpActive) {
      res["NetIcmpActive"] = boost::any(*netIcmpActive);
    }
    if (netIcmpDataCut) {
      res["NetIcmpDataCut"] = boost::any(*netIcmpDataCut);
    }
    if (netIcmpInterval) {
      res["NetIcmpInterval"] = boost::any(*netIcmpInterval);
    }
    if (netIcmpNum) {
      res["NetIcmpNum"] = boost::any(*netIcmpNum);
    }
    if (netIcmpSize) {
      res["NetIcmpSize"] = boost::any(*netIcmpSize);
    }
    if (netIcmpSwitch) {
      res["NetIcmpSwitch"] = boost::any(*netIcmpSwitch);
    }
    if (netIcmpTimeout) {
      res["NetIcmpTimeout"] = boost::any(*netIcmpTimeout);
    }
    if (netTraceRouteNum) {
      res["NetTraceRouteNum"] = boost::any(*netTraceRouteNum);
    }
    if (netTraceRouteSwitch) {
      res["NetTraceRouteSwitch"] = boost::any(*netTraceRouteSwitch);
    }
    if (netTraceRouteTimeout) {
      res["NetTraceRouteTimeout"] = boost::any(*netTraceRouteTimeout);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetDigSwitch") != m.end() && !m["NetDigSwitch"].empty()) {
      netDigSwitch = make_shared<long>(boost::any_cast<long>(m["NetDigSwitch"]));
    }
    if (m.find("NetDnsNs") != m.end() && !m["NetDnsNs"].empty()) {
      netDnsNs = make_shared<string>(boost::any_cast<string>(m["NetDnsNs"]));
    }
    if (m.find("NetDnsQueryMethod") != m.end() && !m["NetDnsQueryMethod"].empty()) {
      netDnsQueryMethod = make_shared<string>(boost::any_cast<string>(m["NetDnsQueryMethod"]));
    }
    if (m.find("NetDnsServer") != m.end() && !m["NetDnsServer"].empty()) {
      netDnsServer = make_shared<long>(boost::any_cast<long>(m["NetDnsServer"]));
    }
    if (m.find("NetDnsSwitch") != m.end() && !m["NetDnsSwitch"].empty()) {
      netDnsSwitch = make_shared<long>(boost::any_cast<long>(m["NetDnsSwitch"]));
    }
    if (m.find("NetDnsTimeout") != m.end() && !m["NetDnsTimeout"].empty()) {
      netDnsTimeout = make_shared<string>(boost::any_cast<string>(m["NetDnsTimeout"]));
    }
    if (m.find("NetIcmpActive") != m.end() && !m["NetIcmpActive"].empty()) {
      netIcmpActive = make_shared<long>(boost::any_cast<long>(m["NetIcmpActive"]));
    }
    if (m.find("NetIcmpDataCut") != m.end() && !m["NetIcmpDataCut"].empty()) {
      netIcmpDataCut = make_shared<long>(boost::any_cast<long>(m["NetIcmpDataCut"]));
    }
    if (m.find("NetIcmpInterval") != m.end() && !m["NetIcmpInterval"].empty()) {
      netIcmpInterval = make_shared<long>(boost::any_cast<long>(m["NetIcmpInterval"]));
    }
    if (m.find("NetIcmpNum") != m.end() && !m["NetIcmpNum"].empty()) {
      netIcmpNum = make_shared<long>(boost::any_cast<long>(m["NetIcmpNum"]));
    }
    if (m.find("NetIcmpSize") != m.end() && !m["NetIcmpSize"].empty()) {
      netIcmpSize = make_shared<long>(boost::any_cast<long>(m["NetIcmpSize"]));
    }
    if (m.find("NetIcmpSwitch") != m.end() && !m["NetIcmpSwitch"].empty()) {
      netIcmpSwitch = make_shared<long>(boost::any_cast<long>(m["NetIcmpSwitch"]));
    }
    if (m.find("NetIcmpTimeout") != m.end() && !m["NetIcmpTimeout"].empty()) {
      netIcmpTimeout = make_shared<long>(boost::any_cast<long>(m["NetIcmpTimeout"]));
    }
    if (m.find("NetTraceRouteNum") != m.end() && !m["NetTraceRouteNum"].empty()) {
      netTraceRouteNum = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteNum"]));
    }
    if (m.find("NetTraceRouteSwitch") != m.end() && !m["NetTraceRouteSwitch"].empty()) {
      netTraceRouteSwitch = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteSwitch"]));
    }
    if (m.find("NetTraceRouteTimeout") != m.end() && !m["NetTraceRouteTimeout"].empty()) {
      netTraceRouteTimeout = make_shared<long>(boost::any_cast<long>(m["NetTraceRouteTimeout"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailNet() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody : public Darabonba::Model {
public:
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata> formdata{};
  shared_ptr<string> language{};
  shared_ptr<string> mode{};
  shared_ptr<string> raw{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded> urlencoded{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formdata) {
      res["Formdata"] = formdata ? boost::any(formdata->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (raw) {
      res["Raw"] = boost::any(*raw);
    }
    if (urlencoded) {
      res["Urlencoded"] = urlencoded ? boost::any(urlencoded->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Formdata") != m.end() && !m["Formdata"].empty()) {
      if (typeid(map<string, boost::any>) == m["Formdata"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Formdata"]));
        formdata = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata>(model1);
      }
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Raw") != m.end() && !m["Raw"].empty()) {
      raw = make_shared<string>(boost::any_cast<string>(m["Raw"]));
    }
    if (m.find("Urlencoded") != m.end() && !m["Urlencoded"].empty()) {
      if (typeid(map<string, boost::any>) == m["Urlencoded"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Urlencoded"]));
        urlencoded = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded>(model1);
      }
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent : public Darabonba::Model {
public:
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody> body{};
  shared_ptr<vector<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader>> header{};
  shared_ptr<string> method{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (header) {
      vector<boost::any> temp1;
      for(auto item1:*header){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Header"] = boost::any(temp1);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      if (typeid(map<string, boost::any>) == m["Body"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Body"]));
        body = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody>(model1);
      }
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(vector<boost::any>) == m["Header"].type()) {
        vector<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Header"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        header = make_shared<vector<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader>>(expect1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetailProtocol : public Darabonba::Model {
public:
  shared_ptr<long> characterEncoding{};
  shared_ptr<long> customHost{};
  shared_ptr<string> customHostIp{};
  shared_ptr<long> protocolConnectionTimeout{};
  shared_ptr<long> protocolMonitorTimeout{};
  shared_ptr<long> receivedDataSize{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent> requestContent{};
  shared_ptr<string> verifyContent{};
  shared_ptr<long> verifyWay{};

  GetSyntheticTaskDetailResponseBodyTaskDetailProtocol() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetailProtocol(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (characterEncoding) {
      res["CharacterEncoding"] = boost::any(*characterEncoding);
    }
    if (customHost) {
      res["CustomHost"] = boost::any(*customHost);
    }
    if (customHostIp) {
      res["CustomHostIp"] = boost::any(*customHostIp);
    }
    if (protocolConnectionTimeout) {
      res["ProtocolConnectionTimeout"] = boost::any(*protocolConnectionTimeout);
    }
    if (protocolMonitorTimeout) {
      res["ProtocolMonitorTimeout"] = boost::any(*protocolMonitorTimeout);
    }
    if (receivedDataSize) {
      res["ReceivedDataSize"] = boost::any(*receivedDataSize);
    }
    if (requestContent) {
      res["RequestContent"] = requestContent ? boost::any(requestContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (verifyContent) {
      res["VerifyContent"] = boost::any(*verifyContent);
    }
    if (verifyWay) {
      res["VerifyWay"] = boost::any(*verifyWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharacterEncoding") != m.end() && !m["CharacterEncoding"].empty()) {
      characterEncoding = make_shared<long>(boost::any_cast<long>(m["CharacterEncoding"]));
    }
    if (m.find("CustomHost") != m.end() && !m["CustomHost"].empty()) {
      customHost = make_shared<long>(boost::any_cast<long>(m["CustomHost"]));
    }
    if (m.find("CustomHostIp") != m.end() && !m["CustomHostIp"].empty()) {
      customHostIp = make_shared<string>(boost::any_cast<string>(m["CustomHostIp"]));
    }
    if (m.find("ProtocolConnectionTimeout") != m.end() && !m["ProtocolConnectionTimeout"].empty()) {
      protocolConnectionTimeout = make_shared<long>(boost::any_cast<long>(m["ProtocolConnectionTimeout"]));
    }
    if (m.find("ProtocolMonitorTimeout") != m.end() && !m["ProtocolMonitorTimeout"].empty()) {
      protocolMonitorTimeout = make_shared<long>(boost::any_cast<long>(m["ProtocolMonitorTimeout"]));
    }
    if (m.find("ReceivedDataSize") != m.end() && !m["ReceivedDataSize"].empty()) {
      receivedDataSize = make_shared<long>(boost::any_cast<long>(m["ReceivedDataSize"]));
    }
    if (m.find("RequestContent") != m.end() && !m["RequestContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestContent"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestContent"]));
        requestContent = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent>(model1);
      }
    }
    if (m.find("VerifyContent") != m.end() && !m["VerifyContent"].empty()) {
      verifyContent = make_shared<string>(boost::any_cast<string>(m["VerifyContent"]));
    }
    if (m.find("VerifyWay") != m.end() && !m["VerifyWay"].empty()) {
      verifyWay = make_shared<long>(boost::any_cast<long>(m["VerifyWay"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetailProtocol() = default;
};
class GetSyntheticTaskDetailResponseBodyTaskDetail : public Darabonba::Model {
public:
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam> commonParam{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailDownload> download{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval> extendInterval{};
  shared_ptr<long> intervalTime{};
  shared_ptr<long> intervalType{};
  shared_ptr<long> ipType{};
  shared_ptr<vector<GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList>> monitorList{};
  shared_ptr<string> monitorListString{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailNav> nav{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailNet> net{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetailProtocol> protocol{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskType{};
  shared_ptr<string> url{};

  GetSyntheticTaskDetailResponseBodyTaskDetail() {}

  explicit GetSyntheticTaskDetailResponseBodyTaskDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonParam) {
      res["CommonParam"] = commonParam ? boost::any(commonParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (download) {
      res["Download"] = download ? boost::any(download->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendInterval) {
      res["ExtendInterval"] = extendInterval ? boost::any(extendInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (intervalTime) {
      res["IntervalTime"] = boost::any(*intervalTime);
    }
    if (intervalType) {
      res["IntervalType"] = boost::any(*intervalType);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (monitorList) {
      vector<boost::any> temp1;
      for(auto item1:*monitorList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorList"] = boost::any(temp1);
    }
    if (monitorListString) {
      res["MonitorListString"] = boost::any(*monitorListString);
    }
    if (nav) {
      res["Nav"] = nav ? boost::any(nav->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (net) {
      res["Net"] = net ? boost::any(net->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocol) {
      res["Protocol"] = protocol ? boost::any(protocol->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonParam") != m.end() && !m["CommonParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonParam"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonParam"]));
        commonParam = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam>(model1);
      }
    }
    if (m.find("Download") != m.end() && !m["Download"].empty()) {
      if (typeid(map<string, boost::any>) == m["Download"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailDownload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Download"]));
        download = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailDownload>(model1);
      }
    }
    if (m.find("ExtendInterval") != m.end() && !m["ExtendInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendInterval"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendInterval"]));
        extendInterval = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval>(model1);
      }
    }
    if (m.find("IntervalTime") != m.end() && !m["IntervalTime"].empty()) {
      intervalTime = make_shared<long>(boost::any_cast<long>(m["IntervalTime"]));
    }
    if (m.find("IntervalType") != m.end() && !m["IntervalType"].empty()) {
      intervalType = make_shared<long>(boost::any_cast<long>(m["IntervalType"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("MonitorList") != m.end() && !m["MonitorList"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorList"].type()) {
        vector<GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorList = make_shared<vector<GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList>>(expect1);
      }
    }
    if (m.find("MonitorListString") != m.end() && !m["MonitorListString"].empty()) {
      monitorListString = make_shared<string>(boost::any_cast<string>(m["MonitorListString"]));
    }
    if (m.find("Nav") != m.end() && !m["Nav"].empty()) {
      if (typeid(map<string, boost::any>) == m["Nav"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailNav model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Nav"]));
        nav = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailNav>(model1);
      }
    }
    if (m.find("Net") != m.end() && !m["Net"].empty()) {
      if (typeid(map<string, boost::any>) == m["Net"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailNet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Net"]));
        net = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailNet>(model1);
      }
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      if (typeid(map<string, boost::any>) == m["Protocol"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetailProtocol model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Protocol"]));
        protocol = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetailProtocol>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBodyTaskDetail() = default;
};
class GetSyntheticTaskDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSyntheticTaskDetailResponseBodyTaskDetail> taskDetail{};

  GetSyntheticTaskDetailResponseBody() {}

  explicit GetSyntheticTaskDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskDetail) {
      res["TaskDetail"] = taskDetail ? boost::any(taskDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskDetail") != m.end() && !m["TaskDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskDetail"].type()) {
        GetSyntheticTaskDetailResponseBodyTaskDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskDetail"]));
        taskDetail = make_shared<GetSyntheticTaskDetailResponseBodyTaskDetail>(model1);
      }
    }
  }


  virtual ~GetSyntheticTaskDetailResponseBody() = default;
};
class GetSyntheticTaskDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSyntheticTaskDetailResponseBody> body{};

  GetSyntheticTaskDetailResponse() {}

  explicit GetSyntheticTaskDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSyntheticTaskDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSyntheticTaskDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetSyntheticTaskDetailResponse() = default;
};
class GetSyntheticTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> taskType{};
  shared_ptr<string> url{};

  GetSyntheticTaskListRequest() {}

  explicit GetSyntheticTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetSyntheticTaskListRequest() = default;
};
class GetSyntheticTaskListResponseBodyPageInfoList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> monitorNumber{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskStatus{};
  shared_ptr<long> taskType{};
  shared_ptr<string> taskTypeName{};
  shared_ptr<string> url{};
  shared_ptr<double> usable{};

  GetSyntheticTaskListResponseBodyPageInfoList() {}

  explicit GetSyntheticTaskListResponseBodyPageInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (monitorNumber) {
      res["MonitorNumber"] = boost::any(*monitorNumber);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskTypeName) {
      res["TaskTypeName"] = boost::any(*taskTypeName);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (usable) {
      res["Usable"] = boost::any(*usable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("MonitorNumber") != m.end() && !m["MonitorNumber"].empty()) {
      monitorNumber = make_shared<long>(boost::any_cast<long>(m["MonitorNumber"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("TaskTypeName") != m.end() && !m["TaskTypeName"].empty()) {
      taskTypeName = make_shared<string>(boost::any_cast<string>(m["TaskTypeName"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Usable") != m.end() && !m["Usable"].empty()) {
      usable = make_shared<double>(boost::any_cast<double>(m["Usable"]));
    }
  }


  virtual ~GetSyntheticTaskListResponseBodyPageInfoList() = default;
};
class GetSyntheticTaskListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<string> hasNextPage{};
  shared_ptr<bool> hasPreviousPage{};
  shared_ptr<bool> isFirstPage{};
  shared_ptr<bool> isLastPage{};
  shared_ptr<vector<GetSyntheticTaskListResponseBodyPageInfoList>> list{};
  shared_ptr<string> navigateFirstPage{};
  shared_ptr<string> navigateLastPage{};
  shared_ptr<string> navigatePageNums{};
  shared_ptr<string> nextPage{};
  shared_ptr<string> pages{};
  shared_ptr<string> prepage{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  GetSyntheticTaskListResponseBodyPageInfo() {}

  explicit GetSyntheticTaskListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasNextPage) {
      res["HasNextPage"] = boost::any(*hasNextPage);
    }
    if (hasPreviousPage) {
      res["HasPreviousPage"] = boost::any(*hasPreviousPage);
    }
    if (isFirstPage) {
      res["IsFirstPage"] = boost::any(*isFirstPage);
    }
    if (isLastPage) {
      res["IsLastPage"] = boost::any(*isLastPage);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (navigateFirstPage) {
      res["NavigateFirstPage"] = boost::any(*navigateFirstPage);
    }
    if (navigateLastPage) {
      res["NavigateLastPage"] = boost::any(*navigateLastPage);
    }
    if (navigatePageNums) {
      res["NavigatePageNums"] = boost::any(*navigatePageNums);
    }
    if (nextPage) {
      res["NextPage"] = boost::any(*nextPage);
    }
    if (pages) {
      res["Pages"] = boost::any(*pages);
    }
    if (prepage) {
      res["Prepage"] = boost::any(*prepage);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasNextPage") != m.end() && !m["HasNextPage"].empty()) {
      hasNextPage = make_shared<string>(boost::any_cast<string>(m["HasNextPage"]));
    }
    if (m.find("HasPreviousPage") != m.end() && !m["HasPreviousPage"].empty()) {
      hasPreviousPage = make_shared<bool>(boost::any_cast<bool>(m["HasPreviousPage"]));
    }
    if (m.find("IsFirstPage") != m.end() && !m["IsFirstPage"].empty()) {
      isFirstPage = make_shared<bool>(boost::any_cast<bool>(m["IsFirstPage"]));
    }
    if (m.find("IsLastPage") != m.end() && !m["IsLastPage"].empty()) {
      isLastPage = make_shared<bool>(boost::any_cast<bool>(m["IsLastPage"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetSyntheticTaskListResponseBodyPageInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticTaskListResponseBodyPageInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetSyntheticTaskListResponseBodyPageInfoList>>(expect1);
      }
    }
    if (m.find("NavigateFirstPage") != m.end() && !m["NavigateFirstPage"].empty()) {
      navigateFirstPage = make_shared<string>(boost::any_cast<string>(m["NavigateFirstPage"]));
    }
    if (m.find("NavigateLastPage") != m.end() && !m["NavigateLastPage"].empty()) {
      navigateLastPage = make_shared<string>(boost::any_cast<string>(m["NavigateLastPage"]));
    }
    if (m.find("NavigatePageNums") != m.end() && !m["NavigatePageNums"].empty()) {
      navigatePageNums = make_shared<string>(boost::any_cast<string>(m["NavigatePageNums"]));
    }
    if (m.find("NextPage") != m.end() && !m["NextPage"].empty()) {
      nextPage = make_shared<string>(boost::any_cast<string>(m["NextPage"]));
    }
    if (m.find("Pages") != m.end() && !m["Pages"].empty()) {
      pages = make_shared<string>(boost::any_cast<string>(m["Pages"]));
    }
    if (m.find("Prepage") != m.end() && !m["Prepage"].empty()) {
      prepage = make_shared<string>(boost::any_cast<string>(m["Prepage"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSyntheticTaskListResponseBodyPageInfo() = default;
};
class GetSyntheticTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetSyntheticTaskListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  GetSyntheticTaskListResponseBody() {}

  explicit GetSyntheticTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        GetSyntheticTaskListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<GetSyntheticTaskListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSyntheticTaskListResponseBody() = default;
};
class GetSyntheticTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSyntheticTaskListResponseBody> body{};

  GetSyntheticTaskListResponse() {}

  explicit GetSyntheticTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSyntheticTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSyntheticTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~GetSyntheticTaskListResponse() = default;
};
class GetSyntheticTaskMonitorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  GetSyntheticTaskMonitorsRequest() {}

  explicit GetSyntheticTaskMonitorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetSyntheticTaskMonitorsRequest() = default;
};
class GetSyntheticTaskMonitorsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> busy{};
  shared_ptr<string> city{};
  shared_ptr<long> cityCode{};
  shared_ptr<long> clientType{};
  shared_ptr<string> district{};
  shared_ptr<long> netServiceId{};
  shared_ptr<string> netServiceName{};

  GetSyntheticTaskMonitorsResponseBodyData() {}

  explicit GetSyntheticTaskMonitorsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (busy) {
      res["Busy"] = boost::any(*busy);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (district) {
      res["District"] = boost::any(*district);
    }
    if (netServiceId) {
      res["NetServiceId"] = boost::any(*netServiceId);
    }
    if (netServiceName) {
      res["NetServiceName"] = boost::any(*netServiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Busy") != m.end() && !m["Busy"].empty()) {
      busy = make_shared<long>(boost::any_cast<long>(m["Busy"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<long>(boost::any_cast<long>(m["ClientType"]));
    }
    if (m.find("District") != m.end() && !m["District"].empty()) {
      district = make_shared<string>(boost::any_cast<string>(m["District"]));
    }
    if (m.find("NetServiceId") != m.end() && !m["NetServiceId"].empty()) {
      netServiceId = make_shared<long>(boost::any_cast<long>(m["NetServiceId"]));
    }
    if (m.find("NetServiceName") != m.end() && !m["NetServiceName"].empty()) {
      netServiceName = make_shared<string>(boost::any_cast<string>(m["NetServiceName"]));
    }
  }


  virtual ~GetSyntheticTaskMonitorsResponseBodyData() = default;
};
class GetSyntheticTaskMonitorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetSyntheticTaskMonitorsResponseBodyData>> data{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  GetSyntheticTaskMonitorsResponseBody() {}

  explicit GetSyntheticTaskMonitorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetSyntheticTaskMonitorsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSyntheticTaskMonitorsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetSyntheticTaskMonitorsResponseBodyData>>(expect1);
      }
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSyntheticTaskMonitorsResponseBody() = default;
};
class GetSyntheticTaskMonitorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSyntheticTaskMonitorsResponseBody> body{};

  GetSyntheticTaskMonitorsResponse() {}

  explicit GetSyntheticTaskMonitorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSyntheticTaskMonitorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSyntheticTaskMonitorsResponseBody>(model1);
      }
    }
  }


  virtual ~GetSyntheticTaskMonitorsResponse() = default;
};
class GetTraceRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> traceID{};

  GetTraceRequest() {}

  explicit GetTraceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~GetTraceRequest() = default;
};
class GetTraceResponseBodySpansLogEventListTagEntryList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTraceResponseBodySpansLogEventListTagEntryList() {}

  explicit GetTraceResponseBodySpansLogEventListTagEntryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTraceResponseBodySpansLogEventListTagEntryList() = default;
};
class GetTraceResponseBodySpansLogEventList : public Darabonba::Model {
public:
  shared_ptr<vector<GetTraceResponseBodySpansLogEventListTagEntryList>> tagEntryList{};
  shared_ptr<long> timestamp{};

  GetTraceResponseBodySpansLogEventList() {}

  explicit GetTraceResponseBodySpansLogEventList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagEntryList) {
      vector<boost::any> temp1;
      for(auto item1:*tagEntryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagEntryList"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagEntryList") != m.end() && !m["TagEntryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagEntryList"].type()) {
        vector<GetTraceResponseBodySpansLogEventListTagEntryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagEntryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceResponseBodySpansLogEventListTagEntryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagEntryList = make_shared<vector<GetTraceResponseBodySpansLogEventListTagEntryList>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~GetTraceResponseBodySpansLogEventList() = default;
};
class GetTraceResponseBodySpansTagEntryList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTraceResponseBodySpansTagEntryList() {}

  explicit GetTraceResponseBodySpansTagEntryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTraceResponseBodySpansTagEntryList() = default;
};
class GetTraceResponseBodySpans : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> children{};
  shared_ptr<long> duration{};
  shared_ptr<bool> haveStack{};
  shared_ptr<vector<GetTraceResponseBodySpansLogEventList>> logEventList{};
  shared_ptr<string> operationName{};
  shared_ptr<string> parentSpanId{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> rpcId{};
  shared_ptr<long> rpcType{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> spanId{};
  shared_ptr<vector<GetTraceResponseBodySpansTagEntryList>> tagEntryList{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> traceID{};

  GetTraceResponseBodySpans() {}

  explicit GetTraceResponseBodySpans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      res["Children"] = boost::any(*children);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (haveStack) {
      res["HaveStack"] = boost::any(*haveStack);
    }
    if (logEventList) {
      vector<boost::any> temp1;
      for(auto item1:*logEventList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogEventList"] = boost::any(temp1);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (parentSpanId) {
      res["ParentSpanId"] = boost::any(*parentSpanId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (rpcId) {
      res["RpcId"] = boost::any(*rpcId);
    }
    if (rpcType) {
      res["RpcType"] = boost::any(*rpcType);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (spanId) {
      res["SpanId"] = boost::any(*spanId);
    }
    if (tagEntryList) {
      vector<boost::any> temp1;
      for(auto item1:*tagEntryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagEntryList"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Children"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      children = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("HaveStack") != m.end() && !m["HaveStack"].empty()) {
      haveStack = make_shared<bool>(boost::any_cast<bool>(m["HaveStack"]));
    }
    if (m.find("LogEventList") != m.end() && !m["LogEventList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogEventList"].type()) {
        vector<GetTraceResponseBodySpansLogEventList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogEventList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceResponseBodySpansLogEventList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logEventList = make_shared<vector<GetTraceResponseBodySpansLogEventList>>(expect1);
      }
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("ParentSpanId") != m.end() && !m["ParentSpanId"].empty()) {
      parentSpanId = make_shared<string>(boost::any_cast<string>(m["ParentSpanId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("RpcId") != m.end() && !m["RpcId"].empty()) {
      rpcId = make_shared<string>(boost::any_cast<string>(m["RpcId"]));
    }
    if (m.find("RpcType") != m.end() && !m["RpcType"].empty()) {
      rpcType = make_shared<long>(boost::any_cast<long>(m["RpcType"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("SpanId") != m.end() && !m["SpanId"].empty()) {
      spanId = make_shared<string>(boost::any_cast<string>(m["SpanId"]));
    }
    if (m.find("TagEntryList") != m.end() && !m["TagEntryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagEntryList"].type()) {
        vector<GetTraceResponseBodySpansTagEntryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagEntryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceResponseBodySpansTagEntryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagEntryList = make_shared<vector<GetTraceResponseBodySpansTagEntryList>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~GetTraceResponseBodySpans() = default;
};
class GetTraceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetTraceResponseBodySpans>> spans{};

  GetTraceResponseBody() {}

  explicit GetTraceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spans) {
      vector<boost::any> temp1;
      for(auto item1:*spans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Spans"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Spans") != m.end() && !m["Spans"].empty()) {
      if (typeid(vector<boost::any>) == m["Spans"].type()) {
        vector<GetTraceResponseBodySpans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Spans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceResponseBodySpans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spans = make_shared<vector<GetTraceResponseBodySpans>>(expect1);
      }
    }
  }


  virtual ~GetTraceResponseBody() = default;
};
class GetTraceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTraceResponseBody> body{};

  GetTraceResponse() {}

  explicit GetTraceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTraceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTraceResponseBody>(model1);
      }
    }
  }


  virtual ~GetTraceResponse() = default;
};
class GetTraceAppRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTraceAppRequestTags() {}

  explicit GetTraceAppRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTraceAppRequestTags() = default;
};
class GetTraceAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<GetTraceAppRequestTags>> tags{};

  GetTraceAppRequest() {}

  explicit GetTraceAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetTraceAppRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceAppRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetTraceAppRequestTags>>(expect1);
      }
    }
  }


  virtual ~GetTraceAppRequest() = default;
};
class GetTraceAppResponseBodyTraceAppTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetTraceAppResponseBodyTraceAppTags() {}

  explicit GetTraceAppResponseBodyTraceAppTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetTraceAppResponseBodyTraceAppTags() = default;
};
class GetTraceAppResponseBodyTraceApp : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> show{};
  shared_ptr<string> source{};
  shared_ptr<vector<GetTraceAppResponseBodyTraceAppTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  GetTraceAppResponseBodyTraceApp() {}

  explicit GetTraceAppResponseBodyTraceApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetTraceAppResponseBodyTraceAppTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTraceAppResponseBodyTraceAppTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetTraceAppResponseBodyTraceAppTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetTraceAppResponseBodyTraceApp() = default;
};
class GetTraceAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTraceAppResponseBodyTraceApp> traceApp{};

  GetTraceAppResponseBody() {}

  explicit GetTraceAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceApp) {
      res["TraceApp"] = traceApp ? boost::any(traceApp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceApp") != m.end() && !m["TraceApp"].empty()) {
      if (typeid(map<string, boost::any>) == m["TraceApp"].type()) {
        GetTraceAppResponseBodyTraceApp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TraceApp"]));
        traceApp = make_shared<GetTraceAppResponseBodyTraceApp>(model1);
      }
    }
  }


  virtual ~GetTraceAppResponseBody() = default;
};
class GetTraceAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTraceAppResponseBody> body{};

  GetTraceAppResponse() {}

  explicit GetTraceAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTraceAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTraceAppResponseBody>(model1);
      }
    }
  }


  virtual ~GetTraceAppResponse() = default;
};
class ImportAppAlertRulesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ImportAppAlertRulesRequestTags() {}

  explicit ImportAppAlertRulesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ImportAppAlertRulesRequestTags() = default;
};
class ImportAppAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupIds{};
  shared_ptr<bool> isAutoStart{};
  shared_ptr<string> pids{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ImportAppAlertRulesRequestTags>> tags{};
  shared_ptr<string> templageAlertConfig{};
  shared_ptr<string> templateAlertId{};

  ImportAppAlertRulesRequest() {}

  explicit ImportAppAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupIds) {
      res["ContactGroupIds"] = boost::any(*contactGroupIds);
    }
    if (isAutoStart) {
      res["IsAutoStart"] = boost::any(*isAutoStart);
    }
    if (pids) {
      res["Pids"] = boost::any(*pids);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (templageAlertConfig) {
      res["TemplageAlertConfig"] = boost::any(*templageAlertConfig);
    }
    if (templateAlertId) {
      res["TemplateAlertId"] = boost::any(*templateAlertId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupIds") != m.end() && !m["ContactGroupIds"].empty()) {
      contactGroupIds = make_shared<string>(boost::any_cast<string>(m["ContactGroupIds"]));
    }
    if (m.find("IsAutoStart") != m.end() && !m["IsAutoStart"].empty()) {
      isAutoStart = make_shared<bool>(boost::any_cast<bool>(m["IsAutoStart"]));
    }
    if (m.find("Pids") != m.end() && !m["Pids"].empty()) {
      pids = make_shared<string>(boost::any_cast<string>(m["Pids"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ImportAppAlertRulesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportAppAlertRulesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ImportAppAlertRulesRequestTags>>(expect1);
      }
    }
    if (m.find("TemplageAlertConfig") != m.end() && !m["TemplageAlertConfig"].empty()) {
      templageAlertConfig = make_shared<string>(boost::any_cast<string>(m["TemplageAlertConfig"]));
    }
    if (m.find("TemplateAlertId") != m.end() && !m["TemplateAlertId"].empty()) {
      templateAlertId = make_shared<string>(boost::any_cast<string>(m["TemplateAlertId"]));
    }
  }


  virtual ~ImportAppAlertRulesRequest() = default;
};
class ImportAppAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  ImportAppAlertRulesResponseBody() {}

  explicit ImportAppAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportAppAlertRulesResponseBody() = default;
};
class ImportAppAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportAppAlertRulesResponseBody> body{};

  ImportAppAlertRulesResponse() {}

  explicit ImportAppAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportAppAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportAppAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ImportAppAlertRulesResponse() = default;
};
class InstallCmsExporterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> cmsArgs{};
  shared_ptr<string> directArgs{};
  shared_ptr<bool> enableTag{};
  shared_ptr<string> regionId{};

  InstallCmsExporterRequest() {}

  explicit InstallCmsExporterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (cmsArgs) {
      res["CmsArgs"] = boost::any(*cmsArgs);
    }
    if (directArgs) {
      res["DirectArgs"] = boost::any(*directArgs);
    }
    if (enableTag) {
      res["EnableTag"] = boost::any(*enableTag);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CmsArgs") != m.end() && !m["CmsArgs"].empty()) {
      cmsArgs = make_shared<string>(boost::any_cast<string>(m["CmsArgs"]));
    }
    if (m.find("DirectArgs") != m.end() && !m["DirectArgs"].empty()) {
      directArgs = make_shared<string>(boost::any_cast<string>(m["DirectArgs"]));
    }
    if (m.find("EnableTag") != m.end() && !m["EnableTag"].empty()) {
      enableTag = make_shared<bool>(boost::any_cast<bool>(m["EnableTag"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~InstallCmsExporterRequest() = default;
};
class InstallCmsExporterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  InstallCmsExporterResponseBody() {}

  explicit InstallCmsExporterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InstallCmsExporterResponseBody() = default;
};
class InstallCmsExporterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallCmsExporterResponseBody> body{};

  InstallCmsExporterResponse() {}

  explicit InstallCmsExporterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallCmsExporterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallCmsExporterResponseBody>(model1);
      }
    }
  }


  virtual ~InstallCmsExporterResponse() = default;
};
class InstallManagedPrometheusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> grafanaInstanceId{};
  shared_ptr<string> kubeConfig{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  InstallManagedPrometheusRequest() {}

  explicit InstallManagedPrometheusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (grafanaInstanceId) {
      res["GrafanaInstanceId"] = boost::any(*grafanaInstanceId);
    }
    if (kubeConfig) {
      res["KubeConfig"] = boost::any(*kubeConfig);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("GrafanaInstanceId") != m.end() && !m["GrafanaInstanceId"].empty()) {
      grafanaInstanceId = make_shared<string>(boost::any_cast<string>(m["GrafanaInstanceId"]));
    }
    if (m.find("KubeConfig") != m.end() && !m["KubeConfig"].empty()) {
      kubeConfig = make_shared<string>(boost::any_cast<string>(m["KubeConfig"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~InstallManagedPrometheusRequest() = default;
};
class InstallManagedPrometheusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InstallManagedPrometheusResponseBody() {}

  explicit InstallManagedPrometheusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallManagedPrometheusResponseBody() = default;
};
class InstallManagedPrometheusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallManagedPrometheusResponseBody> body{};

  InstallManagedPrometheusResponse() {}

  explicit InstallManagedPrometheusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallManagedPrometheusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallManagedPrometheusResponseBody>(model1);
      }
    }
  }


  virtual ~InstallManagedPrometheusResponse() = default;
};
class ListActivatedAlertsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> filter{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  ListActivatedAlertsRequest() {}

  explicit ListActivatedAlertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListActivatedAlertsRequest() = default;
};
class ListActivatedAlertsResponseBodyPageAlertsDispatchRules : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};

  ListActivatedAlertsResponseBodyPageAlertsDispatchRules() {}

  explicit ListActivatedAlertsResponseBodyPageAlertsDispatchRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~ListActivatedAlertsResponseBodyPageAlertsDispatchRules() = default;
};
class ListActivatedAlertsResponseBodyPageAlerts : public Darabonba::Model {
public:
  shared_ptr<string> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<string> alertType{};
  shared_ptr<long> count{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<ListActivatedAlertsResponseBodyPageAlertsDispatchRules>> dispatchRules{};
  shared_ptr<long> endsAt{};
  shared_ptr<map<string, boost::any>> expandFields{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> involvedObjectKind{};
  shared_ptr<string> involvedObjectName{};
  shared_ptr<string> message{};
  shared_ptr<string> severity{};
  shared_ptr<long> startsAt{};
  shared_ptr<string> status{};

  ListActivatedAlertsResponseBodyPageAlerts() {}

  explicit ListActivatedAlertsResponseBodyPageAlerts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dispatchRules) {
      vector<boost::any> temp1;
      for(auto item1:*dispatchRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DispatchRules"] = boost::any(temp1);
    }
    if (endsAt) {
      res["EndsAt"] = boost::any(*endsAt);
    }
    if (expandFields) {
      res["ExpandFields"] = boost::any(*expandFields);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (involvedObjectKind) {
      res["InvolvedObjectKind"] = boost::any(*involvedObjectKind);
    }
    if (involvedObjectName) {
      res["InvolvedObjectName"] = boost::any(*involvedObjectName);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (startsAt) {
      res["StartsAt"] = boost::any(*startsAt);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<string>(boost::any_cast<string>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<string>(boost::any_cast<string>(m["AlertType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DispatchRules") != m.end() && !m["DispatchRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DispatchRules"].type()) {
        vector<ListActivatedAlertsResponseBodyPageAlertsDispatchRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DispatchRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListActivatedAlertsResponseBodyPageAlertsDispatchRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dispatchRules = make_shared<vector<ListActivatedAlertsResponseBodyPageAlertsDispatchRules>>(expect1);
      }
    }
    if (m.find("EndsAt") != m.end() && !m["EndsAt"].empty()) {
      endsAt = make_shared<long>(boost::any_cast<long>(m["EndsAt"]));
    }
    if (m.find("ExpandFields") != m.end() && !m["ExpandFields"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExpandFields"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      expandFields = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("InvolvedObjectKind") != m.end() && !m["InvolvedObjectKind"].empty()) {
      involvedObjectKind = make_shared<string>(boost::any_cast<string>(m["InvolvedObjectKind"]));
    }
    if (m.find("InvolvedObjectName") != m.end() && !m["InvolvedObjectName"].empty()) {
      involvedObjectName = make_shared<string>(boost::any_cast<string>(m["InvolvedObjectName"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("StartsAt") != m.end() && !m["StartsAt"].empty()) {
      startsAt = make_shared<long>(boost::any_cast<long>(m["StartsAt"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListActivatedAlertsResponseBodyPageAlerts() = default;
};
class ListActivatedAlertsResponseBodyPage : public Darabonba::Model {
public:
  shared_ptr<vector<ListActivatedAlertsResponseBodyPageAlerts>> alerts{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  ListActivatedAlertsResponseBodyPage() {}

  explicit ListActivatedAlertsResponseBodyPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alerts) {
      vector<boost::any> temp1;
      for(auto item1:*alerts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Alerts"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alerts") != m.end() && !m["Alerts"].empty()) {
      if (typeid(vector<boost::any>) == m["Alerts"].type()) {
        vector<ListActivatedAlertsResponseBodyPageAlerts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Alerts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListActivatedAlertsResponseBodyPageAlerts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alerts = make_shared<vector<ListActivatedAlertsResponseBodyPageAlerts>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListActivatedAlertsResponseBodyPage() = default;
};
class ListActivatedAlertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListActivatedAlertsResponseBodyPage> page{};
  shared_ptr<string> requestId{};

  ListActivatedAlertsResponseBody() {}

  explicit ListActivatedAlertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = page ? boost::any(page->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      if (typeid(map<string, boost::any>) == m["Page"].type()) {
        ListActivatedAlertsResponseBodyPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Page"]));
        page = make_shared<ListActivatedAlertsResponseBodyPage>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListActivatedAlertsResponseBody() = default;
};
class ListActivatedAlertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListActivatedAlertsResponseBody> body{};

  ListActivatedAlertsResponse() {}

  explicit ListActivatedAlertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListActivatedAlertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListActivatedAlertsResponseBody>(model1);
      }
    }
  }


  virtual ~ListActivatedAlertsResponse() = default;
};
class ListAlertEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> matchingConditions{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListAlertEventsRequest() {}

  explicit ListAlertEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (matchingConditions) {
      res["MatchingConditions"] = boost::any(*matchingConditions);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("MatchingConditions") != m.end() && !m["MatchingConditions"].empty()) {
      matchingConditions = make_shared<string>(boost::any_cast<string>(m["MatchingConditions"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAlertEventsRequest() = default;
};
class ListAlertEventsResponseBodyPageBeanEventsAlarms : public Darabonba::Model {
public:
  shared_ptr<long> alarmId{};
  shared_ptr<string> alarmName{};
  shared_ptr<string> createTime{};
  shared_ptr<long> state{};

  ListAlertEventsResponseBodyPageBeanEventsAlarms() {}

  explicit ListAlertEventsResponseBodyPageBeanEventsAlarms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmId) {
      res["AlarmId"] = boost::any(*alarmId);
    }
    if (alarmName) {
      res["AlarmName"] = boost::any(*alarmName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmId") != m.end() && !m["AlarmId"].empty()) {
      alarmId = make_shared<long>(boost::any_cast<long>(m["AlarmId"]));
    }
    if (m.find("AlarmName") != m.end() && !m["AlarmName"].empty()) {
      alarmName = make_shared<string>(boost::any_cast<string>(m["AlarmName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyPageBeanEventsAlarms() = default;
};
class ListAlertEventsResponseBodyPageBeanEvents : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertEventsResponseBodyPageBeanEventsAlarms>> alarms{};
  shared_ptr<string> alertName{};
  shared_ptr<string> annotations{};
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> generatorURL{};
  shared_ptr<string> handlerName{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> labels{};
  shared_ptr<string> receiveTime{};
  shared_ptr<string> severity{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListAlertEventsResponseBodyPageBeanEvents() {}

  explicit ListAlertEventsResponseBodyPageBeanEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarms) {
      vector<boost::any> temp1;
      for(auto item1:*alarms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Alarms"] = boost::any(temp1);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (generatorURL) {
      res["GeneratorURL"] = boost::any(*generatorURL);
    }
    if (handlerName) {
      res["HandlerName"] = boost::any(*handlerName);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (receiveTime) {
      res["ReceiveTime"] = boost::any(*receiveTime);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alarms") != m.end() && !m["Alarms"].empty()) {
      if (typeid(vector<boost::any>) == m["Alarms"].type()) {
        vector<ListAlertEventsResponseBodyPageBeanEventsAlarms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Alarms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertEventsResponseBodyPageBeanEventsAlarms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarms = make_shared<vector<ListAlertEventsResponseBodyPageBeanEventsAlarms>>(expect1);
      }
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GeneratorURL") != m.end() && !m["GeneratorURL"].empty()) {
      generatorURL = make_shared<string>(boost::any_cast<string>(m["GeneratorURL"]));
    }
    if (m.find("HandlerName") != m.end() && !m["HandlerName"].empty()) {
      handlerName = make_shared<string>(boost::any_cast<string>(m["HandlerName"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("ReceiveTime") != m.end() && !m["ReceiveTime"].empty()) {
      receiveTime = make_shared<string>(boost::any_cast<string>(m["ReceiveTime"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyPageBeanEvents() = default;
};
class ListAlertEventsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertEventsResponseBodyPageBeanEvents>> events{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListAlertEventsResponseBodyPageBean() {}

  explicit ListAlertEventsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Events"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Events") != m.end() && !m["Events"].empty()) {
      if (typeid(vector<boost::any>) == m["Events"].type()) {
        vector<ListAlertEventsResponseBodyPageBeanEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertEventsResponseBodyPageBeanEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<ListAlertEventsResponseBodyPageBeanEvents>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyPageBean() = default;
};
class ListAlertEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAlertEventsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListAlertEventsResponseBody() {}

  explicit ListAlertEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListAlertEventsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListAlertEventsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAlertEventsResponseBody() = default;
};
class ListAlertEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlertEventsResponseBody> body{};

  ListAlertEventsResponse() {}

  explicit ListAlertEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertEventsResponse() = default;
};
class ListAlertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> integrationType{};
  shared_ptr<long> page{};
  shared_ptr<string> severity{};
  shared_ptr<bool> showActivities{};
  shared_ptr<bool> showEvents{};
  shared_ptr<long> size{};
  shared_ptr<string> startTime{};
  shared_ptr<long> state{};

  ListAlertsRequest() {}

  explicit ListAlertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (showActivities) {
      res["ShowActivities"] = boost::any(*showActivities);
    }
    if (showEvents) {
      res["ShowEvents"] = boost::any(*showEvents);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("ShowActivities") != m.end() && !m["ShowActivities"].empty()) {
      showActivities = make_shared<bool>(boost::any_cast<bool>(m["ShowActivities"]));
    }
    if (m.find("ShowEvents") != m.end() && !m["ShowEvents"].empty()) {
      showEvents = make_shared<bool>(boost::any_cast<bool>(m["ShowEvents"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~ListAlertsRequest() = default;
};
class ListAlertsResponseBodyPageBeanListAlertsActivities : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> handlerName{};
  shared_ptr<string> time{};
  shared_ptr<long> type{};

  ListAlertsResponseBodyPageBeanListAlertsActivities() {}

  explicit ListAlertsResponseBodyPageBeanListAlertsActivities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (handlerName) {
      res["HandlerName"] = boost::any(*handlerName);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HandlerName") != m.end() && !m["HandlerName"].empty()) {
      handlerName = make_shared<string>(boost::any_cast<string>(m["HandlerName"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ListAlertsResponseBodyPageBeanListAlertsActivities() = default;
};
class ListAlertsResponseBodyPageBeanListAlertsAlertEvents : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<string> annotations{};
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> generatorURL{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> labels{};
  shared_ptr<string> receiveTime{};
  shared_ptr<string> severity{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};

  ListAlertsResponseBodyPageBeanListAlertsAlertEvents() {}

  explicit ListAlertsResponseBodyPageBeanListAlertsAlertEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (generatorURL) {
      res["GeneratorURL"] = boost::any(*generatorURL);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (receiveTime) {
      res["ReceiveTime"] = boost::any(*receiveTime);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GeneratorURL") != m.end() && !m["GeneratorURL"].empty()) {
      generatorURL = make_shared<string>(boost::any_cast<string>(m["GeneratorURL"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("ReceiveTime") != m.end() && !m["ReceiveTime"].empty()) {
      receiveTime = make_shared<string>(boost::any_cast<string>(m["ReceiveTime"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListAlertsResponseBodyPageBeanListAlertsAlertEvents() = default;
};
class ListAlertsResponseBodyPageBeanListAlerts : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertsResponseBodyPageBeanListAlertsActivities>> activities{};
  shared_ptr<vector<ListAlertsResponseBodyPageBeanListAlertsAlertEvents>> alertEvents{};
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<string> createTime{};
  shared_ptr<double> dispatchRuleId{};
  shared_ptr<string> dispatchRuleName{};
  shared_ptr<string> severity{};
  shared_ptr<string> solution{};
  shared_ptr<long> state{};

  ListAlertsResponseBodyPageBeanListAlerts() {}

  explicit ListAlertsResponseBodyPageBeanListAlerts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activities) {
      vector<boost::any> temp1;
      for(auto item1:*activities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Activities"] = boost::any(temp1);
    }
    if (alertEvents) {
      vector<boost::any> temp1;
      for(auto item1:*alertEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertEvents"] = boost::any(temp1);
    }
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (dispatchRuleName) {
      res["DispatchRuleName"] = boost::any(*dispatchRuleName);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (solution) {
      res["Solution"] = boost::any(*solution);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Activities") != m.end() && !m["Activities"].empty()) {
      if (typeid(vector<boost::any>) == m["Activities"].type()) {
        vector<ListAlertsResponseBodyPageBeanListAlertsActivities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Activities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertsResponseBodyPageBeanListAlertsActivities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activities = make_shared<vector<ListAlertsResponseBodyPageBeanListAlertsActivities>>(expect1);
      }
    }
    if (m.find("AlertEvents") != m.end() && !m["AlertEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertEvents"].type()) {
        vector<ListAlertsResponseBodyPageBeanListAlertsAlertEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertsResponseBodyPageBeanListAlertsAlertEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertEvents = make_shared<vector<ListAlertsResponseBodyPageBeanListAlertsAlertEvents>>(expect1);
      }
    }
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<double>(boost::any_cast<double>(m["DispatchRuleId"]));
    }
    if (m.find("DispatchRuleName") != m.end() && !m["DispatchRuleName"].empty()) {
      dispatchRuleName = make_shared<string>(boost::any_cast<string>(m["DispatchRuleName"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Solution") != m.end() && !m["Solution"].empty()) {
      solution = make_shared<string>(boost::any_cast<string>(m["Solution"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~ListAlertsResponseBodyPageBeanListAlerts() = default;
};
class ListAlertsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertsResponseBodyPageBeanListAlerts>> listAlerts{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListAlertsResponseBodyPageBean() {}

  explicit ListAlertsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listAlerts) {
      vector<boost::any> temp1;
      for(auto item1:*listAlerts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListAlerts"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListAlerts") != m.end() && !m["ListAlerts"].empty()) {
      if (typeid(vector<boost::any>) == m["ListAlerts"].type()) {
        vector<ListAlertsResponseBodyPageBeanListAlerts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListAlerts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertsResponseBodyPageBeanListAlerts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listAlerts = make_shared<vector<ListAlertsResponseBodyPageBeanListAlerts>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListAlertsResponseBodyPageBean() = default;
};
class ListAlertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAlertsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListAlertsResponseBody() {}

  explicit ListAlertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListAlertsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListAlertsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAlertsResponseBody() = default;
};
class ListAlertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlertsResponseBody> body{};

  ListAlertsResponse() {}

  explicit ListAlertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertsResponse() = default;
};
class ListClusterFromGrafanaRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  ListClusterFromGrafanaRequest() {}

  explicit ListClusterFromGrafanaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListClusterFromGrafanaRequest() = default;
};
class ListClusterFromGrafanaResponseBodyPromClusterList : public Darabonba::Model {
public:
  shared_ptr<string> agentStatus{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> controllerId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> extra{};
  shared_ptr<long> id{};
  shared_ptr<long> installTime{};
  shared_ptr<bool> isControllerInstalled{};
  shared_ptr<long> lastHeartBeatTime{};
  shared_ptr<long> nodeNum{};
  shared_ptr<string> options{};
  shared_ptr<string> pluginsJsonArray{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stateJson{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  ListClusterFromGrafanaResponseBodyPromClusterList() {}

  explicit ListClusterFromGrafanaResponseBodyPromClusterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStatus) {
      res["AgentStatus"] = boost::any(*agentStatus);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (controllerId) {
      res["ControllerId"] = boost::any(*controllerId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (installTime) {
      res["InstallTime"] = boost::any(*installTime);
    }
    if (isControllerInstalled) {
      res["IsControllerInstalled"] = boost::any(*isControllerInstalled);
    }
    if (lastHeartBeatTime) {
      res["LastHeartBeatTime"] = boost::any(*lastHeartBeatTime);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (pluginsJsonArray) {
      res["PluginsJsonArray"] = boost::any(*pluginsJsonArray);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stateJson) {
      res["StateJson"] = boost::any(*stateJson);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentStatus") != m.end() && !m["AgentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["AgentStatus"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("ControllerId") != m.end() && !m["ControllerId"].empty()) {
      controllerId = make_shared<string>(boost::any_cast<string>(m["ControllerId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstallTime") != m.end() && !m["InstallTime"].empty()) {
      installTime = make_shared<long>(boost::any_cast<long>(m["InstallTime"]));
    }
    if (m.find("IsControllerInstalled") != m.end() && !m["IsControllerInstalled"].empty()) {
      isControllerInstalled = make_shared<bool>(boost::any_cast<bool>(m["IsControllerInstalled"]));
    }
    if (m.find("LastHeartBeatTime") != m.end() && !m["LastHeartBeatTime"].empty()) {
      lastHeartBeatTime = make_shared<long>(boost::any_cast<long>(m["LastHeartBeatTime"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("PluginsJsonArray") != m.end() && !m["PluginsJsonArray"].empty()) {
      pluginsJsonArray = make_shared<string>(boost::any_cast<string>(m["PluginsJsonArray"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StateJson") != m.end() && !m["StateJson"].empty()) {
      stateJson = make_shared<string>(boost::any_cast<string>(m["StateJson"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListClusterFromGrafanaResponseBodyPromClusterList() = default;
};
class ListClusterFromGrafanaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterFromGrafanaResponseBodyPromClusterList>> promClusterList{};
  shared_ptr<string> requestId{};

  ListClusterFromGrafanaResponseBody() {}

  explicit ListClusterFromGrafanaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (promClusterList) {
      vector<boost::any> temp1;
      for(auto item1:*promClusterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PromClusterList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PromClusterList") != m.end() && !m["PromClusterList"].empty()) {
      if (typeid(vector<boost::any>) == m["PromClusterList"].type()) {
        vector<ListClusterFromGrafanaResponseBodyPromClusterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PromClusterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterFromGrafanaResponseBodyPromClusterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promClusterList = make_shared<vector<ListClusterFromGrafanaResponseBodyPromClusterList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClusterFromGrafanaResponseBody() = default;
};
class ListClusterFromGrafanaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterFromGrafanaResponseBody> body{};

  ListClusterFromGrafanaResponse() {}

  explicit ListClusterFromGrafanaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterFromGrafanaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterFromGrafanaResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterFromGrafanaResponse() = default;
};
class ListCmsInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> typeFilter{};

  ListCmsInstancesRequest() {}

  explicit ListCmsInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (typeFilter) {
      res["TypeFilter"] = boost::any(*typeFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TypeFilter") != m.end() && !m["TypeFilter"].empty()) {
      typeFilter = make_shared<string>(boost::any_cast<string>(m["TypeFilter"]));
    }
  }


  virtual ~ListCmsInstancesRequest() = default;
};
class ListCmsInstancesResponseBodyDataProducts : public Darabonba::Model {
public:
  shared_ptr<string> descr{};
  shared_ptr<string> id{};
  shared_ptr<string> instance{};
  shared_ptr<string> name{};
  shared_ptr<string> prod{};
  shared_ptr<string> source{};
  shared_ptr<string> state{};
  shared_ptr<string> time{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  ListCmsInstancesResponseBodyDataProducts() {}

  explicit ListCmsInstancesResponseBodyDataProducts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (descr) {
      res["Descr"] = boost::any(*descr);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (prod) {
      res["Prod"] = boost::any(*prod);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Descr") != m.end() && !m["Descr"].empty()) {
      descr = make_shared<string>(boost::any_cast<string>(m["Descr"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Prod") != m.end() && !m["Prod"].empty()) {
      prod = make_shared<string>(boost::any_cast<string>(m["Prod"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListCmsInstancesResponseBodyDataProducts() = default;
};
class ListCmsInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> enableTag{};
  shared_ptr<vector<ListCmsInstancesResponseBodyDataProducts>> products{};

  ListCmsInstancesResponseBodyData() {}

  explicit ListCmsInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableTag) {
      res["EnableTag"] = boost::any(*enableTag);
    }
    if (products) {
      vector<boost::any> temp1;
      for(auto item1:*products){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Products"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableTag") != m.end() && !m["EnableTag"].empty()) {
      enableTag = make_shared<bool>(boost::any_cast<bool>(m["EnableTag"]));
    }
    if (m.find("Products") != m.end() && !m["Products"].empty()) {
      if (typeid(vector<boost::any>) == m["Products"].type()) {
        vector<ListCmsInstancesResponseBodyDataProducts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Products"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCmsInstancesResponseBodyDataProducts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        products = make_shared<vector<ListCmsInstancesResponseBodyDataProducts>>(expect1);
      }
    }
  }


  virtual ~ListCmsInstancesResponseBodyData() = default;
};
class ListCmsInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCmsInstancesResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ListCmsInstancesResponseBody() {}

  explicit ListCmsInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCmsInstancesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCmsInstancesResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCmsInstancesResponseBody() = default;
};
class ListCmsInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCmsInstancesResponseBody> body{};

  ListCmsInstancesResponse() {}

  explicit ListCmsInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCmsInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCmsInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCmsInstancesResponse() = default;
};
class ListDashboardsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> dashboardName{};
  shared_ptr<string> language{};
  shared_ptr<string> product{};
  shared_ptr<bool> recreateSwitch{};
  shared_ptr<string> regionId{};
  shared_ptr<string> title{};

  ListDashboardsRequest() {}

  explicit ListDashboardsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (dashboardName) {
      res["DashboardName"] = boost::any(*dashboardName);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (recreateSwitch) {
      res["RecreateSwitch"] = boost::any(*recreateSwitch);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("DashboardName") != m.end() && !m["DashboardName"].empty()) {
      dashboardName = make_shared<string>(boost::any_cast<string>(m["DashboardName"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RecreateSwitch") != m.end() && !m["RecreateSwitch"].empty()) {
      recreateSwitch = make_shared<bool>(boost::any_cast<bool>(m["RecreateSwitch"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~ListDashboardsRequest() = default;
};
class ListDashboardsResponseBodyDashboardVosI18nChild : public Darabonba::Model {
public:
  shared_ptr<string> dashboardType{};
  shared_ptr<string> exporter{};
  shared_ptr<string> httpUrl{};
  shared_ptr<string> httpsUrl{};
  shared_ptr<string> id{};
  shared_ptr<bool> isArmsExporter{};
  shared_ptr<string> kind{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<bool> needUpdate{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> time{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<string> uid{};
  shared_ptr<string> url{};
  shared_ptr<string> version{};

  ListDashboardsResponseBodyDashboardVosI18nChild() {}

  explicit ListDashboardsResponseBodyDashboardVosI18nChild(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboardType) {
      res["DashboardType"] = boost::any(*dashboardType);
    }
    if (exporter) {
      res["Exporter"] = boost::any(*exporter);
    }
    if (httpUrl) {
      res["HttpUrl"] = boost::any(*httpUrl);
    }
    if (httpsUrl) {
      res["HttpsUrl"] = boost::any(*httpsUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isArmsExporter) {
      res["IsArmsExporter"] = boost::any(*isArmsExporter);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needUpdate) {
      res["NeedUpdate"] = boost::any(*needUpdate);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DashboardType") != m.end() && !m["DashboardType"].empty()) {
      dashboardType = make_shared<string>(boost::any_cast<string>(m["DashboardType"]));
    }
    if (m.find("Exporter") != m.end() && !m["Exporter"].empty()) {
      exporter = make_shared<string>(boost::any_cast<string>(m["Exporter"]));
    }
    if (m.find("HttpUrl") != m.end() && !m["HttpUrl"].empty()) {
      httpUrl = make_shared<string>(boost::any_cast<string>(m["HttpUrl"]));
    }
    if (m.find("HttpsUrl") != m.end() && !m["HttpsUrl"].empty()) {
      httpsUrl = make_shared<string>(boost::any_cast<string>(m["HttpsUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsArmsExporter") != m.end() && !m["IsArmsExporter"].empty()) {
      isArmsExporter = make_shared<bool>(boost::any_cast<bool>(m["IsArmsExporter"]));
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedUpdate") != m.end() && !m["NeedUpdate"].empty()) {
      needUpdate = make_shared<bool>(boost::any_cast<bool>(m["NeedUpdate"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListDashboardsResponseBodyDashboardVosI18nChild() = default;
};
class ListDashboardsResponseBodyDashboardVos : public Darabonba::Model {
public:
  shared_ptr<string> dashboardType{};
  shared_ptr<string> exporter{};
  shared_ptr<string> httpUrl{};
  shared_ptr<string> httpsUrl{};
  shared_ptr<ListDashboardsResponseBodyDashboardVosI18nChild> i18nChild{};
  shared_ptr<string> id{};
  shared_ptr<bool> isArmsExporter{};
  shared_ptr<string> kind{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<bool> needUpdate{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> time{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<string> uid{};
  shared_ptr<string> url{};
  shared_ptr<string> version{};

  ListDashboardsResponseBodyDashboardVos() {}

  explicit ListDashboardsResponseBodyDashboardVos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboardType) {
      res["DashboardType"] = boost::any(*dashboardType);
    }
    if (exporter) {
      res["Exporter"] = boost::any(*exporter);
    }
    if (httpUrl) {
      res["HttpUrl"] = boost::any(*httpUrl);
    }
    if (httpsUrl) {
      res["HttpsUrl"] = boost::any(*httpsUrl);
    }
    if (i18nChild) {
      res["I18nChild"] = i18nChild ? boost::any(i18nChild->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isArmsExporter) {
      res["IsArmsExporter"] = boost::any(*isArmsExporter);
    }
    if (kind) {
      res["Kind"] = boost::any(*kind);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needUpdate) {
      res["NeedUpdate"] = boost::any(*needUpdate);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DashboardType") != m.end() && !m["DashboardType"].empty()) {
      dashboardType = make_shared<string>(boost::any_cast<string>(m["DashboardType"]));
    }
    if (m.find("Exporter") != m.end() && !m["Exporter"].empty()) {
      exporter = make_shared<string>(boost::any_cast<string>(m["Exporter"]));
    }
    if (m.find("HttpUrl") != m.end() && !m["HttpUrl"].empty()) {
      httpUrl = make_shared<string>(boost::any_cast<string>(m["HttpUrl"]));
    }
    if (m.find("HttpsUrl") != m.end() && !m["HttpsUrl"].empty()) {
      httpsUrl = make_shared<string>(boost::any_cast<string>(m["HttpsUrl"]));
    }
    if (m.find("I18nChild") != m.end() && !m["I18nChild"].empty()) {
      if (typeid(map<string, boost::any>) == m["I18nChild"].type()) {
        ListDashboardsResponseBodyDashboardVosI18nChild model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["I18nChild"]));
        i18nChild = make_shared<ListDashboardsResponseBodyDashboardVosI18nChild>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsArmsExporter") != m.end() && !m["IsArmsExporter"].empty()) {
      isArmsExporter = make_shared<bool>(boost::any_cast<bool>(m["IsArmsExporter"]));
    }
    if (m.find("Kind") != m.end() && !m["Kind"].empty()) {
      kind = make_shared<string>(boost::any_cast<string>(m["Kind"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedUpdate") != m.end() && !m["NeedUpdate"].empty()) {
      needUpdate = make_shared<bool>(boost::any_cast<bool>(m["NeedUpdate"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListDashboardsResponseBodyDashboardVos() = default;
};
class ListDashboardsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDashboardsResponseBodyDashboardVos>> dashboardVos{};
  shared_ptr<string> requestId{};

  ListDashboardsResponseBody() {}

  explicit ListDashboardsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashboardVos) {
      vector<boost::any> temp1;
      for(auto item1:*dashboardVos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DashboardVos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DashboardVos") != m.end() && !m["DashboardVos"].empty()) {
      if (typeid(vector<boost::any>) == m["DashboardVos"].type()) {
        vector<ListDashboardsResponseBodyDashboardVos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DashboardVos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDashboardsResponseBodyDashboardVos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dashboardVos = make_shared<vector<ListDashboardsResponseBodyDashboardVos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDashboardsResponseBody() = default;
};
class ListDashboardsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDashboardsResponseBody> body{};

  ListDashboardsResponse() {}

  explicit ListDashboardsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDashboardsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDashboardsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDashboardsResponse() = default;
};
class ListDashboardsByNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> dashBoardName{};
  shared_ptr<string> dashBoardVersion{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> groupName{};
  shared_ptr<bool> onlyQuery{};
  shared_ptr<string> productCode{};
  shared_ptr<string> regionId{};

  ListDashboardsByNameRequest() {}

  explicit ListDashboardsByNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (dashBoardName) {
      res["DashBoardName"] = boost::any(*dashBoardName);
    }
    if (dashBoardVersion) {
      res["DashBoardVersion"] = boost::any(*dashBoardVersion);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (onlyQuery) {
      res["OnlyQuery"] = boost::any(*onlyQuery);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("DashBoardName") != m.end() && !m["DashBoardName"].empty()) {
      dashBoardName = make_shared<string>(boost::any_cast<string>(m["DashBoardName"]));
    }
    if (m.find("DashBoardVersion") != m.end() && !m["DashBoardVersion"].empty()) {
      dashBoardVersion = make_shared<string>(boost::any_cast<string>(m["DashBoardVersion"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("OnlyQuery") != m.end() && !m["OnlyQuery"].empty()) {
      onlyQuery = make_shared<bool>(boost::any_cast<bool>(m["OnlyQuery"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListDashboardsByNameRequest() = default;
};
class ListDashboardsByNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListDashboardsByNameResponseBody() {}

  explicit ListDashboardsByNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDashboardsByNameResponseBody() = default;
};
class ListDashboardsByNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDashboardsByNameResponseBody> body{};

  ListDashboardsByNameResponse() {}

  explicit ListDashboardsByNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDashboardsByNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDashboardsByNameResponseBody>(model1);
      }
    }
  }


  virtual ~ListDashboardsByNameResponse() = default;
};
class ListDispatchRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> system{};

  ListDispatchRuleRequest() {}

  explicit ListDispatchRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
  }


  virtual ~ListDispatchRuleRequest() = default;
};
class ListDispatchRuleResponseBodyDispatchRules : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> state{};

  ListDispatchRuleResponseBodyDispatchRules() {}

  explicit ListDispatchRuleResponseBodyDispatchRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListDispatchRuleResponseBodyDispatchRules() = default;
};
class ListDispatchRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDispatchRuleResponseBodyDispatchRules>> dispatchRules{};
  shared_ptr<string> requestId{};

  ListDispatchRuleResponseBody() {}

  explicit ListDispatchRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchRules) {
      vector<boost::any> temp1;
      for(auto item1:*dispatchRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DispatchRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchRules") != m.end() && !m["DispatchRules"].empty()) {
      if (typeid(vector<boost::any>) == m["DispatchRules"].type()) {
        vector<ListDispatchRuleResponseBodyDispatchRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DispatchRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDispatchRuleResponseBodyDispatchRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dispatchRules = make_shared<vector<ListDispatchRuleResponseBodyDispatchRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDispatchRuleResponseBody() = default;
};
class ListDispatchRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDispatchRuleResponseBody> body{};

  ListDispatchRuleResponse() {}

  explicit ListDispatchRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDispatchRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDispatchRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ListDispatchRuleResponse() = default;
};
class ListEscalationPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListEscalationPoliciesRequest() {}

  explicit ListEscalationPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListEscalationPoliciesRequest() = default;
};
class ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies() {}

  explicit ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies() = default;
};
class ListEscalationPoliciesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies>> escalationPolicies{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListEscalationPoliciesResponseBodyPageBean() {}

  explicit ListEscalationPoliciesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EscalationPolicies"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EscalationPolicies") != m.end() && !m["EscalationPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["EscalationPolicies"].type()) {
        vector<ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EscalationPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPolicies = make_shared<vector<ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListEscalationPoliciesResponseBodyPageBean() = default;
};
class ListEscalationPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListEscalationPoliciesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListEscalationPoliciesResponseBody() {}

  explicit ListEscalationPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListEscalationPoliciesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListEscalationPoliciesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEscalationPoliciesResponseBody() = default;
};
class ListEscalationPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEscalationPoliciesResponseBody> body{};

  ListEscalationPoliciesResponse() {}

  explicit ListEscalationPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEscalationPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEscalationPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEscalationPoliciesResponse() = default;
};
class ListEventBridgeIntegrationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListEventBridgeIntegrationsRequest() {}

  explicit ListEventBridgeIntegrationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListEventBridgeIntegrationsRequest() = default;
};
class ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations() {}

  explicit ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations() = default;
};
class ListEventBridgeIntegrationsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations>> eventBridgeIntegrations{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListEventBridgeIntegrationsResponseBodyPageBean() {}

  explicit ListEventBridgeIntegrationsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventBridgeIntegrations) {
      vector<boost::any> temp1;
      for(auto item1:*eventBridgeIntegrations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventBridgeIntegrations"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventBridgeIntegrations") != m.end() && !m["EventBridgeIntegrations"].empty()) {
      if (typeid(vector<boost::any>) == m["EventBridgeIntegrations"].type()) {
        vector<ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventBridgeIntegrations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventBridgeIntegrations = make_shared<vector<ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListEventBridgeIntegrationsResponseBodyPageBean() = default;
};
class ListEventBridgeIntegrationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListEventBridgeIntegrationsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListEventBridgeIntegrationsResponseBody() {}

  explicit ListEventBridgeIntegrationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListEventBridgeIntegrationsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListEventBridgeIntegrationsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEventBridgeIntegrationsResponseBody() = default;
};
class ListEventBridgeIntegrationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEventBridgeIntegrationsResponseBody> body{};

  ListEventBridgeIntegrationsResponse() {}

  explicit ListEventBridgeIntegrationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEventBridgeIntegrationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEventBridgeIntegrationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEventBridgeIntegrationsResponse() = default;
};
class ListInsightsEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> insightsTypes{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  ListInsightsEventsRequest() {}

  explicit ListInsightsEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (insightsTypes) {
      res["InsightsTypes"] = boost::any(*insightsTypes);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InsightsTypes") != m.end() && !m["InsightsTypes"].empty()) {
      insightsTypes = make_shared<string>(boost::any_cast<string>(m["InsightsTypes"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListInsightsEventsRequest() = default;
};
class ListInsightsEventsResponseBodyInsightsEvents : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<string> desc{};
  shared_ptr<string> level{};
  shared_ptr<string> pid{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  ListInsightsEventsResponseBodyInsightsEvents() {}

  explicit ListInsightsEventsResponseBodyInsightsEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["Date"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListInsightsEventsResponseBodyInsightsEvents() = default;
};
class ListInsightsEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListInsightsEventsResponseBodyInsightsEvents>> insightsEvents{};
  shared_ptr<string> requestId{};

  ListInsightsEventsResponseBody() {}

  explicit ListInsightsEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (insightsEvents) {
      vector<boost::any> temp1;
      for(auto item1:*insightsEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InsightsEvents"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InsightsEvents") != m.end() && !m["InsightsEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["InsightsEvents"].type()) {
        vector<ListInsightsEventsResponseBodyInsightsEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InsightsEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInsightsEventsResponseBodyInsightsEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insightsEvents = make_shared<vector<ListInsightsEventsResponseBodyInsightsEvents>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInsightsEventsResponseBody() = default;
};
class ListInsightsEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInsightsEventsResponseBody> body{};

  ListInsightsEventsResponse() {}

  explicit ListInsightsEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInsightsEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInsightsEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListInsightsEventsResponse() = default;
};
class ListIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<bool> isDetail{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListIntegrationRequest() {}

  explicit ListIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (isDetail) {
      res["IsDetail"] = boost::any(*isDetail);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("IsDetail") != m.end() && !m["IsDetail"].empty()) {
      isDetail = make_shared<bool>(boost::any_cast<bool>(m["IsDetail"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListIntegrationRequest() = default;
};
class ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail : public Darabonba::Model {
public:
  shared_ptr<bool> autoRecover{};
  shared_ptr<string> description{};
  shared_ptr<string> duplicateKey{};
  shared_ptr<vector<map<string, boost::any>>> extendedFieldRedefineRules{};
  shared_ptr<vector<map<string, boost::any>>> fieldRedefineRules{};
  shared_ptr<string> initiativeRecoverField{};
  shared_ptr<string> initiativeRecoverValue{};
  shared_ptr<long> recoverTime{};
  shared_ptr<vector<long>> stat{};

  ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail() {}

  explicit ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRecover) {
      res["AutoRecover"] = boost::any(*autoRecover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duplicateKey) {
      res["DuplicateKey"] = boost::any(*duplicateKey);
    }
    if (extendedFieldRedefineRules) {
      res["ExtendedFieldRedefineRules"] = boost::any(*extendedFieldRedefineRules);
    }
    if (fieldRedefineRules) {
      res["FieldRedefineRules"] = boost::any(*fieldRedefineRules);
    }
    if (initiativeRecoverField) {
      res["InitiativeRecoverField"] = boost::any(*initiativeRecoverField);
    }
    if (initiativeRecoverValue) {
      res["InitiativeRecoverValue"] = boost::any(*initiativeRecoverValue);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    if (stat) {
      res["Stat"] = boost::any(*stat);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRecover") != m.end() && !m["AutoRecover"].empty()) {
      autoRecover = make_shared<bool>(boost::any_cast<bool>(m["AutoRecover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DuplicateKey") != m.end() && !m["DuplicateKey"].empty()) {
      duplicateKey = make_shared<string>(boost::any_cast<string>(m["DuplicateKey"]));
    }
    if (m.find("ExtendedFieldRedefineRules") != m.end() && !m["ExtendedFieldRedefineRules"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["ExtendedFieldRedefineRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExtendedFieldRedefineRules"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      extendedFieldRedefineRules = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("FieldRedefineRules") != m.end() && !m["FieldRedefineRules"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["FieldRedefineRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldRedefineRules"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      fieldRedefineRules = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("InitiativeRecoverField") != m.end() && !m["InitiativeRecoverField"].empty()) {
      initiativeRecoverField = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverField"]));
    }
    if (m.find("InitiativeRecoverValue") != m.end() && !m["InitiativeRecoverValue"].empty()) {
      initiativeRecoverValue = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverValue"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
    if (m.find("Stat") != m.end() && !m["Stat"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Stat"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Stat"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      stat = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail() = default;
};
class ListIntegrationResponseBodyPageInfoIntegrations : public Darabonba::Model {
public:
  shared_ptr<string> apiEndpoint{};
  shared_ptr<string> createTime{};
  shared_ptr<ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail> integrationDetail{};
  shared_ptr<long> integrationId{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<string> liveness{};
  shared_ptr<string> shortToken{};
  shared_ptr<bool> state{};

  ListIntegrationResponseBodyPageInfoIntegrations() {}

  explicit ListIntegrationResponseBodyPageInfoIntegrations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiEndpoint) {
      res["ApiEndpoint"] = boost::any(*apiEndpoint);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (integrationDetail) {
      res["IntegrationDetail"] = integrationDetail ? boost::any(integrationDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (shortToken) {
      res["ShortToken"] = boost::any(*shortToken);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiEndpoint") != m.end() && !m["ApiEndpoint"].empty()) {
      apiEndpoint = make_shared<string>(boost::any_cast<string>(m["ApiEndpoint"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IntegrationDetail") != m.end() && !m["IntegrationDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["IntegrationDetail"].type()) {
        ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IntegrationDetail"]));
        integrationDetail = make_shared<ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail>(model1);
      }
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("ShortToken") != m.end() && !m["ShortToken"].empty()) {
      shortToken = make_shared<string>(boost::any_cast<string>(m["ShortToken"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<bool>(boost::any_cast<bool>(m["State"]));
    }
  }


  virtual ~ListIntegrationResponseBodyPageInfoIntegrations() = default;
};
class ListIntegrationResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListIntegrationResponseBodyPageInfoIntegrations>> integrations{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListIntegrationResponseBodyPageInfo() {}

  explicit ListIntegrationResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integrations) {
      vector<boost::any> temp1;
      for(auto item1:*integrations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Integrations"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Integrations") != m.end() && !m["Integrations"].empty()) {
      if (typeid(vector<boost::any>) == m["Integrations"].type()) {
        vector<ListIntegrationResponseBodyPageInfoIntegrations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Integrations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntegrationResponseBodyPageInfoIntegrations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        integrations = make_shared<vector<ListIntegrationResponseBodyPageInfoIntegrations>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListIntegrationResponseBodyPageInfo() = default;
};
class ListIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListIntegrationResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListIntegrationResponseBody() {}

  explicit ListIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListIntegrationResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListIntegrationResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIntegrationResponseBody() = default;
};
class ListIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntegrationResponseBody> body{};

  ListIntegrationResponse() {}

  explicit ListIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntegrationResponse() = default;
};
class ListNotificationPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ids{};
  shared_ptr<bool> isDetail{};
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};

  ListNotificationPoliciesRequest() {}

  explicit ListNotificationPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (isDetail) {
      res["IsDetail"] = boost::any(*isDetail);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("IsDetail") != m.end() && !m["IsDetail"].empty()) {
      isDetail = make_shared<bool>(boost::any_cast<bool>(m["IsDetail"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListNotificationPoliciesRequest() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule : public Darabonba::Model {
public:
  shared_ptr<long> groupInterval{};
  shared_ptr<long> groupWait{};
  shared_ptr<vector<string>> groupingFields{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInterval) {
      res["GroupInterval"] = boost::any(*groupInterval);
    }
    if (groupWait) {
      res["GroupWait"] = boost::any(*groupWait);
    }
    if (groupingFields) {
      res["GroupingFields"] = boost::any(*groupingFields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInterval") != m.end() && !m["GroupInterval"].empty()) {
      groupInterval = make_shared<long>(boost::any_cast<long>(m["GroupInterval"]));
    }
    if (m.find("GroupWait") != m.end() && !m["GroupWait"].empty()) {
      groupWait = make_shared<long>(boost::any_cast<long>(m["GroupWait"]));
    }
    if (m.find("GroupingFields") != m.end() && !m["GroupingFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupingFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupingFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupingFields = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions>> matchingConditions{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchingConditions) {
      vector<boost::any> temp1;
      for(auto item1:*matchingConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchingConditions") != m.end() && !m["MatchingConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingConditions"].type()) {
        vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingConditions = make_shared<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions>>(expect1);
      }
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<long> notifyObjectId{};
  shared_ptr<string> notifyObjectName{};
  shared_ptr<string> notifyObjectType{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyChannels) {
      res["NotifyChannels"] = boost::any(*notifyChannels);
    }
    if (notifyObjectId) {
      res["NotifyObjectId"] = boost::any(*notifyObjectId);
    }
    if (notifyObjectName) {
      res["NotifyObjectName"] = boost::any(*notifyObjectName);
    }
    if (notifyObjectType) {
      res["NotifyObjectType"] = boost::any(*notifyObjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyChannels") != m.end() && !m["NotifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyObjectId") != m.end() && !m["NotifyObjectId"].empty()) {
      notifyObjectId = make_shared<long>(boost::any_cast<long>(m["NotifyObjectId"]));
    }
    if (m.find("NotifyObjectName") != m.end() && !m["NotifyObjectName"].empty()) {
      notifyObjectName = make_shared<string>(boost::any_cast<string>(m["NotifyObjectName"]));
    }
    if (m.find("NotifyObjectType") != m.end() && !m["NotifyObjectType"].empty()) {
      notifyObjectType = make_shared<string>(boost::any_cast<string>(m["NotifyObjectType"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<string> notifyEndTime{};
  shared_ptr<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects>> notifyObjects{};
  shared_ptr<string> notifyStartTime{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyChannels) {
      res["NotifyChannels"] = boost::any(*notifyChannels);
    }
    if (notifyEndTime) {
      res["NotifyEndTime"] = boost::any(*notifyEndTime);
    }
    if (notifyObjects) {
      vector<boost::any> temp1;
      for(auto item1:*notifyObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotifyObjects"] = boost::any(temp1);
    }
    if (notifyStartTime) {
      res["NotifyStartTime"] = boost::any(*notifyStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyChannels") != m.end() && !m["NotifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyEndTime") != m.end() && !m["NotifyEndTime"].empty()) {
      notifyEndTime = make_shared<string>(boost::any_cast<string>(m["NotifyEndTime"]));
    }
    if (m.find("NotifyObjects") != m.end() && !m["NotifyObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["NotifyObjects"].type()) {
        vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotifyObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyObjects = make_shared<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects>>(expect1);
      }
    }
    if (m.find("NotifyStartTime") != m.end() && !m["NotifyStartTime"].empty()) {
      notifyStartTime = make_shared<string>(boost::any_cast<string>(m["NotifyStartTime"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> emailContent{};
  shared_ptr<string> emailRecoverContent{};
  shared_ptr<string> emailRecoverTitle{};
  shared_ptr<string> emailTitle{};
  shared_ptr<string> robotContent{};
  shared_ptr<string> smsContent{};
  shared_ptr<string> smsRecoverContent{};
  shared_ptr<string> ttsContent{};
  shared_ptr<string> ttsRecoverContent{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emailContent) {
      res["EmailContent"] = boost::any(*emailContent);
    }
    if (emailRecoverContent) {
      res["EmailRecoverContent"] = boost::any(*emailRecoverContent);
    }
    if (emailRecoverTitle) {
      res["EmailRecoverTitle"] = boost::any(*emailRecoverTitle);
    }
    if (emailTitle) {
      res["EmailTitle"] = boost::any(*emailTitle);
    }
    if (robotContent) {
      res["RobotContent"] = boost::any(*robotContent);
    }
    if (smsContent) {
      res["SmsContent"] = boost::any(*smsContent);
    }
    if (smsRecoverContent) {
      res["SmsRecoverContent"] = boost::any(*smsRecoverContent);
    }
    if (ttsContent) {
      res["TtsContent"] = boost::any(*ttsContent);
    }
    if (ttsRecoverContent) {
      res["TtsRecoverContent"] = boost::any(*ttsRecoverContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmailContent") != m.end() && !m["EmailContent"].empty()) {
      emailContent = make_shared<string>(boost::any_cast<string>(m["EmailContent"]));
    }
    if (m.find("EmailRecoverContent") != m.end() && !m["EmailRecoverContent"].empty()) {
      emailRecoverContent = make_shared<string>(boost::any_cast<string>(m["EmailRecoverContent"]));
    }
    if (m.find("EmailRecoverTitle") != m.end() && !m["EmailRecoverTitle"].empty()) {
      emailRecoverTitle = make_shared<string>(boost::any_cast<string>(m["EmailRecoverTitle"]));
    }
    if (m.find("EmailTitle") != m.end() && !m["EmailTitle"].empty()) {
      emailTitle = make_shared<string>(boost::any_cast<string>(m["EmailTitle"]));
    }
    if (m.find("RobotContent") != m.end() && !m["RobotContent"].empty()) {
      robotContent = make_shared<string>(boost::any_cast<string>(m["RobotContent"]));
    }
    if (m.find("SmsContent") != m.end() && !m["SmsContent"].empty()) {
      smsContent = make_shared<string>(boost::any_cast<string>(m["SmsContent"]));
    }
    if (m.find("SmsRecoverContent") != m.end() && !m["SmsRecoverContent"].empty()) {
      smsRecoverContent = make_shared<string>(boost::any_cast<string>(m["SmsRecoverContent"]));
    }
    if (m.find("TtsContent") != m.end() && !m["TtsContent"].empty()) {
      ttsContent = make_shared<string>(boost::any_cast<string>(m["TtsContent"]));
    }
    if (m.find("TtsRecoverContent") != m.end() && !m["TtsRecoverContent"].empty()) {
      ttsRecoverContent = make_shared<string>(boost::any_cast<string>(m["TtsRecoverContent"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate() = default;
};
class ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies : public Darabonba::Model {
public:
  shared_ptr<long> escalationPolicyId{};
  shared_ptr<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule> groupRule{};
  shared_ptr<long> id{};
  shared_ptr<long> integrationId{};
  shared_ptr<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules>> matchingRules{};
  shared_ptr<string> name{};
  shared_ptr<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule> notifyRule{};
  shared_ptr<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate> notifyTemplate{};
  shared_ptr<bool> repeat{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<bool> sendRecoverMessage{};

  ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies() {}

  explicit ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPolicyId) {
      res["EscalationPolicyId"] = boost::any(*escalationPolicyId);
    }
    if (groupRule) {
      res["GroupRule"] = groupRule ? boost::any(groupRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (matchingRules) {
      vector<boost::any> temp1;
      for(auto item1:*matchingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingRules"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyRule) {
      res["NotifyRule"] = notifyRule ? boost::any(notifyRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyTemplate) {
      res["NotifyTemplate"] = notifyTemplate ? boost::any(notifyTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (repeat) {
      res["Repeat"] = boost::any(*repeat);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (sendRecoverMessage) {
      res["SendRecoverMessage"] = boost::any(*sendRecoverMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EscalationPolicyId") != m.end() && !m["EscalationPolicyId"].empty()) {
      escalationPolicyId = make_shared<long>(boost::any_cast<long>(m["EscalationPolicyId"]));
    }
    if (m.find("GroupRule") != m.end() && !m["GroupRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupRule"].type()) {
        ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupRule"]));
        groupRule = make_shared<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingRules"].type()) {
        vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingRules = make_shared<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyRule") != m.end() && !m["NotifyRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyRule"].type()) {
        ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyRule"]));
        notifyRule = make_shared<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule>(model1);
      }
    }
    if (m.find("NotifyTemplate") != m.end() && !m["NotifyTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyTemplate"].type()) {
        ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyTemplate"]));
        notifyTemplate = make_shared<ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate>(model1);
      }
    }
    if (m.find("Repeat") != m.end() && !m["Repeat"].empty()) {
      repeat = make_shared<bool>(boost::any_cast<bool>(m["Repeat"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("SendRecoverMessage") != m.end() && !m["SendRecoverMessage"].empty()) {
      sendRecoverMessage = make_shared<bool>(boost::any_cast<bool>(m["SendRecoverMessage"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies() = default;
};
class ListNotificationPoliciesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies>> notificationPolicies{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListNotificationPoliciesResponseBodyPageBean() {}

  explicit ListNotificationPoliciesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notificationPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*notificationPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotificationPolicies"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotificationPolicies") != m.end() && !m["NotificationPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["NotificationPolicies"].type()) {
        vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotificationPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notificationPolicies = make_shared<vector<ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBodyPageBean() = default;
};
class ListNotificationPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListNotificationPoliciesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListNotificationPoliciesResponseBody() {}

  explicit ListNotificationPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListNotificationPoliciesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListNotificationPoliciesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListNotificationPoliciesResponseBody() = default;
};
class ListNotificationPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNotificationPoliciesResponseBody> body{};

  ListNotificationPoliciesResponse() {}

  explicit ListNotificationPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNotificationPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNotificationPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNotificationPoliciesResponse() = default;
};
class ListOnCallSchedulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListOnCallSchedulesRequest() {}

  explicit ListOnCallSchedulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListOnCallSchedulesRequest() = default;
};
class ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules() {}

  explicit ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules() = default;
};
class ListOnCallSchedulesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules>> onCallSchedules{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListOnCallSchedulesResponseBodyPageBean() {}

  explicit ListOnCallSchedulesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onCallSchedules) {
      vector<boost::any> temp1;
      for(auto item1:*onCallSchedules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OnCallSchedules"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnCallSchedules") != m.end() && !m["OnCallSchedules"].empty()) {
      if (typeid(vector<boost::any>) == m["OnCallSchedules"].type()) {
        vector<ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OnCallSchedules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        onCallSchedules = make_shared<vector<ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListOnCallSchedulesResponseBodyPageBean() = default;
};
class ListOnCallSchedulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListOnCallSchedulesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListOnCallSchedulesResponseBody() {}

  explicit ListOnCallSchedulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListOnCallSchedulesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListOnCallSchedulesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListOnCallSchedulesResponseBody() = default;
};
class ListOnCallSchedulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOnCallSchedulesResponseBody> body{};

  ListOnCallSchedulesResponse() {}

  explicit ListOnCallSchedulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOnCallSchedulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOnCallSchedulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListOnCallSchedulesResponse() = default;
};
class ListPrometheusAlertRulesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListPrometheusAlertRulesRequestTags() {}

  explicit ListPrometheusAlertRulesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertRulesRequestTags() = default;
};
class ListPrometheusAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> matchExpressions{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};
  shared_ptr<vector<ListPrometheusAlertRulesRequestTags>> tags{};
  shared_ptr<string> type{};

  ListPrometheusAlertRulesRequest() {}

  explicit ListPrometheusAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (matchExpressions) {
      res["MatchExpressions"] = boost::any(*matchExpressions);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MatchExpressions") != m.end() && !m["MatchExpressions"].empty()) {
      matchExpressions = make_shared<string>(boost::any_cast<string>(m["MatchExpressions"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListPrometheusAlertRulesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertRulesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListPrometheusAlertRulesRequestTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPrometheusAlertRulesRequest() = default;
};
class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations() {}

  explicit ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations() = default;
};
class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels() {}

  explicit ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels() = default;
};
class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags() {}

  explicit ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags() = default;
};
class ListPrometheusAlertRulesResponseBodyPrometheusAlertRules : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations>> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels>> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> status{};
  shared_ptr<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags>> tags{};
  shared_ptr<string> type{};

  ListPrometheusAlertRulesResponseBodyPrometheusAlertRules() {}

  explicit ListPrometheusAlertRulesResponseBodyPrometheusAlertRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations>>(expect1);
      }
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPrometheusAlertRulesResponseBodyPrometheusAlertRules() = default;
};
class ListPrometheusAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRules>> prometheusAlertRules{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListPrometheusAlertRulesResponseBody() {}

  explicit ListPrometheusAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (prometheusAlertRules) {
      vector<boost::any> temp1;
      for(auto item1:*prometheusAlertRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrometheusAlertRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PrometheusAlertRules") != m.end() && !m["PrometheusAlertRules"].empty()) {
      if (typeid(vector<boost::any>) == m["PrometheusAlertRules"].type()) {
        vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrometheusAlertRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertRulesResponseBodyPrometheusAlertRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prometheusAlertRules = make_shared<vector<ListPrometheusAlertRulesResponseBodyPrometheusAlertRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListPrometheusAlertRulesResponseBody() = default;
};
class ListPrometheusAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusAlertRulesResponseBody> body{};

  ListPrometheusAlertRulesResponse() {}

  explicit ListPrometheusAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusAlertRulesResponse() = default;
};
class ListPrometheusAlertTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  ListPrometheusAlertTemplatesRequest() {}

  explicit ListPrometheusAlertTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListPrometheusAlertTemplatesRequest() = default;
};
class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations() {}

  explicit ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations() = default;
};
class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels() {}

  explicit ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels() = default;
};
class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations>> annotations{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels>> labels{};
  shared_ptr<string> type{};
  shared_ptr<string> version{};

  ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates() {}

  explicit ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates() = default;
};
class ListPrometheusAlertTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates>> prometheusAlertTemplates{};
  shared_ptr<string> requestId{};

  ListPrometheusAlertTemplatesResponseBody() {}

  explicit ListPrometheusAlertTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prometheusAlertTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*prometheusAlertTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrometheusAlertTemplates"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrometheusAlertTemplates") != m.end() && !m["PrometheusAlertTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["PrometheusAlertTemplates"].type()) {
        vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrometheusAlertTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prometheusAlertTemplates = make_shared<vector<ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusAlertTemplatesResponseBody() = default;
};
class ListPrometheusAlertTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusAlertTemplatesResponseBody> body{};

  ListPrometheusAlertTemplatesResponse() {}

  explicit ListPrometheusAlertTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusAlertTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusAlertTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusAlertTemplatesResponse() = default;
};
class ListPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  ListPrometheusGlobalViewRequest() {}

  explicit ListPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListPrometheusGlobalViewRequest() = default;
};
class ListPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrometheusGlobalViewResponseBody() {}

  explicit ListPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusGlobalViewResponseBody() = default;
};
class ListPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusGlobalViewResponseBody> body{};

  ListPrometheusGlobalViewResponse() {}

  explicit ListPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusGlobalViewResponse() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListPrometheusInstanceByTagAndResourceGroupIdRequestTag() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdRequestTag() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListPrometheusInstanceByTagAndResourceGroupIdRequestTag>> tag{};

  ListPrometheusInstanceByTagAndResourceGroupIdRequest() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListPrometheusInstanceByTagAndResourceGroupIdRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusInstanceByTagAndResourceGroupIdRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListPrometheusInstanceByTagAndResourceGroupIdRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdRequest() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> grafanaInstanceId{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> subClustersJson{};
  shared_ptr<vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags>> tags{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (grafanaInstanceId) {
      res["GrafanaInstanceId"] = boost::any(*grafanaInstanceId);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (subClustersJson) {
      res["SubClustersJson"] = boost::any(*subClustersJson);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("GrafanaInstanceId") != m.end() && !m["GrafanaInstanceId"].empty()) {
      grafanaInstanceId = make_shared<string>(boost::any_cast<string>(m["GrafanaInstanceId"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SubClustersJson") != m.end() && !m["SubClustersJson"].empty()) {
      subClustersJson = make_shared<string>(boost::any_cast<string>(m["SubClustersJson"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances>> prometheusInstances{};

  ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prometheusInstances) {
      vector<boost::any> temp1;
      for(auto item1:*prometheusInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrometheusInstances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrometheusInstances") != m.end() && !m["PrometheusInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["PrometheusInstances"].type()) {
        vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrometheusInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prometheusInstances = make_shared<vector<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances>>(expect1);
      }
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrometheusInstanceByTagAndResourceGroupIdResponseBody() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdResponseBody() = default;
};
class ListPrometheusInstanceByTagAndResourceGroupIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusInstanceByTagAndResourceGroupIdResponseBody> body{};

  ListPrometheusInstanceByTagAndResourceGroupIdResponse() {}

  explicit ListPrometheusInstanceByTagAndResourceGroupIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusInstanceByTagAndResourceGroupIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusInstanceByTagAndResourceGroupIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusInstanceByTagAndResourceGroupIdResponse() = default;
};
class ListPrometheusInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> showGlobalView{};

  ListPrometheusInstancesRequest() {}

  explicit ListPrometheusInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showGlobalView) {
      res["ShowGlobalView"] = boost::any(*showGlobalView);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowGlobalView") != m.end() && !m["ShowGlobalView"].empty()) {
      showGlobalView = make_shared<bool>(boost::any_cast<bool>(m["ShowGlobalView"]));
    }
  }


  virtual ~ListPrometheusInstancesRequest() = default;
};
class ListPrometheusInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrometheusInstancesResponseBody() {}

  explicit ListPrometheusInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusInstancesResponseBody() = default;
};
class ListPrometheusInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusInstancesResponseBody> body{};

  ListPrometheusInstancesResponse() {}

  explicit ListPrometheusInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusInstancesResponse() = default;
};
class ListPrometheusIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> regionId{};

  ListPrometheusIntegrationRequest() {}

  explicit ListPrometheusIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListPrometheusIntegrationRequest() = default;
};
class ListPrometheusIntegrationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> canDelete{};
  shared_ptr<bool> canEditor{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerName{};
  shared_ptr<string> describe{};
  shared_ptr<string> exporterType{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> namespace_{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> param{};
  shared_ptr<string> podName{};
  shared_ptr<bool> showDescribe{};
  shared_ptr<bool> showLog{};
  shared_ptr<string> status{};
  shared_ptr<string> target{};
  shared_ptr<string> version{};

  ListPrometheusIntegrationResponseBodyData() {}

  explicit ListPrometheusIntegrationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canDelete) {
      res["CanDelete"] = boost::any(*canDelete);
    }
    if (canEditor) {
      res["CanEditor"] = boost::any(*canEditor);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (exporterType) {
      res["ExporterType"] = boost::any(*exporterType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (showDescribe) {
      res["ShowDescribe"] = boost::any(*showDescribe);
    }
    if (showLog) {
      res["ShowLog"] = boost::any(*showLog);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanDelete") != m.end() && !m["CanDelete"].empty()) {
      canDelete = make_shared<bool>(boost::any_cast<bool>(m["CanDelete"]));
    }
    if (m.find("CanEditor") != m.end() && !m["CanEditor"].empty()) {
      canEditor = make_shared<bool>(boost::any_cast<bool>(m["CanEditor"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("ExporterType") != m.end() && !m["ExporterType"].empty()) {
      exporterType = make_shared<string>(boost::any_cast<string>(m["ExporterType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("ShowDescribe") != m.end() && !m["ShowDescribe"].empty()) {
      showDescribe = make_shared<bool>(boost::any_cast<bool>(m["ShowDescribe"]));
    }
    if (m.find("ShowLog") != m.end() && !m["ShowLog"].empty()) {
      showLog = make_shared<bool>(boost::any_cast<bool>(m["ShowLog"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListPrometheusIntegrationResponseBodyData() = default;
};
class ListPrometheusIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListPrometheusIntegrationResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrometheusIntegrationResponseBody() {}

  explicit ListPrometheusIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListPrometheusIntegrationResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusIntegrationResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListPrometheusIntegrationResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusIntegrationResponseBody() = default;
};
class ListPrometheusIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusIntegrationResponseBody> body{};

  ListPrometheusIntegrationResponse() {}

  explicit ListPrometheusIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusIntegrationResponse() = default;
};
class ListPrometheusMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  ListPrometheusMonitoringRequest() {}

  explicit ListPrometheusMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPrometheusMonitoringRequest() = default;
};
class ListPrometheusMonitoringResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListPrometheusMonitoringResponseBodyData() {}

  explicit ListPrometheusMonitoringResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPrometheusMonitoringResponseBodyData() = default;
};
class ListPrometheusMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListPrometheusMonitoringResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrometheusMonitoringResponseBody() {}

  explicit ListPrometheusMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListPrometheusMonitoringResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusMonitoringResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListPrometheusMonitoringResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrometheusMonitoringResponseBody() = default;
};
class ListPrometheusMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusMonitoringResponseBody> body{};

  ListPrometheusMonitoringResponse() {}

  explicit ListPrometheusMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusMonitoringResponse() = default;
};
class ListPrometheusRemoteWritesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  ListPrometheusRemoteWritesRequest() {}

  explicit ListPrometheusRemoteWritesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListPrometheusRemoteWritesRequest() = default;
};
class ListPrometheusRemoteWritesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> remoteWriteName{};
  shared_ptr<string> remoteWriteYaml{};

  ListPrometheusRemoteWritesResponseBodyData() {}

  explicit ListPrometheusRemoteWritesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (remoteWriteName) {
      res["RemoteWriteName"] = boost::any(*remoteWriteName);
    }
    if (remoteWriteYaml) {
      res["RemoteWriteYaml"] = boost::any(*remoteWriteYaml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RemoteWriteName") != m.end() && !m["RemoteWriteName"].empty()) {
      remoteWriteName = make_shared<string>(boost::any_cast<string>(m["RemoteWriteName"]));
    }
    if (m.find("RemoteWriteYaml") != m.end() && !m["RemoteWriteYaml"].empty()) {
      remoteWriteYaml = make_shared<string>(boost::any_cast<string>(m["RemoteWriteYaml"]));
    }
  }


  virtual ~ListPrometheusRemoteWritesResponseBodyData() = default;
};
class ListPrometheusRemoteWritesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListPrometheusRemoteWritesResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListPrometheusRemoteWritesResponseBody() {}

  explicit ListPrometheusRemoteWritesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListPrometheusRemoteWritesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrometheusRemoteWritesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListPrometheusRemoteWritesResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListPrometheusRemoteWritesResponseBody() = default;
};
class ListPrometheusRemoteWritesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrometheusRemoteWritesResponseBody> body{};

  ListPrometheusRemoteWritesResponse() {}

  explicit ListPrometheusRemoteWritesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrometheusRemoteWritesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrometheusRemoteWritesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrometheusRemoteWritesResponse() = default;
};
class ListRetcodeAppsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListRetcodeAppsRequestTags() {}

  explicit ListRetcodeAppsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListRetcodeAppsRequestTags() = default;
};
class ListRetcodeAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListRetcodeAppsRequestTags>> tags{};

  ListRetcodeAppsRequest() {}

  explicit ListRetcodeAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListRetcodeAppsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRetcodeAppsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListRetcodeAppsRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListRetcodeAppsRequest() = default;
};
class ListRetcodeAppsResponseBodyRetcodeAppsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListRetcodeAppsResponseBodyRetcodeAppsTags() {}

  explicit ListRetcodeAppsResponseBodyRetcodeAppsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListRetcodeAppsResponseBodyRetcodeAppsTags() = default;
};
class ListRetcodeAppsResponseBodyRetcodeApps : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> nickName{};
  shared_ptr<string> pid{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> retcodeAppType{};
  shared_ptr<vector<ListRetcodeAppsResponseBodyRetcodeAppsTags>> tags{};

  ListRetcodeAppsResponseBodyRetcodeApps() {}

  explicit ListRetcodeAppsResponseBodyRetcodeApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retcodeAppType) {
      res["RetcodeAppType"] = boost::any(*retcodeAppType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetcodeAppType") != m.end() && !m["RetcodeAppType"].empty()) {
      retcodeAppType = make_shared<string>(boost::any_cast<string>(m["RetcodeAppType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListRetcodeAppsResponseBodyRetcodeAppsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRetcodeAppsResponseBodyRetcodeAppsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListRetcodeAppsResponseBodyRetcodeAppsTags>>(expect1);
      }
    }
  }


  virtual ~ListRetcodeAppsResponseBodyRetcodeApps() = default;
};
class ListRetcodeAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRetcodeAppsResponseBodyRetcodeApps>> retcodeApps{};

  ListRetcodeAppsResponseBody() {}

  explicit ListRetcodeAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retcodeApps) {
      vector<boost::any> temp1;
      for(auto item1:*retcodeApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RetcodeApps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetcodeApps") != m.end() && !m["RetcodeApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RetcodeApps"].type()) {
        vector<ListRetcodeAppsResponseBodyRetcodeApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RetcodeApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRetcodeAppsResponseBodyRetcodeApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        retcodeApps = make_shared<vector<ListRetcodeAppsResponseBodyRetcodeApps>>(expect1);
      }
    }
  }


  virtual ~ListRetcodeAppsResponseBody() = default;
};
class ListRetcodeAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRetcodeAppsResponseBody> body{};

  ListRetcodeAppsResponse() {}

  explicit ListRetcodeAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRetcodeAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRetcodeAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRetcodeAppsResponse() = default;
};
class ListScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scenario{};
  shared_ptr<string> sign{};

  ListScenarioRequest() {}

  explicit ListScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
  }


  virtual ~ListScenarioRequest() = default;
};
class ListScenarioResponseBodyArmsScenarios : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> extensions{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sign{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> userId{};

  ListScenarioResponseBodyArmsScenarios() {}

  explicit ListScenarioResponseBodyArmsScenarios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extensions) {
      res["Extensions"] = boost::any(*extensions);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Extensions") != m.end() && !m["Extensions"].empty()) {
      extensions = make_shared<string>(boost::any_cast<string>(m["Extensions"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListScenarioResponseBodyArmsScenarios() = default;
};
class ListScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListScenarioResponseBodyArmsScenarios>> armsScenarios{};
  shared_ptr<string> requestId{};

  ListScenarioResponseBody() {}

  explicit ListScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (armsScenarios) {
      vector<boost::any> temp1;
      for(auto item1:*armsScenarios){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ArmsScenarios"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArmsScenarios") != m.end() && !m["ArmsScenarios"].empty()) {
      if (typeid(vector<boost::any>) == m["ArmsScenarios"].type()) {
        vector<ListScenarioResponseBodyArmsScenarios> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ArmsScenarios"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenarioResponseBodyArmsScenarios model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        armsScenarios = make_shared<vector<ListScenarioResponseBodyArmsScenarios>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListScenarioResponseBody() = default;
};
class ListScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScenarioResponseBody> body{};

  ListScenarioResponse() {}

  explicit ListScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~ListScenarioResponse() = default;
};
class ListSilencePoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> isDetail{};
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};

  ListSilencePoliciesRequest() {}

  explicit ListSilencePoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isDetail) {
      res["IsDetail"] = boost::any(*isDetail);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsDetail") != m.end() && !m["IsDetail"].empty()) {
      isDetail = make_shared<bool>(boost::any_cast<bool>(m["IsDetail"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListSilencePoliciesRequest() = default;
};
class ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions() {}

  explicit ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions() = default;
};
class ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions>> matchingConditions{};

  ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules() {}

  explicit ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchingConditions) {
      vector<boost::any> temp1;
      for(auto item1:*matchingConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchingConditions") != m.end() && !m["MatchingConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingConditions"].type()) {
        vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingConditions = make_shared<vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions>>(expect1);
      }
    }
  }


  virtual ~ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules() = default;
};
class ListSilencePoliciesResponseBodyPageBeanSilencePolicies : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules>> matchingRules{};
  shared_ptr<string> name{};

  ListSilencePoliciesResponseBodyPageBeanSilencePolicies() {}

  explicit ListSilencePoliciesResponseBodyPageBeanSilencePolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchingRules) {
      vector<boost::any> temp1;
      for(auto item1:*matchingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchingRules"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MatchingRules") != m.end() && !m["MatchingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchingRules"].type()) {
        vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchingRules = make_shared<vector<ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListSilencePoliciesResponseBodyPageBeanSilencePolicies() = default;
};
class ListSilencePoliciesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<vector<ListSilencePoliciesResponseBodyPageBeanSilencePolicies>> silencePolicies{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  ListSilencePoliciesResponseBodyPageBean() {}

  explicit ListSilencePoliciesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (silencePolicies) {
      vector<boost::any> temp1;
      for(auto item1:*silencePolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SilencePolicies"] = boost::any(temp1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("SilencePolicies") != m.end() && !m["SilencePolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["SilencePolicies"].type()) {
        vector<ListSilencePoliciesResponseBodyPageBeanSilencePolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SilencePolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSilencePoliciesResponseBodyPageBeanSilencePolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        silencePolicies = make_shared<vector<ListSilencePoliciesResponseBodyPageBeanSilencePolicies>>(expect1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSilencePoliciesResponseBodyPageBean() = default;
};
class ListSilencePoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSilencePoliciesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  ListSilencePoliciesResponseBody() {}

  explicit ListSilencePoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        ListSilencePoliciesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<ListSilencePoliciesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSilencePoliciesResponseBody() = default;
};
class ListSilencePoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSilencePoliciesResponseBody> body{};

  ListSilencePoliciesResponse() {}

  explicit ListSilencePoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSilencePoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSilencePoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSilencePoliciesResponse() = default;
};
class ListTraceAppsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTraceAppsRequestTags() {}

  explicit ListTraceAppsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTraceAppsRequestTags() = default;
};
class ListTraceAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListTraceAppsRequestTags>> tags{};

  ListTraceAppsRequest() {}

  explicit ListTraceAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTraceAppsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTraceAppsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTraceAppsRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListTraceAppsRequest() = default;
};
class ListTraceAppsResponseBodyTraceAppsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTraceAppsResponseBodyTraceAppsTags() {}

  explicit ListTraceAppsResponseBodyTraceAppsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTraceAppsResponseBodyTraceAppsTags() = default;
};
class ListTraceAppsResponseBodyTraceApps : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> show{};
  shared_ptr<string> source{};
  shared_ptr<vector<ListTraceAppsResponseBodyTraceAppsTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  ListTraceAppsResponseBodyTraceApps() {}

  explicit ListTraceAppsResponseBodyTraceApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTraceAppsResponseBodyTraceAppsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTraceAppsResponseBodyTraceAppsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTraceAppsResponseBodyTraceAppsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListTraceAppsResponseBodyTraceApps() = default;
};
class ListTraceAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListTraceAppsResponseBodyTraceApps>> traceApps{};

  ListTraceAppsResponseBody() {}

  explicit ListTraceAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceApps) {
      vector<boost::any> temp1;
      for(auto item1:*traceApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TraceApps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceApps") != m.end() && !m["TraceApps"].empty()) {
      if (typeid(vector<boost::any>) == m["TraceApps"].type()) {
        vector<ListTraceAppsResponseBodyTraceApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TraceApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTraceAppsResponseBodyTraceApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traceApps = make_shared<vector<ListTraceAppsResponseBodyTraceApps>>(expect1);
      }
    }
  }


  virtual ~ListTraceAppsResponseBody() = default;
};
class ListTraceAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTraceAppsResponseBody> body{};

  ListTraceAppsResponse() {}

  explicit ListTraceAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTraceAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTraceAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTraceAppsResponse() = default;
};
class ManageGetRecordingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> queryUserId{};
  shared_ptr<string> regionId{};

  ManageGetRecordingRuleRequest() {}

  explicit ManageGetRecordingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (queryUserId) {
      res["QueryUserId"] = boost::any(*queryUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("QueryUserId") != m.end() && !m["QueryUserId"].empty()) {
      queryUserId = make_shared<string>(boost::any_cast<string>(m["QueryUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ManageGetRecordingRuleRequest() = default;
};
class ManageGetRecordingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ManageGetRecordingRuleResponseBody() {}

  explicit ManageGetRecordingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ManageGetRecordingRuleResponseBody() = default;
};
class ManageGetRecordingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ManageGetRecordingRuleResponseBody> body{};

  ManageGetRecordingRuleResponse() {}

  explicit ManageGetRecordingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ManageGetRecordingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ManageGetRecordingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ManageGetRecordingRuleResponse() = default;
};
class ManageRecordingRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> queryUserId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleYaml{};

  ManageRecordingRuleRequest() {}

  explicit ManageRecordingRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (queryUserId) {
      res["QueryUserId"] = boost::any(*queryUserId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleYaml) {
      res["RuleYaml"] = boost::any(*ruleYaml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("QueryUserId") != m.end() && !m["QueryUserId"].empty()) {
      queryUserId = make_shared<string>(boost::any_cast<string>(m["QueryUserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleYaml") != m.end() && !m["RuleYaml"].empty()) {
      ruleYaml = make_shared<string>(boost::any_cast<string>(m["RuleYaml"]));
    }
  }


  virtual ~ManageRecordingRuleRequest() = default;
};
class ManageRecordingRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ManageRecordingRuleResponseBody() {}

  explicit ManageRecordingRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ManageRecordingRuleResponseBody() = default;
};
class ManageRecordingRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ManageRecordingRuleResponseBody> body{};

  ManageRecordingRuleResponse() {}

  explicit ManageRecordingRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ManageRecordingRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ManageRecordingRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ManageRecordingRuleResponse() = default;
};
class OpenArmsDefaultSLRRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  OpenArmsDefaultSLRRequest() {}

  explicit OpenArmsDefaultSLRRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~OpenArmsDefaultSLRRequest() = default;
};
class OpenArmsDefaultSLRResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  OpenArmsDefaultSLRResponseBody() {}

  explicit OpenArmsDefaultSLRResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenArmsDefaultSLRResponseBody() = default;
};
class OpenArmsDefaultSLRResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenArmsDefaultSLRResponseBody> body{};

  OpenArmsDefaultSLRResponse() {}

  explicit OpenArmsDefaultSLRResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenArmsDefaultSLRResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenArmsDefaultSLRResponseBody>(model1);
      }
    }
  }


  virtual ~OpenArmsDefaultSLRResponse() = default;
};
class OpenArmsServiceSecondVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  OpenArmsServiceSecondVersionRequest() {}

  explicit OpenArmsServiceSecondVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~OpenArmsServiceSecondVersionRequest() = default;
};
class OpenArmsServiceSecondVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  OpenArmsServiceSecondVersionResponseBody() {}

  explicit OpenArmsServiceSecondVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenArmsServiceSecondVersionResponseBody() = default;
};
class OpenArmsServiceSecondVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenArmsServiceSecondVersionResponseBody> body{};

  OpenArmsServiceSecondVersionResponse() {}

  explicit OpenArmsServiceSecondVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenArmsServiceSecondVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenArmsServiceSecondVersionResponseBody>(model1);
      }
    }
  }


  virtual ~OpenArmsServiceSecondVersionResponse() = default;
};
class OpenVClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<long> length{};
  shared_ptr<string> product{};
  shared_ptr<bool> recreateSwitch{};
  shared_ptr<string> regionId{};

  OpenVClusterRequest() {}

  explicit OpenVClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (recreateSwitch) {
      res["RecreateSwitch"] = boost::any(*recreateSwitch);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RecreateSwitch") != m.end() && !m["RecreateSwitch"].empty()) {
      recreateSwitch = make_shared<bool>(boost::any_cast<bool>(m["RecreateSwitch"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~OpenVClusterRequest() = default;
};
class OpenVClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  OpenVClusterResponseBody() {}

  explicit OpenVClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenVClusterResponseBody() = default;
};
class OpenVClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenVClusterResponseBody> body{};

  OpenVClusterResponse() {}

  explicit OpenVClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenVClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenVClusterResponseBody>(model1);
      }
    }
  }


  virtual ~OpenVClusterResponse() = default;
};
class OpenXtraceDefaultSLRRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  OpenXtraceDefaultSLRRequest() {}

  explicit OpenXtraceDefaultSLRRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~OpenXtraceDefaultSLRRequest() = default;
};
class OpenXtraceDefaultSLRResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  OpenXtraceDefaultSLRResponseBody() {}

  explicit OpenXtraceDefaultSLRResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenXtraceDefaultSLRResponseBody() = default;
};
class OpenXtraceDefaultSLRResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenXtraceDefaultSLRResponseBody> body{};

  OpenXtraceDefaultSLRResponse() {}

  explicit OpenXtraceDefaultSLRResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenXtraceDefaultSLRResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenXtraceDefaultSLRResponseBody>(model1);
      }
    }
  }


  virtual ~OpenXtraceDefaultSLRResponse() = default;
};
class QueryMetricByPageRequestFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  QueryMetricByPageRequestFilters() {}

  explicit QueryMetricByPageRequestFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryMetricByPageRequestFilters() = default;
};
class QueryMetricByPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<string>> customFilters{};
  shared_ptr<vector<string>> dimensions{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<QueryMetricByPageRequestFilters>> filters{};
  shared_ptr<long> intervalInSec{};
  shared_ptr<vector<string>> measures{};
  shared_ptr<string> metric{};
  shared_ptr<string> order{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  QueryMetricByPageRequest() {}

  explicit QueryMetricByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (customFilters) {
      res["CustomFilters"] = boost::any(*customFilters);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (intervalInSec) {
      res["IntervalInSec"] = boost::any(*intervalInSec);
    }
    if (measures) {
      res["Measures"] = boost::any(*measures);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("CustomFilters") != m.end() && !m["CustomFilters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomFilters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomFilters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customFilters = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Dimensions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dimensions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<QueryMetricByPageRequestFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMetricByPageRequestFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<QueryMetricByPageRequestFilters>>(expect1);
      }
    }
    if (m.find("IntervalInSec") != m.end() && !m["IntervalInSec"].empty()) {
      intervalInSec = make_shared<long>(boost::any_cast<long>(m["IntervalInSec"]));
    }
    if (m.find("Measures") != m.end() && !m["Measures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Measures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Measures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      measures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryMetricByPageRequest() = default;
};
class QueryMetricByPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> completed{};
  shared_ptr<vector<map<string, boost::any>>> items{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryMetricByPageResponseBodyData() {}

  explicit QueryMetricByPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completed) {
      res["Completed"] = boost::any(*completed);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Completed") != m.end() && !m["Completed"].empty()) {
      completed = make_shared<bool>(boost::any_cast<bool>(m["Completed"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      items = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryMetricByPageResponseBodyData() = default;
};
class QueryMetricByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryMetricByPageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryMetricByPageResponseBody() {}

  explicit QueryMetricByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryMetricByPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryMetricByPageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMetricByPageResponseBody() = default;
};
class QueryMetricByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMetricByPageResponseBody> body{};

  QueryMetricByPageResponse() {}

  explicit QueryMetricByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMetricByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMetricByPageResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMetricByPageResponse() = default;
};
class QueryPromInstallStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  QueryPromInstallStatusRequest() {}

  explicit QueryPromInstallStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~QueryPromInstallStatusRequest() = default;
};
class QueryPromInstallStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> isControllerInstalled{};

  QueryPromInstallStatusResponseBodyData() {}

  explicit QueryPromInstallStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isControllerInstalled) {
      res["isControllerInstalled"] = boost::any(*isControllerInstalled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isControllerInstalled") != m.end() && !m["isControllerInstalled"].empty()) {
      isControllerInstalled = make_shared<bool>(boost::any_cast<bool>(m["isControllerInstalled"]));
    }
  }


  virtual ~QueryPromInstallStatusResponseBodyData() = default;
};
class QueryPromInstallStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryPromInstallStatusResponseBodyData> data{};
  shared_ptr<string> requestId{};

  QueryPromInstallStatusResponseBody() {}

  explicit QueryPromInstallStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryPromInstallStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryPromInstallStatusResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryPromInstallStatusResponseBody() = default;
};
class QueryPromInstallStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPromInstallStatusResponseBody> body{};

  QueryPromInstallStatusResponse() {}

  explicit QueryPromInstallStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPromInstallStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPromInstallStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPromInstallStatusResponse() = default;
};
class QueryReleaseMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeOrderId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> metricType{};
  shared_ptr<string> pid{};
  shared_ptr<string> proxyUserId{};
  shared_ptr<long> releaseEndTime{};
  shared_ptr<long> releaseStartTime{};
  shared_ptr<string> service{};

  QueryReleaseMetricRequest() {}

  explicit QueryReleaseMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeOrderId) {
      res["ChangeOrderId"] = boost::any(*changeOrderId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (proxyUserId) {
      res["ProxyUserId"] = boost::any(*proxyUserId);
    }
    if (releaseEndTime) {
      res["ReleaseEndTime"] = boost::any(*releaseEndTime);
    }
    if (releaseStartTime) {
      res["ReleaseStartTime"] = boost::any(*releaseStartTime);
    }
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeOrderId") != m.end() && !m["ChangeOrderId"].empty()) {
      changeOrderId = make_shared<string>(boost::any_cast<string>(m["ChangeOrderId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("ProxyUserId") != m.end() && !m["ProxyUserId"].empty()) {
      proxyUserId = make_shared<string>(boost::any_cast<string>(m["ProxyUserId"]));
    }
    if (m.find("ReleaseEndTime") != m.end() && !m["ReleaseEndTime"].empty()) {
      releaseEndTime = make_shared<long>(boost::any_cast<long>(m["ReleaseEndTime"]));
    }
    if (m.find("ReleaseStartTime") != m.end() && !m["ReleaseStartTime"].empty()) {
      releaseStartTime = make_shared<long>(boost::any_cast<long>(m["ReleaseStartTime"]));
    }
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["Service"]));
    }
  }


  virtual ~QueryReleaseMetricRequest() = default;
};
class QueryReleaseMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  QueryReleaseMetricResponseBody() {}

  explicit QueryReleaseMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryReleaseMetricResponseBody() = default;
};
class QueryReleaseMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryReleaseMetricResponseBody> body{};

  QueryReleaseMetricResponse() {}

  explicit QueryReleaseMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryReleaseMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryReleaseMetricResponseBody>(model1);
      }
    }
  }


  virtual ~QueryReleaseMetricResponse() = default;
};
class RemoveAliClusterIdsFromPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterIds{};
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};

  RemoveAliClusterIdsFromPrometheusGlobalViewRequest() {}

  explicit RemoveAliClusterIdsFromPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      clusterIds = make_shared<string>(boost::any_cast<string>(m["ClusterIds"]));
    }
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RemoveAliClusterIdsFromPrometheusGlobalViewRequest() = default;
};
class RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData() {}

  explicit RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData() = default;
};
class RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody() {}

  explicit RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody() = default;
};
class RemoveAliClusterIdsFromPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody> body{};

  RemoveAliClusterIdsFromPrometheusGlobalViewResponse() {}

  explicit RemoveAliClusterIdsFromPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAliClusterIdsFromPrometheusGlobalViewResponse() = default;
};
class RemoveSourcesFromPrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalViewClusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourceNames{};

  RemoveSourcesFromPrometheusGlobalViewRequest() {}

  explicit RemoveSourcesFromPrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalViewClusterId) {
      res["GlobalViewClusterId"] = boost::any(*globalViewClusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceNames) {
      res["SourceNames"] = boost::any(*sourceNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalViewClusterId") != m.end() && !m["GlobalViewClusterId"].empty()) {
      globalViewClusterId = make_shared<string>(boost::any_cast<string>(m["GlobalViewClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceNames") != m.end() && !m["SourceNames"].empty()) {
      sourceNames = make_shared<string>(boost::any_cast<string>(m["SourceNames"]));
    }
  }


  virtual ~RemoveSourcesFromPrometheusGlobalViewRequest() = default;
};
class RemoveSourcesFromPrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> msg{};
  shared_ptr<bool> success{};

  RemoveSourcesFromPrometheusGlobalViewResponseBodyData() {}

  explicit RemoveSourcesFromPrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveSourcesFromPrometheusGlobalViewResponseBodyData() = default;
};
class RemoveSourcesFromPrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<RemoveSourcesFromPrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveSourcesFromPrometheusGlobalViewResponseBody() {}

  explicit RemoveSourcesFromPrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RemoveSourcesFromPrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RemoveSourcesFromPrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveSourcesFromPrometheusGlobalViewResponseBody() = default;
};
class RemoveSourcesFromPrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveSourcesFromPrometheusGlobalViewResponseBody> body{};

  RemoveSourcesFromPrometheusGlobalViewResponse() {}

  explicit RemoveSourcesFromPrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveSourcesFromPrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveSourcesFromPrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveSourcesFromPrometheusGlobalViewResponse() = default;
};
class SaveTraceAppConfigRequestSettings : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SaveTraceAppConfigRequestSettings() {}

  explicit SaveTraceAppConfigRequestSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SaveTraceAppConfigRequestSettings() = default;
};
class SaveTraceAppConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> pid{};
  shared_ptr<vector<SaveTraceAppConfigRequestSettings>> settings{};

  SaveTraceAppConfigRequest() {}

  explicit SaveTraceAppConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (settings) {
      vector<boost::any> temp1;
      for(auto item1:*settings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Settings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Settings") != m.end() && !m["Settings"].empty()) {
      if (typeid(vector<boost::any>) == m["Settings"].type()) {
        vector<SaveTraceAppConfigRequestSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Settings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveTraceAppConfigRequestSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        settings = make_shared<vector<SaveTraceAppConfigRequestSettings>>(expect1);
      }
    }
  }


  virtual ~SaveTraceAppConfigRequest() = default;
};
class SaveTraceAppConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveTraceAppConfigResponseBody() {}

  explicit SaveTraceAppConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveTraceAppConfigResponseBody() = default;
};
class SaveTraceAppConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveTraceAppConfigResponseBody> body{};

  SaveTraceAppConfigResponse() {}

  explicit SaveTraceAppConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveTraceAppConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveTraceAppConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SaveTraceAppConfigResponse() = default;
};
class SearchAlertContactRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactIds{};
  shared_ptr<string> contactName{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> email{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> phone{};
  shared_ptr<string> regionId{};

  SearchAlertContactRequest() {}

  explicit SearchAlertContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SearchAlertContactRequest() = default;
};
class SearchAlertContactResponseBodyPageBeanContacts : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> dingRobot{};
  shared_ptr<string> email{};
  shared_ptr<string> phone{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> systemNoc{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> webhook{};

  SearchAlertContactResponseBodyPageBeanContacts() {}

  explicit SearchAlertContactResponseBodyPageBeanContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dingRobot) {
      res["DingRobot"] = boost::any(*dingRobot);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (systemNoc) {
      res["SystemNoc"] = boost::any(*systemNoc);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DingRobot") != m.end() && !m["DingRobot"].empty()) {
      dingRobot = make_shared<string>(boost::any_cast<string>(m["DingRobot"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SystemNoc") != m.end() && !m["SystemNoc"].empty()) {
      systemNoc = make_shared<bool>(boost::any_cast<bool>(m["SystemNoc"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~SearchAlertContactResponseBodyPageBeanContacts() = default;
};
class SearchAlertContactResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<SearchAlertContactResponseBodyPageBeanContacts>> contacts{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  SearchAlertContactResponseBodyPageBean() {}

  explicit SearchAlertContactResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<SearchAlertContactResponseBodyPageBeanContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertContactResponseBodyPageBeanContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<SearchAlertContactResponseBodyPageBeanContacts>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchAlertContactResponseBodyPageBean() = default;
};
class SearchAlertContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchAlertContactResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchAlertContactResponseBody() {}

  explicit SearchAlertContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchAlertContactResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchAlertContactResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchAlertContactResponseBody() = default;
};
class SearchAlertContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchAlertContactResponseBody> body{};

  SearchAlertContactResponse() {}

  explicit SearchAlertContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchAlertContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchAlertContactResponseBody>(model1);
      }
    }
  }


  virtual ~SearchAlertContactResponse() = default;
};
class SearchAlertContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupIds{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<bool> isDetail{};
  shared_ptr<string> regionId{};

  SearchAlertContactGroupRequest() {}

  explicit SearchAlertContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupIds) {
      res["ContactGroupIds"] = boost::any(*contactGroupIds);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (isDetail) {
      res["IsDetail"] = boost::any(*isDetail);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupIds") != m.end() && !m["ContactGroupIds"].empty()) {
      contactGroupIds = make_shared<string>(boost::any_cast<string>(m["ContactGroupIds"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("IsDetail") != m.end() && !m["IsDetail"].empty()) {
      isDetail = make_shared<bool>(boost::any_cast<bool>(m["IsDetail"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SearchAlertContactGroupRequest() = default;
};
class SearchAlertContactGroupResponseBodyContactGroupsContacts : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> dingRobot{};
  shared_ptr<string> email{};
  shared_ptr<string> phone{};
  shared_ptr<bool> systemNoc{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchAlertContactGroupResponseBodyContactGroupsContacts() {}

  explicit SearchAlertContactGroupResponseBodyContactGroupsContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dingRobot) {
      res["DingRobot"] = boost::any(*dingRobot);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (systemNoc) {
      res["SystemNoc"] = boost::any(*systemNoc);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DingRobot") != m.end() && !m["DingRobot"].empty()) {
      dingRobot = make_shared<string>(boost::any_cast<string>(m["DingRobot"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("SystemNoc") != m.end() && !m["SystemNoc"].empty()) {
      systemNoc = make_shared<bool>(boost::any_cast<bool>(m["SystemNoc"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchAlertContactGroupResponseBodyContactGroupsContacts() = default;
};
class SearchAlertContactGroupResponseBodyContactGroups : public Darabonba::Model {
public:
  shared_ptr<long> contactGroupId{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<vector<SearchAlertContactGroupResponseBodyContactGroupsContacts>> contacts{};
  shared_ptr<long> createTime{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchAlertContactGroupResponseBodyContactGroups() {}

  explicit SearchAlertContactGroupResponseBodyContactGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<long>(boost::any_cast<long>(m["ContactGroupId"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<SearchAlertContactGroupResponseBodyContactGroupsContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertContactGroupResponseBodyContactGroupsContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<SearchAlertContactGroupResponseBodyContactGroupsContacts>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchAlertContactGroupResponseBodyContactGroups() = default;
};
class SearchAlertContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SearchAlertContactGroupResponseBodyContactGroups>> contactGroups{};
  shared_ptr<string> requestId{};

  SearchAlertContactGroupResponseBody() {}

  explicit SearchAlertContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroups) {
      vector<boost::any> temp1;
      for(auto item1:*contactGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactGroups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactGroups"].type()) {
        vector<SearchAlertContactGroupResponseBodyContactGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertContactGroupResponseBodyContactGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactGroups = make_shared<vector<SearchAlertContactGroupResponseBodyContactGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchAlertContactGroupResponseBody() = default;
};
class SearchAlertContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchAlertContactGroupResponseBody> body{};

  SearchAlertContactGroupResponse() {}

  explicit SearchAlertContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchAlertContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchAlertContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SearchAlertContactGroupResponse() = default;
};
class SearchAlertHistoriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<long> alertType{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  SearchAlertHistoriesRequest() {}

  explicit SearchAlertHistoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<long>(boost::any_cast<long>(m["AlertType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~SearchAlertHistoriesRequest() = default;
};
class SearchAlertHistoriesResponseBodyPageBeanAlarmHistories : public Darabonba::Model {
public:
  shared_ptr<string> alarmContent{};
  shared_ptr<long> alarmResponseCode{};
  shared_ptr<string> alarmSources{};
  shared_ptr<long> alarmTime{};
  shared_ptr<long> alarmType{};
  shared_ptr<string> emails{};
  shared_ptr<long> id{};
  shared_ptr<string> phones{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> target{};
  shared_ptr<string> userId{};

  SearchAlertHistoriesResponseBodyPageBeanAlarmHistories() {}

  explicit SearchAlertHistoriesResponseBodyPageBeanAlarmHistories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmContent) {
      res["AlarmContent"] = boost::any(*alarmContent);
    }
    if (alarmResponseCode) {
      res["AlarmResponseCode"] = boost::any(*alarmResponseCode);
    }
    if (alarmSources) {
      res["AlarmSources"] = boost::any(*alarmSources);
    }
    if (alarmTime) {
      res["AlarmTime"] = boost::any(*alarmTime);
    }
    if (alarmType) {
      res["AlarmType"] = boost::any(*alarmType);
    }
    if (emails) {
      res["Emails"] = boost::any(*emails);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (phones) {
      res["Phones"] = boost::any(*phones);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmContent") != m.end() && !m["AlarmContent"].empty()) {
      alarmContent = make_shared<string>(boost::any_cast<string>(m["AlarmContent"]));
    }
    if (m.find("AlarmResponseCode") != m.end() && !m["AlarmResponseCode"].empty()) {
      alarmResponseCode = make_shared<long>(boost::any_cast<long>(m["AlarmResponseCode"]));
    }
    if (m.find("AlarmSources") != m.end() && !m["AlarmSources"].empty()) {
      alarmSources = make_shared<string>(boost::any_cast<string>(m["AlarmSources"]));
    }
    if (m.find("AlarmTime") != m.end() && !m["AlarmTime"].empty()) {
      alarmTime = make_shared<long>(boost::any_cast<long>(m["AlarmTime"]));
    }
    if (m.find("AlarmType") != m.end() && !m["AlarmType"].empty()) {
      alarmType = make_shared<long>(boost::any_cast<long>(m["AlarmType"]));
    }
    if (m.find("Emails") != m.end() && !m["Emails"].empty()) {
      emails = make_shared<string>(boost::any_cast<string>(m["Emails"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Phones") != m.end() && !m["Phones"].empty()) {
      phones = make_shared<string>(boost::any_cast<string>(m["Phones"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchAlertHistoriesResponseBodyPageBeanAlarmHistories() = default;
};
class SearchAlertHistoriesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<SearchAlertHistoriesResponseBodyPageBeanAlarmHistories>> alarmHistories{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  SearchAlertHistoriesResponseBodyPageBean() {}

  explicit SearchAlertHistoriesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmHistories) {
      vector<boost::any> temp1;
      for(auto item1:*alarmHistories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmHistories"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmHistories") != m.end() && !m["AlarmHistories"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmHistories"].type()) {
        vector<SearchAlertHistoriesResponseBodyPageBeanAlarmHistories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmHistories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertHistoriesResponseBodyPageBeanAlarmHistories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmHistories = make_shared<vector<SearchAlertHistoriesResponseBodyPageBeanAlarmHistories>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchAlertHistoriesResponseBodyPageBean() = default;
};
class SearchAlertHistoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchAlertHistoriesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchAlertHistoriesResponseBody() {}

  explicit SearchAlertHistoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchAlertHistoriesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchAlertHistoriesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchAlertHistoriesResponseBody() = default;
};
class SearchAlertHistoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchAlertHistoriesResponseBody> body{};

  SearchAlertHistoriesResponse() {}

  explicit SearchAlertHistoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchAlertHistoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchAlertHistoriesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchAlertHistoriesResponse() = default;
};
class SearchAlertRulesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchAlertRulesRequestTags() {}

  explicit SearchAlertRulesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchAlertRulesRequestTags() = default;
};
class SearchAlertRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertRuleId{};
  shared_ptr<string> appType{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> systemRegionId{};
  shared_ptr<vector<SearchAlertRulesRequestTags>> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  SearchAlertRulesRequest() {}

  explicit SearchAlertRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRuleId) {
      res["AlertRuleId"] = boost::any(*alertRuleId);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (systemRegionId) {
      res["SystemRegionId"] = boost::any(*systemRegionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRuleId") != m.end() && !m["AlertRuleId"].empty()) {
      alertRuleId = make_shared<string>(boost::any_cast<string>(m["AlertRuleId"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SystemRegionId") != m.end() && !m["SystemRegionId"].empty()) {
      systemRegionId = make_shared<string>(boost::any_cast<string>(m["SystemRegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchAlertRulesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertRulesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchAlertRulesRequestTags>>(expect1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SearchAlertRulesRequest() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext : public Darabonba::Model {
public:
  shared_ptr<string> alarmContentSubTitle{};
  shared_ptr<string> alarmContentTemplate{};
  shared_ptr<string> content{};
  shared_ptr<string> subTitle{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmContentSubTitle) {
      res["AlarmContentSubTitle"] = boost::any(*alarmContentSubTitle);
    }
    if (alarmContentTemplate) {
      res["AlarmContentTemplate"] = boost::any(*alarmContentTemplate);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (subTitle) {
      res["SubTitle"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmContentSubTitle") != m.end() && !m["AlarmContentSubTitle"].empty()) {
      alarmContentSubTitle = make_shared<string>(boost::any_cast<string>(m["AlarmContentSubTitle"]));
    }
    if (m.find("AlarmContentTemplate") != m.end() && !m["AlarmContentTemplate"].empty()) {
      alarmContentTemplate = make_shared<string>(boost::any_cast<string>(m["AlarmContentTemplate"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SubTitle") != m.end() && !m["SubTitle"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["SubTitle"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules : public Darabonba::Model {
public:
  shared_ptr<string> aggregates{};
  shared_ptr<string> alias{};
  shared_ptr<string> measure{};
  shared_ptr<long> NValue{};
  shared_ptr<string> operator_{};
  shared_ptr<double> value{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregates) {
      res["Aggregates"] = boost::any(*aggregates);
    }
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (measure) {
      res["Measure"] = boost::any(*measure);
    }
    if (NValue) {
      res["NValue"] = boost::any(*NValue);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregates") != m.end() && !m["Aggregates"].empty()) {
      aggregates = make_shared<string>(boost::any_cast<string>(m["Aggregates"]));
    }
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Measure") != m.end() && !m["Measure"].empty()) {
      measure = make_shared<string>(boost::any_cast<string>(m["Measure"]));
    }
    if (m.find("NValue") != m.end() && !m["NValue"].empty()) {
      NValue = make_shared<long>(boost::any_cast<long>(m["NValue"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<vector<SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules>> rules{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules>>(expect1);
      }
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam : public Darabonba::Model {
public:
  shared_ptr<string> appGroupId{};
  shared_ptr<string> appId{};
  shared_ptr<vector<SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions>> dimensions{};
  shared_ptr<string> pid{};
  shared_ptr<string> type{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGroupId) {
      res["AppGroupId"] = boost::any(*appGroupId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGroupId") != m.end() && !m["AppGroupId"].empty()) {
      appGroupId = make_shared<string>(boost::any_cast<string>(m["AppGroupId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions>>(expect1);
      }
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRulesNotice : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> noticeEndTime{};
  shared_ptr<long> noticeStartTime{};
  shared_ptr<long> startTime{};

  SearchAlertRulesResponseBodyPageBeanAlertRulesNotice() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRulesNotice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (noticeEndTime) {
      res["NoticeEndTime"] = boost::any(*noticeEndTime);
    }
    if (noticeStartTime) {
      res["NoticeStartTime"] = boost::any(*noticeStartTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("NoticeEndTime") != m.end() && !m["NoticeEndTime"].empty()) {
      noticeEndTime = make_shared<long>(boost::any_cast<long>(m["NoticeEndTime"]));
    }
    if (m.find("NoticeStartTime") != m.end() && !m["NoticeStartTime"].empty()) {
      noticeStartTime = make_shared<long>(boost::any_cast<long>(m["NoticeStartTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRulesNotice() = default;
};
class SearchAlertRulesResponseBodyPageBeanAlertRules : public Darabonba::Model {
public:
  shared_ptr<SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext> alarmContext{};
  shared_ptr<string> alertLevel{};
  shared_ptr<SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule> alertRule{};
  shared_ptr<string> alertTitle{};
  shared_ptr<long> alertType{};
  shared_ptr<long> alertVersion{};
  shared_ptr<vector<string>> alertWays{};
  shared_ptr<string> config{};
  shared_ptr<string> contactGroupIdList{};
  shared_ptr<string> contactGroupIds{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> hostByAlertManager{};
  shared_ptr<long> id{};
  shared_ptr<SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam> metricParam{};
  shared_ptr<SearchAlertRulesResponseBodyPageBeanAlertRulesNotice> notice{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> title{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchAlertRulesResponseBodyPageBeanAlertRules() {}

  explicit SearchAlertRulesResponseBodyPageBeanAlertRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmContext) {
      res["AlarmContext"] = alarmContext ? boost::any(alarmContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertLevel) {
      res["AlertLevel"] = boost::any(*alertLevel);
    }
    if (alertRule) {
      res["AlertRule"] = alertRule ? boost::any(alertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertTitle) {
      res["AlertTitle"] = boost::any(*alertTitle);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (alertVersion) {
      res["AlertVersion"] = boost::any(*alertVersion);
    }
    if (alertWays) {
      res["AlertWays"] = boost::any(*alertWays);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (contactGroupIdList) {
      res["ContactGroupIdList"] = boost::any(*contactGroupIdList);
    }
    if (contactGroupIds) {
      res["ContactGroupIds"] = boost::any(*contactGroupIds);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hostByAlertManager) {
      res["HostByAlertManager"] = boost::any(*hostByAlertManager);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metricParam) {
      res["MetricParam"] = metricParam ? boost::any(metricParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notice) {
      res["Notice"] = notice ? boost::any(notice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmContext") != m.end() && !m["AlarmContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlarmContext"].type()) {
        SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlarmContext"]));
        alarmContext = make_shared<SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext>(model1);
      }
    }
    if (m.find("AlertLevel") != m.end() && !m["AlertLevel"].empty()) {
      alertLevel = make_shared<string>(boost::any_cast<string>(m["AlertLevel"]));
    }
    if (m.find("AlertRule") != m.end() && !m["AlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertRule"].type()) {
        SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertRule"]));
        alertRule = make_shared<SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule>(model1);
      }
    }
    if (m.find("AlertTitle") != m.end() && !m["AlertTitle"].empty()) {
      alertTitle = make_shared<string>(boost::any_cast<string>(m["AlertTitle"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<long>(boost::any_cast<long>(m["AlertType"]));
    }
    if (m.find("AlertVersion") != m.end() && !m["AlertVersion"].empty()) {
      alertVersion = make_shared<long>(boost::any_cast<long>(m["AlertVersion"]));
    }
    if (m.find("AlertWays") != m.end() && !m["AlertWays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertWays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertWays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertWays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("ContactGroupIdList") != m.end() && !m["ContactGroupIdList"].empty()) {
      contactGroupIdList = make_shared<string>(boost::any_cast<string>(m["ContactGroupIdList"]));
    }
    if (m.find("ContactGroupIds") != m.end() && !m["ContactGroupIds"].empty()) {
      contactGroupIds = make_shared<string>(boost::any_cast<string>(m["ContactGroupIds"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("HostByAlertManager") != m.end() && !m["HostByAlertManager"].empty()) {
      hostByAlertManager = make_shared<bool>(boost::any_cast<bool>(m["HostByAlertManager"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MetricParam") != m.end() && !m["MetricParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricParam"].type()) {
        SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricParam"]));
        metricParam = make_shared<SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam>(model1);
      }
    }
    if (m.find("Notice") != m.end() && !m["Notice"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notice"].type()) {
        SearchAlertRulesResponseBodyPageBeanAlertRulesNotice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notice"]));
        notice = make_shared<SearchAlertRulesResponseBodyPageBeanAlertRulesNotice>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBeanAlertRules() = default;
};
class SearchAlertRulesResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<SearchAlertRulesResponseBodyPageBeanAlertRules>> alertRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  SearchAlertRulesResponseBodyPageBean() {}

  explicit SearchAlertRulesResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertRules) {
      vector<boost::any> temp1;
      for(auto item1:*alertRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertRules"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertRules") != m.end() && !m["AlertRules"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertRules"].type()) {
        vector<SearchAlertRulesResponseBodyPageBeanAlertRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchAlertRulesResponseBodyPageBeanAlertRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertRules = make_shared<vector<SearchAlertRulesResponseBodyPageBeanAlertRules>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchAlertRulesResponseBodyPageBean() = default;
};
class SearchAlertRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchAlertRulesResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchAlertRulesResponseBody() {}

  explicit SearchAlertRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchAlertRulesResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchAlertRulesResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchAlertRulesResponseBody() = default;
};
class SearchAlertRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchAlertRulesResponseBody> body{};

  SearchAlertRulesResponse() {}

  explicit SearchAlertRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchAlertRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchAlertRulesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchAlertRulesResponse() = default;
};
class SearchEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<long> alertType{};
  shared_ptr<string> appType{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<long> isTrigger{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  SearchEventsRequest() {}

  explicit SearchEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (isTrigger) {
      res["IsTrigger"] = boost::any(*isTrigger);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<long>(boost::any_cast<long>(m["AlertType"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("IsTrigger") != m.end() && !m["IsTrigger"].empty()) {
      isTrigger = make_shared<long>(boost::any_cast<long>(m["IsTrigger"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~SearchEventsRequest() = default;
};
class SearchEventsResponseBodyPageBeanEvent : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<string> alertRule{};
  shared_ptr<long> alertType{};
  shared_ptr<string> eventLevel{};
  shared_ptr<long> eventTime{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> links{};
  shared_ptr<string> message{};

  SearchEventsResponseBodyPageBeanEvent() {}

  explicit SearchEventsResponseBodyPageBeanEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertRule) {
      res["AlertRule"] = boost::any(*alertRule);
    }
    if (alertType) {
      res["AlertType"] = boost::any(*alertType);
    }
    if (eventLevel) {
      res["EventLevel"] = boost::any(*eventLevel);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (links) {
      res["Links"] = boost::any(*links);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertRule") != m.end() && !m["AlertRule"].empty()) {
      alertRule = make_shared<string>(boost::any_cast<string>(m["AlertRule"]));
    }
    if (m.find("AlertType") != m.end() && !m["AlertType"].empty()) {
      alertType = make_shared<long>(boost::any_cast<long>(m["AlertType"]));
    }
    if (m.find("EventLevel") != m.end() && !m["EventLevel"].empty()) {
      eventLevel = make_shared<string>(boost::any_cast<string>(m["EventLevel"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Links") != m.end() && !m["Links"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Links"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Links"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      links = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~SearchEventsResponseBodyPageBeanEvent() = default;
};
class SearchEventsResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<vector<SearchEventsResponseBodyPageBeanEvent>> event{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  SearchEventsResponseBodyPageBean() {}

  explicit SearchEventsResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      vector<boost::any> temp1;
      for(auto item1:*event){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Event"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      if (typeid(vector<boost::any>) == m["Event"].type()) {
        vector<SearchEventsResponseBodyPageBeanEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Event"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchEventsResponseBodyPageBeanEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        event = make_shared<vector<SearchEventsResponseBodyPageBeanEvent>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchEventsResponseBodyPageBean() = default;
};
class SearchEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> isTrigger{};
  shared_ptr<SearchEventsResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchEventsResponseBody() {}

  explicit SearchEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isTrigger) {
      res["IsTrigger"] = boost::any(*isTrigger);
    }
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsTrigger") != m.end() && !m["IsTrigger"].empty()) {
      isTrigger = make_shared<long>(boost::any_cast<long>(m["IsTrigger"]));
    }
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchEventsResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchEventsResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchEventsResponseBody() = default;
};
class SearchEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchEventsResponseBody> body{};

  SearchEventsResponse() {}

  explicit SearchEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchEventsResponseBody>(model1);
      }
    }
  }


  virtual ~SearchEventsResponse() = default;
};
class SearchRetcodeAppByPageRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchRetcodeAppByPageRequestTags() {}

  explicit SearchRetcodeAppByPageRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchRetcodeAppByPageRequestTags() = default;
};
class SearchRetcodeAppByPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> retcodeAppId{};
  shared_ptr<string> retcodeAppName{};
  shared_ptr<vector<SearchRetcodeAppByPageRequestTags>> tags{};

  SearchRetcodeAppByPageRequest() {}

  explicit SearchRetcodeAppByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retcodeAppId) {
      res["RetcodeAppId"] = boost::any(*retcodeAppId);
    }
    if (retcodeAppName) {
      res["RetcodeAppName"] = boost::any(*retcodeAppName);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetcodeAppId") != m.end() && !m["RetcodeAppId"].empty()) {
      retcodeAppId = make_shared<string>(boost::any_cast<string>(m["RetcodeAppId"]));
    }
    if (m.find("RetcodeAppName") != m.end() && !m["RetcodeAppName"].empty()) {
      retcodeAppName = make_shared<string>(boost::any_cast<string>(m["RetcodeAppName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchRetcodeAppByPageRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchRetcodeAppByPageRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchRetcodeAppByPageRequestTags>>(expect1);
      }
    }
  }


  virtual ~SearchRetcodeAppByPageRequest() = default;
};
class SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags() {}

  explicit SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags() = default;
};
class SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> nickName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> retcodeAppType{};
  shared_ptr<vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps() {}

  explicit SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retcodeAppType) {
      res["RetcodeAppType"] = boost::any(*retcodeAppType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetcodeAppType") != m.end() && !m["RetcodeAppType"].empty()) {
      retcodeAppType = make_shared<string>(boost::any_cast<string>(m["RetcodeAppType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps() = default;
};
class SearchRetcodeAppByPageResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps>> retcodeApps{};
  shared_ptr<long> totalCount{};

  SearchRetcodeAppByPageResponseBodyPageBean() {}

  explicit SearchRetcodeAppByPageResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (retcodeApps) {
      vector<boost::any> temp1;
      for(auto item1:*retcodeApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RetcodeApps"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RetcodeApps") != m.end() && !m["RetcodeApps"].empty()) {
      if (typeid(vector<boost::any>) == m["RetcodeApps"].type()) {
        vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RetcodeApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        retcodeApps = make_shared<vector<SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchRetcodeAppByPageResponseBodyPageBean() = default;
};
class SearchRetcodeAppByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchRetcodeAppByPageResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchRetcodeAppByPageResponseBody() {}

  explicit SearchRetcodeAppByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchRetcodeAppByPageResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchRetcodeAppByPageResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchRetcodeAppByPageResponseBody() = default;
};
class SearchRetcodeAppByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchRetcodeAppByPageResponseBody> body{};

  SearchRetcodeAppByPageResponse() {}

  explicit SearchRetcodeAppByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchRetcodeAppByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchRetcodeAppByPageResponseBody>(model1);
      }
    }
  }


  virtual ~SearchRetcodeAppByPageResponse() = default;
};
class SearchTraceAppByNameRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTraceAppByNameRequestTags() {}

  explicit SearchTraceAppByNameRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTraceAppByNameRequestTags() = default;
};
class SearchTraceAppByNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<SearchTraceAppByNameRequestTags>> tags{};
  shared_ptr<string> traceAppName{};

  SearchTraceAppByNameRequest() {}

  explicit SearchTraceAppByNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (traceAppName) {
      res["TraceAppName"] = boost::any(*traceAppName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchTraceAppByNameRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByNameRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchTraceAppByNameRequestTags>>(expect1);
      }
    }
    if (m.find("TraceAppName") != m.end() && !m["TraceAppName"].empty()) {
      traceAppName = make_shared<string>(boost::any_cast<string>(m["TraceAppName"]));
    }
  }


  virtual ~SearchTraceAppByNameRequest() = default;
};
class SearchTraceAppByNameResponseBodyTraceAppsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTraceAppByNameResponseBodyTraceAppsTags() {}

  explicit SearchTraceAppByNameResponseBodyTraceAppsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTraceAppByNameResponseBodyTraceAppsTags() = default;
};
class SearchTraceAppByNameResponseBodyTraceApps : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> show{};
  shared_ptr<vector<SearchTraceAppByNameResponseBodyTraceAppsTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchTraceAppByNameResponseBodyTraceApps() {}

  explicit SearchTraceAppByNameResponseBodyTraceApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchTraceAppByNameResponseBodyTraceAppsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByNameResponseBodyTraceAppsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchTraceAppByNameResponseBodyTraceAppsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchTraceAppByNameResponseBodyTraceApps() = default;
};
class SearchTraceAppByNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<SearchTraceAppByNameResponseBodyTraceApps>> traceApps{};

  SearchTraceAppByNameResponseBody() {}

  explicit SearchTraceAppByNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceApps) {
      vector<boost::any> temp1;
      for(auto item1:*traceApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TraceApps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceApps") != m.end() && !m["TraceApps"].empty()) {
      if (typeid(vector<boost::any>) == m["TraceApps"].type()) {
        vector<SearchTraceAppByNameResponseBodyTraceApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TraceApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByNameResponseBodyTraceApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traceApps = make_shared<vector<SearchTraceAppByNameResponseBodyTraceApps>>(expect1);
      }
    }
  }


  virtual ~SearchTraceAppByNameResponseBody() = default;
};
class SearchTraceAppByNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTraceAppByNameResponseBody> body{};

  SearchTraceAppByNameResponse() {}

  explicit SearchTraceAppByNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTraceAppByNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTraceAppByNameResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTraceAppByNameResponse() = default;
};
class SearchTraceAppByPageRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTraceAppByPageRequestTags() {}

  explicit SearchTraceAppByPageRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTraceAppByPageRequestTags() = default;
};
class SearchTraceAppByPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<SearchTraceAppByPageRequestTags>> tags{};
  shared_ptr<string> traceAppName{};

  SearchTraceAppByPageRequest() {}

  explicit SearchTraceAppByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (traceAppName) {
      res["TraceAppName"] = boost::any(*traceAppName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchTraceAppByPageRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByPageRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchTraceAppByPageRequestTags>>(expect1);
      }
    }
    if (m.find("TraceAppName") != m.end() && !m["TraceAppName"].empty()) {
      traceAppName = make_shared<string>(boost::any_cast<string>(m["TraceAppName"]));
    }
  }


  virtual ~SearchTraceAppByPageRequest() = default;
};
class SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags() {}

  explicit SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags() = default;
};
class SearchTraceAppByPageResponseBodyPageBeanTraceApps : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> show{};
  shared_ptr<vector<SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};

  SearchTraceAppByPageResponseBodyPageBeanTraceApps() {}

  explicit SearchTraceAppByPageResponseBodyPageBeanTraceApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchTraceAppByPageResponseBodyPageBeanTraceApps() = default;
};
class SearchTraceAppByPageResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<SearchTraceAppByPageResponseBodyPageBeanTraceApps>> traceApps{};

  SearchTraceAppByPageResponseBodyPageBean() {}

  explicit SearchTraceAppByPageResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (traceApps) {
      vector<boost::any> temp1;
      for(auto item1:*traceApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TraceApps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TraceApps") != m.end() && !m["TraceApps"].empty()) {
      if (typeid(vector<boost::any>) == m["TraceApps"].type()) {
        vector<SearchTraceAppByPageResponseBodyPageBeanTraceApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TraceApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTraceAppByPageResponseBodyPageBeanTraceApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traceApps = make_shared<vector<SearchTraceAppByPageResponseBodyPageBeanTraceApps>>(expect1);
      }
    }
  }


  virtual ~SearchTraceAppByPageResponseBodyPageBean() = default;
};
class SearchTraceAppByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchTraceAppByPageResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchTraceAppByPageResponseBody() {}

  explicit SearchTraceAppByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchTraceAppByPageResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchTraceAppByPageResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchTraceAppByPageResponseBody() = default;
};
class SearchTraceAppByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTraceAppByPageResponseBody> body{};

  SearchTraceAppByPageResponse() {}

  explicit SearchTraceAppByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTraceAppByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTraceAppByPageResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTraceAppByPageResponse() = default;
};
class SearchTracesRequestExclusionFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTracesRequestExclusionFilters() {}

  explicit SearchTracesRequestExclusionFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTracesRequestExclusionFilters() = default;
};
class SearchTracesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTracesRequestTag() {}

  explicit SearchTracesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTracesRequestTag() = default;
};
class SearchTracesRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<SearchTracesRequestExclusionFilters>> exclusionFilters{};
  shared_ptr<long> minDuration{};
  shared_ptr<string> operationName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> reverse{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<SearchTracesRequestTag>> tag{};

  SearchTracesRequest() {}

  explicit SearchTracesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (exclusionFilters) {
      vector<boost::any> temp1;
      for(auto item1:*exclusionFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExclusionFilters"] = boost::any(temp1);
    }
    if (minDuration) {
      res["MinDuration"] = boost::any(*minDuration);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExclusionFilters") != m.end() && !m["ExclusionFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["ExclusionFilters"].type()) {
        vector<SearchTracesRequestExclusionFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExclusionFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesRequestExclusionFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        exclusionFilters = make_shared<vector<SearchTracesRequestExclusionFilters>>(expect1);
      }
    }
    if (m.find("MinDuration") != m.end() && !m["MinDuration"].empty()) {
      minDuration = make_shared<long>(boost::any_cast<long>(m["MinDuration"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<SearchTracesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<SearchTracesRequestTag>>(expect1);
      }
    }
  }


  virtual ~SearchTracesRequest() = default;
};
class SearchTracesResponseBodyTraceInfos : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> operationName{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> traceID{};

  SearchTracesResponseBodyTraceInfos() {}

  explicit SearchTracesResponseBodyTraceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~SearchTracesResponseBodyTraceInfos() = default;
};
class SearchTracesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<SearchTracesResponseBodyTraceInfos>> traceInfos{};

  SearchTracesResponseBody() {}

  explicit SearchTracesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*traceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TraceInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TraceInfos") != m.end() && !m["TraceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["TraceInfos"].type()) {
        vector<SearchTracesResponseBodyTraceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TraceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesResponseBodyTraceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traceInfos = make_shared<vector<SearchTracesResponseBodyTraceInfos>>(expect1);
      }
    }
  }


  virtual ~SearchTracesResponseBody() = default;
};
class SearchTracesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTracesResponseBody> body{};

  SearchTracesResponse() {}

  explicit SearchTracesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTracesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTracesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTracesResponse() = default;
};
class SearchTracesByPageRequestExclusionFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTracesByPageRequestExclusionFilters() {}

  explicit SearchTracesByPageRequestExclusionFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTracesByPageRequestExclusionFilters() = default;
};
class SearchTracesByPageRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SearchTracesByPageRequestTags() {}

  explicit SearchTracesByPageRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchTracesByPageRequestTags() = default;
};
class SearchTracesByPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<SearchTracesByPageRequestExclusionFilters>> exclusionFilters{};
  shared_ptr<bool> isError{};
  shared_ptr<long> minDuration{};
  shared_ptr<string> operationName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> reverse{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<SearchTracesByPageRequestTags>> tags{};

  SearchTracesByPageRequest() {}

  explicit SearchTracesByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (exclusionFilters) {
      vector<boost::any> temp1;
      for(auto item1:*exclusionFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExclusionFilters"] = boost::any(temp1);
    }
    if (isError) {
      res["IsError"] = boost::any(*isError);
    }
    if (minDuration) {
      res["MinDuration"] = boost::any(*minDuration);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExclusionFilters") != m.end() && !m["ExclusionFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["ExclusionFilters"].type()) {
        vector<SearchTracesByPageRequestExclusionFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExclusionFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesByPageRequestExclusionFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        exclusionFilters = make_shared<vector<SearchTracesByPageRequestExclusionFilters>>(expect1);
      }
    }
    if (m.find("IsError") != m.end() && !m["IsError"].empty()) {
      isError = make_shared<bool>(boost::any_cast<bool>(m["IsError"]));
    }
    if (m.find("MinDuration") != m.end() && !m["MinDuration"].empty()) {
      minDuration = make_shared<long>(boost::any_cast<long>(m["MinDuration"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<SearchTracesByPageRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesByPageRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<SearchTracesByPageRequestTags>>(expect1);
      }
    }
  }


  virtual ~SearchTracesByPageRequest() = default;
};
class SearchTracesByPageResponseBodyPageBeanTraceInfos : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> operationName{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> traceID{};

  SearchTracesByPageResponseBodyPageBeanTraceInfos() {}

  explicit SearchTracesByPageResponseBodyPageBeanTraceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (traceID) {
      res["TraceID"] = boost::any(*traceID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TraceID") != m.end() && !m["TraceID"].empty()) {
      traceID = make_shared<string>(boost::any_cast<string>(m["TraceID"]));
    }
  }


  virtual ~SearchTracesByPageResponseBodyPageBeanTraceInfos() = default;
};
class SearchTracesByPageResponseBodyPageBean : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<vector<SearchTracesByPageResponseBodyPageBeanTraceInfos>> traceInfos{};

  SearchTracesByPageResponseBodyPageBean() {}

  explicit SearchTracesByPageResponseBodyPageBean(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (traceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*traceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TraceInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TraceInfos") != m.end() && !m["TraceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["TraceInfos"].type()) {
        vector<SearchTracesByPageResponseBodyPageBeanTraceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TraceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTracesByPageResponseBodyPageBeanTraceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traceInfos = make_shared<vector<SearchTracesByPageResponseBodyPageBeanTraceInfos>>(expect1);
      }
    }
  }


  virtual ~SearchTracesByPageResponseBodyPageBean() = default;
};
class SearchTracesByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchTracesByPageResponseBodyPageBean> pageBean{};
  shared_ptr<string> requestId{};

  SearchTracesByPageResponseBody() {}

  explicit SearchTracesByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageBean) {
      res["PageBean"] = pageBean ? boost::any(pageBean->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageBean") != m.end() && !m["PageBean"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageBean"].type()) {
        SearchTracesByPageResponseBodyPageBean model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageBean"]));
        pageBean = make_shared<SearchTracesByPageResponseBodyPageBean>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchTracesByPageResponseBody() = default;
};
class SearchTracesByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTracesByPageResponseBody> body{};

  SearchTracesByPageResponse() {}

  explicit SearchTracesByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTracesByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTracesByPageResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTracesByPageResponse() = default;
};
class SendTTSVerifyLinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> phone{};

  SendTTSVerifyLinkRequest() {}

  explicit SendTTSVerifyLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~SendTTSVerifyLinkRequest() = default;
};
class SendTTSVerifyLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  SendTTSVerifyLinkResponseBody() {}

  explicit SendTTSVerifyLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendTTSVerifyLinkResponseBody() = default;
};
class SendTTSVerifyLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendTTSVerifyLinkResponseBody> body{};

  SendTTSVerifyLinkResponse() {}

  explicit SendTTSVerifyLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendTTSVerifyLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendTTSVerifyLinkResponseBody>(model1);
      }
    }
  }


  virtual ~SendTTSVerifyLinkResponse() = default;
};
class SetRetcodeShareStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> pid{};
  shared_ptr<bool> status{};

  SetRetcodeShareStatusRequest() {}

  explicit SetRetcodeShareStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~SetRetcodeShareStatusRequest() = default;
};
class SetRetcodeShareStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  SetRetcodeShareStatusResponseBody() {}

  explicit SetRetcodeShareStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetRetcodeShareStatusResponseBody() = default;
};
class SetRetcodeShareStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetRetcodeShareStatusResponseBody> body{};

  SetRetcodeShareStatusResponse() {}

  explicit SetRetcodeShareStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetRetcodeShareStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetRetcodeShareStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetRetcodeShareStatusResponse() = default;
};
class StartAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertId{};
  shared_ptr<string> regionId{};

  StartAlertRequest() {}

  explicit StartAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<string>(boost::any_cast<string>(m["AlertId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StartAlertRequest() = default;
};
class StartAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  StartAlertResponseBody() {}

  explicit StartAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartAlertResponseBody() = default;
};
class StartAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartAlertResponseBody> body{};

  StartAlertResponse() {}

  explicit StartAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartAlertResponseBody>(model1);
      }
    }
  }


  virtual ~StartAlertResponse() = default;
};
class StopAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertId{};
  shared_ptr<string> regionId{};

  StopAlertRequest() {}

  explicit StopAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<string>(boost::any_cast<string>(m["AlertId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopAlertRequest() = default;
};
class StopAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  StopAlertResponseBody() {}

  explicit StopAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopAlertResponseBody() = default;
};
class StopAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopAlertResponseBody> body{};

  StopAlertResponse() {}

  explicit StopAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopAlertResponseBody>(model1);
      }
    }
  }


  virtual ~StopAlertResponse() = default;
};
class SwitchSyntheticTaskStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> switchStatus{};
  shared_ptr<vector<long>> taskIds{};

  SwitchSyntheticTaskStatusRequest() {}

  explicit SwitchSyntheticTaskStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (switchStatus) {
      res["SwitchStatus"] = boost::any(*switchStatus);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SwitchStatus") != m.end() && !m["SwitchStatus"].empty()) {
      switchStatus = make_shared<long>(boost::any_cast<long>(m["SwitchStatus"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~SwitchSyntheticTaskStatusRequest() = default;
};
class SwitchSyntheticTaskStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  SwitchSyntheticTaskStatusResponseBody() {}

  explicit SwitchSyntheticTaskStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~SwitchSyntheticTaskStatusResponseBody() = default;
};
class SwitchSyntheticTaskStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchSyntheticTaskStatusResponseBody> body{};

  SwitchSyntheticTaskStatusResponse() {}

  explicit SwitchSyntheticTaskStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchSyntheticTaskStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchSyntheticTaskStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchSyntheticTaskStatusResponse() = default;
};
class SyncRecordingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> targetClusters{};

  SyncRecordingRulesRequest() {}

  explicit SyncRecordingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetClusters) {
      res["TargetClusters"] = boost::any(*targetClusters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetClusters") != m.end() && !m["TargetClusters"].empty()) {
      targetClusters = make_shared<string>(boost::any_cast<string>(m["TargetClusters"]));
    }
  }


  virtual ~SyncRecordingRulesRequest() = default;
};
class SyncRecordingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  SyncRecordingRulesResponseBody() {}

  explicit SyncRecordingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SyncRecordingRulesResponseBody() = default;
};
class SyncRecordingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncRecordingRulesResponseBody> body{};

  SyncRecordingRulesResponse() {}

  explicit SyncRecordingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncRecordingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncRecordingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~SyncRecordingRulesResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UninstallManagedPrometheusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vpcId{};

  UninstallManagedPrometheusRequest() {}

  explicit UninstallManagedPrometheusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~UninstallManagedPrometheusRequest() = default;
};
class UninstallManagedPrometheusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UninstallManagedPrometheusResponseBody() {}

  explicit UninstallManagedPrometheusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UninstallManagedPrometheusResponseBody() = default;
};
class UninstallManagedPrometheusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallManagedPrometheusResponseBody> body{};

  UninstallManagedPrometheusResponse() {}

  explicit UninstallManagedPrometheusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallManagedPrometheusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallManagedPrometheusResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallManagedPrometheusResponse() = default;
};
class UninstallPromClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  UninstallPromClusterRequest() {}

  explicit UninstallPromClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UninstallPromClusterRequest() = default;
};
class UninstallPromClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UninstallPromClusterResponseBody() {}

  explicit UninstallPromClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UninstallPromClusterResponseBody() = default;
};
class UninstallPromClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallPromClusterResponseBody> body{};

  UninstallPromClusterResponse() {}

  explicit UninstallPromClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallPromClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallPromClusterResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallPromClusterResponse() = default;
};
class UntagResourcesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UntagResourcesRequestTags() {}

  explicit UntagResourcesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UntagResourcesRequestTags() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};
  shared_ptr<vector<UntagResourcesRequestTags>> tags{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UntagResourcesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UntagResourcesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UntagResourcesRequestTags>>(expect1);
      }
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAlertContactRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> dingRobotWebhookUrl{};
  shared_ptr<string> email{};
  shared_ptr<string> phoneNum{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> systemNoc{};

  UpdateAlertContactRequest() {}

  explicit UpdateAlertContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (dingRobotWebhookUrl) {
      res["DingRobotWebhookUrl"] = boost::any(*dingRobotWebhookUrl);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (phoneNum) {
      res["PhoneNum"] = boost::any(*phoneNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (systemNoc) {
      res["SystemNoc"] = boost::any(*systemNoc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("DingRobotWebhookUrl") != m.end() && !m["DingRobotWebhookUrl"].empty()) {
      dingRobotWebhookUrl = make_shared<string>(boost::any_cast<string>(m["DingRobotWebhookUrl"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("PhoneNum") != m.end() && !m["PhoneNum"].empty()) {
      phoneNum = make_shared<string>(boost::any_cast<string>(m["PhoneNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SystemNoc") != m.end() && !m["SystemNoc"].empty()) {
      systemNoc = make_shared<bool>(boost::any_cast<bool>(m["SystemNoc"]));
    }
  }


  virtual ~UpdateAlertContactRequest() = default;
};
class UpdateAlertContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  UpdateAlertContactResponseBody() {}

  explicit UpdateAlertContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAlertContactResponseBody() = default;
};
class UpdateAlertContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAlertContactResponseBody> body{};

  UpdateAlertContactResponse() {}

  explicit UpdateAlertContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAlertContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAlertContactResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAlertContactResponse() = default;
};
class UpdateAlertContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> contactGroupId{};
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> contactIds{};
  shared_ptr<string> regionId{};

  UpdateAlertContactGroupRequest() {}

  explicit UpdateAlertContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupId) {
      res["ContactGroupId"] = boost::any(*contactGroupId);
    }
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupId") != m.end() && !m["ContactGroupId"].empty()) {
      contactGroupId = make_shared<long>(boost::any_cast<long>(m["ContactGroupId"]));
    }
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateAlertContactGroupRequest() = default;
};
class UpdateAlertContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  UpdateAlertContactGroupResponseBody() {}

  explicit UpdateAlertContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAlertContactGroupResponseBody() = default;
};
class UpdateAlertContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAlertContactGroupResponseBody> body{};

  UpdateAlertContactGroupResponse() {}

  explicit UpdateAlertContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAlertContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAlertContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAlertContactGroupResponse() = default;
};
class UpdateAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> contactGroupIds{};
  shared_ptr<bool> isAutoStart{};
  shared_ptr<string> regionId{};
  shared_ptr<string> templageAlertConfig{};

  UpdateAlertRuleRequest() {}

  explicit UpdateAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (contactGroupIds) {
      res["ContactGroupIds"] = boost::any(*contactGroupIds);
    }
    if (isAutoStart) {
      res["IsAutoStart"] = boost::any(*isAutoStart);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templageAlertConfig) {
      res["TemplageAlertConfig"] = boost::any(*templageAlertConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("ContactGroupIds") != m.end() && !m["ContactGroupIds"].empty()) {
      contactGroupIds = make_shared<string>(boost::any_cast<string>(m["ContactGroupIds"]));
    }
    if (m.find("IsAutoStart") != m.end() && !m["IsAutoStart"].empty()) {
      isAutoStart = make_shared<bool>(boost::any_cast<bool>(m["IsAutoStart"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplageAlertConfig") != m.end() && !m["TemplageAlertConfig"].empty()) {
      templageAlertConfig = make_shared<string>(boost::any_cast<string>(m["TemplageAlertConfig"]));
    }
  }


  virtual ~UpdateAlertRuleRequest() = default;
};
class UpdateAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  UpdateAlertRuleResponseBody() {}

  explicit UpdateAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAlertRuleResponseBody() = default;
};
class UpdateAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAlertRuleResponseBody> body{};

  UpdateAlertRuleResponse() {}

  explicit UpdateAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAlertRuleResponse() = default;
};
class UpdateDispatchRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> dispatchRule{};
  shared_ptr<string> regionId{};

  UpdateDispatchRuleRequest() {}

  explicit UpdateDispatchRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dispatchRule) {
      res["DispatchRule"] = boost::any(*dispatchRule);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DispatchRule") != m.end() && !m["DispatchRule"].empty()) {
      dispatchRule = make_shared<string>(boost::any_cast<string>(m["DispatchRule"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateDispatchRuleRequest() = default;
};
class UpdateDispatchRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDispatchRuleResponseBody() {}

  explicit UpdateDispatchRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDispatchRuleResponseBody() = default;
};
class UpdateDispatchRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDispatchRuleResponseBody> body{};

  UpdateDispatchRuleResponse() {}

  explicit UpdateDispatchRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDispatchRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDispatchRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDispatchRuleResponse() = default;
};
class UpdateIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRecover{};
  shared_ptr<string> description{};
  shared_ptr<string> duplicateKey{};
  shared_ptr<string> extendedFieldRedefineRules{};
  shared_ptr<string> fieldRedefineRules{};
  shared_ptr<string> initiativeRecoverField{};
  shared_ptr<string> initiativeRecoverValue{};
  shared_ptr<long> integrationId{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<string> liveness{};
  shared_ptr<long> recoverTime{};
  shared_ptr<string> stat{};
  shared_ptr<bool> state{};

  UpdateIntegrationRequest() {}

  explicit UpdateIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRecover) {
      res["AutoRecover"] = boost::any(*autoRecover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duplicateKey) {
      res["DuplicateKey"] = boost::any(*duplicateKey);
    }
    if (extendedFieldRedefineRules) {
      res["ExtendedFieldRedefineRules"] = boost::any(*extendedFieldRedefineRules);
    }
    if (fieldRedefineRules) {
      res["FieldRedefineRules"] = boost::any(*fieldRedefineRules);
    }
    if (initiativeRecoverField) {
      res["InitiativeRecoverField"] = boost::any(*initiativeRecoverField);
    }
    if (initiativeRecoverValue) {
      res["InitiativeRecoverValue"] = boost::any(*initiativeRecoverValue);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    if (stat) {
      res["Stat"] = boost::any(*stat);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRecover") != m.end() && !m["AutoRecover"].empty()) {
      autoRecover = make_shared<bool>(boost::any_cast<bool>(m["AutoRecover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DuplicateKey") != m.end() && !m["DuplicateKey"].empty()) {
      duplicateKey = make_shared<string>(boost::any_cast<string>(m["DuplicateKey"]));
    }
    if (m.find("ExtendedFieldRedefineRules") != m.end() && !m["ExtendedFieldRedefineRules"].empty()) {
      extendedFieldRedefineRules = make_shared<string>(boost::any_cast<string>(m["ExtendedFieldRedefineRules"]));
    }
    if (m.find("FieldRedefineRules") != m.end() && !m["FieldRedefineRules"].empty()) {
      fieldRedefineRules = make_shared<string>(boost::any_cast<string>(m["FieldRedefineRules"]));
    }
    if (m.find("InitiativeRecoverField") != m.end() && !m["InitiativeRecoverField"].empty()) {
      initiativeRecoverField = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverField"]));
    }
    if (m.find("InitiativeRecoverValue") != m.end() && !m["InitiativeRecoverValue"].empty()) {
      initiativeRecoverValue = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverValue"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
    if (m.find("Stat") != m.end() && !m["Stat"].empty()) {
      stat = make_shared<string>(boost::any_cast<string>(m["Stat"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<bool>(boost::any_cast<bool>(m["State"]));
    }
  }


  virtual ~UpdateIntegrationRequest() = default;
};
class UpdateIntegrationResponseBodyIntegration : public Darabonba::Model {
public:
  shared_ptr<string> apiEndpoint{};
  shared_ptr<bool> autoRecover{};
  shared_ptr<string> description{};
  shared_ptr<string> duplicateKey{};
  shared_ptr<vector<map<string, boost::any>>> extendedFieldRedefineRules{};
  shared_ptr<vector<map<string, boost::any>>> fieldRedefineRules{};
  shared_ptr<string> initiativeRecoverField{};
  shared_ptr<string> initiativeRecoverValue{};
  shared_ptr<long> integrationId{};
  shared_ptr<string> integrationName{};
  shared_ptr<string> integrationProductType{};
  shared_ptr<string> liveness{};
  shared_ptr<long> recoverTime{};
  shared_ptr<string> shortToken{};
  shared_ptr<vector<long>> stat{};
  shared_ptr<bool> state{};

  UpdateIntegrationResponseBodyIntegration() {}

  explicit UpdateIntegrationResponseBodyIntegration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiEndpoint) {
      res["ApiEndpoint"] = boost::any(*apiEndpoint);
    }
    if (autoRecover) {
      res["AutoRecover"] = boost::any(*autoRecover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duplicateKey) {
      res["DuplicateKey"] = boost::any(*duplicateKey);
    }
    if (extendedFieldRedefineRules) {
      res["ExtendedFieldRedefineRules"] = boost::any(*extendedFieldRedefineRules);
    }
    if (fieldRedefineRules) {
      res["FieldRedefineRules"] = boost::any(*fieldRedefineRules);
    }
    if (initiativeRecoverField) {
      res["InitiativeRecoverField"] = boost::any(*initiativeRecoverField);
    }
    if (initiativeRecoverValue) {
      res["InitiativeRecoverValue"] = boost::any(*initiativeRecoverValue);
    }
    if (integrationId) {
      res["IntegrationId"] = boost::any(*integrationId);
    }
    if (integrationName) {
      res["IntegrationName"] = boost::any(*integrationName);
    }
    if (integrationProductType) {
      res["IntegrationProductType"] = boost::any(*integrationProductType);
    }
    if (liveness) {
      res["Liveness"] = boost::any(*liveness);
    }
    if (recoverTime) {
      res["RecoverTime"] = boost::any(*recoverTime);
    }
    if (shortToken) {
      res["ShortToken"] = boost::any(*shortToken);
    }
    if (stat) {
      res["Stat"] = boost::any(*stat);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiEndpoint") != m.end() && !m["ApiEndpoint"].empty()) {
      apiEndpoint = make_shared<string>(boost::any_cast<string>(m["ApiEndpoint"]));
    }
    if (m.find("AutoRecover") != m.end() && !m["AutoRecover"].empty()) {
      autoRecover = make_shared<bool>(boost::any_cast<bool>(m["AutoRecover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DuplicateKey") != m.end() && !m["DuplicateKey"].empty()) {
      duplicateKey = make_shared<string>(boost::any_cast<string>(m["DuplicateKey"]));
    }
    if (m.find("ExtendedFieldRedefineRules") != m.end() && !m["ExtendedFieldRedefineRules"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["ExtendedFieldRedefineRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExtendedFieldRedefineRules"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      extendedFieldRedefineRules = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("FieldRedefineRules") != m.end() && !m["FieldRedefineRules"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["FieldRedefineRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldRedefineRules"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      fieldRedefineRules = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("InitiativeRecoverField") != m.end() && !m["InitiativeRecoverField"].empty()) {
      initiativeRecoverField = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverField"]));
    }
    if (m.find("InitiativeRecoverValue") != m.end() && !m["InitiativeRecoverValue"].empty()) {
      initiativeRecoverValue = make_shared<string>(boost::any_cast<string>(m["InitiativeRecoverValue"]));
    }
    if (m.find("IntegrationId") != m.end() && !m["IntegrationId"].empty()) {
      integrationId = make_shared<long>(boost::any_cast<long>(m["IntegrationId"]));
    }
    if (m.find("IntegrationName") != m.end() && !m["IntegrationName"].empty()) {
      integrationName = make_shared<string>(boost::any_cast<string>(m["IntegrationName"]));
    }
    if (m.find("IntegrationProductType") != m.end() && !m["IntegrationProductType"].empty()) {
      integrationProductType = make_shared<string>(boost::any_cast<string>(m["IntegrationProductType"]));
    }
    if (m.find("Liveness") != m.end() && !m["Liveness"].empty()) {
      liveness = make_shared<string>(boost::any_cast<string>(m["Liveness"]));
    }
    if (m.find("RecoverTime") != m.end() && !m["RecoverTime"].empty()) {
      recoverTime = make_shared<long>(boost::any_cast<long>(m["RecoverTime"]));
    }
    if (m.find("ShortToken") != m.end() && !m["ShortToken"].empty()) {
      shortToken = make_shared<string>(boost::any_cast<string>(m["ShortToken"]));
    }
    if (m.find("Stat") != m.end() && !m["Stat"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Stat"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Stat"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      stat = make_shared<vector<long>>(toVec1);
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<bool>(boost::any_cast<bool>(m["State"]));
    }
  }


  virtual ~UpdateIntegrationResponseBodyIntegration() = default;
};
class UpdateIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateIntegrationResponseBodyIntegration> integration{};
  shared_ptr<string> requestId{};

  UpdateIntegrationResponseBody() {}

  explicit UpdateIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integration) {
      res["Integration"] = integration ? boost::any(integration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Integration") != m.end() && !m["Integration"].empty()) {
      if (typeid(map<string, boost::any>) == m["Integration"].type()) {
        UpdateIntegrationResponseBodyIntegration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Integration"]));
        integration = make_shared<UpdateIntegrationResponseBodyIntegration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateIntegrationResponseBody() = default;
};
class UpdateIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIntegrationResponseBody> body{};

  UpdateIntegrationResponse() {}

  explicit UpdateIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIntegrationResponse() = default;
};
class UpdatePrometheusAlertRuleRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdatePrometheusAlertRuleRequestTags() {}

  explicit UpdatePrometheusAlertRuleRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleRequestTags() = default;
};
class UpdatePrometheusAlertRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<string> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<string> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<UpdatePrometheusAlertRuleRequestTags>> tags{};
  shared_ptr<string> type{};

  UpdatePrometheusAlertRuleRequest() {}

  explicit UpdatePrometheusAlertRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<UpdatePrometheusAlertRuleRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePrometheusAlertRuleRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<UpdatePrometheusAlertRuleRequestTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleRequest() = default;
};
class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() {}

  explicit UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations() = default;
};
class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() {}

  explicit UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels() = default;
};
class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertName{};
  shared_ptr<vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> dispatchRuleId{};
  shared_ptr<string> duration{};
  shared_ptr<string> expression{};
  shared_ptr<vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> notifyType{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule() {}

  explicit UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dispatchRuleId) {
      res["DispatchRuleId"] = boost::any(*dispatchRuleId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations>>(expect1);
      }
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DispatchRuleId") != m.end() && !m["DispatchRuleId"].empty()) {
      dispatchRuleId = make_shared<long>(boost::any_cast<long>(m["DispatchRuleId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule() = default;
};
class UpdatePrometheusAlertRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule> prometheusAlertRule{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdatePrometheusAlertRuleResponseBody() {}

  explicit UpdatePrometheusAlertRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (prometheusAlertRule) {
      res["PrometheusAlertRule"] = prometheusAlertRule ? boost::any(prometheusAlertRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PrometheusAlertRule") != m.end() && !m["PrometheusAlertRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrometheusAlertRule"].type()) {
        UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrometheusAlertRule"]));
        prometheusAlertRule = make_shared<UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdatePrometheusAlertRuleResponseBody() = default;
};
class UpdatePrometheusAlertRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusAlertRuleResponseBody> body{};

  UpdatePrometheusAlertRuleResponse() {}

  explicit UpdatePrometheusAlertRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusAlertRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusAlertRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusAlertRuleResponse() = default;
};
class UpdatePrometheusGlobalViewRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allSubClustersSuccess{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> mostRegionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> subClustersJson{};

  UpdatePrometheusGlobalViewRequest() {}

  explicit UpdatePrometheusGlobalViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allSubClustersSuccess) {
      res["AllSubClustersSuccess"] = boost::any(*allSubClustersSuccess);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (mostRegionId) {
      res["MostRegionId"] = boost::any(*mostRegionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (subClustersJson) {
      res["SubClustersJson"] = boost::any(*subClustersJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllSubClustersSuccess") != m.end() && !m["AllSubClustersSuccess"].empty()) {
      allSubClustersSuccess = make_shared<bool>(boost::any_cast<bool>(m["AllSubClustersSuccess"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("MostRegionId") != m.end() && !m["MostRegionId"].empty()) {
      mostRegionId = make_shared<string>(boost::any_cast<string>(m["MostRegionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SubClustersJson") != m.end() && !m["SubClustersJson"].empty()) {
      subClustersJson = make_shared<string>(boost::any_cast<string>(m["SubClustersJson"]));
    }
  }


  virtual ~UpdatePrometheusGlobalViewRequest() = default;
};
class UpdatePrometheusGlobalViewResponseBodyDataFailedInstances : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> userId{};

  UpdatePrometheusGlobalViewResponseBodyDataFailedInstances() {}

  explicit UpdatePrometheusGlobalViewResponseBodyDataFailedInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdatePrometheusGlobalViewResponseBodyDataFailedInstances() = default;
};
class UpdatePrometheusGlobalViewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<UpdatePrometheusGlobalViewResponseBodyDataFailedInstances>> failedInstances{};
  shared_ptr<bool> success{};

  UpdatePrometheusGlobalViewResponseBodyData() {}

  explicit UpdatePrometheusGlobalViewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedInstances) {
      vector<boost::any> temp1;
      for(auto item1:*failedInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedInstances"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedInstances") != m.end() && !m["FailedInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedInstances"].type()) {
        vector<UpdatePrometheusGlobalViewResponseBodyDataFailedInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePrometheusGlobalViewResponseBodyDataFailedInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedInstances = make_shared<vector<UpdatePrometheusGlobalViewResponseBodyDataFailedInstances>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdatePrometheusGlobalViewResponseBodyData() = default;
};
class UpdatePrometheusGlobalViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdatePrometheusGlobalViewResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdatePrometheusGlobalViewResponseBody() {}

  explicit UpdatePrometheusGlobalViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdatePrometheusGlobalViewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdatePrometheusGlobalViewResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePrometheusGlobalViewResponseBody() = default;
};
class UpdatePrometheusGlobalViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusGlobalViewResponseBody> body{};

  UpdatePrometheusGlobalViewResponse() {}

  explicit UpdatePrometheusGlobalViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusGlobalViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusGlobalViewResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusGlobalViewResponse() = default;
};
class UpdatePrometheusIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> integrationType{};
  shared_ptr<string> param{};
  shared_ptr<string> regionId{};

  UpdatePrometheusIntegrationRequest() {}

  explicit UpdatePrometheusIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (integrationType) {
      res["IntegrationType"] = boost::any(*integrationType);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("IntegrationType") != m.end() && !m["IntegrationType"].empty()) {
      integrationType = make_shared<string>(boost::any_cast<string>(m["IntegrationType"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdatePrometheusIntegrationRequest() = default;
};
class UpdatePrometheusIntegrationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};

  UpdatePrometheusIntegrationResponseBodyData() {}

  explicit UpdatePrometheusIntegrationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~UpdatePrometheusIntegrationResponseBodyData() = default;
};
class UpdatePrometheusIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdatePrometheusIntegrationResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdatePrometheusIntegrationResponseBody() {}

  explicit UpdatePrometheusIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdatePrometheusIntegrationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdatePrometheusIntegrationResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePrometheusIntegrationResponseBody() = default;
};
class UpdatePrometheusIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusIntegrationResponseBody> body{};

  UpdatePrometheusIntegrationResponse() {}

  explicit UpdatePrometheusIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusIntegrationResponse() = default;
};
class UpdatePrometheusMonitoringRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> configYaml{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  UpdatePrometheusMonitoringRequest() {}

  explicit UpdatePrometheusMonitoringRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configYaml) {
      res["ConfigYaml"] = boost::any(*configYaml);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigYaml") != m.end() && !m["ConfigYaml"].empty()) {
      configYaml = make_shared<string>(boost::any_cast<string>(m["ConfigYaml"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdatePrometheusMonitoringRequest() = default;
};
class UpdatePrometheusMonitoringResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdatePrometheusMonitoringResponseBody() {}

  explicit UpdatePrometheusMonitoringResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePrometheusMonitoringResponseBody() = default;
};
class UpdatePrometheusMonitoringResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusMonitoringResponseBody> body{};

  UpdatePrometheusMonitoringResponse() {}

  explicit UpdatePrometheusMonitoringResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusMonitoringResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusMonitoringResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusMonitoringResponse() = default;
};
class UpdatePrometheusMonitoringStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> monitoringName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  UpdatePrometheusMonitoringStatusRequest() {}

  explicit UpdatePrometheusMonitoringStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (monitoringName) {
      res["MonitoringName"] = boost::any(*monitoringName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MonitoringName") != m.end() && !m["MonitoringName"].empty()) {
      monitoringName = make_shared<string>(boost::any_cast<string>(m["MonitoringName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdatePrometheusMonitoringStatusRequest() = default;
};
class UpdatePrometheusMonitoringStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdatePrometheusMonitoringStatusResponseBody() {}

  explicit UpdatePrometheusMonitoringStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePrometheusMonitoringStatusResponseBody() = default;
};
class UpdatePrometheusMonitoringStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusMonitoringStatusResponseBody> body{};

  UpdatePrometheusMonitoringStatusResponse() {}

  explicit UpdatePrometheusMonitoringStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusMonitoringStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusMonitoringStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusMonitoringStatusResponse() = default;
};
class UpdatePrometheusRemoteWriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteWriteName{};
  shared_ptr<string> remoteWriteYaml{};

  UpdatePrometheusRemoteWriteRequest() {}

  explicit UpdatePrometheusRemoteWriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteWriteName) {
      res["RemoteWriteName"] = boost::any(*remoteWriteName);
    }
    if (remoteWriteYaml) {
      res["RemoteWriteYaml"] = boost::any(*remoteWriteYaml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteWriteName") != m.end() && !m["RemoteWriteName"].empty()) {
      remoteWriteName = make_shared<string>(boost::any_cast<string>(m["RemoteWriteName"]));
    }
    if (m.find("RemoteWriteYaml") != m.end() && !m["RemoteWriteYaml"].empty()) {
      remoteWriteYaml = make_shared<string>(boost::any_cast<string>(m["RemoteWriteYaml"]));
    }
  }


  virtual ~UpdatePrometheusRemoteWriteRequest() = default;
};
class UpdatePrometheusRemoteWriteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdatePrometheusRemoteWriteResponseBody() {}

  explicit UpdatePrometheusRemoteWriteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdatePrometheusRemoteWriteResponseBody() = default;
};
class UpdatePrometheusRemoteWriteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrometheusRemoteWriteResponseBody> body{};

  UpdatePrometheusRemoteWriteResponse() {}

  explicit UpdatePrometheusRemoteWriteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrometheusRemoteWriteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrometheusRemoteWriteResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrometheusRemoteWriteResponse() = default;
};
class UpdateWebhookRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<long> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> httpHeaders{};
  shared_ptr<string> httpParams{};
  shared_ptr<string> method{};
  shared_ptr<string> recoverBody{};
  shared_ptr<string> regionId{};
  shared_ptr<string> url{};

  UpdateWebhookRequest() {}

  explicit UpdateWebhookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (httpHeaders) {
      res["HttpHeaders"] = boost::any(*httpHeaders);
    }
    if (httpParams) {
      res["HttpParams"] = boost::any(*httpParams);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (recoverBody) {
      res["RecoverBody"] = boost::any(*recoverBody);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<long>(boost::any_cast<long>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("HttpHeaders") != m.end() && !m["HttpHeaders"].empty()) {
      httpHeaders = make_shared<string>(boost::any_cast<string>(m["HttpHeaders"]));
    }
    if (m.find("HttpParams") != m.end() && !m["HttpParams"].empty()) {
      httpParams = make_shared<string>(boost::any_cast<string>(m["HttpParams"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("RecoverBody") != m.end() && !m["RecoverBody"].empty()) {
      recoverBody = make_shared<string>(boost::any_cast<string>(m["RecoverBody"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~UpdateWebhookRequest() = default;
};
class UpdateWebhookResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> requestId{};

  UpdateWebhookResponseBody() {}

  explicit UpdateWebhookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateWebhookResponseBody() = default;
};
class UpdateWebhookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWebhookResponseBody> body{};

  UpdateWebhookResponse() {}

  explicit UpdateWebhookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWebhookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWebhookResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWebhookResponse() = default;
};
class UploadRequest : public Darabonba::Model {
public:
  shared_ptr<string> edition{};
  shared_ptr<string> file{};
  shared_ptr<string> fileName{};
  shared_ptr<string> pid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> version{};

  UploadRequest() {}

  explicit UploadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (file) {
      res["File"] = boost::any(*file);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<string>(boost::any_cast<string>(m["Edition"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      file = make_shared<string>(boost::any_cast<string>(m["File"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~UploadRequest() = default;
};
class UploadResponseBodyUploadResult : public Darabonba::Model {
public:
  shared_ptr<string> fid{};
  shared_ptr<string> fileName{};
  shared_ptr<string> uploadTime{};

  UploadResponseBodyUploadResult() {}

  explicit UploadResponseBodyUploadResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fid) {
      res["Fid"] = boost::any(*fid);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (uploadTime) {
      res["UploadTime"] = boost::any(*uploadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fid") != m.end() && !m["Fid"].empty()) {
      fid = make_shared<string>(boost::any_cast<string>(m["Fid"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("UploadTime") != m.end() && !m["UploadTime"].empty()) {
      uploadTime = make_shared<string>(boost::any_cast<string>(m["UploadTime"]));
    }
  }


  virtual ~UploadResponseBodyUploadResult() = default;
};
class UploadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UploadResponseBodyUploadResult> uploadResult{};

  UploadResponseBody() {}

  explicit UploadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadResult) {
      res["UploadResult"] = uploadResult ? boost::any(uploadResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadResult") != m.end() && !m["UploadResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["UploadResult"].type()) {
        UploadResponseBodyUploadResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UploadResult"]));
        uploadResult = make_shared<UploadResponseBodyUploadResult>(model1);
      }
    }
  }


  virtual ~UploadResponseBody() = default;
};
class UploadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadResponseBody> body{};

  UploadResponse() {}

  explicit UploadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadResponseBody>(model1);
      }
    }
  }


  virtual ~UploadResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddAliClusterIdsToPrometheusGlobalViewResponse addAliClusterIdsToPrometheusGlobalViewWithOptions(shared_ptr<AddAliClusterIdsToPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAliClusterIdsToPrometheusGlobalViewResponse addAliClusterIdsToPrometheusGlobalView(shared_ptr<AddAliClusterIdsToPrometheusGlobalViewRequest> request);
  AddGrafanaResponse addGrafanaWithOptions(shared_ptr<AddGrafanaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGrafanaResponse addGrafana(shared_ptr<AddGrafanaRequest> request);
  AddIntegrationResponse addIntegrationWithOptions(shared_ptr<AddIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddIntegrationResponse addIntegration(shared_ptr<AddIntegrationRequest> request);
  AddPrometheusGlobalViewResponse addPrometheusGlobalViewWithOptions(shared_ptr<AddPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPrometheusGlobalViewResponse addPrometheusGlobalView(shared_ptr<AddPrometheusGlobalViewRequest> request);
  AddPrometheusGlobalViewByAliClusterIdsResponse addPrometheusGlobalViewByAliClusterIdsWithOptions(shared_ptr<AddPrometheusGlobalViewByAliClusterIdsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPrometheusGlobalViewByAliClusterIdsResponse addPrometheusGlobalViewByAliClusterIds(shared_ptr<AddPrometheusGlobalViewByAliClusterIdsRequest> request);
  AddPrometheusInstanceResponse addPrometheusInstanceWithOptions(shared_ptr<AddPrometheusInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPrometheusInstanceResponse addPrometheusInstance(shared_ptr<AddPrometheusInstanceRequest> request);
  AddPrometheusIntegrationResponse addPrometheusIntegrationWithOptions(shared_ptr<AddPrometheusIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPrometheusIntegrationResponse addPrometheusIntegration(shared_ptr<AddPrometheusIntegrationRequest> request);
  AddPrometheusRemoteWriteResponse addPrometheusRemoteWriteWithOptions(shared_ptr<AddPrometheusRemoteWriteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPrometheusRemoteWriteResponse addPrometheusRemoteWrite(shared_ptr<AddPrometheusRemoteWriteRequest> request);
  AddRecordingRuleResponse addRecordingRuleWithOptions(shared_ptr<AddRecordingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddRecordingRuleResponse addRecordingRule(shared_ptr<AddRecordingRuleRequest> request);
  AppendInstancesToPrometheusGlobalViewResponse appendInstancesToPrometheusGlobalViewWithOptions(shared_ptr<AppendInstancesToPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AppendInstancesToPrometheusGlobalViewResponse appendInstancesToPrometheusGlobalView(shared_ptr<AppendInstancesToPrometheusGlobalViewRequest> request);
  ApplyScenarioResponse applyScenarioWithOptions(shared_ptr<ApplyScenarioRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyScenarioResponse applyScenario(shared_ptr<ApplyScenarioRequest> request);
  BindPrometheusGrafanaInstanceResponse bindPrometheusGrafanaInstanceWithOptions(shared_ptr<BindPrometheusGrafanaInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindPrometheusGrafanaInstanceResponse bindPrometheusGrafanaInstance(shared_ptr<BindPrometheusGrafanaInstanceRequest> request);
  ChangeResourceGroupResponse changeResourceGroupWithOptions(shared_ptr<ChangeResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeResourceGroupResponse changeResourceGroup(shared_ptr<ChangeResourceGroupRequest> request);
  CheckServiceStatusResponse checkServiceStatusWithOptions(shared_ptr<CheckServiceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckServiceStatusResponse checkServiceStatus(shared_ptr<CheckServiceStatusRequest> request);
  ConfigAppResponse configAppWithOptions(shared_ptr<ConfigAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigAppResponse configApp(shared_ptr<ConfigAppRequest> request);
  CreateAlertContactResponse createAlertContactWithOptions(shared_ptr<CreateAlertContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAlertContactResponse createAlertContact(shared_ptr<CreateAlertContactRequest> request);
  CreateAlertContactGroupResponse createAlertContactGroupWithOptions(shared_ptr<CreateAlertContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAlertContactGroupResponse createAlertContactGroup(shared_ptr<CreateAlertContactGroupRequest> request);
  CreateDispatchRuleResponse createDispatchRuleWithOptions(shared_ptr<CreateDispatchRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDispatchRuleResponse createDispatchRule(shared_ptr<CreateDispatchRuleRequest> request);
  CreateIntegrationResponse createIntegrationWithOptions(shared_ptr<CreateIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIntegrationResponse createIntegration(shared_ptr<CreateIntegrationRequest> request);
  CreateOrUpdateAlertRuleResponse createOrUpdateAlertRuleWithOptions(shared_ptr<CreateOrUpdateAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateAlertRuleResponse createOrUpdateAlertRule(shared_ptr<CreateOrUpdateAlertRuleRequest> request);
  CreateOrUpdateContactResponse createOrUpdateContactWithOptions(shared_ptr<CreateOrUpdateContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateContactResponse createOrUpdateContact(shared_ptr<CreateOrUpdateContactRequest> request);
  CreateOrUpdateContactGroupResponse createOrUpdateContactGroupWithOptions(shared_ptr<CreateOrUpdateContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateContactGroupResponse createOrUpdateContactGroup(shared_ptr<CreateOrUpdateContactGroupRequest> request);
  CreateOrUpdateEventBridgeIntegrationResponse createOrUpdateEventBridgeIntegrationWithOptions(shared_ptr<CreateOrUpdateEventBridgeIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateEventBridgeIntegrationResponse createOrUpdateEventBridgeIntegration(shared_ptr<CreateOrUpdateEventBridgeIntegrationRequest> request);
  CreateOrUpdateIMRobotResponse createOrUpdateIMRobotWithOptions(shared_ptr<CreateOrUpdateIMRobotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateIMRobotResponse createOrUpdateIMRobot(shared_ptr<CreateOrUpdateIMRobotRequest> request);
  CreateOrUpdateNotificationPolicyResponse createOrUpdateNotificationPolicyWithOptions(shared_ptr<CreateOrUpdateNotificationPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateNotificationPolicyResponse createOrUpdateNotificationPolicy(shared_ptr<CreateOrUpdateNotificationPolicyRequest> request);
  CreateOrUpdateSilencePolicyResponse createOrUpdateSilencePolicyWithOptions(shared_ptr<CreateOrUpdateSilencePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateSilencePolicyResponse createOrUpdateSilencePolicy(shared_ptr<CreateOrUpdateSilencePolicyRequest> request);
  CreateOrUpdateWebhookContactResponse createOrUpdateWebhookContactWithOptions(shared_ptr<CreateOrUpdateWebhookContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateWebhookContactResponse createOrUpdateWebhookContact(shared_ptr<CreateOrUpdateWebhookContactRequest> request);
  CreatePrometheusAlertRuleResponse createPrometheusAlertRuleWithOptions(shared_ptr<CreatePrometheusAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePrometheusAlertRuleResponse createPrometheusAlertRule(shared_ptr<CreatePrometheusAlertRuleRequest> request);
  CreatePrometheusInstanceResponse createPrometheusInstanceWithOptions(shared_ptr<CreatePrometheusInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePrometheusInstanceResponse createPrometheusInstance(shared_ptr<CreatePrometheusInstanceRequest> request);
  CreatePrometheusMonitoringResponse createPrometheusMonitoringWithOptions(shared_ptr<CreatePrometheusMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePrometheusMonitoringResponse createPrometheusMonitoring(shared_ptr<CreatePrometheusMonitoringRequest> request);
  CreateRetcodeAppResponse createRetcodeAppWithOptions(shared_ptr<CreateRetcodeAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRetcodeAppResponse createRetcodeApp(shared_ptr<CreateRetcodeAppRequest> request);
  CreateSyntheticTaskResponse createSyntheticTaskWithOptions(shared_ptr<CreateSyntheticTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSyntheticTaskResponse createSyntheticTask(shared_ptr<CreateSyntheticTaskRequest> request);
  CreateWebhookResponse createWebhookWithOptions(shared_ptr<CreateWebhookRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWebhookResponse createWebhook(shared_ptr<CreateWebhookRequest> request);
  DelAuthTokenResponse delAuthTokenWithOptions(shared_ptr<DelAuthTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DelAuthTokenResponse delAuthToken(shared_ptr<DelAuthTokenRequest> request);
  DeleteAlertContactResponse deleteAlertContactWithOptions(shared_ptr<DeleteAlertContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertContactResponse deleteAlertContact(shared_ptr<DeleteAlertContactRequest> request);
  DeleteAlertContactGroupResponse deleteAlertContactGroupWithOptions(shared_ptr<DeleteAlertContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertContactGroupResponse deleteAlertContactGroup(shared_ptr<DeleteAlertContactGroupRequest> request);
  DeleteAlertRuleResponse deleteAlertRuleWithOptions(shared_ptr<DeleteAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertRuleResponse deleteAlertRule(shared_ptr<DeleteAlertRuleRequest> request);
  DeleteAlertRulesResponse deleteAlertRulesWithOptions(shared_ptr<DeleteAlertRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAlertRulesResponse deleteAlertRules(shared_ptr<DeleteAlertRulesRequest> request);
  DeleteCmsExporterResponse deleteCmsExporterWithOptions(shared_ptr<DeleteCmsExporterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCmsExporterResponse deleteCmsExporter(shared_ptr<DeleteCmsExporterRequest> request);
  DeleteContactResponse deleteContactWithOptions(shared_ptr<DeleteContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactResponse deleteContact(shared_ptr<DeleteContactRequest> request);
  DeleteContactGroupResponse deleteContactGroupWithOptions(shared_ptr<DeleteContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactGroupResponse deleteContactGroup(shared_ptr<DeleteContactGroupRequest> request);
  DeleteDispatchRuleResponse deleteDispatchRuleWithOptions(shared_ptr<DeleteDispatchRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDispatchRuleResponse deleteDispatchRule(shared_ptr<DeleteDispatchRuleRequest> request);
  DeleteEventBridgeIntegrationResponse deleteEventBridgeIntegrationWithOptions(shared_ptr<DeleteEventBridgeIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEventBridgeIntegrationResponse deleteEventBridgeIntegration(shared_ptr<DeleteEventBridgeIntegrationRequest> request);
  DeleteGrafanaResourceResponse deleteGrafanaResourceWithOptions(shared_ptr<DeleteGrafanaResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGrafanaResourceResponse deleteGrafanaResource(shared_ptr<DeleteGrafanaResourceRequest> request);
  DeleteIMRobotResponse deleteIMRobotWithOptions(shared_ptr<DeleteIMRobotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIMRobotResponse deleteIMRobot(shared_ptr<DeleteIMRobotRequest> request);
  DeleteIntegrationResponse deleteIntegrationWithOptions(shared_ptr<DeleteIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIntegrationResponse deleteIntegration(shared_ptr<DeleteIntegrationRequest> request);
  DeleteIntegrationsResponse deleteIntegrationsWithOptions(shared_ptr<DeleteIntegrationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIntegrationsResponse deleteIntegrations(shared_ptr<DeleteIntegrationsRequest> request);
  DeleteNotificationPolicyResponse deleteNotificationPolicyWithOptions(shared_ptr<DeleteNotificationPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNotificationPolicyResponse deleteNotificationPolicy(shared_ptr<DeleteNotificationPolicyRequest> request);
  DeletePrometheusAlertRuleResponse deletePrometheusAlertRuleWithOptions(shared_ptr<DeletePrometheusAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrometheusAlertRuleResponse deletePrometheusAlertRule(shared_ptr<DeletePrometheusAlertRuleRequest> request);
  DeletePrometheusGlobalViewResponse deletePrometheusGlobalViewWithOptions(shared_ptr<DeletePrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrometheusGlobalViewResponse deletePrometheusGlobalView(shared_ptr<DeletePrometheusGlobalViewRequest> request);
  DeletePrometheusIntegrationResponse deletePrometheusIntegrationWithOptions(shared_ptr<DeletePrometheusIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrometheusIntegrationResponse deletePrometheusIntegration(shared_ptr<DeletePrometheusIntegrationRequest> request);
  DeletePrometheusMonitoringResponse deletePrometheusMonitoringWithOptions(shared_ptr<DeletePrometheusMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrometheusMonitoringResponse deletePrometheusMonitoring(shared_ptr<DeletePrometheusMonitoringRequest> request);
  DeletePrometheusRemoteWriteResponse deletePrometheusRemoteWriteWithOptions(shared_ptr<DeletePrometheusRemoteWriteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrometheusRemoteWriteResponse deletePrometheusRemoteWrite(shared_ptr<DeletePrometheusRemoteWriteRequest> request);
  DeleteRetcodeAppResponse deleteRetcodeAppWithOptions(shared_ptr<DeleteRetcodeAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRetcodeAppResponse deleteRetcodeApp(shared_ptr<DeleteRetcodeAppRequest> request);
  DeleteScenarioResponse deleteScenarioWithOptions(shared_ptr<DeleteScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScenarioResponse deleteScenario(shared_ptr<DeleteScenarioRequest> request);
  DeleteSilencePolicyResponse deleteSilencePolicyWithOptions(shared_ptr<DeleteSilencePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSilencePolicyResponse deleteSilencePolicy(shared_ptr<DeleteSilencePolicyRequest> request);
  DeleteSourceMapResponse deleteSourceMapWithOptions(shared_ptr<DeleteSourceMapRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSourceMapResponse deleteSourceMap(shared_ptr<DeleteSourceMapRequest> request);
  DeleteSyntheticTaskResponse deleteSyntheticTaskWithOptions(shared_ptr<DeleteSyntheticTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSyntheticTaskResponse deleteSyntheticTask(shared_ptr<DeleteSyntheticTaskRequest> request);
  DeleteTraceAppResponse deleteTraceAppWithOptions(shared_ptr<DeleteTraceAppRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTraceAppResponse deleteTraceApp(shared_ptr<DeleteTraceAppRequest> request);
  DeleteWebhookContactResponse deleteWebhookContactWithOptions(shared_ptr<DeleteWebhookContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWebhookContactResponse deleteWebhookContact(shared_ptr<DeleteWebhookContactRequest> request);
  DescribeContactGroupsResponse describeContactGroupsWithOptions(shared_ptr<DescribeContactGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContactGroupsResponse describeContactGroups(shared_ptr<DescribeContactGroupsRequest> request);
  DescribeContactsResponse describeContactsWithOptions(shared_ptr<DescribeContactsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContactsResponse describeContacts(shared_ptr<DescribeContactsRequest> request);
  DescribeDispatchRuleResponse describeDispatchRuleWithOptions(shared_ptr<DescribeDispatchRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDispatchRuleResponse describeDispatchRule(shared_ptr<DescribeDispatchRuleRequest> request);
  DescribeIMRobotsResponse describeIMRobotsWithOptions(shared_ptr<DescribeIMRobotsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIMRobotsResponse describeIMRobots(shared_ptr<DescribeIMRobotsRequest> request);
  DescribePrometheusAlertRuleResponse describePrometheusAlertRuleWithOptions(shared_ptr<DescribePrometheusAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePrometheusAlertRuleResponse describePrometheusAlertRule(shared_ptr<DescribePrometheusAlertRuleRequest> request);
  DescribeTraceLicenseKeyResponse describeTraceLicenseKeyWithOptions(shared_ptr<DescribeTraceLicenseKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTraceLicenseKeyResponse describeTraceLicenseKey(shared_ptr<DescribeTraceLicenseKeyRequest> request);
  DescribeWebhookContactsResponse describeWebhookContactsWithOptions(shared_ptr<DescribeWebhookContactsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebhookContactsResponse describeWebhookContacts(shared_ptr<DescribeWebhookContactsRequest> request);
  EnableMetricResponse enableMetricWithOptions(shared_ptr<EnableMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableMetricResponse enableMetric(shared_ptr<EnableMetricRequest> request);
  GetAgentDownloadUrlResponse getAgentDownloadUrlWithOptions(shared_ptr<GetAgentDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAgentDownloadUrlResponse getAgentDownloadUrl(shared_ptr<GetAgentDownloadUrlRequest> request);
  GetAlertRulesResponse getAlertRulesWithOptions(shared_ptr<GetAlertRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAlertRulesResponse getAlertRules(shared_ptr<GetAlertRulesRequest> request);
  GetAppApiByPageResponse getAppApiByPageWithOptions(shared_ptr<GetAppApiByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAppApiByPageResponse getAppApiByPage(shared_ptr<GetAppApiByPageRequest> request);
  GetAuthTokenResponse getAuthTokenWithOptions(shared_ptr<GetAuthTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAuthTokenResponse getAuthToken(shared_ptr<GetAuthTokenRequest> request);
  GetCloudClusterAllUrlResponse getCloudClusterAllUrlWithOptions(shared_ptr<GetCloudClusterAllUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCloudClusterAllUrlResponse getCloudClusterAllUrl(shared_ptr<GetCloudClusterAllUrlRequest> request);
  GetClusterAllUrlResponse getClusterAllUrlWithOptions(shared_ptr<GetClusterAllUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterAllUrlResponse getClusterAllUrl(shared_ptr<GetClusterAllUrlRequest> request);
  GetExploreUrlResponse getExploreUrlWithOptions(shared_ptr<GetExploreUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetExploreUrlResponse getExploreUrl(shared_ptr<GetExploreUrlRequest> request);
  GetIntegrationStateResponse getIntegrationStateWithOptions(shared_ptr<GetIntegrationStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIntegrationStateResponse getIntegrationState(shared_ptr<GetIntegrationStateRequest> request);
  GetManagedPrometheusStatusResponse getManagedPrometheusStatusWithOptions(shared_ptr<GetManagedPrometheusStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetManagedPrometheusStatusResponse getManagedPrometheusStatus(shared_ptr<GetManagedPrometheusStatusRequest> request);
  GetMultipleTraceResponse getMultipleTraceWithOptions(shared_ptr<GetMultipleTraceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultipleTraceResponse getMultipleTrace(shared_ptr<GetMultipleTraceRequest> request);
  GetOnCallSchedulesDetailResponse getOnCallSchedulesDetailWithOptions(shared_ptr<GetOnCallSchedulesDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOnCallSchedulesDetailResponse getOnCallSchedulesDetail(shared_ptr<GetOnCallSchedulesDetailRequest> request);
  GetPrometheusApiTokenResponse getPrometheusApiTokenWithOptions(shared_ptr<GetPrometheusApiTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusApiTokenResponse getPrometheusApiToken(shared_ptr<GetPrometheusApiTokenRequest> request);
  GetPrometheusGlobalViewResponse getPrometheusGlobalViewWithOptions(shared_ptr<GetPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusGlobalViewResponse getPrometheusGlobalView(shared_ptr<GetPrometheusGlobalViewRequest> request);
  GetPrometheusInstanceResponse getPrometheusInstanceWithOptions(shared_ptr<GetPrometheusInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusInstanceResponse getPrometheusInstance(shared_ptr<GetPrometheusInstanceRequest> request);
  GetPrometheusIntegrationResponse getPrometheusIntegrationWithOptions(shared_ptr<GetPrometheusIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusIntegrationResponse getPrometheusIntegration(shared_ptr<GetPrometheusIntegrationRequest> request);
  GetPrometheusMonitoringResponse getPrometheusMonitoringWithOptions(shared_ptr<GetPrometheusMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusMonitoringResponse getPrometheusMonitoring(shared_ptr<GetPrometheusMonitoringRequest> request);
  GetPrometheusRemoteWriteResponse getPrometheusRemoteWriteWithOptions(shared_ptr<GetPrometheusRemoteWriteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPrometheusRemoteWriteResponse getPrometheusRemoteWrite(shared_ptr<GetPrometheusRemoteWriteRequest> request);
  GetRecordingRuleResponse getRecordingRuleWithOptions(shared_ptr<GetRecordingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRecordingRuleResponse getRecordingRule(shared_ptr<GetRecordingRuleRequest> request);
  GetRetcodeAppByPidResponse getRetcodeAppByPidWithOptions(shared_ptr<GetRetcodeAppByPidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRetcodeAppByPidResponse getRetcodeAppByPid(shared_ptr<GetRetcodeAppByPidRequest> request);
  GetRetcodeDataByQueryResponse getRetcodeDataByQueryWithOptions(shared_ptr<GetRetcodeDataByQueryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRetcodeDataByQueryResponse getRetcodeDataByQuery(shared_ptr<GetRetcodeDataByQueryRequest> request);
  GetRetcodeLogstoreResponse getRetcodeLogstoreWithOptions(shared_ptr<GetRetcodeLogstoreRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRetcodeLogstoreResponse getRetcodeLogstore(shared_ptr<GetRetcodeLogstoreRequest> request);
  GetRetcodeShareUrlResponse getRetcodeShareUrlWithOptions(shared_ptr<GetRetcodeShareUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRetcodeShareUrlResponse getRetcodeShareUrl(shared_ptr<GetRetcodeShareUrlRequest> request);
  GetSourceMapInfoResponse getSourceMapInfoWithOptions(shared_ptr<GetSourceMapInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSourceMapInfoResponse getSourceMapInfo(shared_ptr<GetSourceMapInfoRequest> request);
  GetStackResponse getStackWithOptions(shared_ptr<GetStackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStackResponse getStack(shared_ptr<GetStackRequest> request);
  GetSyntheticTaskDetailResponse getSyntheticTaskDetailWithOptions(shared_ptr<GetSyntheticTaskDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSyntheticTaskDetailResponse getSyntheticTaskDetail(shared_ptr<GetSyntheticTaskDetailRequest> request);
  GetSyntheticTaskListResponse getSyntheticTaskListWithOptions(shared_ptr<GetSyntheticTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSyntheticTaskListResponse getSyntheticTaskList(shared_ptr<GetSyntheticTaskListRequest> request);
  GetSyntheticTaskMonitorsResponse getSyntheticTaskMonitorsWithOptions(shared_ptr<GetSyntheticTaskMonitorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSyntheticTaskMonitorsResponse getSyntheticTaskMonitors(shared_ptr<GetSyntheticTaskMonitorsRequest> request);
  GetTraceResponse getTraceWithOptions(shared_ptr<GetTraceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTraceResponse getTrace(shared_ptr<GetTraceRequest> request);
  GetTraceAppResponse getTraceAppWithOptions(shared_ptr<GetTraceAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTraceAppResponse getTraceApp(shared_ptr<GetTraceAppRequest> request);
  ImportAppAlertRulesResponse importAppAlertRulesWithOptions(shared_ptr<ImportAppAlertRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportAppAlertRulesResponse importAppAlertRules(shared_ptr<ImportAppAlertRulesRequest> request);
  InstallCmsExporterResponse installCmsExporterWithOptions(shared_ptr<InstallCmsExporterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallCmsExporterResponse installCmsExporter(shared_ptr<InstallCmsExporterRequest> request);
  InstallManagedPrometheusResponse installManagedPrometheusWithOptions(shared_ptr<InstallManagedPrometheusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallManagedPrometheusResponse installManagedPrometheus(shared_ptr<InstallManagedPrometheusRequest> request);
  ListActivatedAlertsResponse listActivatedAlertsWithOptions(shared_ptr<ListActivatedAlertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListActivatedAlertsResponse listActivatedAlerts(shared_ptr<ListActivatedAlertsRequest> request);
  ListAlertEventsResponse listAlertEventsWithOptions(shared_ptr<ListAlertEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertEventsResponse listAlertEvents(shared_ptr<ListAlertEventsRequest> request);
  ListAlertsResponse listAlertsWithOptions(shared_ptr<ListAlertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertsResponse listAlerts(shared_ptr<ListAlertsRequest> request);
  ListClusterFromGrafanaResponse listClusterFromGrafanaWithOptions(shared_ptr<ListClusterFromGrafanaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterFromGrafanaResponse listClusterFromGrafana(shared_ptr<ListClusterFromGrafanaRequest> request);
  ListCmsInstancesResponse listCmsInstancesWithOptions(shared_ptr<ListCmsInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCmsInstancesResponse listCmsInstances(shared_ptr<ListCmsInstancesRequest> request);
  ListDashboardsResponse listDashboardsWithOptions(shared_ptr<ListDashboardsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDashboardsResponse listDashboards(shared_ptr<ListDashboardsRequest> request);
  ListDashboardsByNameResponse listDashboardsByNameWithOptions(shared_ptr<ListDashboardsByNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDashboardsByNameResponse listDashboardsByName(shared_ptr<ListDashboardsByNameRequest> request);
  ListDispatchRuleResponse listDispatchRuleWithOptions(shared_ptr<ListDispatchRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDispatchRuleResponse listDispatchRule(shared_ptr<ListDispatchRuleRequest> request);
  ListEscalationPoliciesResponse listEscalationPoliciesWithOptions(shared_ptr<ListEscalationPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEscalationPoliciesResponse listEscalationPolicies(shared_ptr<ListEscalationPoliciesRequest> request);
  ListEventBridgeIntegrationsResponse listEventBridgeIntegrationsWithOptions(shared_ptr<ListEventBridgeIntegrationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEventBridgeIntegrationsResponse listEventBridgeIntegrations(shared_ptr<ListEventBridgeIntegrationsRequest> request);
  ListInsightsEventsResponse listInsightsEventsWithOptions(shared_ptr<ListInsightsEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInsightsEventsResponse listInsightsEvents(shared_ptr<ListInsightsEventsRequest> request);
  ListIntegrationResponse listIntegrationWithOptions(shared_ptr<ListIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntegrationResponse listIntegration(shared_ptr<ListIntegrationRequest> request);
  ListNotificationPoliciesResponse listNotificationPoliciesWithOptions(shared_ptr<ListNotificationPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNotificationPoliciesResponse listNotificationPolicies(shared_ptr<ListNotificationPoliciesRequest> request);
  ListOnCallSchedulesResponse listOnCallSchedulesWithOptions(shared_ptr<ListOnCallSchedulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOnCallSchedulesResponse listOnCallSchedules(shared_ptr<ListOnCallSchedulesRequest> request);
  ListPrometheusAlertRulesResponse listPrometheusAlertRulesWithOptions(shared_ptr<ListPrometheusAlertRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusAlertRulesResponse listPrometheusAlertRules(shared_ptr<ListPrometheusAlertRulesRequest> request);
  ListPrometheusAlertTemplatesResponse listPrometheusAlertTemplatesWithOptions(shared_ptr<ListPrometheusAlertTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusAlertTemplatesResponse listPrometheusAlertTemplates(shared_ptr<ListPrometheusAlertTemplatesRequest> request);
  ListPrometheusGlobalViewResponse listPrometheusGlobalViewWithOptions(shared_ptr<ListPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusGlobalViewResponse listPrometheusGlobalView(shared_ptr<ListPrometheusGlobalViewRequest> request);
  ListPrometheusInstanceByTagAndResourceGroupIdResponse listPrometheusInstanceByTagAndResourceGroupIdWithOptions(shared_ptr<ListPrometheusInstanceByTagAndResourceGroupIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusInstanceByTagAndResourceGroupIdResponse listPrometheusInstanceByTagAndResourceGroupId(shared_ptr<ListPrometheusInstanceByTagAndResourceGroupIdRequest> request);
  ListPrometheusInstancesResponse listPrometheusInstancesWithOptions(shared_ptr<ListPrometheusInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusInstancesResponse listPrometheusInstances(shared_ptr<ListPrometheusInstancesRequest> request);
  ListPrometheusIntegrationResponse listPrometheusIntegrationWithOptions(shared_ptr<ListPrometheusIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusIntegrationResponse listPrometheusIntegration(shared_ptr<ListPrometheusIntegrationRequest> request);
  ListPrometheusMonitoringResponse listPrometheusMonitoringWithOptions(shared_ptr<ListPrometheusMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusMonitoringResponse listPrometheusMonitoring(shared_ptr<ListPrometheusMonitoringRequest> request);
  ListPrometheusRemoteWritesResponse listPrometheusRemoteWritesWithOptions(shared_ptr<ListPrometheusRemoteWritesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrometheusRemoteWritesResponse listPrometheusRemoteWrites(shared_ptr<ListPrometheusRemoteWritesRequest> request);
  ListRetcodeAppsResponse listRetcodeAppsWithOptions(shared_ptr<ListRetcodeAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRetcodeAppsResponse listRetcodeApps(shared_ptr<ListRetcodeAppsRequest> request);
  ListScenarioResponse listScenarioWithOptions(shared_ptr<ListScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScenarioResponse listScenario(shared_ptr<ListScenarioRequest> request);
  ListSilencePoliciesResponse listSilencePoliciesWithOptions(shared_ptr<ListSilencePoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSilencePoliciesResponse listSilencePolicies(shared_ptr<ListSilencePoliciesRequest> request);
  ListTraceAppsResponse listTraceAppsWithOptions(shared_ptr<ListTraceAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTraceAppsResponse listTraceApps(shared_ptr<ListTraceAppsRequest> request);
  ManageGetRecordingRuleResponse manageGetRecordingRuleWithOptions(shared_ptr<ManageGetRecordingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ManageGetRecordingRuleResponse manageGetRecordingRule(shared_ptr<ManageGetRecordingRuleRequest> request);
  ManageRecordingRuleResponse manageRecordingRuleWithOptions(shared_ptr<ManageRecordingRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ManageRecordingRuleResponse manageRecordingRule(shared_ptr<ManageRecordingRuleRequest> request);
  OpenArmsDefaultSLRResponse openArmsDefaultSLRWithOptions(shared_ptr<OpenArmsDefaultSLRRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenArmsDefaultSLRResponse openArmsDefaultSLR(shared_ptr<OpenArmsDefaultSLRRequest> request);
  OpenArmsServiceSecondVersionResponse openArmsServiceSecondVersionWithOptions(shared_ptr<OpenArmsServiceSecondVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenArmsServiceSecondVersionResponse openArmsServiceSecondVersion(shared_ptr<OpenArmsServiceSecondVersionRequest> request);
  OpenVClusterResponse openVClusterWithOptions(shared_ptr<OpenVClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenVClusterResponse openVCluster(shared_ptr<OpenVClusterRequest> request);
  OpenXtraceDefaultSLRResponse openXtraceDefaultSLRWithOptions(shared_ptr<OpenXtraceDefaultSLRRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenXtraceDefaultSLRResponse openXtraceDefaultSLR(shared_ptr<OpenXtraceDefaultSLRRequest> request);
  QueryMetricByPageResponse queryMetricByPageWithOptions(shared_ptr<QueryMetricByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMetricByPageResponse queryMetricByPage(shared_ptr<QueryMetricByPageRequest> request);
  QueryPromInstallStatusResponse queryPromInstallStatusWithOptions(shared_ptr<QueryPromInstallStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPromInstallStatusResponse queryPromInstallStatus(shared_ptr<QueryPromInstallStatusRequest> request);
  QueryReleaseMetricResponse queryReleaseMetricWithOptions(shared_ptr<QueryReleaseMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryReleaseMetricResponse queryReleaseMetric(shared_ptr<QueryReleaseMetricRequest> request);
  RemoveAliClusterIdsFromPrometheusGlobalViewResponse removeAliClusterIdsFromPrometheusGlobalViewWithOptions(shared_ptr<RemoveAliClusterIdsFromPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAliClusterIdsFromPrometheusGlobalViewResponse removeAliClusterIdsFromPrometheusGlobalView(shared_ptr<RemoveAliClusterIdsFromPrometheusGlobalViewRequest> request);
  RemoveSourcesFromPrometheusGlobalViewResponse removeSourcesFromPrometheusGlobalViewWithOptions(shared_ptr<RemoveSourcesFromPrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveSourcesFromPrometheusGlobalViewResponse removeSourcesFromPrometheusGlobalView(shared_ptr<RemoveSourcesFromPrometheusGlobalViewRequest> request);
  SaveTraceAppConfigResponse saveTraceAppConfigWithOptions(shared_ptr<SaveTraceAppConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveTraceAppConfigResponse saveTraceAppConfig(shared_ptr<SaveTraceAppConfigRequest> request);
  SearchAlertContactResponse searchAlertContactWithOptions(shared_ptr<SearchAlertContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchAlertContactResponse searchAlertContact(shared_ptr<SearchAlertContactRequest> request);
  SearchAlertContactGroupResponse searchAlertContactGroupWithOptions(shared_ptr<SearchAlertContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchAlertContactGroupResponse searchAlertContactGroup(shared_ptr<SearchAlertContactGroupRequest> request);
  SearchAlertHistoriesResponse searchAlertHistoriesWithOptions(shared_ptr<SearchAlertHistoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchAlertHistoriesResponse searchAlertHistories(shared_ptr<SearchAlertHistoriesRequest> request);
  SearchAlertRulesResponse searchAlertRulesWithOptions(shared_ptr<SearchAlertRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchAlertRulesResponse searchAlertRules(shared_ptr<SearchAlertRulesRequest> request);
  SearchEventsResponse searchEventsWithOptions(shared_ptr<SearchEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchEventsResponse searchEvents(shared_ptr<SearchEventsRequest> request);
  SearchRetcodeAppByPageResponse searchRetcodeAppByPageWithOptions(shared_ptr<SearchRetcodeAppByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchRetcodeAppByPageResponse searchRetcodeAppByPage(shared_ptr<SearchRetcodeAppByPageRequest> request);
  SearchTraceAppByNameResponse searchTraceAppByNameWithOptions(shared_ptr<SearchTraceAppByNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTraceAppByNameResponse searchTraceAppByName(shared_ptr<SearchTraceAppByNameRequest> request);
  SearchTraceAppByPageResponse searchTraceAppByPageWithOptions(shared_ptr<SearchTraceAppByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTraceAppByPageResponse searchTraceAppByPage(shared_ptr<SearchTraceAppByPageRequest> request);
  SearchTracesResponse searchTracesWithOptions(shared_ptr<SearchTracesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTracesResponse searchTraces(shared_ptr<SearchTracesRequest> request);
  SearchTracesByPageResponse searchTracesByPageWithOptions(shared_ptr<SearchTracesByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTracesByPageResponse searchTracesByPage(shared_ptr<SearchTracesByPageRequest> request);
  SendTTSVerifyLinkResponse sendTTSVerifyLinkWithOptions(shared_ptr<SendTTSVerifyLinkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendTTSVerifyLinkResponse sendTTSVerifyLink(shared_ptr<SendTTSVerifyLinkRequest> request);
  SetRetcodeShareStatusResponse setRetcodeShareStatusWithOptions(shared_ptr<SetRetcodeShareStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetRetcodeShareStatusResponse setRetcodeShareStatus(shared_ptr<SetRetcodeShareStatusRequest> request);
  StartAlertResponse startAlertWithOptions(shared_ptr<StartAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartAlertResponse startAlert(shared_ptr<StartAlertRequest> request);
  StopAlertResponse stopAlertWithOptions(shared_ptr<StopAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopAlertResponse stopAlert(shared_ptr<StopAlertRequest> request);
  SwitchSyntheticTaskStatusResponse switchSyntheticTaskStatusWithOptions(shared_ptr<SwitchSyntheticTaskStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchSyntheticTaskStatusResponse switchSyntheticTaskStatus(shared_ptr<SwitchSyntheticTaskStatusRequest> request);
  SyncRecordingRulesResponse syncRecordingRulesWithOptions(shared_ptr<SyncRecordingRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncRecordingRulesResponse syncRecordingRules(shared_ptr<SyncRecordingRulesRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UninstallManagedPrometheusResponse uninstallManagedPrometheusWithOptions(shared_ptr<UninstallManagedPrometheusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallManagedPrometheusResponse uninstallManagedPrometheus(shared_ptr<UninstallManagedPrometheusRequest> request);
  UninstallPromClusterResponse uninstallPromClusterWithOptions(shared_ptr<UninstallPromClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallPromClusterResponse uninstallPromCluster(shared_ptr<UninstallPromClusterRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateAlertContactResponse updateAlertContactWithOptions(shared_ptr<UpdateAlertContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAlertContactResponse updateAlertContact(shared_ptr<UpdateAlertContactRequest> request);
  UpdateAlertContactGroupResponse updateAlertContactGroupWithOptions(shared_ptr<UpdateAlertContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAlertContactGroupResponse updateAlertContactGroup(shared_ptr<UpdateAlertContactGroupRequest> request);
  UpdateAlertRuleResponse updateAlertRuleWithOptions(shared_ptr<UpdateAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAlertRuleResponse updateAlertRule(shared_ptr<UpdateAlertRuleRequest> request);
  UpdateDispatchRuleResponse updateDispatchRuleWithOptions(shared_ptr<UpdateDispatchRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDispatchRuleResponse updateDispatchRule(shared_ptr<UpdateDispatchRuleRequest> request);
  UpdateIntegrationResponse updateIntegrationWithOptions(shared_ptr<UpdateIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIntegrationResponse updateIntegration(shared_ptr<UpdateIntegrationRequest> request);
  UpdatePrometheusAlertRuleResponse updatePrometheusAlertRuleWithOptions(shared_ptr<UpdatePrometheusAlertRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusAlertRuleResponse updatePrometheusAlertRule(shared_ptr<UpdatePrometheusAlertRuleRequest> request);
  UpdatePrometheusGlobalViewResponse updatePrometheusGlobalViewWithOptions(shared_ptr<UpdatePrometheusGlobalViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusGlobalViewResponse updatePrometheusGlobalView(shared_ptr<UpdatePrometheusGlobalViewRequest> request);
  UpdatePrometheusIntegrationResponse updatePrometheusIntegrationWithOptions(shared_ptr<UpdatePrometheusIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusIntegrationResponse updatePrometheusIntegration(shared_ptr<UpdatePrometheusIntegrationRequest> request);
  UpdatePrometheusMonitoringResponse updatePrometheusMonitoringWithOptions(shared_ptr<UpdatePrometheusMonitoringRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusMonitoringResponse updatePrometheusMonitoring(shared_ptr<UpdatePrometheusMonitoringRequest> request);
  UpdatePrometheusMonitoringStatusResponse updatePrometheusMonitoringStatusWithOptions(shared_ptr<UpdatePrometheusMonitoringStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusMonitoringStatusResponse updatePrometheusMonitoringStatus(shared_ptr<UpdatePrometheusMonitoringStatusRequest> request);
  UpdatePrometheusRemoteWriteResponse updatePrometheusRemoteWriteWithOptions(shared_ptr<UpdatePrometheusRemoteWriteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrometheusRemoteWriteResponse updatePrometheusRemoteWrite(shared_ptr<UpdatePrometheusRemoteWriteRequest> request);
  UpdateWebhookResponse updateWebhookWithOptions(shared_ptr<UpdateWebhookRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWebhookResponse updateWebhook(shared_ptr<UpdateWebhookRequest> request);
  UploadResponse uploadWithOptions(shared_ptr<UploadRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadResponse upload(shared_ptr<UploadRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_ARMS20190808

#endif
